// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access is denied. Your account is not authorized to perform this operation.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Data Store is in a transition state and the user requested action can not be performed.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateFHIRDatastoreInputBodyMiddleware: Middleware {
    public let id: String = "CreateFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFHIRDatastoreOutputError>
}

extension CreateFHIRDatastoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFHIRDatastoreInput(clientToken: \(String(describing: clientToken)), datastoreName: \(String(describing: datastoreName)), datastoreTypeVersion: \(String(describing: datastoreTypeVersion)), preloadDataConfig: \(String(describing: preloadDataConfig)))"}
}

extension CreateFHIRDatastoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreTypeVersion = datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let preloadDataConfig = preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
    }
}

public struct CreateFHIRDatastoreInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFHIRDatastoreOutputError>
}

public struct CreateFHIRDatastoreInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<CreateFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFHIRDatastoreOutputError>
}

public struct CreateFHIRDatastoreInput: Equatable {
    /// <p>Optional user provided token used for ensuring idempotency.</p>
    public var clientToken: String?
    /// <p>The user generated name for the Data Store.</p>
    public let datastoreName: String?
    /// <p>The FHIR version of the Data Store. The only supported version is R4.</p>
    public let datastoreTypeVersion: FHIRVersion?
    /// <p>Optional parameter to preload data upon creation of the Data Store. Currently, the only
    ///          supported preloaded data is synthetic data generated from Synthea.</p>
    public let preloadDataConfig: PreloadDataConfig?

    public init (
        clientToken: String? = nil,
        datastoreName: String? = nil,
        datastoreTypeVersion: FHIRVersion? = nil,
        preloadDataConfig: PreloadDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.datastoreName = datastoreName
        self.datastoreTypeVersion = datastoreTypeVersion
        self.preloadDataConfig = preloadDataConfig
    }
}

struct CreateFHIRDatastoreInputBody: Equatable {
    public let datastoreName: String?
    public let datastoreTypeVersion: FHIRVersion?
    public let preloadDataConfig: PreloadDataConfig?
    public let clientToken: String?
}

extension CreateFHIRDatastoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case datastoreName = "DatastoreName"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateFHIRDatastoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFHIRDatastoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFHIRDatastoreOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFHIRDatastoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFHIRDatastoreOutputResponse(datastoreArn: \(String(describing: datastoreArn)), datastoreEndpoint: \(String(describing: datastoreEndpoint)), datastoreId: \(String(describing: datastoreId)), datastoreStatus: \(String(describing: datastoreStatus)))"}
}

extension CreateFHIRDatastoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct CreateFHIRDatastoreOutputResponse: Equatable {
    /// <p>The datastore ARN is generated during the creation of the Data Store and can be found in
    ///          the output from the initial Data Store creation call.</p>
    public let datastoreArn: String?
    /// <p>The AWS endpoint for the created Data Store. For preview, only US-east-1 endpoints are
    ///          supported.</p>
    public let datastoreEndpoint: String?
    /// <p>The AWS-generated Data Store id. This id is in the output from the initial Data Store
    ///          creation call.</p>
    public let datastoreId: String?
    /// <p>The status of the FHIR Data Store. Possible statuses are ‘CREATING’, ‘ACTIVE’, ‘DELETING’,
    ///          ‘DELETED’.</p>
    public let datastoreStatus: DatastoreStatus?

    public init (
        datastoreArn: String? = nil,
        datastoreEndpoint: String? = nil,
        datastoreId: String? = nil,
        datastoreStatus: DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct CreateFHIRDatastoreOutputResponseBody: Equatable {
    public let datastoreId: String?
    public let datastoreArn: String?
    public let datastoreStatus: DatastoreStatus?
    public let datastoreEndpoint: String?
}

extension CreateFHIRDatastoreOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

extension DatastoreFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAfter = "CreatedAfter"
        case createdBefore = "CreatedBefore"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = createdAfter {
            try encodeContainer.encode(createdAfter.timeIntervalSince1970, forKey: .createdAfter)
        }
        if let createdBefore = createdBefore {
            try encodeContainer.encode(createdBefore.timeIntervalSince1970, forKey: .createdBefore)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
        let createdAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
    }
}

extension DatastoreFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatastoreFilter(createdAfter: \(String(describing: createdAfter)), createdBefore: \(String(describing: createdBefore)), datastoreName: \(String(describing: datastoreName)), datastoreStatus: \(String(describing: datastoreStatus)))"}
}

/// <p>The filters applied to Data Store query.</p>
public struct DatastoreFilter: Equatable {
    /// <p>A filter that allows the user to set cutoff dates for records. All Data Stores created
    ///          after the specified date will be included in the results.</p>
    public let createdAfter: Date?
    /// <p>A filter that allows the user to set cutoff dates for records. All Data Stores created
    ///          before the specified date will be included in the results. </p>
    public let createdBefore: Date?
    /// <p>Allows the user to filter Data Store results by name.</p>
    public let datastoreName: String?
    /// <p>Allows the user to filter Data Store results by status.</p>
    public let datastoreStatus: DatastoreStatus?

    public init (
        createdAfter: Date? = nil,
        createdBefore: Date? = nil,
        datastoreName: String? = nil,
        datastoreStatus: DatastoreStatus? = nil
    )
    {
        self.createdAfter = createdAfter
        self.createdBefore = createdBefore
        self.datastoreName = datastoreName
        self.datastoreStatus = datastoreStatus
    }
}

extension DatastoreProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreName = "DatastoreName"
        case datastoreStatus = "DatastoreStatus"
        case datastoreTypeVersion = "DatastoreTypeVersion"
        case preloadDataConfig = "PreloadDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let datastoreArn = datastoreArn {
            try encodeContainer.encode(datastoreArn, forKey: .datastoreArn)
        }
        if let datastoreEndpoint = datastoreEndpoint {
            try encodeContainer.encode(datastoreEndpoint, forKey: .datastoreEndpoint)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let datastoreName = datastoreName {
            try encodeContainer.encode(datastoreName, forKey: .datastoreName)
        }
        if let datastoreStatus = datastoreStatus {
            try encodeContainer.encode(datastoreStatus.rawValue, forKey: .datastoreStatus)
        }
        if let datastoreTypeVersion = datastoreTypeVersion {
            try encodeContainer.encode(datastoreTypeVersion.rawValue, forKey: .datastoreTypeVersion)
        }
        if let preloadDataConfig = preloadDataConfig {
            try encodeContainer.encode(preloadDataConfig, forKey: .preloadDataConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreName)
        datastoreName = datastoreNameDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let datastoreTypeVersionDecoded = try containerValues.decodeIfPresent(FHIRVersion.self, forKey: .datastoreTypeVersion)
        datastoreTypeVersion = datastoreTypeVersionDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
        let preloadDataConfigDecoded = try containerValues.decodeIfPresent(PreloadDataConfig.self, forKey: .preloadDataConfig)
        preloadDataConfig = preloadDataConfigDecoded
    }
}

extension DatastoreProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatastoreProperties(createdAt: \(String(describing: createdAt)), datastoreArn: \(String(describing: datastoreArn)), datastoreEndpoint: \(String(describing: datastoreEndpoint)), datastoreId: \(String(describing: datastoreId)), datastoreName: \(String(describing: datastoreName)), datastoreStatus: \(String(describing: datastoreStatus)), datastoreTypeVersion: \(String(describing: datastoreTypeVersion)), preloadDataConfig: \(String(describing: preloadDataConfig)))"}
}

/// <p>Displays the properties of the Data Store, including the ID, Arn, name, and the status of the Data Store.</p>
public struct DatastoreProperties: Equatable {
    /// <p>The time that a Data Store was created. </p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name used in the creation of the Data Store.</p>
    public let datastoreArn: String?
    /// <p>The AWS endpoint for the Data Store. Each Data Store will have it's own endpoint with Data Store ID in the endpoint URL.</p>
    public let datastoreEndpoint: String?
    /// <p>The AWS-generated ID number for the Data Store.</p>
    public let datastoreId: String?
    /// <p>The user-generated name for the Data Store.</p>
    public let datastoreName: String?
    /// <p>The status of the Data Store. Possible statuses are 'CREATING', 'ACTIVE', 'DELETING', or 'DELETED'.</p>
    public let datastoreStatus: DatastoreStatus?
    /// <p>The FHIR version. Only R4 version data is supported.</p>
    public let datastoreTypeVersion: FHIRVersion?
    /// <p>The preloaded data configuration for the Data Store. Only data preloaded from Synthea is supported.</p>
    public let preloadDataConfig: PreloadDataConfig?

    public init (
        createdAt: Date? = nil,
        datastoreArn: String? = nil,
        datastoreEndpoint: String? = nil,
        datastoreId: String? = nil,
        datastoreName: String? = nil,
        datastoreStatus: DatastoreStatus? = nil,
        datastoreTypeVersion: FHIRVersion? = nil,
        preloadDataConfig: PreloadDataConfig? = nil
    )
    {
        self.createdAt = createdAt
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreName = datastoreName
        self.datastoreStatus = datastoreStatus
        self.datastoreTypeVersion = datastoreTypeVersion
        self.preloadDataConfig = preloadDataConfig
    }
}

public enum DatastoreStatus {
    case active
    case creating
    case deleted
    case deleting
    case sdkUnknown(String)
}

extension DatastoreStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatastoreStatus] {
        return [
            .active,
            .creating,
            .deleted,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatastoreStatus(rawValue: rawValue) ?? DatastoreStatus.sdkUnknown(rawValue)
    }
}

public struct DeleteFHIRDatastoreInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFHIRDatastoreOutputError>
}

extension DeleteFHIRDatastoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFHIRDatastoreInput(datastoreId: \(String(describing: datastoreId)))"}
}

extension DeleteFHIRDatastoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

public struct DeleteFHIRDatastoreInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFHIRDatastoreOutputError>
}

public struct DeleteFHIRDatastoreInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<DeleteFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFHIRDatastoreOutputError>
}

public struct DeleteFHIRDatastoreInput: Equatable {
    /// <p> The AWS-generated ID for the Data Store to be deleted.</p>
    public let datastoreId: String?

    public init (
        datastoreId: String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DeleteFHIRDatastoreInputBody: Equatable {
    public let datastoreId: String?
}

extension DeleteFHIRDatastoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension DeleteFHIRDatastoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFHIRDatastoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFHIRDatastoreOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFHIRDatastoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFHIRDatastoreOutputResponse(datastoreArn: \(String(describing: datastoreArn)), datastoreEndpoint: \(String(describing: datastoreEndpoint)), datastoreId: \(String(describing: datastoreId)), datastoreStatus: \(String(describing: datastoreStatus)))"}
}

extension DeleteFHIRDatastoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastoreArn = output.datastoreArn
            self.datastoreEndpoint = output.datastoreEndpoint
            self.datastoreId = output.datastoreId
            self.datastoreStatus = output.datastoreStatus
        } else {
            self.datastoreArn = nil
            self.datastoreEndpoint = nil
            self.datastoreId = nil
            self.datastoreStatus = nil
        }
    }
}

public struct DeleteFHIRDatastoreOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon HealthLake access permission.</p>
    public let datastoreArn: String?
    /// <p>The AWS endpoint for the Data Store the user has requested to be deleted.</p>
    public let datastoreEndpoint: String?
    /// <p>The AWS-generated ID for the Data Store to be deleted.</p>
    public let datastoreId: String?
    /// <p>The status of the Data Store that the user has requested to be deleted.
    ///       </p>
    public let datastoreStatus: DatastoreStatus?

    public init (
        datastoreArn: String? = nil,
        datastoreEndpoint: String? = nil,
        datastoreId: String? = nil,
        datastoreStatus: DatastoreStatus? = nil
    )
    {
        self.datastoreArn = datastoreArn
        self.datastoreEndpoint = datastoreEndpoint
        self.datastoreId = datastoreId
        self.datastoreStatus = datastoreStatus
    }
}

struct DeleteFHIRDatastoreOutputResponseBody: Equatable {
    public let datastoreId: String?
    public let datastoreArn: String?
    public let datastoreStatus: DatastoreStatus?
    public let datastoreEndpoint: String?
}

extension DeleteFHIRDatastoreOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreArn = "DatastoreArn"
        case datastoreEndpoint = "DatastoreEndpoint"
        case datastoreId = "DatastoreId"
        case datastoreStatus = "DatastoreStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let datastoreArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreArn)
        datastoreArn = datastoreArnDecoded
        let datastoreStatusDecoded = try containerValues.decodeIfPresent(DatastoreStatus.self, forKey: .datastoreStatus)
        datastoreStatus = datastoreStatusDecoded
        let datastoreEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreEndpoint)
        datastoreEndpoint = datastoreEndpointDecoded
    }
}

public struct DescribeFHIRDatastoreInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFHIRDatastoreInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRDatastoreOutputError>
}

extension DescribeFHIRDatastoreInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFHIRDatastoreInput(datastoreId: \(String(describing: datastoreId)))"}
}

extension DescribeFHIRDatastoreInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
    }
}

public struct DescribeFHIRDatastoreInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFHIRDatastoreInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRDatastoreOutputError>
}

public struct DescribeFHIRDatastoreInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFHIRDatastoreInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRDatastoreInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRDatastoreOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRDatastoreInput>
    public typealias MOutput = OperationOutput<DescribeFHIRDatastoreOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRDatastoreOutputError>
}

public struct DescribeFHIRDatastoreInput: Equatable {
    /// <p>The AWS-generated Data Store id. This is part of the ‘CreateFHIRDatastore’ output.</p>
    public let datastoreId: String?

    public init (
        datastoreId: String? = nil
    )
    {
        self.datastoreId = datastoreId
    }
}

struct DescribeFHIRDatastoreInputBody: Equatable {
    public let datastoreId: String?
}

extension DescribeFHIRDatastoreInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension DescribeFHIRDatastoreOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRDatastoreOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRDatastoreOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRDatastoreOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFHIRDatastoreOutputResponse(datastoreProperties: \(String(describing: datastoreProperties)))"}
}

extension DescribeFHIRDatastoreOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFHIRDatastoreOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastoreProperties = output.datastoreProperties
        } else {
            self.datastoreProperties = nil
        }
    }
}

public struct DescribeFHIRDatastoreOutputResponse: Equatable {
    /// <p>All properties associated with a Data Store, including the Data Store ID, Data Store ARN,
    ///          Data Store name, Data Store status, created at, Data Store type version, and Data Store
    ///          endpoint.</p>
    public let datastoreProperties: DatastoreProperties?

    public init (
        datastoreProperties: DatastoreProperties? = nil
    )
    {
        self.datastoreProperties = datastoreProperties
    }
}

struct DescribeFHIRDatastoreOutputResponseBody: Equatable {
    public let datastoreProperties: DatastoreProperties?
}

extension DescribeFHIRDatastoreOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreProperties = "DatastoreProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesDecoded = try containerValues.decodeIfPresent(DatastoreProperties.self, forKey: .datastoreProperties)
        datastoreProperties = datastorePropertiesDecoded
    }
}

public struct DescribeFHIRExportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFHIRExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRExportJobOutputError>
}

extension DescribeFHIRExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFHIRExportJobInput(datastoreId: \(String(describing: datastoreId)), jobId: \(String(describing: jobId)))"}
}

extension DescribeFHIRExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeFHIRExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFHIRExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRExportJobOutputError>
}

public struct DescribeFHIRExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFHIRExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRExportJobInput>
    public typealias MOutput = OperationOutput<DescribeFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRExportJobOutputError>
}

public struct DescribeFHIRExportJobInput: Equatable {
    /// <p>The AWS generated ID for the Data Store from which files are being exported from for an export job.</p>
    public let datastoreId: String?
    /// <p>The AWS generated ID for an export job.</p>
    public let jobId: String?

    public init (
        datastoreId: String? = nil,
        jobId: String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRExportJobInputBody: Equatable {
    public let datastoreId: String?
    public let jobId: String?
}

extension DescribeFHIRExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFHIRExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRExportJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFHIRExportJobOutputResponse(exportJobProperties: \(String(describing: exportJobProperties)))"}
}

extension DescribeFHIRExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exportJobProperties = output.exportJobProperties
        } else {
            self.exportJobProperties = nil
        }
    }
}

public struct DescribeFHIRExportJobOutputResponse: Equatable {
    /// <p>Displays the properties of the export job, including the ID, Arn, Name, and the status of the job. </p>
    public let exportJobProperties: ExportJobProperties?

    public init (
        exportJobProperties: ExportJobProperties? = nil
    )
    {
        self.exportJobProperties = exportJobProperties
    }
}

struct DescribeFHIRExportJobOutputResponseBody: Equatable {
    public let exportJobProperties: ExportJobProperties?
}

extension DescribeFHIRExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportJobProperties = "ExportJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobPropertiesDecoded = try containerValues.decodeIfPresent(ExportJobProperties.self, forKey: .exportJobProperties)
        exportJobProperties = exportJobPropertiesDecoded
    }
}

public struct DescribeFHIRImportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFHIRImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRImportJobOutputError>
}

extension DescribeFHIRImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFHIRImportJobInput(datastoreId: \(String(describing: datastoreId)), jobId: \(String(describing: jobId)))"}
}

extension DescribeFHIRImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeFHIRImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFHIRImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRImportJobOutputError>
}

public struct DescribeFHIRImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFHIRImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFHIRImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFHIRImportJobInput>
    public typealias MOutput = OperationOutput<DescribeFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFHIRImportJobOutputError>
}

public struct DescribeFHIRImportJobInput: Equatable {
    /// <p>The AWS-generated ID of the Data Store.</p>
    public let datastoreId: String?
    /// <p>The AWS-generated job ID.</p>
    public let jobId: String?

    public init (
        datastoreId: String? = nil,
        jobId: String? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
    }
}

struct DescribeFHIRImportJobInputBody: Equatable {
    public let datastoreId: String?
    public let jobId: String?
}

extension DescribeFHIRImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeFHIRImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFHIRImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFHIRImportJobOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFHIRImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFHIRImportJobOutputResponse(importJobProperties: \(String(describing: importJobProperties)))"}
}

extension DescribeFHIRImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.importJobProperties = output.importJobProperties
        } else {
            self.importJobProperties = nil
        }
    }
}

public struct DescribeFHIRImportJobOutputResponse: Equatable {
    /// <p>The properties of the Import job request, including the ID, ARN, name, and the status of the job.</p>
    public let importJobProperties: ImportJobProperties?

    public init (
        importJobProperties: ImportJobProperties? = nil
    )
    {
        self.importJobProperties = importJobProperties
    }
}

struct DescribeFHIRImportJobOutputResponseBody: Equatable {
    public let importJobProperties: ImportJobProperties?
}

extension DescribeFHIRImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importJobProperties = "ImportJobProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobPropertiesDecoded = try containerValues.decodeIfPresent(ImportJobProperties.self, forKey: .importJobProperties)
        importJobProperties = importJobPropertiesDecoded
    }
}

extension ExportJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case outputDataConfig = "OutputDataConfig"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ExportJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), datastoreId: \(String(describing: datastoreId)), endTime: \(String(describing: endTime)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), message: \(String(describing: message)), outputDataConfig: \(String(describing: outputDataConfig)), submitTime: \(String(describing: submitTime)))"}
}

/// <p>The properties of a FHIR export job, including the ID, ARN, name, and the status of the job.</p>
public struct ExportJobProperties: Equatable {
    /// <p>The Amazon Resource Name used during the initiation of the job.</p>
    public let dataAccessRoleArn: String?
    /// <p>The AWS generated ID for the Data Store from which files are being exported for an export job.</p>
    public let datastoreId: String?
    /// <p>The time an export job completed.</p>
    public let endTime: Date?
    /// <p>The AWS generated ID for an export job.</p>
    public let jobId: String?
    /// <p>The user generated name for an export job.</p>
    public let jobName: String?
    /// <p>The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.</p>
    public let jobStatus: JobStatus?
    /// <p>An explanation of any errors that may have occurred during the export job.</p>
    public let message: String?
    /// <p>The output data configuration that was supplied when the export job was created.</p>
    public let outputDataConfig: OutputDataConfig?
    /// <p>The time an export job was initiated.</p>
    public let submitTime: Date?

    public init (
        dataAccessRoleArn: String? = nil,
        datastoreId: String? = nil,
        endTime: Date? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        message: String? = nil,
        outputDataConfig: OutputDataConfig? = nil,
        submitTime: Date? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.endTime = endTime
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.message = message
        self.outputDataConfig = outputDataConfig
        self.submitTime = submitTime
    }
}

public enum FHIRVersion {
    case r4
    case sdkUnknown(String)
}

extension FHIRVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FHIRVersion] {
        return [
            .r4,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .r4: return "R4"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FHIRVersion(rawValue: rawValue) ?? FHIRVersion.sdkUnknown(rawValue)
    }
}

extension ImportJobProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case endTime = "EndTime"
        case inputDataConfig = "InputDataConfig"
        case jobId = "JobId"
        case jobName = "JobName"
        case jobStatus = "JobStatus"
        case message = "Message"
        case submitTime = "SubmitTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImportJobProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportJobProperties(dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), datastoreId: \(String(describing: datastoreId)), endTime: \(String(describing: endTime)), inputDataConfig: \(String(describing: inputDataConfig)), jobId: \(String(describing: jobId)), jobName: \(String(describing: jobName)), jobStatus: \(String(describing: jobStatus)), message: \(String(describing: message)), submitTime: \(String(describing: submitTime)))"}
}

/// <p>Displays the properties of the import job, including the ID, Arn, Name, and the status of the Data Store.</p>
public struct ImportJobProperties: Equatable {
    /// <p>The Amazon Resource Name (ARN) that gives Amazon HealthLake access to your input data.</p>
    public let dataAccessRoleArn: String?
    /// <p>The datastore id used when the Import job was created. </p>
    public let datastoreId: String?
    /// <p>The time that the Import job was completed.</p>
    public let endTime: Date?
    /// <p>The input data configuration that was supplied when  the Import job was created.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The AWS-generated id number for the Import job.</p>
    public let jobId: String?
    /// <p>The user-generated name for an Import job.</p>
    public let jobName: String?
    /// <p>The job status for an Import job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, FAILED.</p>
    public let jobStatus: JobStatus?
    /// <p>An explanation of any errors that may have occurred during the FHIR import job. </p>
    public let message: String?
    /// <p>The time that the Import job was submitted for processing.</p>
    public let submitTime: Date?

    public init (
        dataAccessRoleArn: String? = nil,
        datastoreId: String? = nil,
        endTime: Date? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobId: String? = nil,
        jobName: String? = nil,
        jobStatus: JobStatus? = nil,
        message: String? = nil,
        submitTime: Date? = nil
    )
    {
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.endTime = endTime
        self.inputDataConfig = inputDataConfig
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
        self.message = message
        self.submitTime = submitTime
    }
}

extension InputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3uri = "S3Uri"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3uri(s3uri):
                try container.encode(s3uri, forKey: .s3uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3uriDecoded = try values.decodeIfPresent(String.self, forKey: .s3uri)
        if let s3uri = s3uriDecoded {
            self = .s3uri(s3uri)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p> The input properties for an import job.</p>
public enum InputDataConfig: Equatable, Hashable {
    /// <p>The S3Uri is the user specified S3 location of the FHIR data to be imported into Amazon HealthLake. </p>
    case s3uri(String)
    case sdkUnknown(String)
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unknown error occurs in the service.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum JobStatus {
    case completed
    case failed
    case inProgress
    case submitted
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .completed,
            .failed,
            .inProgress,
            .submitted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .submitted: return "SUBMITTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

public struct ListFHIRDatastoresInputBodyMiddleware: Middleware {
    public let id: String = "ListFHIRDatastoresInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFHIRDatastoresOutputError>
}

extension ListFHIRDatastoresInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFHIRDatastoresInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFHIRDatastoresInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFHIRDatastoresInputHeadersMiddleware: Middleware {
    public let id: String = "ListFHIRDatastoresInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFHIRDatastoresOutputError>
}

public struct ListFHIRDatastoresInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFHIRDatastoresInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFHIRDatastoresInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFHIRDatastoresOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFHIRDatastoresInput>
    public typealias MOutput = OperationOutput<ListFHIRDatastoresOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFHIRDatastoresOutputError>
}

public struct ListFHIRDatastoresInput: Equatable {
    /// <p>Lists all filters associated with a FHIR Data Store request.</p>
    public let filter: DatastoreFilter?
    /// <p>The maximum number of Data Stores returned in a single page of a
    ///          ListFHIRDatastoresRequest call.</p>
    public let maxResults: Int?
    /// <p>Fetches the next page of Data Stores when results are paginated.</p>
    public let nextToken: String?

    public init (
        filter: DatastoreFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresInputBody: Equatable {
    public let filter: DatastoreFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFHIRDatastoresInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(DatastoreFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFHIRDatastoresOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFHIRDatastoresOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFHIRDatastoresOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFHIRDatastoresOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFHIRDatastoresOutputResponse(datastorePropertiesList: \(String(describing: datastorePropertiesList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFHIRDatastoresOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFHIRDatastoresOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastorePropertiesList = output.datastorePropertiesList
            self.nextToken = output.nextToken
        } else {
            self.datastorePropertiesList = nil
            self.nextToken = nil
        }
    }
}

public struct ListFHIRDatastoresOutputResponse: Equatable {
    /// <p>All properties associated with the listed Data Stores.</p>
    public let datastorePropertiesList: [DatastoreProperties]?
    /// <p>Pagination token that can be used to retrieve the next page of results.</p>
    public let nextToken: String?

    public init (
        datastorePropertiesList: [DatastoreProperties]? = nil,
        nextToken: String? = nil
    )
    {
        self.datastorePropertiesList = datastorePropertiesList
        self.nextToken = nextToken
    }
}

struct ListFHIRDatastoresOutputResponseBody: Equatable {
    public let datastorePropertiesList: [DatastoreProperties]?
    public let nextToken: String?
}

extension ListFHIRDatastoresOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastorePropertiesList = "DatastorePropertiesList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datastorePropertiesListContainer = try containerValues.decodeIfPresent([DatastoreProperties?].self, forKey: .datastorePropertiesList)
        var datastorePropertiesListDecoded0:[DatastoreProperties]? = nil
        if let datastorePropertiesListContainer = datastorePropertiesListContainer {
            datastorePropertiesListDecoded0 = [DatastoreProperties]()
            for structure0 in datastorePropertiesListContainer {
                if let structure0 = structure0 {
                    datastorePropertiesListDecoded0?.append(structure0)
                }
            }
        }
        datastorePropertiesList = datastorePropertiesListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OutputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3uri = "S3Uri"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3uri(s3uri):
                try container.encode(s3uri, forKey: .s3uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3uriDecoded = try values.decodeIfPresent(String.self, forKey: .s3uri)
        if let s3uri = s3uriDecoded {
            self = .s3uri(s3uri)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The output data configuration that was supplied when the export job was created.</p>
public enum OutputDataConfig: Equatable, Hashable {
    /// <p>The S3Uri is the user specified S3 location to which data will be exported from a FHIR Data Store.</p>
    case s3uri(String)
    case sdkUnknown(String)
}

extension PreloadDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case preloadDataType = "PreloadDataType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let preloadDataType = preloadDataType {
            try encodeContainer.encode(preloadDataType.rawValue, forKey: .preloadDataType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preloadDataTypeDecoded = try containerValues.decodeIfPresent(PreloadDataType.self, forKey: .preloadDataType)
        preloadDataType = preloadDataTypeDecoded
    }
}

extension PreloadDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreloadDataConfig(preloadDataType: \(String(describing: preloadDataType)))"}
}

/// <p> The input properties for the preloaded Data Store. Only data preloaded from Synthea is supported.</p>
public struct PreloadDataConfig: Equatable {
    /// <p>The type of preloaded data. Only Synthea preloaded data is supported.</p>
    public let preloadDataType: PreloadDataType?

    public init (
        preloadDataType: PreloadDataType? = nil
    )
    {
        self.preloadDataType = preloadDataType
    }
}

public enum PreloadDataType {
    case synthea
    case sdkUnknown(String)
}

extension PreloadDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PreloadDataType] {
        return [
            .synthea,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .synthea: return "SYNTHEA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PreloadDataType(rawValue: rawValue) ?? PreloadDataType.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The requested Data Store was not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartFHIRExportJobInputBodyMiddleware: Middleware {
    public let id: String = "StartFHIRExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFHIRExportJobOutputError>
}

extension StartFHIRExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFHIRExportJobInput(clientToken: \(String(describing: clientToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), datastoreId: \(String(describing: datastoreId)), jobName: \(String(describing: jobName)), outputDataConfig: \(String(describing: outputDataConfig)))"}
}

extension StartFHIRExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let outputDataConfig = outputDataConfig {
            try encodeContainer.encode(outputDataConfig, forKey: .outputDataConfig)
        }
    }
}

public struct StartFHIRExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartFHIRExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFHIRExportJobOutputError>
}

public struct StartFHIRExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartFHIRExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFHIRExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFHIRExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFHIRExportJobInput>
    public typealias MOutput = OperationOutput<StartFHIRExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFHIRExportJobOutputError>
}

public struct StartFHIRExportJobInput: Equatable {
    /// <p>An optional user provided token used for ensuring idempotency.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name used during the initiation of the job.</p>
    public let dataAccessRoleArn: String?
    /// <p>The AWS generated ID for the Data Store from which files are being exported for an export job.</p>
    public let datastoreId: String?
    /// <p>The user generated name for an export job.</p>
    public let jobName: String?
    /// <p>The output data configuration that was supplied when the export job was created.</p>
    public let outputDataConfig: OutputDataConfig?

    public init (
        clientToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        datastoreId: String? = nil,
        jobName: String? = nil,
        outputDataConfig: OutputDataConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.jobName = jobName
        self.outputDataConfig = outputDataConfig
    }
}

struct StartFHIRExportJobInputBody: Equatable {
    public let jobName: String?
    public let outputDataConfig: OutputDataConfig?
    public let datastoreId: String?
    public let dataAccessRoleArn: String?
    public let clientToken: String?
}

extension StartFHIRExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case jobName = "JobName"
        case outputDataConfig = "OutputDataConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let outputDataConfigDecoded = try containerValues.decodeIfPresent(OutputDataConfig.self, forKey: .outputDataConfig)
        outputDataConfig = outputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFHIRExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFHIRExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFHIRExportJobOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFHIRExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFHIRExportJobOutputResponse(datastoreId: \(String(describing: datastoreId)), jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartFHIRExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartFHIRExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRExportJobOutputResponse: Equatable {
    /// <p>The AWS generated ID for the Data Store from which files are being exported for an export job.</p>
    public let datastoreId: String?
    /// <p>The AWS generated ID for an export job.</p>
    public let jobId: String?
    /// <p>The status of a FHIR export job. Possible statuses are SUBMITTED, IN_PROGRESS, COMPLETED, or FAILED.</p>
    public let jobStatus: JobStatus?

    public init (
        datastoreId: String? = nil,
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRExportJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
    public let datastoreId: String?
}

extension StartFHIRExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

public struct StartFHIRImportJobInputBodyMiddleware: Middleware {
    public let id: String = "StartFHIRImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFHIRImportJobOutputError>
}

extension StartFHIRImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFHIRImportJobInput(clientToken: \(String(describing: clientToken)), dataAccessRoleArn: \(String(describing: dataAccessRoleArn)), datastoreId: \(String(describing: datastoreId)), inputDataConfig: \(String(describing: inputDataConfig)), jobName: \(String(describing: jobName)))"}
}

extension StartFHIRImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataAccessRoleArn = dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let datastoreId = datastoreId {
            try encodeContainer.encode(datastoreId, forKey: .datastoreId)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
    }
}

public struct StartFHIRImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartFHIRImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFHIRImportJobOutputError>
}

public struct StartFHIRImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartFHIRImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartFHIRImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartFHIRImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartFHIRImportJobInput>
    public typealias MOutput = OperationOutput<StartFHIRImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartFHIRImportJobOutputError>
}

public struct StartFHIRImportJobInput: Equatable {
    /// <p>Optional user provided token used for ensuring idempotency.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name (ARN) that gives Amazon HealthLake access permission.</p>
    public let dataAccessRoleArn: String?
    /// <p>The AWS-generated Data Store ID.</p>
    public let datastoreId: String?
    /// <p>The input properties of the FHIR Import job in the StartFHIRImport job request.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The name of the FHIR Import job in the StartFHIRImport job request.</p>
    public let jobName: String?

    public init (
        clientToken: String? = nil,
        dataAccessRoleArn: String? = nil,
        datastoreId: String? = nil,
        inputDataConfig: InputDataConfig? = nil,
        jobName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.dataAccessRoleArn = dataAccessRoleArn
        self.datastoreId = datastoreId
        self.inputDataConfig = inputDataConfig
        self.jobName = jobName
    }
}

struct StartFHIRImportJobInputBody: Equatable {
    public let jobName: String?
    public let inputDataConfig: InputDataConfig?
    public let datastoreId: String?
    public let dataAccessRoleArn: String?
    public let clientToken: String?
}

extension StartFHIRImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataAccessRoleArn = "DataAccessRoleArn"
        case datastoreId = "DatastoreId"
        case inputDataConfig = "InputDataConfig"
        case jobName = "JobName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFHIRImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFHIRImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFHIRImportJobOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFHIRImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartFHIRImportJobOutputResponse(datastoreId: \(String(describing: datastoreId)), jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartFHIRImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartFHIRImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datastoreId = output.datastoreId
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.datastoreId = nil
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartFHIRImportJobOutputResponse: Equatable {
    /// <p>The AWS-generated Data Store ID.</p>
    public let datastoreId: String?
    /// <p>The AWS-generated job ID.</p>
    public let jobId: String?
    /// <p>The status of an import job.</p>
    public let jobStatus: JobStatus?

    public init (
        datastoreId: String? = nil,
        jobId: String? = nil,
        jobStatus: JobStatus? = nil
    )
    {
        self.datastoreId = datastoreId
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartFHIRImportJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: JobStatus?
    public let datastoreId: String?
}

extension StartFHIRImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datastoreId = "DatastoreId"
        case jobId = "JobId"
        case jobStatus = "JobStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let datastoreIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datastoreId)
        datastoreId = datastoreIdDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user has exceeded their maximum number of allowed calls to the given API. </p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user input parameter was invalid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
