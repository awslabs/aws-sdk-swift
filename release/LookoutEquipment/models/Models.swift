// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be completed because you do not have access to the resource.
///       </p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The request could not be completed due to a conflict with the current state of the
///          target resource. </p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetInput(clientToken: \(String(describing: clientToken)), datasetName: \(String(describing: datasetName)), datasetSchema: \(String(describing: datasetSchema)), serverSideKmsKeyId: \(String(describing: serverSideKmsKeyId)), tags: \(String(describing: tags)))"}
}

extension CreateDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case datasetName = "DatasetName"
        case datasetSchema = "DatasetSchema"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetSchema = datasetSchema {
            try encodeContainer.encode(datasetSchema, forKey: .datasetSchema)
        }
        if let serverSideKmsKeyId = serverSideKmsKeyId {
            try encodeContainer.encode(serverSideKmsKeyId, forKey: .serverSideKmsKeyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Equatable {
    /// <p> A unique identifier for the request. If you do not set the client request token, Amazon
    ///          Lookout for Equipment generates one. </p>
    public var clientToken: String?
    /// <p>The name of the dataset being created. </p>
    public let datasetName: String?
    /// <p>A JSON description of the data that is in each time series dataset, including names,
    ///          column names, and data types. </p>
    public let datasetSchema: DatasetSchema?
    /// <p>Provides the identifier of the AWS KMS customer master key (CMK) used to encrypt dataset data by Amazon Lookout for Equipment. </p>
    public let serverSideKmsKeyId: String?
    /// <p>Any tags associated with the ingested data described in the dataset. </p>
    public let tags: [Tag]?

    public init (
        clientToken: String? = nil,
        datasetName: String? = nil,
        datasetSchema: DatasetSchema? = nil,
        serverSideKmsKeyId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetName = datasetName
        self.datasetSchema = datasetSchema
        self.serverSideKmsKeyId = serverSideKmsKeyId
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Equatable {
    public let datasetName: String?
    public let datasetSchema: DatasetSchema?
    public let serverSideKmsKeyId: String?
    public let clientToken: String?
    public let tags: [Tag]?
}

extension CreateDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case datasetName = "DatasetName"
        case datasetSchema = "DatasetSchema"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetSchemaDecoded = try containerValues.decodeIfPresent(DatasetSchema.self, forKey: .datasetSchema)
        datasetSchema = datasetSchemaDecoded
        let serverSideKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideKmsKeyId)
        serverSideKmsKeyId = serverSideKmsKeyIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetOutputResponse(datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), status: \(String(describing: status)))"}
}

extension CreateDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.status = output.status
        } else {
            self.datasetArn = nil
            self.datasetName = nil
            self.status = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the dataset being created. </p>
    public let datasetArn: String?
    /// <p>The name of the dataset being created. </p>
    public let datasetName: String?
    /// <p>Indicates the status of the <code>CreateDataset</code> operation. </p>
    public let status: DatasetStatus?

    public init (
        datasetArn: String? = nil,
        datasetName: String? = nil,
        status: DatasetStatus? = nil
    )
    {
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.status = status
    }
}

struct CreateDatasetOutputResponseBody: Equatable {
    public let datasetName: String?
    public let datasetArn: String?
    public let status: DatasetStatus?
}

extension CreateDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatasetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateInferenceSchedulerInputBodyMiddleware: Middleware {
    public let id: String = "CreateInferenceSchedulerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<CreateInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInferenceSchedulerOutputError>
}

extension CreateInferenceSchedulerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInferenceSchedulerInput(clientToken: \(String(describing: clientToken)), dataDelayOffsetInMinutes: \(String(describing: dataDelayOffsetInMinutes)), dataInputConfiguration: \(String(describing: dataInputConfiguration)), dataOutputConfiguration: \(String(describing: dataOutputConfiguration)), dataUploadFrequency: \(String(describing: dataUploadFrequency)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), modelName: \(String(describing: modelName)), roleArn: \(String(describing: roleArn)), serverSideKmsKeyId: \(String(describing: serverSideKmsKeyId)), tags: \(String(describing: tags)))"}
}

extension CreateInferenceSchedulerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataDelayOffsetInMinutes = "DataDelayOffsetInMinutes"
        case dataInputConfiguration = "DataInputConfiguration"
        case dataOutputConfiguration = "DataOutputConfiguration"
        case dataUploadFrequency = "DataUploadFrequency"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case modelName = "ModelName"
        case roleArn = "RoleArn"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataDelayOffsetInMinutes = dataDelayOffsetInMinutes {
            try encodeContainer.encode(dataDelayOffsetInMinutes, forKey: .dataDelayOffsetInMinutes)
        }
        if let dataInputConfiguration = dataInputConfiguration {
            try encodeContainer.encode(dataInputConfiguration, forKey: .dataInputConfiguration)
        }
        if let dataOutputConfiguration = dataOutputConfiguration {
            try encodeContainer.encode(dataOutputConfiguration, forKey: .dataOutputConfiguration)
        }
        if let dataUploadFrequency = dataUploadFrequency {
            try encodeContainer.encode(dataUploadFrequency.rawValue, forKey: .dataUploadFrequency)
        }
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let serverSideKmsKeyId = serverSideKmsKeyId {
            try encodeContainer.encode(serverSideKmsKeyId, forKey: .serverSideKmsKeyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateInferenceSchedulerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInferenceSchedulerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<CreateInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInferenceSchedulerOutputError>
}

public struct CreateInferenceSchedulerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInferenceSchedulerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<CreateInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInferenceSchedulerOutputError>
}

public struct CreateInferenceSchedulerInput: Equatable {
    /// <p> A unique identifier for the request. If you do not set the client request token, Amazon
    ///          Lookout for Equipment generates one. </p>
    public var clientToken: String?
    /// <p> A period of time (in minutes) by which inference on the data is delayed after the data
    ///          starts. For instance, if you select an offset delay time of five minutes, inference will
    ///          not begin on the data until the first data measurement after the five minute mark. For example, if
    ///          five minutes is selected, the inference scheduler will wake up at the configured frequency with the
    ///          additional five minute delay time to check the customer S3 bucket. The customer can upload data at
    ///          the same frequency and they don't need to stop and restart the scheduler when uploading new data. </p>
    public let dataDelayOffsetInMinutes: Int?
    /// <p>Specifies configuration information for the input data for the inference scheduler,
    ///          including delimiter, format, and dataset location. </p>
    public let dataInputConfiguration: InferenceInputConfiguration?
    /// <p>Specifies configuration information for the output results for the inference scheduler,
    ///          including the S3 location for the output. </p>
    public let dataOutputConfiguration: InferenceOutputConfiguration?
    /// <p> How often data is uploaded to the source S3 bucket for the input data. The value chosen
    ///          is the length of time between data uploads. For instance, if you select 5 minutes, Amazon
    ///          Lookout for Equipment will upload the real-time data to the source bucket once every 5 minutes. This frequency
    ///          also determines how often Amazon Lookout for Equipment starts a scheduled inference on your data. In this
    ///          example, it starts once every 5 minutes. </p>
    public let dataUploadFrequency: DataUploadFrequency?
    /// <p>The name of the inference scheduler being created. </p>
    public let inferenceSchedulerName: String?
    /// <p>The name of the previously trained ML model being used to create the inference
    ///          scheduler. </p>
    public let modelName: String?
    /// <p>The Amazon Resource Name (ARN) of a role with permission to access the data source being
    ///          used for the inference. </p>
    public let roleArn: String?
    /// <p>Provides the identifier of the AWS KMS customer master key (CMK) used to encrypt inference scheduler data by Amazon Lookout for Equipment. </p>
    public let serverSideKmsKeyId: String?
    /// <p>Any tags associated with the inference scheduler. </p>
    public let tags: [Tag]?

    public init (
        clientToken: String? = nil,
        dataDelayOffsetInMinutes: Int? = nil,
        dataInputConfiguration: InferenceInputConfiguration? = nil,
        dataOutputConfiguration: InferenceOutputConfiguration? = nil,
        dataUploadFrequency: DataUploadFrequency? = nil,
        inferenceSchedulerName: String? = nil,
        modelName: String? = nil,
        roleArn: String? = nil,
        serverSideKmsKeyId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.dataDelayOffsetInMinutes = dataDelayOffsetInMinutes
        self.dataInputConfiguration = dataInputConfiguration
        self.dataOutputConfiguration = dataOutputConfiguration
        self.dataUploadFrequency = dataUploadFrequency
        self.inferenceSchedulerName = inferenceSchedulerName
        self.modelName = modelName
        self.roleArn = roleArn
        self.serverSideKmsKeyId = serverSideKmsKeyId
        self.tags = tags
    }
}

struct CreateInferenceSchedulerInputBody: Equatable {
    public let modelName: String?
    public let inferenceSchedulerName: String?
    public let dataDelayOffsetInMinutes: Int?
    public let dataUploadFrequency: DataUploadFrequency?
    public let dataInputConfiguration: InferenceInputConfiguration?
    public let dataOutputConfiguration: InferenceOutputConfiguration?
    public let roleArn: String?
    public let serverSideKmsKeyId: String?
    public let clientToken: String?
    public let tags: [Tag]?
}

extension CreateInferenceSchedulerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataDelayOffsetInMinutes = "DataDelayOffsetInMinutes"
        case dataInputConfiguration = "DataInputConfiguration"
        case dataOutputConfiguration = "DataOutputConfiguration"
        case dataUploadFrequency = "DataUploadFrequency"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case modelName = "ModelName"
        case roleArn = "RoleArn"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let dataDelayOffsetInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataDelayOffsetInMinutes)
        dataDelayOffsetInMinutes = dataDelayOffsetInMinutesDecoded
        let dataUploadFrequencyDecoded = try containerValues.decodeIfPresent(DataUploadFrequency.self, forKey: .dataUploadFrequency)
        dataUploadFrequency = dataUploadFrequencyDecoded
        let dataInputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceInputConfiguration.self, forKey: .dataInputConfiguration)
        dataInputConfiguration = dataInputConfigurationDecoded
        let dataOutputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceOutputConfiguration.self, forKey: .dataOutputConfiguration)
        dataOutputConfiguration = dataOutputConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let serverSideKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideKmsKeyId)
        serverSideKmsKeyId = serverSideKmsKeyIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateInferenceSchedulerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInferenceSchedulerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInferenceSchedulerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInferenceSchedulerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInferenceSchedulerOutputResponse(inferenceSchedulerArn: \(String(describing: inferenceSchedulerArn)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), status: \(String(describing: status)))"}
}

extension CreateInferenceSchedulerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInferenceSchedulerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inferenceSchedulerArn = output.inferenceSchedulerArn
            self.inferenceSchedulerName = output.inferenceSchedulerName
            self.status = output.status
        } else {
            self.inferenceSchedulerArn = nil
            self.inferenceSchedulerName = nil
            self.status = nil
        }
    }
}

public struct CreateInferenceSchedulerOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the inference scheduler being created. </p>
    public let inferenceSchedulerArn: String?
    /// <p>The name of inference scheduler being created. </p>
    public let inferenceSchedulerName: String?
    /// <p>Indicates the status of the <code>CreateInferenceScheduler</code> operation. </p>
    public let status: InferenceSchedulerStatus?

    public init (
        inferenceSchedulerArn: String? = nil,
        inferenceSchedulerName: String? = nil,
        status: InferenceSchedulerStatus? = nil
    )
    {
        self.inferenceSchedulerArn = inferenceSchedulerArn
        self.inferenceSchedulerName = inferenceSchedulerName
        self.status = status
    }
}

struct CreateInferenceSchedulerOutputResponseBody: Equatable {
    public let inferenceSchedulerArn: String?
    public let inferenceSchedulerName: String?
    public let status: InferenceSchedulerStatus?
}

extension CreateInferenceSchedulerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerArn = "InferenceSchedulerArn"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inferenceSchedulerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerArn)
        inferenceSchedulerArn = inferenceSchedulerArnDecoded
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InferenceSchedulerStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateModelInputBodyMiddleware: Middleware {
    public let id: String = "CreateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

extension CreateModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelInput(clientToken: \(String(describing: clientToken)), dataPreProcessingConfiguration: \(String(describing: dataPreProcessingConfiguration)), datasetName: \(String(describing: datasetName)), datasetSchema: \(String(describing: datasetSchema)), evaluationDataEndTime: \(String(describing: evaluationDataEndTime)), evaluationDataStartTime: \(String(describing: evaluationDataStartTime)), labelsInputConfiguration: \(String(describing: labelsInputConfiguration)), modelName: \(String(describing: modelName)), roleArn: \(String(describing: roleArn)), serverSideKmsKeyId: \(String(describing: serverSideKmsKeyId)), tags: \(String(describing: tags)), trainingDataEndTime: \(String(describing: trainingDataEndTime)), trainingDataStartTime: \(String(describing: trainingDataStartTime)))"}
}

extension CreateModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataPreProcessingConfiguration = "DataPreProcessingConfiguration"
        case datasetName = "DatasetName"
        case datasetSchema = "DatasetSchema"
        case evaluationDataEndTime = "EvaluationDataEndTime"
        case evaluationDataStartTime = "EvaluationDataStartTime"
        case labelsInputConfiguration = "LabelsInputConfiguration"
        case modelName = "ModelName"
        case roleArn = "RoleArn"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case tags = "Tags"
        case trainingDataEndTime = "TrainingDataEndTime"
        case trainingDataStartTime = "TrainingDataStartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataPreProcessingConfiguration = dataPreProcessingConfiguration {
            try encodeContainer.encode(dataPreProcessingConfiguration, forKey: .dataPreProcessingConfiguration)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetSchema = datasetSchema {
            try encodeContainer.encode(datasetSchema, forKey: .datasetSchema)
        }
        if let evaluationDataEndTime = evaluationDataEndTime {
            try encodeContainer.encode(evaluationDataEndTime.timeIntervalSince1970, forKey: .evaluationDataEndTime)
        }
        if let evaluationDataStartTime = evaluationDataStartTime {
            try encodeContainer.encode(evaluationDataStartTime.timeIntervalSince1970, forKey: .evaluationDataStartTime)
        }
        if let labelsInputConfiguration = labelsInputConfiguration {
            try encodeContainer.encode(labelsInputConfiguration, forKey: .labelsInputConfiguration)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let serverSideKmsKeyId = serverSideKmsKeyId {
            try encodeContainer.encode(serverSideKmsKeyId, forKey: .serverSideKmsKeyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let trainingDataEndTime = trainingDataEndTime {
            try encodeContainer.encode(trainingDataEndTime.timeIntervalSince1970, forKey: .trainingDataEndTime)
        }
        if let trainingDataStartTime = trainingDataStartTime {
            try encodeContainer.encode(trainingDataStartTime.timeIntervalSince1970, forKey: .trainingDataStartTime)
        }
    }
}

public struct CreateModelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

public struct CreateModelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

public struct CreateModelInput: Equatable {
    /// <p>A unique identifier for the request. If you do not set the client request token, Amazon
    ///          Lookout for Equipment generates one. </p>
    public var clientToken: String?
    /// <p>The configuration is the <code>TargetSamplingRate</code>, which is the sampling rate of
    ///          the data after post processing by
    ///          Amazon Lookout for Equipment. For example, if you provide data that
    ///          has been collected at a 1 second level and you want the system to resample
    ///          the data at a 1 minute rate before training, the <code>TargetSamplingRate</code> is 1 minute.</p>
    ///          <p>When providing a value for the <code>TargetSamplingRate</code>, you must
    ///             attach the prefix "PT" to the rate you want.  The value for a 1 second rate
    ///             is therefore <i>PT1S</i>, the value for a 15 minute rate
    ///             is <i>PT15M</i>, and the value for a 1 hour rate
    ///             is <i>PT1H</i>
    ///          </p>
    public let dataPreProcessingConfiguration: DataPreProcessingConfiguration?
    /// <p>The name of the dataset for the ML model being created. </p>
    public let datasetName: String?
    /// <p>The data schema for the ML model being created. </p>
    public let datasetSchema: DatasetSchema?
    /// <p> Indicates the time reference in the dataset that should be used to end the subset of
    ///          evaluation data for the ML model. </p>
    public let evaluationDataEndTime: Date?
    /// <p>Indicates the time reference in the dataset that should be used to begin the subset of
    ///          evaluation data for the ML model. </p>
    public let evaluationDataStartTime: Date?
    /// <p>The input configuration for the labels being used for the ML model that's being created.
    ///       </p>
    public let labelsInputConfiguration: LabelsInputConfiguration?
    /// <p>The name for the ML model to be created.</p>
    public let modelName: String?
    /// <p> The Amazon Resource Name (ARN) of a role with permission to access the data source
    ///          being used to create the ML model. </p>
    public let roleArn: String?
    /// <p>Provides the identifier of the AWS KMS customer master key (CMK) used to encrypt model data by Amazon Lookout for Equipment. </p>
    public let serverSideKmsKeyId: String?
    /// <p> Any tags associated with the ML model being created. </p>
    public let tags: [Tag]?
    /// <p>Indicates the time reference in the dataset that should be used to end the subset of
    ///          training data for the ML model. </p>
    public let trainingDataEndTime: Date?
    /// <p>Indicates the time reference in the dataset that should be used to begin the subset of
    ///          training data for the ML model. </p>
    public let trainingDataStartTime: Date?

    public init (
        clientToken: String? = nil,
        dataPreProcessingConfiguration: DataPreProcessingConfiguration? = nil,
        datasetName: String? = nil,
        datasetSchema: DatasetSchema? = nil,
        evaluationDataEndTime: Date? = nil,
        evaluationDataStartTime: Date? = nil,
        labelsInputConfiguration: LabelsInputConfiguration? = nil,
        modelName: String? = nil,
        roleArn: String? = nil,
        serverSideKmsKeyId: String? = nil,
        tags: [Tag]? = nil,
        trainingDataEndTime: Date? = nil,
        trainingDataStartTime: Date? = nil
    )
    {
        self.clientToken = clientToken
        self.dataPreProcessingConfiguration = dataPreProcessingConfiguration
        self.datasetName = datasetName
        self.datasetSchema = datasetSchema
        self.evaluationDataEndTime = evaluationDataEndTime
        self.evaluationDataStartTime = evaluationDataStartTime
        self.labelsInputConfiguration = labelsInputConfiguration
        self.modelName = modelName
        self.roleArn = roleArn
        self.serverSideKmsKeyId = serverSideKmsKeyId
        self.tags = tags
        self.trainingDataEndTime = trainingDataEndTime
        self.trainingDataStartTime = trainingDataStartTime
    }
}

struct CreateModelInputBody: Equatable {
    public let modelName: String?
    public let datasetName: String?
    public let datasetSchema: DatasetSchema?
    public let labelsInputConfiguration: LabelsInputConfiguration?
    public let clientToken: String?
    public let trainingDataStartTime: Date?
    public let trainingDataEndTime: Date?
    public let evaluationDataStartTime: Date?
    public let evaluationDataEndTime: Date?
    public let roleArn: String?
    public let dataPreProcessingConfiguration: DataPreProcessingConfiguration?
    public let serverSideKmsKeyId: String?
    public let tags: [Tag]?
}

extension CreateModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case dataPreProcessingConfiguration = "DataPreProcessingConfiguration"
        case datasetName = "DatasetName"
        case datasetSchema = "DatasetSchema"
        case evaluationDataEndTime = "EvaluationDataEndTime"
        case evaluationDataStartTime = "EvaluationDataStartTime"
        case labelsInputConfiguration = "LabelsInputConfiguration"
        case modelName = "ModelName"
        case roleArn = "RoleArn"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case tags = "Tags"
        case trainingDataEndTime = "TrainingDataEndTime"
        case trainingDataStartTime = "TrainingDataStartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetSchemaDecoded = try containerValues.decodeIfPresent(DatasetSchema.self, forKey: .datasetSchema)
        datasetSchema = datasetSchemaDecoded
        let labelsInputConfigurationDecoded = try containerValues.decodeIfPresent(LabelsInputConfiguration.self, forKey: .labelsInputConfiguration)
        labelsInputConfiguration = labelsInputConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let trainingDataStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingDataStartTime)
        trainingDataStartTime = trainingDataStartTimeDecoded
        let trainingDataEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingDataEndTime)
        trainingDataEndTime = trainingDataEndTimeDecoded
        let evaluationDataStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .evaluationDataStartTime)
        evaluationDataStartTime = evaluationDataStartTimeDecoded
        let evaluationDataEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .evaluationDataEndTime)
        evaluationDataEndTime = evaluationDataEndTimeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPreProcessingConfigurationDecoded = try containerValues.decodeIfPresent(DataPreProcessingConfiguration.self, forKey: .dataPreProcessingConfiguration)
        dataPreProcessingConfiguration = dataPreProcessingConfigurationDecoded
        let serverSideKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideKmsKeyId)
        serverSideKmsKeyId = serverSideKmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelOutputResponse(modelArn: \(String(describing: modelArn)), status: \(String(describing: status)))"}
}

extension CreateModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelArn = output.modelArn
            self.status = output.status
        } else {
            self.modelArn = nil
            self.status = nil
        }
    }
}

public struct CreateModelOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the model being created. </p>
    public let modelArn: String?
    /// <p>Indicates the status of the <code>CreateModel</code> operation. </p>
    public let status: ModelStatus?

    public init (
        modelArn: String? = nil,
        status: ModelStatus? = nil
    )
    {
        self.modelArn = modelArn
        self.status = status
    }
}

struct CreateModelOutputResponseBody: Equatable {
    public let modelArn: String?
    public let status: ModelStatus?
}

extension CreateModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelArn = "ModelArn"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DataIngestionJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case ingestionInputConfiguration = "IngestionInputConfiguration"
        case jobId = "JobId"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let ingestionInputConfiguration = ingestionInputConfiguration {
            try encodeContainer.encode(ingestionInputConfiguration, forKey: .ingestionInputConfiguration)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionInputConfigurationDecoded = try containerValues.decodeIfPresent(IngestionInputConfiguration.self, forKey: .ingestionInputConfiguration)
        ingestionInputConfiguration = ingestionInputConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IngestionJobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DataIngestionJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataIngestionJobSummary(datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), ingestionInputConfiguration: \(String(describing: ingestionInputConfiguration)), jobId: \(String(describing: jobId)), status: \(String(describing: status)))"}
}

/// <p>Provides information about a specified data ingestion job, including dataset
///          information, data ingestion configuration, and status. </p>
public struct DataIngestionJobSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset used in the data ingestion job. </p>
    public let datasetArn: String?
    /// <p>The name of the dataset used for the data ingestion job. </p>
    public let datasetName: String?
    /// <p> Specifies information for the input data for the data inference job, including data S3
    ///          location parameters. </p>
    public let ingestionInputConfiguration: IngestionInputConfiguration?
    /// <p>Indicates the job ID of the data ingestion job. </p>
    public let jobId: String?
    /// <p>Indicates the status of the data ingestion job. </p>
    public let status: IngestionJobStatus?

    public init (
        datasetArn: String? = nil,
        datasetName: String? = nil,
        ingestionInputConfiguration: IngestionInputConfiguration? = nil,
        jobId: String? = nil,
        status: IngestionJobStatus? = nil
    )
    {
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.ingestionInputConfiguration = ingestionInputConfiguration
        self.jobId = jobId
        self.status = status
    }
}

extension DataPreProcessingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetSamplingRate = "TargetSamplingRate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetSamplingRate = targetSamplingRate {
            try encodeContainer.encode(targetSamplingRate.rawValue, forKey: .targetSamplingRate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetSamplingRateDecoded = try containerValues.decodeIfPresent(TargetSamplingRate.self, forKey: .targetSamplingRate)
        targetSamplingRate = targetSamplingRateDecoded
    }
}

extension DataPreProcessingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataPreProcessingConfiguration(targetSamplingRate: \(String(describing: targetSamplingRate)))"}
}

/// <p>The configuration is the <code>TargetSamplingRate</code>, which is the sampling rate of
///          the data after post processing by
///          Amazon Lookout for Equipment. For example, if you provide data that
///          has been collected at a 1 second level and you want the system to resample
///          the data at a 1 minute rate before training, the <code>TargetSamplingRate</code> is 1 minute.</p>
///             <p>When providing a value for the <code>TargetSamplingRate</code>, you must
///                attach the prefix "PT" to the rate you want.  The value for a 1 second rate
///                is therefore <i>PT1S</i>, the value for a 15 minute rate
///                is <i>PT15M</i>, and the value for a 1 hour rate
///                is <i>PT1H</i>
///          </p>
public struct DataPreProcessingConfiguration: Equatable {
    /// <p>The sampling rate of the data after post processing by Amazon Lookout for Equipment.
    ///          For example, if you provide data that has been collected at a 1 second level and
    ///          you want the system to resample the data at a 1 minute rate before training,
    ///          the <code>TargetSamplingRate</code> is 1 minute.</p>
    ///          <p>When providing a value for the <code>TargetSamplingRate</code>, you must attach
    ///             the prefix "PT" to the rate you want.  The value for a 1 second rate is
    ///             therefore <i>PT1S</i>, the value for a 15 minute
    ///             rate is <i>PT15M</i>, and the value for a 1 hour rate
    ///             is <i>PT1H</i>
    ///          </p>
    public let targetSamplingRate: TargetSamplingRate?

    public init (
        targetSamplingRate: TargetSamplingRate? = nil
    )
    {
        self.targetSamplingRate = targetSamplingRate
    }
}

public enum DataUploadFrequency {
    case pt10m
    case pt15m
    case pt1h
    case pt30m
    case pt5m
    case sdkUnknown(String)
}

extension DataUploadFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataUploadFrequency] {
        return [
            .pt10m,
            .pt15m,
            .pt1h,
            .pt30m,
            .pt5m,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pt10m: return "PT10M"
        case .pt15m: return "PT15M"
        case .pt1h: return "PT1H"
        case .pt30m: return "PT30M"
        case .pt5m: return "PT5M"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataUploadFrequency(rawValue: rawValue) ?? DataUploadFrequency.sdkUnknown(rawValue)
    }
}

extension DatasetSchema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inlineDataSchema = "InlineDataSchema"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlineDataSchema = inlineDataSchema {
            try encodeContainer.encode(inlineDataSchema, forKey: .inlineDataSchema)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlineDataSchemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inlineDataSchema)
        inlineDataSchema = inlineDataSchemaDecoded
    }
}

extension DatasetSchema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetSchema(inlineDataSchema: \(String(describing: inlineDataSchema)))"}
}

/// <p>Provides information about the data schema used with the given dataset. </p>
public struct DatasetSchema: Equatable {
    /// <p>
    ///       </p>
    public let inlineDataSchema: String?

    public init (
        inlineDataSchema: String? = nil
    )
    {
        self.inlineDataSchema = inlineDataSchema
    }
}

public enum DatasetStatus {
    case active
    case created
    case ingestionInProgress
    case sdkUnknown(String)
}

extension DatasetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatasetStatus] {
        return [
            .active,
            .created,
            .ingestionInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .created: return "CREATED"
        case .ingestionInProgress: return "INGESTION_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
    }
}

extension DatasetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension DatasetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetSummary(createdAt: \(String(describing: createdAt)), datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), status: \(String(describing: status)))"}
}

/// <p>Contains information about the specific data set, including name, ARN, and status.
///       </p>
public struct DatasetSummary: Equatable {
    /// <p>The time at which the dataset was created in Amazon Lookout for Equipment. </p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the specified dataset. </p>
    public let datasetArn: String?
    /// <p>The name of the dataset. </p>
    public let datasetName: String?
    /// <p>Indicates the status of the dataset. </p>
    public let status: DatasetStatus?

    public init (
        createdAt: Date? = nil,
        datasetArn: String? = nil,
        datasetName: String? = nil,
        status: DatasetStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.status = status
    }
}

public struct DeleteDatasetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

extension DeleteDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetInput(datasetName: \(String(describing: datasetName)))"}
}

extension DeleteDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
    }
}

public struct DeleteDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Equatable {
    /// <p>The name of the dataset to be deleted. </p>
    public let datasetName: String?

    public init (
        datasetName: String? = nil
    )
    {
        self.datasetName = datasetName
    }
}

struct DeleteDatasetInputBody: Equatable {
    public let datasetName: String?
}

extension DeleteDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
    }
}

extension DeleteDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Equatable {
}

extension DeleteDatasetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteInferenceSchedulerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInferenceSchedulerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<DeleteInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInferenceSchedulerOutputError>
}

extension DeleteInferenceSchedulerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInferenceSchedulerInput(inferenceSchedulerName: \(String(describing: inferenceSchedulerName)))"}
}

extension DeleteInferenceSchedulerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerName = "InferenceSchedulerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
    }
}

public struct DeleteInferenceSchedulerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInferenceSchedulerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<DeleteInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInferenceSchedulerOutputError>
}

public struct DeleteInferenceSchedulerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInferenceSchedulerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<DeleteInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInferenceSchedulerOutputError>
}

public struct DeleteInferenceSchedulerInput: Equatable {
    /// <p>The name of the inference scheduler to be deleted. </p>
    public let inferenceSchedulerName: String?

    public init (
        inferenceSchedulerName: String? = nil
    )
    {
        self.inferenceSchedulerName = inferenceSchedulerName
    }
}

struct DeleteInferenceSchedulerInputBody: Equatable {
    public let inferenceSchedulerName: String?
}

extension DeleteInferenceSchedulerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerName = "InferenceSchedulerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
    }
}

extension DeleteInferenceSchedulerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInferenceSchedulerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInferenceSchedulerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInferenceSchedulerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInferenceSchedulerOutputResponse()"}
}

extension DeleteInferenceSchedulerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteInferenceSchedulerOutputResponse: Equatable {

    public init() {}
}

struct DeleteInferenceSchedulerOutputResponseBody: Equatable {
}

extension DeleteInferenceSchedulerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteModelInputBodyMiddleware: Middleware {
    public let id: String = "DeleteModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

extension DeleteModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelInput(modelName: \(String(describing: modelName)))"}
}

extension DeleteModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelName = "ModelName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }
}

public struct DeleteModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInput: Equatable {
    /// <p>The name of the ML model to be deleted. </p>
    public let modelName: String?

    public init (
        modelName: String? = nil
    )
    {
        self.modelName = modelName
    }
}

struct DeleteModelInputBody: Equatable {
    public let modelName: String?
}

extension DeleteModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelName = "ModelName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension DeleteModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelOutputResponse()"}
}

extension DeleteModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelOutputResponse: Equatable {

    public init() {}
}

struct DeleteModelOutputResponseBody: Equatable {
}

extension DeleteModelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeDataIngestionJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDataIngestionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataIngestionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataIngestionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataIngestionJobInput>
    public typealias MOutput = OperationOutput<DescribeDataIngestionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataIngestionJobOutputError>
}

extension DescribeDataIngestionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataIngestionJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeDataIngestionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeDataIngestionJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDataIngestionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataIngestionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataIngestionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataIngestionJobInput>
    public typealias MOutput = OperationOutput<DescribeDataIngestionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataIngestionJobOutputError>
}

public struct DescribeDataIngestionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDataIngestionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDataIngestionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDataIngestionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDataIngestionJobInput>
    public typealias MOutput = OperationOutput<DescribeDataIngestionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDataIngestionJobOutputError>
}

public struct DescribeDataIngestionJobInput: Equatable {
    /// <p>The job ID of the data ingestion job. </p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeDataIngestionJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeDataIngestionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeDataIngestionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDataIngestionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDataIngestionJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDataIngestionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDataIngestionJobOutputResponse(createdAt: \(String(describing: createdAt)), datasetArn: \(String(describing: datasetArn)), failedReason: \(String(describing: failedReason)), ingestionInputConfiguration: \(String(describing: ingestionInputConfiguration)), jobId: \(String(describing: jobId)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

extension DescribeDataIngestionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDataIngestionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.datasetArn = output.datasetArn
            self.failedReason = output.failedReason
            self.ingestionInputConfiguration = output.ingestionInputConfiguration
            self.jobId = output.jobId
            self.roleArn = output.roleArn
            self.status = output.status
        } else {
            self.createdAt = nil
            self.datasetArn = nil
            self.failedReason = nil
            self.ingestionInputConfiguration = nil
            self.jobId = nil
            self.roleArn = nil
            self.status = nil
        }
    }
}

public struct DescribeDataIngestionJobOutputResponse: Equatable {
    /// <p>The time at which the data ingestion job was created. </p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset being used in the data ingestion job.
    ///       </p>
    public let datasetArn: String?
    /// <p>Specifies the reason for failure when a data ingestion job has failed. </p>
    public let failedReason: String?
    /// <p>Specifies the S3 location configuration for the data input for the data ingestion job.
    ///       </p>
    public let ingestionInputConfiguration: IngestionInputConfiguration?
    /// <p>Indicates the job ID of the data ingestion job. </p>
    public let jobId: String?
    /// <p>The Amazon Resource Name (ARN) of an IAM role with permission to access the data source
    ///          being ingested. </p>
    public let roleArn: String?
    /// <p>Indicates the status of the <code>DataIngestionJob</code> operation. </p>
    public let status: IngestionJobStatus?

    public init (
        createdAt: Date? = nil,
        datasetArn: String? = nil,
        failedReason: String? = nil,
        ingestionInputConfiguration: IngestionInputConfiguration? = nil,
        jobId: String? = nil,
        roleArn: String? = nil,
        status: IngestionJobStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.datasetArn = datasetArn
        self.failedReason = failedReason
        self.ingestionInputConfiguration = ingestionInputConfiguration
        self.jobId = jobId
        self.roleArn = roleArn
        self.status = status
    }
}

struct DescribeDataIngestionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let datasetArn: String?
    public let ingestionInputConfiguration: IngestionInputConfiguration?
    public let roleArn: String?
    public let createdAt: Date?
    public let status: IngestionJobStatus?
    public let failedReason: String?
}

extension DescribeDataIngestionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case datasetArn = "DatasetArn"
        case failedReason = "FailedReason"
        case ingestionInputConfiguration = "IngestionInputConfiguration"
        case jobId = "JobId"
        case roleArn = "RoleArn"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let ingestionInputConfigurationDecoded = try containerValues.decodeIfPresent(IngestionInputConfiguration.self, forKey: .ingestionInputConfiguration)
        ingestionInputConfiguration = ingestionInputConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IngestionJobStatus.self, forKey: .status)
        status = statusDecoded
        let failedReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failedReason)
        failedReason = failedReasonDecoded
    }
}

public struct DescribeDatasetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

extension DescribeDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetInput(datasetName: \(String(describing: datasetName)))"}
}

extension DescribeDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
    }
}

public struct DescribeDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Equatable {
    /// <p>The name of the dataset to be described. </p>
    public let datasetName: String?

    public init (
        datasetName: String? = nil
    )
    {
        self.datasetName = datasetName
    }
}

struct DescribeDatasetInputBody: Equatable {
    public let datasetName: String?
}

extension DescribeDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
    }
}

extension DescribeDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetOutputResponse(createdAt: \(String(describing: createdAt)), datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), ingestionInputConfiguration: \(String(describing: ingestionInputConfiguration)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), schema: \(String(describing: schema)), serverSideKmsKeyId: \(String(describing: serverSideKmsKeyId)), status: \(String(describing: status)))"}
}

extension DescribeDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.ingestionInputConfiguration = output.ingestionInputConfiguration
            self.lastUpdatedAt = output.lastUpdatedAt
            self.schema = output.schema
            self.serverSideKmsKeyId = output.serverSideKmsKeyId
            self.status = output.status
        } else {
            self.createdAt = nil
            self.datasetArn = nil
            self.datasetName = nil
            self.ingestionInputConfiguration = nil
            self.lastUpdatedAt = nil
            self.schema = nil
            self.serverSideKmsKeyId = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Equatable {
    /// <p>Specifies the time the dataset was created in Amazon Lookout for Equipment. </p>
    public let createdAt: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset being described. </p>
    public let datasetArn: String?
    /// <p>The name of the dataset being described. </p>
    public let datasetName: String?
    /// <p>Specifies the S3 location configuration for the data input for the data ingestion job. </p>
    public let ingestionInputConfiguration: IngestionInputConfiguration?
    /// <p>Specifies the time the dataset was last updated, if it was. </p>
    public let lastUpdatedAt: Date?
    /// <p>A JSON description of the data that is in each time series dataset, including names,
    ///          column names, and data types. </p>
    public let schema: String?
    /// <p>Provides the identifier of the AWS KMS customer master key (CMK) used to encrypt dataset data by Amazon Lookout for Equipment. </p>
    public let serverSideKmsKeyId: String?
    /// <p>Indicates the status of the dataset. </p>
    public let status: DatasetStatus?

    public init (
        createdAt: Date? = nil,
        datasetArn: String? = nil,
        datasetName: String? = nil,
        ingestionInputConfiguration: IngestionInputConfiguration? = nil,
        lastUpdatedAt: Date? = nil,
        schema: String? = nil,
        serverSideKmsKeyId: String? = nil,
        status: DatasetStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.ingestionInputConfiguration = ingestionInputConfiguration
        self.lastUpdatedAt = lastUpdatedAt
        self.schema = schema
        self.serverSideKmsKeyId = serverSideKmsKeyId
        self.status = status
    }
}

struct DescribeDatasetOutputResponseBody: Equatable {
    public let datasetName: String?
    public let datasetArn: String?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
    public let status: DatasetStatus?
    public let schema: String?
    public let serverSideKmsKeyId: String?
    public let ingestionInputConfiguration: IngestionInputConfiguration?
}

extension DescribeDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case ingestionInputConfiguration = "IngestionInputConfiguration"
        case lastUpdatedAt = "LastUpdatedAt"
        case schema = "Schema"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let serverSideKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideKmsKeyId)
        serverSideKmsKeyId = serverSideKmsKeyIdDecoded
        let ingestionInputConfigurationDecoded = try containerValues.decodeIfPresent(IngestionInputConfiguration.self, forKey: .ingestionInputConfiguration)
        ingestionInputConfiguration = ingestionInputConfigurationDecoded
    }
}

public struct DescribeInferenceSchedulerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeInferenceSchedulerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<DescribeInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInferenceSchedulerOutputError>
}

extension DescribeInferenceSchedulerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInferenceSchedulerInput(inferenceSchedulerName: \(String(describing: inferenceSchedulerName)))"}
}

extension DescribeInferenceSchedulerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerName = "InferenceSchedulerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
    }
}

public struct DescribeInferenceSchedulerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeInferenceSchedulerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<DescribeInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInferenceSchedulerOutputError>
}

public struct DescribeInferenceSchedulerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeInferenceSchedulerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<DescribeInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeInferenceSchedulerOutputError>
}

public struct DescribeInferenceSchedulerInput: Equatable {
    /// <p>The name of the inference scheduler being described. </p>
    public let inferenceSchedulerName: String?

    public init (
        inferenceSchedulerName: String? = nil
    )
    {
        self.inferenceSchedulerName = inferenceSchedulerName
    }
}

struct DescribeInferenceSchedulerInputBody: Equatable {
    public let inferenceSchedulerName: String?
}

extension DescribeInferenceSchedulerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerName = "InferenceSchedulerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
    }
}

extension DescribeInferenceSchedulerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeInferenceSchedulerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeInferenceSchedulerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeInferenceSchedulerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeInferenceSchedulerOutputResponse(createdAt: \(String(describing: createdAt)), dataDelayOffsetInMinutes: \(String(describing: dataDelayOffsetInMinutes)), dataInputConfiguration: \(String(describing: dataInputConfiguration)), dataOutputConfiguration: \(String(describing: dataOutputConfiguration)), dataUploadFrequency: \(String(describing: dataUploadFrequency)), inferenceSchedulerArn: \(String(describing: inferenceSchedulerArn)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), modelArn: \(String(describing: modelArn)), modelName: \(String(describing: modelName)), roleArn: \(String(describing: roleArn)), serverSideKmsKeyId: \(String(describing: serverSideKmsKeyId)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

extension DescribeInferenceSchedulerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeInferenceSchedulerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.dataDelayOffsetInMinutes = output.dataDelayOffsetInMinutes
            self.dataInputConfiguration = output.dataInputConfiguration
            self.dataOutputConfiguration = output.dataOutputConfiguration
            self.dataUploadFrequency = output.dataUploadFrequency
            self.inferenceSchedulerArn = output.inferenceSchedulerArn
            self.inferenceSchedulerName = output.inferenceSchedulerName
            self.modelArn = output.modelArn
            self.modelName = output.modelName
            self.roleArn = output.roleArn
            self.serverSideKmsKeyId = output.serverSideKmsKeyId
            self.status = output.status
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.dataDelayOffsetInMinutes = nil
            self.dataInputConfiguration = nil
            self.dataOutputConfiguration = nil
            self.dataUploadFrequency = nil
            self.inferenceSchedulerArn = nil
            self.inferenceSchedulerName = nil
            self.modelArn = nil
            self.modelName = nil
            self.roleArn = nil
            self.serverSideKmsKeyId = nil
            self.status = nil
            self.updatedAt = nil
        }
    }
}

public struct DescribeInferenceSchedulerOutputResponse: Equatable {
    /// <p>Specifies the time at which the inference scheduler was created. </p>
    public let createdAt: Date?
    /// <p> A period of time (in minutes) by which inference on the data is delayed after the data
    ///          starts. For instance, if you select an offset delay time of five minutes, inference will
    ///          not begin on the data until the first data measurement after the five minute mark. For example, if
    ///          five minutes is selected, the inference scheduler will wake up at the configured frequency with the
    ///          additional five minute delay time to check the customer S3 bucket. The customer can upload data at
    ///          the same frequency and they don't need to stop and restart the scheduler when uploading new data.</p>
    public let dataDelayOffsetInMinutes: Int?
    /// <p> Specifies configuration information for the input data for the inference scheduler,
    ///          including delimiter, format, and dataset location. </p>
    public let dataInputConfiguration: InferenceInputConfiguration?
    /// <p> Specifies information for the output results for the inference scheduler,
    ///          including the output S3 location. </p>
    public let dataOutputConfiguration: InferenceOutputConfiguration?
    /// <p>Specifies how often data is uploaded to the source S3 bucket for the input data. This
    ///          value is the length of time between data uploads. For instance, if you select 5 minutes,
    ///          Amazon Lookout for Equipment will upload the real-time data to the source bucket once every 5 minutes. This
    ///          frequency also determines how often Amazon Lookout for Equipment starts a scheduled inference on your data.
    ///          In this example, it starts once every 5 minutes. </p>
    public let dataUploadFrequency: DataUploadFrequency?
    /// <p>The Amazon Resource Name (ARN) of the inference scheduler being described. </p>
    public let inferenceSchedulerArn: String?
    /// <p>The name of the inference scheduler being described. </p>
    public let inferenceSchedulerName: String?
    /// <p>The Amazon Resource Name (ARN) of the ML model of the inference scheduler being
    ///          described. </p>
    public let modelArn: String?
    /// <p>The name of the ML model of the inference scheduler being described. </p>
    public let modelName: String?
    /// <p> The Amazon Resource Name (ARN) of a role with permission to access the data source for
    ///          the inference scheduler being described. </p>
    public let roleArn: String?
    /// <p>Provides the identifier of the AWS KMS customer master key (CMK) used to encrypt inference scheduler data by Amazon Lookout for Equipment. </p>
    public let serverSideKmsKeyId: String?
    /// <p>Indicates the status of the inference scheduler. </p>
    public let status: InferenceSchedulerStatus?
    /// <p>Specifies the time at which the inference scheduler was last updated, if it was. </p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        dataDelayOffsetInMinutes: Int? = nil,
        dataInputConfiguration: InferenceInputConfiguration? = nil,
        dataOutputConfiguration: InferenceOutputConfiguration? = nil,
        dataUploadFrequency: DataUploadFrequency? = nil,
        inferenceSchedulerArn: String? = nil,
        inferenceSchedulerName: String? = nil,
        modelArn: String? = nil,
        modelName: String? = nil,
        roleArn: String? = nil,
        serverSideKmsKeyId: String? = nil,
        status: InferenceSchedulerStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.dataDelayOffsetInMinutes = dataDelayOffsetInMinutes
        self.dataInputConfiguration = dataInputConfiguration
        self.dataOutputConfiguration = dataOutputConfiguration
        self.dataUploadFrequency = dataUploadFrequency
        self.inferenceSchedulerArn = inferenceSchedulerArn
        self.inferenceSchedulerName = inferenceSchedulerName
        self.modelArn = modelArn
        self.modelName = modelName
        self.roleArn = roleArn
        self.serverSideKmsKeyId = serverSideKmsKeyId
        self.status = status
        self.updatedAt = updatedAt
    }
}

struct DescribeInferenceSchedulerOutputResponseBody: Equatable {
    public let modelArn: String?
    public let modelName: String?
    public let inferenceSchedulerName: String?
    public let inferenceSchedulerArn: String?
    public let status: InferenceSchedulerStatus?
    public let dataDelayOffsetInMinutes: Int?
    public let dataUploadFrequency: DataUploadFrequency?
    public let createdAt: Date?
    public let updatedAt: Date?
    public let dataInputConfiguration: InferenceInputConfiguration?
    public let dataOutputConfiguration: InferenceOutputConfiguration?
    public let roleArn: String?
    public let serverSideKmsKeyId: String?
}

extension DescribeInferenceSchedulerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case dataDelayOffsetInMinutes = "DataDelayOffsetInMinutes"
        case dataInputConfiguration = "DataInputConfiguration"
        case dataOutputConfiguration = "DataOutputConfiguration"
        case dataUploadFrequency = "DataUploadFrequency"
        case inferenceSchedulerArn = "InferenceSchedulerArn"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case modelArn = "ModelArn"
        case modelName = "ModelName"
        case roleArn = "RoleArn"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let inferenceSchedulerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerArn)
        inferenceSchedulerArn = inferenceSchedulerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InferenceSchedulerStatus.self, forKey: .status)
        status = statusDecoded
        let dataDelayOffsetInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataDelayOffsetInMinutes)
        dataDelayOffsetInMinutes = dataDelayOffsetInMinutesDecoded
        let dataUploadFrequencyDecoded = try containerValues.decodeIfPresent(DataUploadFrequency.self, forKey: .dataUploadFrequency)
        dataUploadFrequency = dataUploadFrequencyDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let dataInputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceInputConfiguration.self, forKey: .dataInputConfiguration)
        dataInputConfiguration = dataInputConfigurationDecoded
        let dataOutputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceOutputConfiguration.self, forKey: .dataOutputConfiguration)
        dataOutputConfiguration = dataOutputConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let serverSideKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideKmsKeyId)
        serverSideKmsKeyId = serverSideKmsKeyIdDecoded
    }
}

public struct DescribeModelInputBodyMiddleware: Middleware {
    public let id: String = "DescribeModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeModelInput>
    public typealias MOutput = OperationOutput<DescribeModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeModelOutputError>
}

extension DescribeModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeModelInput(modelName: \(String(describing: modelName)))"}
}

extension DescribeModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case modelName = "ModelName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }
}

public struct DescribeModelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeModelInput>
    public typealias MOutput = OperationOutput<DescribeModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeModelOutputError>
}

public struct DescribeModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeModelInput>
    public typealias MOutput = OperationOutput<DescribeModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeModelOutputError>
}

public struct DescribeModelInput: Equatable {
    /// <p>The name of the ML model to be described. </p>
    public let modelName: String?

    public init (
        modelName: String? = nil
    )
    {
        self.modelName = modelName
    }
}

struct DescribeModelInputBody: Equatable {
    public let modelName: String?
}

extension DescribeModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelName = "ModelName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension DescribeModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeModelOutputResponse(createdAt: \(String(describing: createdAt)), dataPreProcessingConfiguration: \(String(describing: dataPreProcessingConfiguration)), datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), evaluationDataEndTime: \(String(describing: evaluationDataEndTime)), evaluationDataStartTime: \(String(describing: evaluationDataStartTime)), failedReason: \(String(describing: failedReason)), labelsInputConfiguration: \(String(describing: labelsInputConfiguration)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), modelArn: \(String(describing: modelArn)), modelMetrics: \(String(describing: modelMetrics)), modelName: \(String(describing: modelName)), roleArn: \(String(describing: roleArn)), schema: \(String(describing: schema)), serverSideKmsKeyId: \(String(describing: serverSideKmsKeyId)), status: \(String(describing: status)), trainingDataEndTime: \(String(describing: trainingDataEndTime)), trainingDataStartTime: \(String(describing: trainingDataStartTime)), trainingExecutionEndTime: \(String(describing: trainingExecutionEndTime)), trainingExecutionStartTime: \(String(describing: trainingExecutionStartTime)))"}
}

extension DescribeModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.dataPreProcessingConfiguration = output.dataPreProcessingConfiguration
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.evaluationDataEndTime = output.evaluationDataEndTime
            self.evaluationDataStartTime = output.evaluationDataStartTime
            self.failedReason = output.failedReason
            self.labelsInputConfiguration = output.labelsInputConfiguration
            self.lastUpdatedTime = output.lastUpdatedTime
            self.modelArn = output.modelArn
            self.modelMetrics = output.modelMetrics
            self.modelName = output.modelName
            self.roleArn = output.roleArn
            self.schema = output.schema
            self.serverSideKmsKeyId = output.serverSideKmsKeyId
            self.status = output.status
            self.trainingDataEndTime = output.trainingDataEndTime
            self.trainingDataStartTime = output.trainingDataStartTime
            self.trainingExecutionEndTime = output.trainingExecutionEndTime
            self.trainingExecutionStartTime = output.trainingExecutionStartTime
        } else {
            self.createdAt = nil
            self.dataPreProcessingConfiguration = nil
            self.datasetArn = nil
            self.datasetName = nil
            self.evaluationDataEndTime = nil
            self.evaluationDataStartTime = nil
            self.failedReason = nil
            self.labelsInputConfiguration = nil
            self.lastUpdatedTime = nil
            self.modelArn = nil
            self.modelMetrics = nil
            self.modelName = nil
            self.roleArn = nil
            self.schema = nil
            self.serverSideKmsKeyId = nil
            self.status = nil
            self.trainingDataEndTime = nil
            self.trainingDataStartTime = nil
            self.trainingExecutionEndTime = nil
            self.trainingExecutionStartTime = nil
        }
    }
}

public struct DescribeModelOutputResponse: Equatable {
    /// <p>Indicates the time and date at which the ML model was created. </p>
    public let createdAt: Date?
    /// <p>The configuration is the <code>TargetSamplingRate</code>, which is the sampling rate of
    ///          the data after post processing by
    ///          Amazon Lookout for Equipment. For example, if you provide data that
    ///          has been collected at a 1 second level and you want the system to resample
    ///          the data at a 1 minute rate before training, the <code>TargetSamplingRate</code> is 1 minute.</p>
    ///             <p>When providing a value for the <code>TargetSamplingRate</code>, you must
    ///                attach the prefix "PT" to the rate you want.  The value for a 1 second rate
    ///                is therefore <i>PT1S</i>, the value for a 15 minute rate
    ///                is <i>PT15M</i>, and the value for a 1 hour rate
    ///                is <i>PT1H</i>
    ///          </p>
    public let dataPreProcessingConfiguration: DataPreProcessingConfiguration?
    /// <p>The Amazon Resouce Name (ARN) of the dataset used to create the ML model being
    ///          described. </p>
    public let datasetArn: String?
    /// <p>The name of the dataset being used by the ML being described. </p>
    public let datasetName: String?
    /// <p> Indicates the time reference in the dataset that was used to end the subset of
    ///          evaluation data for the ML model. </p>
    public let evaluationDataEndTime: Date?
    /// <p> Indicates the time reference in the dataset that was used to begin the subset of
    ///          evaluation data for the ML model. </p>
    public let evaluationDataStartTime: Date?
    /// <p>If the training of the ML model failed, this indicates the reason for that failure.
    ///       </p>
    public let failedReason: String?
    /// <p>Specifies configuration information about the labels input, including its S3 location.
    ///       </p>
    public let labelsInputConfiguration: LabelsInputConfiguration?
    /// <p>Indicates the last time the ML model was updated. The type of update is not specified.
    ///       </p>
    public let lastUpdatedTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the ML model being described. </p>
    public let modelArn: String?
    /// <p>The Model Metrics show an aggregated summary of the model's performance within the evaluation time
    ///          range. This is the JSON content of the metrics created when evaluating the model. </p>
    public let modelMetrics: String?
    /// <p>The name of the ML model being described. </p>
    public let modelName: String?
    /// <p> The Amazon Resource Name (ARN) of a role with permission to access the data source for
    ///          the ML model being described. </p>
    public let roleArn: String?
    /// <p>A JSON description of the data that is in each time series dataset, including names,
    ///          column names, and data types. </p>
    public let schema: String?
    /// <p>Provides the identifier of the AWS KMS customer master key (CMK) used to encrypt model data by Amazon Lookout for Equipment. </p>
    public let serverSideKmsKeyId: String?
    /// <p>Specifies the current status of the model being described. Status describes the status
    ///          of the most recent action of the model. </p>
    public let status: ModelStatus?
    /// <p> Indicates the time reference in the dataset that was used to end the subset of training
    ///          data for the ML model. </p>
    public let trainingDataEndTime: Date?
    /// <p> Indicates the time reference in the dataset that was used to begin the subset of
    ///          training data for the ML model. </p>
    public let trainingDataStartTime: Date?
    /// <p>Indicates the time at which the training of the ML model was completed. </p>
    public let trainingExecutionEndTime: Date?
    /// <p>Indicates the time at which the training of the ML model began. </p>
    public let trainingExecutionStartTime: Date?

    public init (
        createdAt: Date? = nil,
        dataPreProcessingConfiguration: DataPreProcessingConfiguration? = nil,
        datasetArn: String? = nil,
        datasetName: String? = nil,
        evaluationDataEndTime: Date? = nil,
        evaluationDataStartTime: Date? = nil,
        failedReason: String? = nil,
        labelsInputConfiguration: LabelsInputConfiguration? = nil,
        lastUpdatedTime: Date? = nil,
        modelArn: String? = nil,
        modelMetrics: String? = nil,
        modelName: String? = nil,
        roleArn: String? = nil,
        schema: String? = nil,
        serverSideKmsKeyId: String? = nil,
        status: ModelStatus? = nil,
        trainingDataEndTime: Date? = nil,
        trainingDataStartTime: Date? = nil,
        trainingExecutionEndTime: Date? = nil,
        trainingExecutionStartTime: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.dataPreProcessingConfiguration = dataPreProcessingConfiguration
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.evaluationDataEndTime = evaluationDataEndTime
        self.evaluationDataStartTime = evaluationDataStartTime
        self.failedReason = failedReason
        self.labelsInputConfiguration = labelsInputConfiguration
        self.lastUpdatedTime = lastUpdatedTime
        self.modelArn = modelArn
        self.modelMetrics = modelMetrics
        self.modelName = modelName
        self.roleArn = roleArn
        self.schema = schema
        self.serverSideKmsKeyId = serverSideKmsKeyId
        self.status = status
        self.trainingDataEndTime = trainingDataEndTime
        self.trainingDataStartTime = trainingDataStartTime
        self.trainingExecutionEndTime = trainingExecutionEndTime
        self.trainingExecutionStartTime = trainingExecutionStartTime
    }
}

struct DescribeModelOutputResponseBody: Equatable {
    public let modelName: String?
    public let modelArn: String?
    public let datasetName: String?
    public let datasetArn: String?
    public let schema: String?
    public let labelsInputConfiguration: LabelsInputConfiguration?
    public let trainingDataStartTime: Date?
    public let trainingDataEndTime: Date?
    public let evaluationDataStartTime: Date?
    public let evaluationDataEndTime: Date?
    public let roleArn: String?
    public let dataPreProcessingConfiguration: DataPreProcessingConfiguration?
    public let status: ModelStatus?
    public let trainingExecutionStartTime: Date?
    public let trainingExecutionEndTime: Date?
    public let failedReason: String?
    public let modelMetrics: String?
    public let lastUpdatedTime: Date?
    public let createdAt: Date?
    public let serverSideKmsKeyId: String?
}

extension DescribeModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case dataPreProcessingConfiguration = "DataPreProcessingConfiguration"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case evaluationDataEndTime = "EvaluationDataEndTime"
        case evaluationDataStartTime = "EvaluationDataStartTime"
        case failedReason = "FailedReason"
        case labelsInputConfiguration = "LabelsInputConfiguration"
        case lastUpdatedTime = "LastUpdatedTime"
        case modelArn = "ModelArn"
        case modelMetrics = "ModelMetrics"
        case modelName = "ModelName"
        case roleArn = "RoleArn"
        case schema = "Schema"
        case serverSideKmsKeyId = "ServerSideKmsKeyId"
        case status = "Status"
        case trainingDataEndTime = "TrainingDataEndTime"
        case trainingDataStartTime = "TrainingDataStartTime"
        case trainingExecutionEndTime = "TrainingExecutionEndTime"
        case trainingExecutionStartTime = "TrainingExecutionStartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let labelsInputConfigurationDecoded = try containerValues.decodeIfPresent(LabelsInputConfiguration.self, forKey: .labelsInputConfiguration)
        labelsInputConfiguration = labelsInputConfigurationDecoded
        let trainingDataStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingDataStartTime)
        trainingDataStartTime = trainingDataStartTimeDecoded
        let trainingDataEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingDataEndTime)
        trainingDataEndTime = trainingDataEndTimeDecoded
        let evaluationDataStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .evaluationDataStartTime)
        evaluationDataStartTime = evaluationDataStartTimeDecoded
        let evaluationDataEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .evaluationDataEndTime)
        evaluationDataEndTime = evaluationDataEndTimeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataPreProcessingConfigurationDecoded = try containerValues.decodeIfPresent(DataPreProcessingConfiguration.self, forKey: .dataPreProcessingConfiguration)
        dataPreProcessingConfiguration = dataPreProcessingConfigurationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let trainingExecutionStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingExecutionStartTime)
        trainingExecutionStartTime = trainingExecutionStartTimeDecoded
        let trainingExecutionEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .trainingExecutionEndTime)
        trainingExecutionEndTime = trainingExecutionEndTimeDecoded
        let failedReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failedReason)
        failedReason = failedReasonDecoded
        let modelMetricsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelMetrics)
        modelMetrics = modelMetricsDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serverSideKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverSideKmsKeyId)
        serverSideKmsKeyId = serverSideKmsKeyIdDecoded
    }
}

public enum InferenceExecutionStatus {
    case failed
    case inProgress
    case success
    case sdkUnknown(String)
}

extension InferenceExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InferenceExecutionStatus] {
        return [
            .failed,
            .inProgress,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InferenceExecutionStatus(rawValue: rawValue) ?? InferenceExecutionStatus.sdkUnknown(rawValue)
    }
}

extension InferenceExecutionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerResultObject = "CustomerResultObject"
        case dataEndTime = "DataEndTime"
        case dataInputConfiguration = "DataInputConfiguration"
        case dataOutputConfiguration = "DataOutputConfiguration"
        case dataStartTime = "DataStartTime"
        case failedReason = "FailedReason"
        case inferenceSchedulerArn = "InferenceSchedulerArn"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case modelArn = "ModelArn"
        case modelName = "ModelName"
        case scheduledStartTime = "ScheduledStartTime"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerResultObject = customerResultObject {
            try encodeContainer.encode(customerResultObject, forKey: .customerResultObject)
        }
        if let dataEndTime = dataEndTime {
            try encodeContainer.encode(dataEndTime.timeIntervalSince1970, forKey: .dataEndTime)
        }
        if let dataInputConfiguration = dataInputConfiguration {
            try encodeContainer.encode(dataInputConfiguration, forKey: .dataInputConfiguration)
        }
        if let dataOutputConfiguration = dataOutputConfiguration {
            try encodeContainer.encode(dataOutputConfiguration, forKey: .dataOutputConfiguration)
        }
        if let dataStartTime = dataStartTime {
            try encodeContainer.encode(dataStartTime.timeIntervalSince1970, forKey: .dataStartTime)
        }
        if let failedReason = failedReason {
            try encodeContainer.encode(failedReason, forKey: .failedReason)
        }
        if let inferenceSchedulerArn = inferenceSchedulerArn {
            try encodeContainer.encode(inferenceSchedulerArn, forKey: .inferenceSchedulerArn)
        }
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let scheduledStartTime = scheduledStartTime {
            try encodeContainer.encode(scheduledStartTime.timeIntervalSince1970, forKey: .scheduledStartTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let inferenceSchedulerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerArn)
        inferenceSchedulerArn = inferenceSchedulerArnDecoded
        let scheduledStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .scheduledStartTime)
        scheduledStartTime = scheduledStartTimeDecoded
        let dataStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dataStartTime)
        dataStartTime = dataStartTimeDecoded
        let dataEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dataEndTime)
        dataEndTime = dataEndTimeDecoded
        let dataInputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceInputConfiguration.self, forKey: .dataInputConfiguration)
        dataInputConfiguration = dataInputConfigurationDecoded
        let dataOutputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceOutputConfiguration.self, forKey: .dataOutputConfiguration)
        dataOutputConfiguration = dataOutputConfigurationDecoded
        let customerResultObjectDecoded = try containerValues.decodeIfPresent(S3Object.self, forKey: .customerResultObject)
        customerResultObject = customerResultObjectDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InferenceExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let failedReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failedReason)
        failedReason = failedReasonDecoded
    }
}

extension InferenceExecutionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferenceExecutionSummary(customerResultObject: \(String(describing: customerResultObject)), dataEndTime: \(String(describing: dataEndTime)), dataInputConfiguration: \(String(describing: dataInputConfiguration)), dataOutputConfiguration: \(String(describing: dataOutputConfiguration)), dataStartTime: \(String(describing: dataStartTime)), failedReason: \(String(describing: failedReason)), inferenceSchedulerArn: \(String(describing: inferenceSchedulerArn)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), modelArn: \(String(describing: modelArn)), modelName: \(String(describing: modelName)), scheduledStartTime: \(String(describing: scheduledStartTime)), status: \(String(describing: status)))"}
}

/// <p>Contains information about the specific inference execution, including input and output
///          data configuration, inference scheduling information, status, and so on. </p>
public struct InferenceExecutionSummary: Equatable {
    /// <p>
    ///       </p>
    public let customerResultObject: S3Object?
    /// <p>Indicates the time reference in the dataset at which the inference execution stopped.
    ///       </p>
    public let dataEndTime: Date?
    /// <p> Specifies configuration information for the input data for the inference scheduler,
    ///          including delimiter, format, and dataset location. </p>
    public let dataInputConfiguration: InferenceInputConfiguration?
    /// <p> Specifies configuration information for the output results from for the inference
    ///          execution, including the output S3 location. </p>
    public let dataOutputConfiguration: InferenceOutputConfiguration?
    /// <p>Indicates the time reference in the dataset at which the inference execution began.
    ///       </p>
    public let dataStartTime: Date?
    /// <p> Specifies the reason for failure when an inference execution has failed. </p>
    public let failedReason: String?
    /// <p> The Amazon Resource Name (ARN) of the inference scheduler being used for the inference
    ///          execution. </p>
    public let inferenceSchedulerArn: String?
    /// <p>The name of the inference scheduler being used for the inference execution. </p>
    public let inferenceSchedulerName: String?
    /// <p>The Amazon Resource Name (ARN) of the ML model used for the inference execution. </p>
    public let modelArn: String?
    /// <p>The name of the ML model being used for the inference execution. </p>
    public let modelName: String?
    /// <p>Indicates the start time at which the inference scheduler began the specific inference
    ///          execution. </p>
    public let scheduledStartTime: Date?
    /// <p>Indicates the status of the inference execution. </p>
    public let status: InferenceExecutionStatus?

    public init (
        customerResultObject: S3Object? = nil,
        dataEndTime: Date? = nil,
        dataInputConfiguration: InferenceInputConfiguration? = nil,
        dataOutputConfiguration: InferenceOutputConfiguration? = nil,
        dataStartTime: Date? = nil,
        failedReason: String? = nil,
        inferenceSchedulerArn: String? = nil,
        inferenceSchedulerName: String? = nil,
        modelArn: String? = nil,
        modelName: String? = nil,
        scheduledStartTime: Date? = nil,
        status: InferenceExecutionStatus? = nil
    )
    {
        self.customerResultObject = customerResultObject
        self.dataEndTime = dataEndTime
        self.dataInputConfiguration = dataInputConfiguration
        self.dataOutputConfiguration = dataOutputConfiguration
        self.dataStartTime = dataStartTime
        self.failedReason = failedReason
        self.inferenceSchedulerArn = inferenceSchedulerArn
        self.inferenceSchedulerName = inferenceSchedulerName
        self.modelArn = modelArn
        self.modelName = modelName
        self.scheduledStartTime = scheduledStartTime
        self.status = status
    }
}

extension InferenceInputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inferenceInputNameConfiguration = "InferenceInputNameConfiguration"
        case inputTimeZoneOffset = "InputTimeZoneOffset"
        case s3InputConfiguration = "S3InputConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inferenceInputNameConfiguration = inferenceInputNameConfiguration {
            try encodeContainer.encode(inferenceInputNameConfiguration, forKey: .inferenceInputNameConfiguration)
        }
        if let inputTimeZoneOffset = inputTimeZoneOffset {
            try encodeContainer.encode(inputTimeZoneOffset, forKey: .inputTimeZoneOffset)
        }
        if let s3InputConfiguration = s3InputConfiguration {
            try encodeContainer.encode(s3InputConfiguration, forKey: .s3InputConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3InputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceS3InputConfiguration.self, forKey: .s3InputConfiguration)
        s3InputConfiguration = s3InputConfigurationDecoded
        let inputTimeZoneOffsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputTimeZoneOffset)
        inputTimeZoneOffset = inputTimeZoneOffsetDecoded
        let inferenceInputNameConfigurationDecoded = try containerValues.decodeIfPresent(InferenceInputNameConfiguration.self, forKey: .inferenceInputNameConfiguration)
        inferenceInputNameConfiguration = inferenceInputNameConfigurationDecoded
    }
}

extension InferenceInputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferenceInputConfiguration(inferenceInputNameConfiguration: \(String(describing: inferenceInputNameConfiguration)), inputTimeZoneOffset: \(String(describing: inputTimeZoneOffset)), s3InputConfiguration: \(String(describing: s3InputConfiguration)))"}
}

/// <p>> Specifies configuration information for the input data for the inference, including S3
///          location of input data.. </p>
public struct InferenceInputConfiguration: Equatable {
    /// <p>> Specifies configuration information for the input data for the inference, including
    ///          timestamp format and delimiter. </p>
    public let inferenceInputNameConfiguration: InferenceInputNameConfiguration?
    /// <p>Indicates the difference between your time zone and Greenwich Mean Time (GMT). </p>
    public let inputTimeZoneOffset: String?
    /// <p> Specifies configuration information for the input data for the inference, including S3
    ///          location of input data.. </p>
    public let s3InputConfiguration: InferenceS3InputConfiguration?

    public init (
        inferenceInputNameConfiguration: InferenceInputNameConfiguration? = nil,
        inputTimeZoneOffset: String? = nil,
        s3InputConfiguration: InferenceS3InputConfiguration? = nil
    )
    {
        self.inferenceInputNameConfiguration = inferenceInputNameConfiguration
        self.inputTimeZoneOffset = inputTimeZoneOffset
        self.s3InputConfiguration = s3InputConfiguration
    }
}

extension InferenceInputNameConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentTimestampDelimiter = "ComponentTimestampDelimiter"
        case timestampFormat = "TimestampFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentTimestampDelimiter = componentTimestampDelimiter {
            try encodeContainer.encode(componentTimestampDelimiter, forKey: .componentTimestampDelimiter)
        }
        if let timestampFormat = timestampFormat {
            try encodeContainer.encode(timestampFormat, forKey: .timestampFormat)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let componentTimestampDelimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentTimestampDelimiter)
        componentTimestampDelimiter = componentTimestampDelimiterDecoded
    }
}

extension InferenceInputNameConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferenceInputNameConfiguration(componentTimestampDelimiter: \(String(describing: componentTimestampDelimiter)), timestampFormat: \(String(describing: timestampFormat)))"}
}

/// <p>>> Specifies configuration information for the input data for the inference, including
///          timestamp format and delimiter. </p>
public struct InferenceInputNameConfiguration: Equatable {
    /// <p>Indicates the delimiter character used between items in the data. </p>
    public let componentTimestampDelimiter: String?
    /// <p>The format of the timestamp, whether Epoch time, or standard, with or without hyphens
    ///          (-). </p>
    public let timestampFormat: String?

    public init (
        componentTimestampDelimiter: String? = nil,
        timestampFormat: String? = nil
    )
    {
        self.componentTimestampDelimiter = componentTimestampDelimiter
        self.timestampFormat = timestampFormat
    }
}

extension InferenceOutputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "KmsKeyId"
        case s3OutputConfiguration = "S3OutputConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let s3OutputConfiguration = s3OutputConfiguration {
            try encodeContainer.encode(s3OutputConfiguration, forKey: .s3OutputConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3OutputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceS3OutputConfiguration.self, forKey: .s3OutputConfiguration)
        s3OutputConfiguration = s3OutputConfigurationDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension InferenceOutputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferenceOutputConfiguration(kmsKeyId: \(String(describing: kmsKeyId)), s3OutputConfiguration: \(String(describing: s3OutputConfiguration)))"}
}

/// <p> Specifies configuration information for the output results from for the inference,
///          including KMS key ID and output S3 location. </p>
public struct InferenceOutputConfiguration: Equatable {
    /// <p>The ID number for the AWS KMS key used to encrypt the inference output. </p>
    public let kmsKeyId: String?
    /// <p> Specifies configuration information for the output results from for the inference,
    ///          output S3 location. </p>
    public let s3OutputConfiguration: InferenceS3OutputConfiguration?

    public init (
        kmsKeyId: String? = nil,
        s3OutputConfiguration: InferenceS3OutputConfiguration? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.s3OutputConfiguration = s3OutputConfiguration
    }
}

extension InferenceS3InputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension InferenceS3InputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferenceS3InputConfiguration(bucket: \(String(describing: bucket)), prefix: \(String(describing: prefix)))"}
}

/// <p> Specifies configuration information for the input data for the inference, including
///          input data S3 location. </p>
public struct InferenceS3InputConfiguration: Equatable {
    /// <p>The bucket containing the input dataset for the inference. </p>
    public let bucket: String?
    /// <p>The prefix for the S3 bucket used for the input data for the inference. </p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.prefix = prefix
    }
}

extension InferenceS3OutputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension InferenceS3OutputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferenceS3OutputConfiguration(bucket: \(String(describing: bucket)), prefix: \(String(describing: prefix)))"}
}

/// <p> Specifies configuration information for the output results from the inference,
///          including output S3 location. </p>
public struct InferenceS3OutputConfiguration: Equatable {
    /// <p> The bucket containing the output results from the inference </p>
    public let bucket: String?
    /// <p> The prefix for the S3 bucket used for the output results from the inference. </p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.prefix = prefix
    }
}

public enum InferenceSchedulerStatus {
    case pending
    case running
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension InferenceSchedulerStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InferenceSchedulerStatus] {
        return [
            .pending,
            .running,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InferenceSchedulerStatus(rawValue: rawValue) ?? InferenceSchedulerStatus.sdkUnknown(rawValue)
    }
}

extension InferenceSchedulerSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataDelayOffsetInMinutes = "DataDelayOffsetInMinutes"
        case dataUploadFrequency = "DataUploadFrequency"
        case inferenceSchedulerArn = "InferenceSchedulerArn"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case modelArn = "ModelArn"
        case modelName = "ModelName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataDelayOffsetInMinutes = dataDelayOffsetInMinutes {
            try encodeContainer.encode(dataDelayOffsetInMinutes, forKey: .dataDelayOffsetInMinutes)
        }
        if let dataUploadFrequency = dataUploadFrequency {
            try encodeContainer.encode(dataUploadFrequency.rawValue, forKey: .dataUploadFrequency)
        }
        if let inferenceSchedulerArn = inferenceSchedulerArn {
            try encodeContainer.encode(inferenceSchedulerArn, forKey: .inferenceSchedulerArn)
        }
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let inferenceSchedulerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerArn)
        inferenceSchedulerArn = inferenceSchedulerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InferenceSchedulerStatus.self, forKey: .status)
        status = statusDecoded
        let dataDelayOffsetInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataDelayOffsetInMinutes)
        dataDelayOffsetInMinutes = dataDelayOffsetInMinutesDecoded
        let dataUploadFrequencyDecoded = try containerValues.decodeIfPresent(DataUploadFrequency.self, forKey: .dataUploadFrequency)
        dataUploadFrequency = dataUploadFrequencyDecoded
    }
}

extension InferenceSchedulerSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InferenceSchedulerSummary(dataDelayOffsetInMinutes: \(String(describing: dataDelayOffsetInMinutes)), dataUploadFrequency: \(String(describing: dataUploadFrequency)), inferenceSchedulerArn: \(String(describing: inferenceSchedulerArn)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), modelArn: \(String(describing: modelArn)), modelName: \(String(describing: modelName)), status: \(String(describing: status)))"}
}

/// <p>Contains information about the specific inference scheduler, including data delay
///          offset, model name and ARN, status, and so on. </p>
public struct InferenceSchedulerSummary: Equatable {
    /// <p>> A period of time (in minutes) by which inference on the data is delayed after the data
    ///          starts. For instance, if an offset delay time of five minutes was selected, inference will
    ///          not begin on the data until the first data measurement after the five minute mark. For example, if
    ///          five minutes is selected, the inference scheduler will wake up at the configured frequency with the
    ///          additional five minute delay time to check the customer S3 bucket. The customer can upload data at
    ///          the same frequency and they don't need to stop and restart the scheduler when uploading new data.
    ///       </p>
    public let dataDelayOffsetInMinutes: Int?
    /// <p>How often data is uploaded to the source S3 bucket for the input data. This value is the
    ///          length of time between data uploads. For instance, if you select 5 minutes, Amazon Lookout for Equipment
    ///          will upload the real-time data to the source bucket once every 5 minutes. This frequency also
    ///          determines how often Amazon Lookout for Equipment starts a scheduled inference on your data. In this
    ///          example, it starts once every 5 minutes. </p>
    public let dataUploadFrequency: DataUploadFrequency?
    /// <p> The Amazon Resource Name (ARN) of the inference scheduler. </p>
    public let inferenceSchedulerArn: String?
    /// <p>The name of the inference scheduler. </p>
    public let inferenceSchedulerName: String?
    /// <p> The Amazon Resource Name (ARN) of the ML model used by the inference scheduler. </p>
    public let modelArn: String?
    /// <p>The name of the ML model used for the inference scheduler. </p>
    public let modelName: String?
    /// <p>Indicates the status of the inference scheduler. </p>
    public let status: InferenceSchedulerStatus?

    public init (
        dataDelayOffsetInMinutes: Int? = nil,
        dataUploadFrequency: DataUploadFrequency? = nil,
        inferenceSchedulerArn: String? = nil,
        inferenceSchedulerName: String? = nil,
        modelArn: String? = nil,
        modelName: String? = nil,
        status: InferenceSchedulerStatus? = nil
    )
    {
        self.dataDelayOffsetInMinutes = dataDelayOffsetInMinutes
        self.dataUploadFrequency = dataUploadFrequency
        self.inferenceSchedulerArn = inferenceSchedulerArn
        self.inferenceSchedulerName = inferenceSchedulerName
        self.modelArn = modelArn
        self.modelName = modelName
        self.status = status
    }
}

extension IngestionInputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3InputConfiguration = "S3InputConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3InputConfiguration = s3InputConfiguration {
            try encodeContainer.encode(s3InputConfiguration, forKey: .s3InputConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3InputConfigurationDecoded = try containerValues.decodeIfPresent(IngestionS3InputConfiguration.self, forKey: .s3InputConfiguration)
        s3InputConfiguration = s3InputConfigurationDecoded
    }
}

extension IngestionInputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IngestionInputConfiguration(s3InputConfiguration: \(String(describing: s3InputConfiguration)))"}
}

/// <p> Specifies configuration information for the input data for the data ingestion job,
///          including input data S3 location. </p>
public struct IngestionInputConfiguration: Equatable {
    /// <p>The location information for the S3 bucket used for input data for the data ingestion.
    ///       </p>
    public let s3InputConfiguration: IngestionS3InputConfiguration?

    public init (
        s3InputConfiguration: IngestionS3InputConfiguration? = nil
    )
    {
        self.s3InputConfiguration = s3InputConfiguration
    }
}

public enum IngestionJobStatus {
    case failed
    case inProgress
    case success
    case sdkUnknown(String)
}

extension IngestionJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IngestionJobStatus] {
        return [
            .failed,
            .inProgress,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IngestionJobStatus(rawValue: rawValue) ?? IngestionJobStatus.sdkUnknown(rawValue)
    }
}

extension IngestionS3InputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension IngestionS3InputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IngestionS3InputConfiguration(bucket: \(String(describing: bucket)), prefix: \(String(describing: prefix)))"}
}

/// <p> Specifies S3 configuration information for the input data for the data ingestion job.
///       </p>
public struct IngestionS3InputConfiguration: Equatable {
    /// <p>The name of the S3 bucket used for the input data for the data ingestion. </p>
    public let bucket: String?
    /// <p>The prefix for the S3 location being used for the input data for the data ingestion.
    ///       </p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.prefix = prefix
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Processing of the request has failed because of an unknown error, exception or failure.
///       </p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LabelsInputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3InputConfiguration = "S3InputConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3InputConfiguration = s3InputConfiguration {
            try encodeContainer.encode(s3InputConfiguration, forKey: .s3InputConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3InputConfigurationDecoded = try containerValues.decodeIfPresent(LabelsS3InputConfiguration.self, forKey: .s3InputConfiguration)
        s3InputConfiguration = s3InputConfigurationDecoded
    }
}

extension LabelsInputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelsInputConfiguration(s3InputConfiguration: \(String(describing: s3InputConfiguration)))"}
}

/// <p>Contains the configuration information for the S3 location being used to hold label
///          data. </p>
public struct LabelsInputConfiguration: Equatable {
    /// <p>Contains location information for the S3 location being used for label data. </p>
    public let s3InputConfiguration: LabelsS3InputConfiguration?

    public init (
        s3InputConfiguration: LabelsS3InputConfiguration? = nil
    )
    {
        self.s3InputConfiguration = s3InputConfiguration
    }
}

extension LabelsS3InputConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension LabelsS3InputConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LabelsS3InputConfiguration(bucket: \(String(describing: bucket)), prefix: \(String(describing: prefix)))"}
}

/// <p>The location information (prefix and bucket name) for the s3 location being used for
///          label data. </p>
public struct LabelsS3InputConfiguration: Equatable {
    /// <p>The name of the S3 bucket holding the label data. </p>
    public let bucket: String?
    /// <p> The prefix for the S3 bucket used for the label data. </p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.prefix = prefix
    }
}

public struct ListDataIngestionJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListDataIngestionJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataIngestionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataIngestionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataIngestionJobsInput>
    public typealias MOutput = OperationOutput<ListDataIngestionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataIngestionJobsOutputError>
}

extension ListDataIngestionJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataIngestionJobsInput(datasetName: \(String(describing: datasetName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension ListDataIngestionJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListDataIngestionJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataIngestionJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataIngestionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataIngestionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataIngestionJobsInput>
    public typealias MOutput = OperationOutput<ListDataIngestionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataIngestionJobsOutputError>
}

public struct ListDataIngestionJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataIngestionJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataIngestionJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataIngestionJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataIngestionJobsInput>
    public typealias MOutput = OperationOutput<ListDataIngestionJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataIngestionJobsOutputError>
}

public struct ListDataIngestionJobsInput: Equatable {
    /// <p>The name of the dataset being used for the data ingestion job. </p>
    public let datasetName: String?
    /// <p> Specifies the maximum number of data ingestion jobs to list. </p>
    public let maxResults: Int?
    /// <p> An opaque pagination token indicating where to continue the listing of data ingestion
    ///          jobs. </p>
    public let nextToken: String?
    /// <p>Indicates the status of the data ingestion job. </p>
    public let status: IngestionJobStatus?

    public init (
        datasetName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: IngestionJobStatus? = nil
    )
    {
        self.datasetName = datasetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListDataIngestionJobsInputBody: Equatable {
    public let datasetName: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let status: IngestionJobStatus?
}

extension ListDataIngestionJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetName = "DatasetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IngestionJobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListDataIngestionJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataIngestionJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataIngestionJobsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataIngestionJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataIngestionJobsOutputResponse(dataIngestionJobSummaries: \(String(describing: dataIngestionJobSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataIngestionJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataIngestionJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataIngestionJobSummaries = output.dataIngestionJobSummaries
            self.nextToken = output.nextToken
        } else {
            self.dataIngestionJobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataIngestionJobsOutputResponse: Equatable {
    /// <p>Specifies information about the specific data ingestion job, including dataset name and
    ///          status. </p>
    public let dataIngestionJobSummaries: [DataIngestionJobSummary]?
    /// <p> An opaque pagination token indicating where to continue the listing of data ingestion
    ///          jobs. </p>
    public let nextToken: String?

    public init (
        dataIngestionJobSummaries: [DataIngestionJobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.dataIngestionJobSummaries = dataIngestionJobSummaries
        self.nextToken = nextToken
    }
}

struct ListDataIngestionJobsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let dataIngestionJobSummaries: [DataIngestionJobSummary]?
}

extension ListDataIngestionJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataIngestionJobSummaries = "DataIngestionJobSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataIngestionJobSummariesContainer = try containerValues.decodeIfPresent([DataIngestionJobSummary?].self, forKey: .dataIngestionJobSummaries)
        var dataIngestionJobSummariesDecoded0:[DataIngestionJobSummary]? = nil
        if let dataIngestionJobSummariesContainer = dataIngestionJobSummariesContainer {
            dataIngestionJobSummariesDecoded0 = [DataIngestionJobSummary]()
            for structure0 in dataIngestionJobSummariesContainer {
                if let structure0 = structure0 {
                    dataIngestionJobSummariesDecoded0?.append(structure0)
                }
            }
        }
        dataIngestionJobSummaries = dataIngestionJobSummariesDecoded0
    }
}

public struct ListDatasetsInputBodyMiddleware: Middleware {
    public let id: String = "ListDatasetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

extension ListDatasetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsInput(datasetNameBeginsWith: \(String(describing: datasetNameBeginsWith)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetNameBeginsWith = "DatasetNameBeginsWith"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetNameBeginsWith = datasetNameBeginsWith {
            try encodeContainer.encode(datasetNameBeginsWith, forKey: .datasetNameBeginsWith)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInput: Equatable {
    /// <p>The beginning of the name of the datasets to be listed. </p>
    public let datasetNameBeginsWith: String?
    /// <p> Specifies the maximum number of datasets to list. </p>
    public let maxResults: Int?
    /// <p> An opaque pagination token indicating where to continue the listing of datasets.
    ///       </p>
    public let nextToken: String?

    public init (
        datasetNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetNameBeginsWith = datasetNameBeginsWith
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let datasetNameBeginsWith: String?
}

extension ListDatasetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetNameBeginsWith = "DatasetNameBeginsWith"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let datasetNameBeginsWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetNameBeginsWith)
        datasetNameBeginsWith = datasetNameBeginsWithDecoded
    }
}

extension ListDatasetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsOutputResponse(datasetSummaries: \(String(describing: datasetSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetSummaries = output.datasetSummaries
            self.nextToken = output.nextToken
        } else {
            self.datasetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Equatable {
    /// <p>Provides information about the specified dataset, including creation time, dataset ARN,
    ///          and status. </p>
    public let datasetSummaries: [DatasetSummary]?
    /// <p> An opaque pagination token indicating where to continue the listing of datasets.
    ///       </p>
    public let nextToken: String?

    public init (
        datasetSummaries: [DatasetSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetSummaries = datasetSummaries
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let datasetSummaries: [DatasetSummary]?
}

extension ListDatasetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetSummaries = "DatasetSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let datasetSummariesContainer = try containerValues.decodeIfPresent([DatasetSummary?].self, forKey: .datasetSummaries)
        var datasetSummariesDecoded0:[DatasetSummary]? = nil
        if let datasetSummariesContainer = datasetSummariesContainer {
            datasetSummariesDecoded0 = [DatasetSummary]()
            for structure0 in datasetSummariesContainer {
                if let structure0 = structure0 {
                    datasetSummariesDecoded0?.append(structure0)
                }
            }
        }
        datasetSummaries = datasetSummariesDecoded0
    }
}

public struct ListInferenceExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "ListInferenceExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInferenceExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInferenceExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInferenceExecutionsInput>
    public typealias MOutput = OperationOutput<ListInferenceExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInferenceExecutionsOutputError>
}

extension ListInferenceExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInferenceExecutionsInput(dataEndTimeBefore: \(String(describing: dataEndTimeBefore)), dataStartTimeAfter: \(String(describing: dataStartTimeAfter)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension ListInferenceExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataEndTimeBefore = "DataEndTimeBefore"
        case dataStartTimeAfter = "DataStartTimeAfter"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataEndTimeBefore = dataEndTimeBefore {
            try encodeContainer.encode(dataEndTimeBefore.timeIntervalSince1970, forKey: .dataEndTimeBefore)
        }
        if let dataStartTimeAfter = dataStartTimeAfter {
            try encodeContainer.encode(dataStartTimeAfter.timeIntervalSince1970, forKey: .dataStartTimeAfter)
        }
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListInferenceExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInferenceExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInferenceExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInferenceExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInferenceExecutionsInput>
    public typealias MOutput = OperationOutput<ListInferenceExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInferenceExecutionsOutputError>
}

public struct ListInferenceExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInferenceExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInferenceExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInferenceExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInferenceExecutionsInput>
    public typealias MOutput = OperationOutput<ListInferenceExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInferenceExecutionsOutputError>
}

public struct ListInferenceExecutionsInput: Equatable {
    /// <p>The time reference in the inferenced dataset before which Amazon Lookout for Equipment stopped the
    ///          inference execution. </p>
    public let dataEndTimeBefore: Date?
    /// <p>The time reference in the inferenced dataset after which Amazon Lookout for Equipment started the
    ///          inference execution. </p>
    public let dataStartTimeAfter: Date?
    /// <p>The name of the inference scheduler for the inference execution listed. </p>
    public let inferenceSchedulerName: String?
    /// <p>Specifies the maximum number of inference executions to list. </p>
    public let maxResults: Int?
    /// <p>An opaque pagination token indicating where to continue the listing of inference
    ///          executions.</p>
    public let nextToken: String?
    /// <p>The status of the inference execution. </p>
    public let status: InferenceExecutionStatus?

    public init (
        dataEndTimeBefore: Date? = nil,
        dataStartTimeAfter: Date? = nil,
        inferenceSchedulerName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        status: InferenceExecutionStatus? = nil
    )
    {
        self.dataEndTimeBefore = dataEndTimeBefore
        self.dataStartTimeAfter = dataStartTimeAfter
        self.inferenceSchedulerName = inferenceSchedulerName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListInferenceExecutionsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let inferenceSchedulerName: String?
    public let dataStartTimeAfter: Date?
    public let dataEndTimeBefore: Date?
    public let status: InferenceExecutionStatus?
}

extension ListInferenceExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataEndTimeBefore = "DataEndTimeBefore"
        case dataStartTimeAfter = "DataStartTimeAfter"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let dataStartTimeAfterDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dataStartTimeAfter)
        dataStartTimeAfter = dataStartTimeAfterDecoded
        let dataEndTimeBeforeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dataEndTimeBefore)
        dataEndTimeBefore = dataEndTimeBeforeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InferenceExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ListInferenceExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInferenceExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInferenceExecutionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInferenceExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInferenceExecutionsOutputResponse(inferenceExecutionSummaries: \(String(describing: inferenceExecutionSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInferenceExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInferenceExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inferenceExecutionSummaries = output.inferenceExecutionSummaries
            self.nextToken = output.nextToken
        } else {
            self.inferenceExecutionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListInferenceExecutionsOutputResponse: Equatable {
    /// <p>Provides an array of information about the individual inference executions returned from
    ///          the <code>ListInferenceExecutions</code> operation, including model used, inference
    ///          scheduler, data configuration, and so on. </p>
    public let inferenceExecutionSummaries: [InferenceExecutionSummary]?
    /// <p> An opaque pagination token indicating where to continue the listing of inference
    ///          executions. </p>
    public let nextToken: String?

    public init (
        inferenceExecutionSummaries: [InferenceExecutionSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.inferenceExecutionSummaries = inferenceExecutionSummaries
        self.nextToken = nextToken
    }
}

struct ListInferenceExecutionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let inferenceExecutionSummaries: [InferenceExecutionSummary]?
}

extension ListInferenceExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceExecutionSummaries = "InferenceExecutionSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let inferenceExecutionSummariesContainer = try containerValues.decodeIfPresent([InferenceExecutionSummary?].self, forKey: .inferenceExecutionSummaries)
        var inferenceExecutionSummariesDecoded0:[InferenceExecutionSummary]? = nil
        if let inferenceExecutionSummariesContainer = inferenceExecutionSummariesContainer {
            inferenceExecutionSummariesDecoded0 = [InferenceExecutionSummary]()
            for structure0 in inferenceExecutionSummariesContainer {
                if let structure0 = structure0 {
                    inferenceExecutionSummariesDecoded0?.append(structure0)
                }
            }
        }
        inferenceExecutionSummaries = inferenceExecutionSummariesDecoded0
    }
}

public struct ListInferenceSchedulersInputBodyMiddleware: Middleware {
    public let id: String = "ListInferenceSchedulersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInferenceSchedulersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInferenceSchedulersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInferenceSchedulersInput>
    public typealias MOutput = OperationOutput<ListInferenceSchedulersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInferenceSchedulersOutputError>
}

extension ListInferenceSchedulersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInferenceSchedulersInput(inferenceSchedulerNameBeginsWith: \(String(describing: inferenceSchedulerNameBeginsWith)), maxResults: \(String(describing: maxResults)), modelName: \(String(describing: modelName)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInferenceSchedulersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerNameBeginsWith = "InferenceSchedulerNameBeginsWith"
        case maxResults = "MaxResults"
        case modelName = "ModelName"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inferenceSchedulerNameBeginsWith = inferenceSchedulerNameBeginsWith {
            try encodeContainer.encode(inferenceSchedulerNameBeginsWith, forKey: .inferenceSchedulerNameBeginsWith)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInferenceSchedulersInputHeadersMiddleware: Middleware {
    public let id: String = "ListInferenceSchedulersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInferenceSchedulersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInferenceSchedulersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInferenceSchedulersInput>
    public typealias MOutput = OperationOutput<ListInferenceSchedulersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInferenceSchedulersOutputError>
}

public struct ListInferenceSchedulersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInferenceSchedulersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInferenceSchedulersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInferenceSchedulersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInferenceSchedulersInput>
    public typealias MOutput = OperationOutput<ListInferenceSchedulersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInferenceSchedulersOutputError>
}

public struct ListInferenceSchedulersInput: Equatable {
    /// <p>The beginning of the name of the inference schedulers to be listed. </p>
    public let inferenceSchedulerNameBeginsWith: String?
    /// <p> Specifies the maximum number of inference schedulers to list. </p>
    public let maxResults: Int?
    /// <p>The name of the ML model used by the inference scheduler to be listed. </p>
    public let modelName: String?
    /// <p> An opaque pagination token indicating where to continue the listing of inference
    ///          schedulers. </p>
    public let nextToken: String?

    public init (
        inferenceSchedulerNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        modelName: String? = nil,
        nextToken: String? = nil
    )
    {
        self.inferenceSchedulerNameBeginsWith = inferenceSchedulerNameBeginsWith
        self.maxResults = maxResults
        self.modelName = modelName
        self.nextToken = nextToken
    }
}

struct ListInferenceSchedulersInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let inferenceSchedulerNameBeginsWith: String?
    public let modelName: String?
}

extension ListInferenceSchedulersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerNameBeginsWith = "InferenceSchedulerNameBeginsWith"
        case maxResults = "MaxResults"
        case modelName = "ModelName"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let inferenceSchedulerNameBeginsWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerNameBeginsWith)
        inferenceSchedulerNameBeginsWith = inferenceSchedulerNameBeginsWithDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension ListInferenceSchedulersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInferenceSchedulersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInferenceSchedulersOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInferenceSchedulersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInferenceSchedulersOutputResponse(inferenceSchedulerSummaries: \(String(describing: inferenceSchedulerSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInferenceSchedulersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInferenceSchedulersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inferenceSchedulerSummaries = output.inferenceSchedulerSummaries
            self.nextToken = output.nextToken
        } else {
            self.inferenceSchedulerSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListInferenceSchedulersOutputResponse: Equatable {
    /// <p>Provides information about the specified inference scheduler, including data upload
    ///          frequency, model name and ARN, and status. </p>
    public let inferenceSchedulerSummaries: [InferenceSchedulerSummary]?
    /// <p> An opaque pagination token indicating where to continue the listing of inference
    ///          schedulers. </p>
    public let nextToken: String?

    public init (
        inferenceSchedulerSummaries: [InferenceSchedulerSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.inferenceSchedulerSummaries = inferenceSchedulerSummaries
        self.nextToken = nextToken
    }
}

struct ListInferenceSchedulersOutputResponseBody: Equatable {
    public let nextToken: String?
    public let inferenceSchedulerSummaries: [InferenceSchedulerSummary]?
}

extension ListInferenceSchedulersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerSummaries = "InferenceSchedulerSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let inferenceSchedulerSummariesContainer = try containerValues.decodeIfPresent([InferenceSchedulerSummary?].self, forKey: .inferenceSchedulerSummaries)
        var inferenceSchedulerSummariesDecoded0:[InferenceSchedulerSummary]? = nil
        if let inferenceSchedulerSummariesContainer = inferenceSchedulerSummariesContainer {
            inferenceSchedulerSummariesDecoded0 = [InferenceSchedulerSummary]()
            for structure0 in inferenceSchedulerSummariesContainer {
                if let structure0 = structure0 {
                    inferenceSchedulerSummariesDecoded0?.append(structure0)
                }
            }
        }
        inferenceSchedulerSummaries = inferenceSchedulerSummariesDecoded0
    }
}

public struct ListModelsInputBodyMiddleware: Middleware {
    public let id: String = "ListModelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListModelsInput>
    public typealias MOutput = OperationOutput<ListModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListModelsOutputError>
}

extension ListModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListModelsInput(datasetNameBeginsWith: \(String(describing: datasetNameBeginsWith)), maxResults: \(String(describing: maxResults)), modelNameBeginsWith: \(String(describing: modelNameBeginsWith)), nextToken: \(String(describing: nextToken)), status: \(String(describing: status)))"}
}

extension ListModelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetNameBeginsWith = "DatasetNameBeginsWith"
        case maxResults = "MaxResults"
        case modelNameBeginsWith = "ModelNameBeginsWith"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetNameBeginsWith = datasetNameBeginsWith {
            try encodeContainer.encode(datasetNameBeginsWith, forKey: .datasetNameBeginsWith)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelNameBeginsWith = modelNameBeginsWith {
            try encodeContainer.encode(modelNameBeginsWith, forKey: .modelNameBeginsWith)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct ListModelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListModelsInput>
    public typealias MOutput = OperationOutput<ListModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListModelsOutputError>
}

public struct ListModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListModelsInput>
    public typealias MOutput = OperationOutput<ListModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListModelsOutputError>
}

public struct ListModelsInput: Equatable {
    /// <p>The beginning of the name of the dataset of the ML models to be listed. </p>
    public let datasetNameBeginsWith: String?
    /// <p> Specifies the maximum number of ML models to list. </p>
    public let maxResults: Int?
    /// <p>The beginning of the name of the ML models being listed. </p>
    public let modelNameBeginsWith: String?
    /// <p> An opaque pagination token indicating where to continue the listing of ML models.
    ///       </p>
    public let nextToken: String?
    /// <p>The status of the ML model. </p>
    public let status: ModelStatus?

    public init (
        datasetNameBeginsWith: String? = nil,
        maxResults: Int? = nil,
        modelNameBeginsWith: String? = nil,
        nextToken: String? = nil,
        status: ModelStatus? = nil
    )
    {
        self.datasetNameBeginsWith = datasetNameBeginsWith
        self.maxResults = maxResults
        self.modelNameBeginsWith = modelNameBeginsWith
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListModelsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let status: ModelStatus?
    public let modelNameBeginsWith: String?
    public let datasetNameBeginsWith: String?
}

extension ListModelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetNameBeginsWith = "DatasetNameBeginsWith"
        case maxResults = "MaxResults"
        case modelNameBeginsWith = "ModelNameBeginsWith"
        case nextToken = "NextToken"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let modelNameBeginsWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelNameBeginsWith)
        modelNameBeginsWith = modelNameBeginsWithDecoded
        let datasetNameBeginsWithDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetNameBeginsWith)
        datasetNameBeginsWith = datasetNameBeginsWithDecoded
    }
}

extension ListModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListModelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListModelsOutputResponse(modelSummaries: \(String(describing: modelSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelSummaries = output.modelSummaries
            self.nextToken = output.nextToken
        } else {
            self.modelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListModelsOutputResponse: Equatable {
    /// <p>Provides information on the specified model, including created time, model and dataset
    ///          ARNs, and status. </p>
    public let modelSummaries: [ModelSummary]?
    /// <p> An opaque pagination token indicating where to continue the listing of ML models.
    ///       </p>
    public let nextToken: String?

    public init (
        modelSummaries: [ModelSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.modelSummaries = modelSummaries
        self.nextToken = nextToken
    }
}

struct ListModelsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let modelSummaries: [ModelSummary]?
}

extension ListModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelSummaries = "ModelSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let modelSummariesContainer = try containerValues.decodeIfPresent([ModelSummary?].self, forKey: .modelSummaries)
        var modelSummariesDecoded0:[ModelSummary]? = nil
        if let modelSummariesContainer = modelSummariesContainer {
            modelSummariesDecoded0 = [ModelSummary]()
            for structure0 in modelSummariesContainer {
                if let structure0 = structure0 {
                    modelSummariesDecoded0?.append(structure0)
                }
            }
        }
        modelSummaries = modelSummariesDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource (such as the dataset or model) that is
    ///          the focus of the <code>ListTagsForResource</code> operation. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p> Any tags associated with the resource. </p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum ModelStatus {
    case failed
    case inProgress
    case success
    case sdkUnknown(String)
}

extension ModelStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelStatus] {
        return [
            .failed,
            .inProgress,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelStatus(rawValue: rawValue) ?? ModelStatus.sdkUnknown(rawValue)
    }
}

extension ModelSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case modelArn = "ModelArn"
        case modelName = "ModelName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension ModelSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelSummary(createdAt: \(String(describing: createdAt)), datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), modelArn: \(String(describing: modelArn)), modelName: \(String(describing: modelName)), status: \(String(describing: status)))"}
}

/// <p>Provides information about the specified ML model, including dataset and model names and
///          ARNs, as well as status. </p>
public struct ModelSummary: Equatable {
    /// <p>The time at which the specific model was created. </p>
    public let createdAt: Date?
    /// <p> The Amazon Resource Name (ARN) of the dataset used to create the model. </p>
    public let datasetArn: String?
    /// <p>The name of the dataset being used for the ML model. </p>
    public let datasetName: String?
    /// <p> The Amazon Resource Name (ARN) of the ML model. </p>
    public let modelArn: String?
    /// <p>The name of the ML model. </p>
    public let modelName: String?
    /// <p>Indicates the status of the ML model. </p>
    public let status: ModelStatus?

    public init (
        createdAt: Date? = nil,
        datasetArn: String? = nil,
        datasetName: String? = nil,
        modelArn: String? = nil,
        modelName: String? = nil,
        status: ModelStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.modelArn = modelArn
        self.modelName = modelName
        self.status = status
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The resource requested could not be found. Verify the resource ID and retry your
///          request. </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Object: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension S3Object: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Object(bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>Contains information about an S3 bucket. </p>
public struct S3Object: Equatable {
    /// <p>The name of the specific S3 bucket. </p>
    public let bucket: String?
    /// <p>The AWS Key Management Service (AWS KMS) key being used to encrypt the S3 object.
    ///          Without this key, data in the bucket is not accessible. </p>
    public let key: String?

    public init (
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Resource limitations have been exceeded. </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartDataIngestionJobInputBodyMiddleware: Middleware {
    public let id: String = "StartDataIngestionJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataIngestionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataIngestionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataIngestionJobInput>
    public typealias MOutput = OperationOutput<StartDataIngestionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataIngestionJobOutputError>
}

extension StartDataIngestionJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDataIngestionJobInput(clientToken: \(String(describing: clientToken)), datasetName: \(String(describing: datasetName)), ingestionInputConfiguration: \(String(describing: ingestionInputConfiguration)), roleArn: \(String(describing: roleArn)))"}
}

extension StartDataIngestionJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case datasetName = "DatasetName"
        case ingestionInputConfiguration = "IngestionInputConfiguration"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let ingestionInputConfiguration = ingestionInputConfiguration {
            try encodeContainer.encode(ingestionInputConfiguration, forKey: .ingestionInputConfiguration)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct StartDataIngestionJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartDataIngestionJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataIngestionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataIngestionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataIngestionJobInput>
    public typealias MOutput = OperationOutput<StartDataIngestionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataIngestionJobOutputError>
}

public struct StartDataIngestionJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartDataIngestionJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartDataIngestionJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartDataIngestionJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartDataIngestionJobInput>
    public typealias MOutput = OperationOutput<StartDataIngestionJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartDataIngestionJobOutputError>
}

public struct StartDataIngestionJobInput: Equatable {
    /// <p> A unique identifier for the request. If you do not set the client request token, Amazon
    ///          Lookout for Equipment generates one. </p>
    public var clientToken: String?
    /// <p>The name of the dataset being used by the data ingestion job. </p>
    public let datasetName: String?
    /// <p> Specifies information for the input data for the data ingestion job, including dataset
    ///          S3 location. </p>
    public let ingestionInputConfiguration: IngestionInputConfiguration?
    /// <p> The Amazon Resource Name (ARN) of a role with permission to access the data source for
    ///          the data ingestion job. </p>
    public let roleArn: String?

    public init (
        clientToken: String? = nil,
        datasetName: String? = nil,
        ingestionInputConfiguration: IngestionInputConfiguration? = nil,
        roleArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetName = datasetName
        self.ingestionInputConfiguration = ingestionInputConfiguration
        self.roleArn = roleArn
    }
}

struct StartDataIngestionJobInputBody: Equatable {
    public let datasetName: String?
    public let ingestionInputConfiguration: IngestionInputConfiguration?
    public let roleArn: String?
    public let clientToken: String?
}

extension StartDataIngestionJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case datasetName = "DatasetName"
        case ingestionInputConfiguration = "IngestionInputConfiguration"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let ingestionInputConfigurationDecoded = try containerValues.decodeIfPresent(IngestionInputConfiguration.self, forKey: .ingestionInputConfiguration)
        ingestionInputConfiguration = ingestionInputConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartDataIngestionJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDataIngestionJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDataIngestionJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDataIngestionJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartDataIngestionJobOutputResponse(jobId: \(String(describing: jobId)), status: \(String(describing: status)))"}
}

extension StartDataIngestionJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartDataIngestionJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.status = output.status
        } else {
            self.jobId = nil
            self.status = nil
        }
    }
}

public struct StartDataIngestionJobOutputResponse: Equatable {
    /// <p>Indicates the job ID of the data ingestion job. </p>
    public let jobId: String?
    /// <p>Indicates the status of the <code>StartDataIngestionJob</code> operation. </p>
    public let status: IngestionJobStatus?

    public init (
        jobId: String? = nil,
        status: IngestionJobStatus? = nil
    )
    {
        self.jobId = jobId
        self.status = status
    }
}

struct StartDataIngestionJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let status: IngestionJobStatus?
}

extension StartDataIngestionJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IngestionJobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct StartInferenceSchedulerInputBodyMiddleware: Middleware {
    public let id: String = "StartInferenceSchedulerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<StartInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartInferenceSchedulerOutputError>
}

extension StartInferenceSchedulerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartInferenceSchedulerInput(inferenceSchedulerName: \(String(describing: inferenceSchedulerName)))"}
}

extension StartInferenceSchedulerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerName = "InferenceSchedulerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
    }
}

public struct StartInferenceSchedulerInputHeadersMiddleware: Middleware {
    public let id: String = "StartInferenceSchedulerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<StartInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartInferenceSchedulerOutputError>
}

public struct StartInferenceSchedulerInputQueryItemMiddleware: Middleware {
    public let id: String = "StartInferenceSchedulerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<StartInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartInferenceSchedulerOutputError>
}

public struct StartInferenceSchedulerInput: Equatable {
    /// <p>The name of the inference scheduler to be started. </p>
    public let inferenceSchedulerName: String?

    public init (
        inferenceSchedulerName: String? = nil
    )
    {
        self.inferenceSchedulerName = inferenceSchedulerName
    }
}

struct StartInferenceSchedulerInputBody: Equatable {
    public let inferenceSchedulerName: String?
}

extension StartInferenceSchedulerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerName = "InferenceSchedulerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
    }
}

extension StartInferenceSchedulerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartInferenceSchedulerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartInferenceSchedulerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartInferenceSchedulerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartInferenceSchedulerOutputResponse(inferenceSchedulerArn: \(String(describing: inferenceSchedulerArn)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), modelArn: \(String(describing: modelArn)), modelName: \(String(describing: modelName)), status: \(String(describing: status)))"}
}

extension StartInferenceSchedulerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartInferenceSchedulerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inferenceSchedulerArn = output.inferenceSchedulerArn
            self.inferenceSchedulerName = output.inferenceSchedulerName
            self.modelArn = output.modelArn
            self.modelName = output.modelName
            self.status = output.status
        } else {
            self.inferenceSchedulerArn = nil
            self.inferenceSchedulerName = nil
            self.modelArn = nil
            self.modelName = nil
            self.status = nil
        }
    }
}

public struct StartInferenceSchedulerOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the inference scheduler being started. </p>
    public let inferenceSchedulerArn: String?
    /// <p>The name of the inference scheduler being started. </p>
    public let inferenceSchedulerName: String?
    /// <p>The Amazon Resource Name (ARN) of the ML model being used by the inference scheduler.
    ///       </p>
    public let modelArn: String?
    /// <p>The name of the ML model being used by the inference scheduler. </p>
    public let modelName: String?
    /// <p>Indicates the status of the inference scheduler. </p>
    public let status: InferenceSchedulerStatus?

    public init (
        inferenceSchedulerArn: String? = nil,
        inferenceSchedulerName: String? = nil,
        modelArn: String? = nil,
        modelName: String? = nil,
        status: InferenceSchedulerStatus? = nil
    )
    {
        self.inferenceSchedulerArn = inferenceSchedulerArn
        self.inferenceSchedulerName = inferenceSchedulerName
        self.modelArn = modelArn
        self.modelName = modelName
        self.status = status
    }
}

struct StartInferenceSchedulerOutputResponseBody: Equatable {
    public let modelArn: String?
    public let modelName: String?
    public let inferenceSchedulerName: String?
    public let inferenceSchedulerArn: String?
    public let status: InferenceSchedulerStatus?
}

extension StartInferenceSchedulerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerArn = "InferenceSchedulerArn"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case modelArn = "ModelArn"
        case modelName = "ModelName"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let inferenceSchedulerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerArn)
        inferenceSchedulerArn = inferenceSchedulerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InferenceSchedulerStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct StopInferenceSchedulerInputBodyMiddleware: Middleware {
    public let id: String = "StopInferenceSchedulerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<StopInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopInferenceSchedulerOutputError>
}

extension StopInferenceSchedulerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopInferenceSchedulerInput(inferenceSchedulerName: \(String(describing: inferenceSchedulerName)))"}
}

extension StopInferenceSchedulerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerName = "InferenceSchedulerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
    }
}

public struct StopInferenceSchedulerInputHeadersMiddleware: Middleware {
    public let id: String = "StopInferenceSchedulerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<StopInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopInferenceSchedulerOutputError>
}

public struct StopInferenceSchedulerInputQueryItemMiddleware: Middleware {
    public let id: String = "StopInferenceSchedulerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<StopInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopInferenceSchedulerOutputError>
}

public struct StopInferenceSchedulerInput: Equatable {
    /// <p>The name of the inference scheduler to be stopped. </p>
    public let inferenceSchedulerName: String?

    public init (
        inferenceSchedulerName: String? = nil
    )
    {
        self.inferenceSchedulerName = inferenceSchedulerName
    }
}

struct StopInferenceSchedulerInputBody: Equatable {
    public let inferenceSchedulerName: String?
}

extension StopInferenceSchedulerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerName = "InferenceSchedulerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
    }
}

extension StopInferenceSchedulerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopInferenceSchedulerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopInferenceSchedulerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopInferenceSchedulerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopInferenceSchedulerOutputResponse(inferenceSchedulerArn: \(String(describing: inferenceSchedulerArn)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), modelArn: \(String(describing: modelArn)), modelName: \(String(describing: modelName)), status: \(String(describing: status)))"}
}

extension StopInferenceSchedulerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopInferenceSchedulerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.inferenceSchedulerArn = output.inferenceSchedulerArn
            self.inferenceSchedulerName = output.inferenceSchedulerName
            self.modelArn = output.modelArn
            self.modelName = output.modelName
            self.status = output.status
        } else {
            self.inferenceSchedulerArn = nil
            self.inferenceSchedulerName = nil
            self.modelArn = nil
            self.modelName = nil
            self.status = nil
        }
    }
}

public struct StopInferenceSchedulerOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the inference schedule being stopped. </p>
    public let inferenceSchedulerArn: String?
    /// <p>The name of the inference scheduler being stopped. </p>
    public let inferenceSchedulerName: String?
    /// <p>The Amazon Resource Name (ARN) of the ML model used by the inference scheduler being
    ///          stopped. </p>
    public let modelArn: String?
    /// <p>The name of the ML model used by the inference scheduler being stopped. </p>
    public let modelName: String?
    /// <p>Indicates the status of the inference scheduler. </p>
    public let status: InferenceSchedulerStatus?

    public init (
        inferenceSchedulerArn: String? = nil,
        inferenceSchedulerName: String? = nil,
        modelArn: String? = nil,
        modelName: String? = nil,
        status: InferenceSchedulerStatus? = nil
    )
    {
        self.inferenceSchedulerArn = inferenceSchedulerArn
        self.inferenceSchedulerName = inferenceSchedulerName
        self.modelArn = modelArn
        self.modelName = modelName
        self.status = status
    }
}

struct StopInferenceSchedulerOutputResponseBody: Equatable {
    public let modelArn: String?
    public let modelName: String?
    public let inferenceSchedulerName: String?
    public let inferenceSchedulerArn: String?
    public let status: InferenceSchedulerStatus?
}

extension StopInferenceSchedulerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case inferenceSchedulerArn = "InferenceSchedulerArn"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case modelArn = "ModelArn"
        case modelName = "ModelName"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelName)
        modelName = modelNameDecoded
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let inferenceSchedulerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerArn)
        inferenceSchedulerArn = inferenceSchedulerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(InferenceSchedulerStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag is a key-value pair that can be added to a resource as metadata. </p>
public struct Tag: Equatable {
    /// <p>The key for the specified tag. </p>
    public let key: String?
    /// <p>The value for the specified tag. </p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the specific resource to which the tag should be
    ///          associated. </p>
    public let resourceArn: String?
    /// <p>The tag or tags to be associated with a specific resource. Both the tag key and value
    ///          are specified. </p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TargetSamplingRate {
    case pt10m
    case pt10s
    case pt15m
    case pt15s
    case pt1h
    case pt1m
    case pt1s
    case pt30m
    case pt30s
    case pt5m
    case pt5s
    case sdkUnknown(String)
}

extension TargetSamplingRate : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetSamplingRate] {
        return [
            .pt10m,
            .pt10s,
            .pt15m,
            .pt15s,
            .pt1h,
            .pt1m,
            .pt1s,
            .pt30m,
            .pt30s,
            .pt5m,
            .pt5s,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pt10m: return "PT10M"
        case .pt10s: return "PT10S"
        case .pt15m: return "PT15M"
        case .pt15s: return "PT15S"
        case .pt1h: return "PT1H"
        case .pt1m: return "PT1M"
        case .pt1s: return "PT1S"
        case .pt30m: return "PT30M"
        case .pt30s: return "PT30S"
        case .pt5m: return "PT5M"
        case .pt5s: return "PT5S"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetSamplingRate(rawValue: rawValue) ?? TargetSamplingRate.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to which the tag is currently associated.
    ///       </p>
    public let resourceArn: String?
    /// <p>Specifies the key of the tag to be removed from a specified resource. </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateInferenceSchedulerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInferenceSchedulerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<UpdateInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInferenceSchedulerOutputError>
}

extension UpdateInferenceSchedulerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInferenceSchedulerInput(dataDelayOffsetInMinutes: \(String(describing: dataDelayOffsetInMinutes)), dataInputConfiguration: \(String(describing: dataInputConfiguration)), dataOutputConfiguration: \(String(describing: dataOutputConfiguration)), dataUploadFrequency: \(String(describing: dataUploadFrequency)), inferenceSchedulerName: \(String(describing: inferenceSchedulerName)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateInferenceSchedulerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataDelayOffsetInMinutes = "DataDelayOffsetInMinutes"
        case dataInputConfiguration = "DataInputConfiguration"
        case dataOutputConfiguration = "DataOutputConfiguration"
        case dataUploadFrequency = "DataUploadFrequency"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataDelayOffsetInMinutes = dataDelayOffsetInMinutes {
            try encodeContainer.encode(dataDelayOffsetInMinutes, forKey: .dataDelayOffsetInMinutes)
        }
        if let dataInputConfiguration = dataInputConfiguration {
            try encodeContainer.encode(dataInputConfiguration, forKey: .dataInputConfiguration)
        }
        if let dataOutputConfiguration = dataOutputConfiguration {
            try encodeContainer.encode(dataOutputConfiguration, forKey: .dataOutputConfiguration)
        }
        if let dataUploadFrequency = dataUploadFrequency {
            try encodeContainer.encode(dataUploadFrequency.rawValue, forKey: .dataUploadFrequency)
        }
        if let inferenceSchedulerName = inferenceSchedulerName {
            try encodeContainer.encode(inferenceSchedulerName, forKey: .inferenceSchedulerName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateInferenceSchedulerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInferenceSchedulerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<UpdateInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInferenceSchedulerOutputError>
}

public struct UpdateInferenceSchedulerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInferenceSchedulerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInferenceSchedulerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInferenceSchedulerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInferenceSchedulerInput>
    public typealias MOutput = OperationOutput<UpdateInferenceSchedulerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInferenceSchedulerOutputError>
}

public struct UpdateInferenceSchedulerInput: Equatable {
    /// <p>> A period of time (in minutes) by which inference on the data is delayed after the data
    ///          starts. For instance, if you select an offset delay time of five minutes, inference will
    ///          not begin on the data until the first data measurement after the five minute mark. For example, if
    ///          five minutes is selected, the inference scheduler will wake up at the configured frequency with the
    ///          additional five minute delay time to check the customer S3 bucket. The customer can upload data at
    ///          the same frequency and they don't need to stop and restart the scheduler when uploading new data.</p>
    public let dataDelayOffsetInMinutes: Int?
    /// <p> Specifies information for the input data for the inference scheduler, including
    ///          delimiter, format, and dataset location. </p>
    public let dataInputConfiguration: InferenceInputConfiguration?
    /// <p> Specifies information for the output results from the inference scheduler, including the output S3 location. </p>
    public let dataOutputConfiguration: InferenceOutputConfiguration?
    /// <p>How often data is uploaded to the source S3 bucket for the input data. The value chosen
    ///          is the length of time between data uploads. For instance, if you select 5 minutes, Amazon
    ///          Lookout for Equipment will upload the real-time data to the source bucket once every 5 minutes. This frequency
    ///          also determines how often Amazon Lookout for Equipment starts a scheduled inference on your data. In this
    ///          example, it starts once every 5 minutes. </p>
    public let dataUploadFrequency: DataUploadFrequency?
    /// <p>The name of the inference scheduler to be updated. </p>
    public let inferenceSchedulerName: String?
    /// <p> The Amazon Resource Name (ARN) of a role with permission to access the data source for
    ///          the inference scheduler. </p>
    public let roleArn: String?

    public init (
        dataDelayOffsetInMinutes: Int? = nil,
        dataInputConfiguration: InferenceInputConfiguration? = nil,
        dataOutputConfiguration: InferenceOutputConfiguration? = nil,
        dataUploadFrequency: DataUploadFrequency? = nil,
        inferenceSchedulerName: String? = nil,
        roleArn: String? = nil
    )
    {
        self.dataDelayOffsetInMinutes = dataDelayOffsetInMinutes
        self.dataInputConfiguration = dataInputConfiguration
        self.dataOutputConfiguration = dataOutputConfiguration
        self.dataUploadFrequency = dataUploadFrequency
        self.inferenceSchedulerName = inferenceSchedulerName
        self.roleArn = roleArn
    }
}

struct UpdateInferenceSchedulerInputBody: Equatable {
    public let inferenceSchedulerName: String?
    public let dataDelayOffsetInMinutes: Int?
    public let dataUploadFrequency: DataUploadFrequency?
    public let dataInputConfiguration: InferenceInputConfiguration?
    public let dataOutputConfiguration: InferenceOutputConfiguration?
    public let roleArn: String?
}

extension UpdateInferenceSchedulerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataDelayOffsetInMinutes = "DataDelayOffsetInMinutes"
        case dataInputConfiguration = "DataInputConfiguration"
        case dataOutputConfiguration = "DataOutputConfiguration"
        case dataUploadFrequency = "DataUploadFrequency"
        case inferenceSchedulerName = "InferenceSchedulerName"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inferenceSchedulerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceSchedulerName)
        inferenceSchedulerName = inferenceSchedulerNameDecoded
        let dataDelayOffsetInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataDelayOffsetInMinutes)
        dataDelayOffsetInMinutes = dataDelayOffsetInMinutesDecoded
        let dataUploadFrequencyDecoded = try containerValues.decodeIfPresent(DataUploadFrequency.self, forKey: .dataUploadFrequency)
        dataUploadFrequency = dataUploadFrequencyDecoded
        let dataInputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceInputConfiguration.self, forKey: .dataInputConfiguration)
        dataInputConfiguration = dataInputConfigurationDecoded
        let dataOutputConfigurationDecoded = try containerValues.decodeIfPresent(InferenceOutputConfiguration.self, forKey: .dataOutputConfiguration)
        dataOutputConfiguration = dataOutputConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateInferenceSchedulerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInferenceSchedulerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInferenceSchedulerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInferenceSchedulerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInferenceSchedulerOutputResponse()"}
}

extension UpdateInferenceSchedulerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateInferenceSchedulerOutputResponse: Equatable {

    public init() {}
}

struct UpdateInferenceSchedulerOutputResponseBody: Equatable {
}

extension UpdateInferenceSchedulerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> The input fails to satisfy constraints specified by Amazon Lookout for Equipment or a related AWS
///          service that's being utilized. </p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
