// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct CreateResolverInput: Equatable {
    /// <p>The ID for the GraphQL API for which the resolver is being created.</p>
    public let apiId: String?
    /// <p>The caching configuration for the resolver.</p>
    public let cachingConfig: CachingConfig?
    /// <p>The name of the data source for which the resolver is being created.</p>
    public let dataSourceName: String?
    /// <p>The name of the field to attach the resolver to.</p>
    public let fieldName: String?
    /// <p>The resolver type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is
    ///                the default resolver type. A UNIT resolver enables you to execute a GraphQL query
    ///                against a single data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PIPELINE</b>: A PIPELINE resolver type. A PIPELINE
    ///                resolver enables you to execute a series of <code>Function</code> in a serial manner.
    ///                You can use a pipeline resolver to execute a GraphQL query against multiple data
    ///                sources.</p>
    ///             </li>
    ///          </ul>
    public let kind: ResolverKind?
    /// <p>The <code>PipelineConfig</code>.</p>
    public let pipelineConfig: PipelineConfig?
    /// <p>The mapping template to be used for requests.</p>
    ///          <p>A resolver uses a request mapping template to convert a GraphQL expression into a format
    ///          that a data source can understand. Mapping templates are written in Apache Velocity
    ///          Template Language (VTL).</p>
    ///          <p>VTL request mapping templates are optional when using a Lambda data source. For all
    ///          other data sources, VTL request and response mapping templates are required.</p>
    public let requestMappingTemplate: String?
    /// <p>The mapping template to be used for responses from the data source.</p>
    public let responseMappingTemplate: String?
    /// <p>The <code>SyncConfig</code> for a resolver attached to a versioned datasource.</p>
    public let syncConfig: SyncConfig?
    /// <p>The name of the <code>Type</code>.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        cachingConfig: CachingConfig? = nil,
        dataSourceName: String? = nil,
        fieldName: String? = nil,
        kind: ResolverKind? = nil,
        pipelineConfig: PipelineConfig? = nil,
        requestMappingTemplate: String? = nil,
        responseMappingTemplate: String? = nil,
        syncConfig: SyncConfig? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}
