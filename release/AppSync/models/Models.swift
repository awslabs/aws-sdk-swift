// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have access to perform this operation on this resource.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AdditionalAuthenticationProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationType
        case openIDConnectConfig
        case userPoolConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(CognitoUserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
    }
}

extension AdditionalAuthenticationProvider: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdditionalAuthenticationProvider(authenticationType: \(String(describing: authenticationType)), openIDConnectConfig: \(String(describing: openIDConnectConfig)), userPoolConfig: \(String(describing: userPoolConfig)))"}
}

/// <p>Describes an additional authentication provider.</p>
public struct AdditionalAuthenticationProvider: Equatable {
    /// <p>The authentication type: API key, AWS IAM, OIDC, or Amazon Cognito user pools.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The OpenID Connect configuration.</p>
    public let openIDConnectConfig: OpenIDConnectConfig?
    /// <p>The Amazon Cognito user pool configuration.</p>
    public let userPoolConfig: CognitoUserPoolConfig?

    public init (
        authenticationType: AuthenticationType? = nil,
        openIDConnectConfig: OpenIDConnectConfig? = nil,
        userPoolConfig: CognitoUserPoolConfig? = nil
    )
    {
        self.authenticationType = authenticationType
        self.openIDConnectConfig = openIDConnectConfig
        self.userPoolConfig = userPoolConfig
    }
}

extension ApiCache: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case status
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if atRestEncryptionEnabled != false {
            try encodeContainer.encode(atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if transitEncryptionEnabled != false {
            try encodeContainer.encode(transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decode(Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decode(Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ApiCacheType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApiCacheStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ApiCache: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiCache(apiCachingBehavior: \(String(describing: apiCachingBehavior)), atRestEncryptionEnabled: \(String(describing: atRestEncryptionEnabled)), status: \(String(describing: status)), transitEncryptionEnabled: \(String(describing: transitEncryptionEnabled)), ttl: \(String(describing: ttl)), type: \(String(describing: type)))"}
}

/// <p>The <code>ApiCache</code> object.</p>
public struct ApiCache: Equatable {
    /// <p>Caching behavior.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>FULL_REQUEST_CACHING</b>: All requests are fully
    ///                cached.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PER_RESOLVER_CACHING</b>: Individual resolvers
    ///                that you specify are cached.</p>
    ///             </li>
    ///          </ul>
    public let apiCachingBehavior: ApiCachingBehavior?
    /// <p>At rest encryption flag for cache. This setting cannot be updated after creation.</p>
    public let atRestEncryptionEnabled: Bool
    /// <p>The cache instance status.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>AVAILABLE</b>: The instance is available for
    ///                use.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>CREATING</b>: The instance is currently
    ///                creating.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>DELETING</b>: The instance is currently
    ///                deleting.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>MODIFYING</b>: The instance is currently
    ///                modifying.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>FAILED</b>: The instance has failed
    ///                creation.</p>
    ///             </li>
    ///          </ul>
    public let status: ApiCacheStatus?
    /// <p>Transit encryption flag when connecting to cache. This setting cannot be updated after
    ///          creation.</p>
    public let transitEncryptionEnabled: Bool
    /// <p>TTL in seconds for cache entries.</p>
    ///          <p>Valid values are between 1 and 3600 seconds.</p>
    public let ttl: Int
    /// <p>The cache instance type. Valid values are </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SMALL</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MEDIUM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>XLARGE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_2X</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_4X</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_8X</code> (not available in all regions)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_12X</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p>
    ///          <p>The following legacy instance types are available, but their use is discouraged:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>T2_SMALL</b>: A t2.small instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>T2_MEDIUM</b>: A t2.medium instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_LARGE</b>: A r4.large instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_XLARGE</b>: A r4.xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p>
    ///             </li>
    ///          </ul>
    public let type: ApiCacheType?

    public init (
        apiCachingBehavior: ApiCachingBehavior? = nil,
        atRestEncryptionEnabled: Bool = false,
        status: ApiCacheStatus? = nil,
        transitEncryptionEnabled: Bool = false,
        ttl: Int = 0,
        type: ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.atRestEncryptionEnabled = atRestEncryptionEnabled
        self.status = status
        self.transitEncryptionEnabled = transitEncryptionEnabled
        self.ttl = ttl
        self.type = type
    }
}

public enum ApiCacheStatus {
    case available
    case creating
    case deleting
    case failed
    case modifying
    case sdkUnknown(String)
}

extension ApiCacheStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApiCacheStatus] {
        return [
            .available,
            .creating,
            .deleting,
            .failed,
            .modifying,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .modifying: return "MODIFYING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApiCacheStatus(rawValue: rawValue) ?? ApiCacheStatus.sdkUnknown(rawValue)
    }
}

public enum ApiCacheType {
    case large
    case large12x
    case large2x
    case large4x
    case large8x
    case medium
    case r42xlarge
    case r44xlarge
    case r48xlarge
    case r4Large
    case r4Xlarge
    case small
    case t2Medium
    case t2Small
    case xlarge
    case sdkUnknown(String)
}

extension ApiCacheType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApiCacheType] {
        return [
            .large,
            .large12x,
            .large2x,
            .large4x,
            .large8x,
            .medium,
            .r42xlarge,
            .r44xlarge,
            .r48xlarge,
            .r4Large,
            .r4Xlarge,
            .small,
            .t2Medium,
            .t2Small,
            .xlarge,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .large: return "LARGE"
        case .large12x: return "LARGE_12X"
        case .large2x: return "LARGE_2X"
        case .large4x: return "LARGE_4X"
        case .large8x: return "LARGE_8X"
        case .medium: return "MEDIUM"
        case .r42xlarge: return "R4_2XLARGE"
        case .r44xlarge: return "R4_4XLARGE"
        case .r48xlarge: return "R4_8XLARGE"
        case .r4Large: return "R4_LARGE"
        case .r4Xlarge: return "R4_XLARGE"
        case .small: return "SMALL"
        case .t2Medium: return "T2_MEDIUM"
        case .t2Small: return "T2_SMALL"
        case .xlarge: return "XLARGE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApiCacheType(rawValue: rawValue) ?? ApiCacheType.sdkUnknown(rawValue)
    }
}

public enum ApiCachingBehavior {
    case fullRequestCaching
    case perResolverCaching
    case sdkUnknown(String)
}

extension ApiCachingBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApiCachingBehavior] {
        return [
            .fullRequestCaching,
            .perResolverCaching,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullRequestCaching: return "FULL_REQUEST_CACHING"
        case .perResolverCaching: return "PER_RESOLVER_CACHING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApiCachingBehavior(rawValue: rawValue) ?? ApiCachingBehavior.sdkUnknown(rawValue)
    }
}

extension ApiKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deletes
        case description
        case expires
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deletes != 0 {
            try encodeContainer.encode(deletes, forKey: .deletes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Int.self, forKey: .expires)
        expires = expiresDecoded
        let deletesDecoded = try containerValues.decode(Int.self, forKey: .deletes)
        deletes = deletesDecoded
    }
}

extension ApiKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiKey(deletes: \(String(describing: deletes)), description: \(String(describing: description)), expires: \(String(describing: expires)), id: \(String(describing: id)))"}
}

/// <p>Describes an API key.</p>
///          <p>Customers invoke AWS AppSync GraphQL API operations with API keys as an identity
///          mechanism. There are two key versions:</p>
///          <p>
///             <b>da1</b>: This version was introduced at launch in November
///          2017. These keys always expire after 7 days. Key expiration is managed by Amazon DynamoDB
///          TTL. The keys ceased to be valid after February 21, 2018 and should not be used after that
///          date.</p>
///          <ul>
///             <li>
///                <p>
///                   <code>ListApiKeys</code> returns the expiration time in milliseconds.</p>
///             </li>
///             <li>
///                <p>
///                   <code>CreateApiKey</code> returns the expiration time in
///                milliseconds.</p>
///             </li>
///             <li>
///                <p>
///                   <code>UpdateApiKey</code> is not available for this key version.</p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteApiKey</code> deletes the item from the table.</p>
///             </li>
///             <li>
///                <p>Expiration is stored in Amazon DynamoDB as milliseconds. This results in a bug
///                where keys are not automatically deleted because DynamoDB expects the TTL to be
///                stored in seconds. As a one-time action, we will delete these keys from the table
///                after February 21, 2018.</p>
///             </li>
///          </ul>
///          <p>
///             <b>da2</b>: This version was introduced in February 2018 when
///          AppSync added support to extend key expiration.</p>
///          <ul>
///             <li>
///                <p>
///                   <code>ListApiKeys</code> returns the expiration time and deletion time
///                in seconds.</p>
///             </li>
///             <li>
///                <p>
///                   <code>CreateApiKey</code> returns the expiration time and deletion time
///                in seconds and accepts a user-provided expiration time in seconds.</p>
///             </li>
///             <li>
///                <p>
///                   <code>UpdateApiKey</code> returns the expiration time and and deletion time
///                in seconds and accepts a user-provided expiration time in seconds. Expired API keys
///                are kept for 60 days after the expiration time. Key expiration time can be updated
///                while the key is not deleted. </p>
///             </li>
///             <li>
///                <p>
///                   <code>DeleteApiKey</code> deletes the item from the table.</p>
///             </li>
///             <li>
///                <p>Expiration is stored in Amazon DynamoDB as seconds. After the expiration
///                time, using the key to authenticate will fail. But the key can be reinstated before
///                deletion.</p>
///             </li>
///             <li>
///                <p>Deletion is stored in Amazon DynamoDB as seconds. The key will be deleted
///                after deletion time. </p>
///             </li>
///          </ul>
public struct ApiKey: Equatable {
    /// <p>The time after which the API key is deleted. The date is represented as seconds since the
    ///          epoch, rounded down to the nearest hour.</p>
    public let deletes: Int
    /// <p>A description of the purpose of the API key.</p>
    public let description: String?
    /// <p>The time after which the API key expires. The date is represented as seconds since the
    ///          epoch, rounded down to the nearest hour.</p>
    public let expires: Int
    /// <p>The API key ID.</p>
    public let id: String?

    public init (
        deletes: Int = 0,
        description: String? = nil,
        expires: Int = 0,
        id: String? = nil
    )
    {
        self.deletes = deletes
        self.description = description
        self.expires = expires
        self.id = id
    }
}

extension ApiKeyLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiKeyLimitExceededException(message: \(String(describing: message)))"}
}

extension ApiKeyLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApiKeyLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The API key exceeded a limit. Try your request again.</p>
public struct ApiKeyLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApiKeyLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ApiKeyLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiKeyValidityOutOfBoundsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiKeyValidityOutOfBoundsException(message: \(String(describing: message)))"}
}

extension ApiKeyValidityOutOfBoundsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApiKeyValidityOutOfBoundsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The API key expiration must be set to a value between 1 and 365 days from creation (for
///             <code>CreateApiKey</code>) or from update (for <code>UpdateApiKey</code>).</p>
public struct ApiKeyValidityOutOfBoundsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApiKeyValidityOutOfBoundsExceptionBody: Equatable {
    public let message: String?
}

extension ApiKeyValidityOutOfBoundsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiLimitExceededException(message: \(String(describing: message)))"}
}

extension ApiLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ApiLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The GraphQL API exceeded a limit. Try your request again.</p>
public struct ApiLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApiLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ApiLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AuthenticationType {
    case amazonCognitoUserPools
    case apiKey
    case awsIam
    case openidConnect
    case sdkUnknown(String)
}

extension AuthenticationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthenticationType] {
        return [
            .amazonCognitoUserPools,
            .apiKey,
            .awsIam,
            .openidConnect,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazonCognitoUserPools: return "AMAZON_COGNITO_USER_POOLS"
        case .apiKey: return "API_KEY"
        case .awsIam: return "AWS_IAM"
        case .openidConnect: return "OPENID_CONNECT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
    }
}

extension AuthorizationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationType
        case awsIamConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let awsIamConfig = awsIamConfig {
            try encodeContainer.encode(awsIamConfig, forKey: .awsIamConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(AuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let awsIamConfigDecoded = try containerValues.decodeIfPresent(AwsIamConfig.self, forKey: .awsIamConfig)
        awsIamConfig = awsIamConfigDecoded
    }
}

extension AuthorizationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationConfig(authorizationType: \(String(describing: authorizationType)), awsIamConfig: \(String(describing: awsIamConfig)))"}
}

/// <p>The authorization config in case the HTTP endpoint requires authorization.</p>
public struct AuthorizationConfig: Equatable {
    /// <p>The authorization type required by the HTTP endpoint.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>AWS_IAM</b>: The authorization type is
    ///                Sigv4.</p>
    ///             </li>
    ///          </ul>
    public let authorizationType: AuthorizationType?
    /// <p>The AWS IAM settings.</p>
    public let awsIamConfig: AwsIamConfig?

    public init (
        authorizationType: AuthorizationType? = nil,
        awsIamConfig: AwsIamConfig? = nil
    )
    {
        self.authorizationType = authorizationType
        self.awsIamConfig = awsIamConfig
    }
}

public enum AuthorizationType {
    case awsIam
    case sdkUnknown(String)
}

extension AuthorizationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthorizationType] {
        return [
            .awsIam,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsIam: return "AWS_IAM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthorizationType(rawValue: rawValue) ?? AuthorizationType.sdkUnknown(rawValue)
    }
}

extension AwsIamConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingRegion
        case signingServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingRegion = signingRegion {
            try encodeContainer.encode(signingRegion, forKey: .signingRegion)
        }
        if let signingServiceName = signingServiceName {
            try encodeContainer.encode(signingServiceName, forKey: .signingServiceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingRegion)
        signingRegion = signingRegionDecoded
        let signingServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingServiceName)
        signingServiceName = signingServiceNameDecoded
    }
}

extension AwsIamConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsIamConfig(signingRegion: \(String(describing: signingRegion)), signingServiceName: \(String(describing: signingServiceName)))"}
}

/// <p>The AWS IAM configuration.</p>
public struct AwsIamConfig: Equatable {
    /// <p>The signing region for AWS IAM authorization.</p>
    public let signingRegion: String?
    /// <p>The signing service name for AWS IAM authorization.</p>
    public let signingServiceName: String?

    public init (
        signingRegion: String? = nil,
        signingServiceName: String? = nil
    )
    {
        self.signingRegion = signingRegion
        self.signingServiceName = signingServiceName
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not well formed. For example, a value is invalid or a required field is
///          missing. Check the field values, and then try again. </p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CachingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachingKeys
        case ttl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingKeys = cachingKeys {
            var cachingKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cachingKeys)
            for cachingkeys0 in cachingKeys {
                try cachingKeysContainer.encode(cachingkeys0)
            }
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let cachingKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .cachingKeys)
        var cachingKeysDecoded0:[String]? = nil
        if let cachingKeysContainer = cachingKeysContainer {
            cachingKeysDecoded0 = [String]()
            for string0 in cachingKeysContainer {
                if let string0 = string0 {
                    cachingKeysDecoded0?.append(string0)
                }
            }
        }
        cachingKeys = cachingKeysDecoded0
    }
}

extension CachingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachingConfig(cachingKeys: \(String(describing: cachingKeys)), ttl: \(String(describing: ttl)))"}
}

/// <p>The caching configuration for a resolver that has caching enabled.</p>
public struct CachingConfig: Equatable {
    /// <p>The caching keys for a resolver that has caching enabled.</p>
    ///          <p>Valid values are entries from the <code>$context.arguments</code>,
    ///             <code>$context.source</code>, and <code>$context.identity</code> maps.</p>
    public let cachingKeys: [String]?
    /// <p>The TTL in seconds for a resolver that has caching enabled.</p>
    ///          <p>Valid values are between 1 and 3600 seconds.</p>
    public let ttl: Int

    public init (
        cachingKeys: [String]? = nil,
        ttl: Int = 0
    )
    {
        self.cachingKeys = cachingKeys
        self.ttl = ttl
    }
}

extension CognitoUserPoolConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appIdClientRegex
        case awsRegion
        case userPoolId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIdClientRegex = appIdClientRegex {
            try encodeContainer.encode(appIdClientRegex, forKey: .appIdClientRegex)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let appIdClientRegexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appIdClientRegex)
        appIdClientRegex = appIdClientRegexDecoded
    }
}

extension CognitoUserPoolConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CognitoUserPoolConfig(appIdClientRegex: \(String(describing: appIdClientRegex)), awsRegion: \(String(describing: awsRegion)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>Describes an Amazon Cognito user pool configuration.</p>
public struct CognitoUserPoolConfig: Equatable {
    /// <p>A regular expression for validating the incoming Amazon Cognito user pool app client
    ///          ID.</p>
    public let appIdClientRegex: String?
    /// <p>The AWS Region in which the user pool was created.</p>
    public let awsRegion: String?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        appIdClientRegex: String? = nil,
        awsRegion: String? = nil,
        userPoolId: String? = nil
    )
    {
        self.appIdClientRegex = appIdClientRegex
        self.awsRegion = awsRegion
        self.userPoolId = userPoolId
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Another modification is in progress at this time and it must complete before you can
///          make your change. </p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ConflictDetectionType {
    case `none`
    case version
    case sdkUnknown(String)
}

extension ConflictDetectionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConflictDetectionType] {
        return [
            .none,
            .version,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .version: return "VERSION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConflictDetectionType(rawValue: rawValue) ?? ConflictDetectionType.sdkUnknown(rawValue)
    }
}

public enum ConflictHandlerType {
    case automerge
    case lambda
    case `none`
    case optimisticConcurrency
    case sdkUnknown(String)
}

extension ConflictHandlerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConflictHandlerType] {
        return [
            .automerge,
            .lambda,
            .none,
            .optimisticConcurrency,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automerge: return "AUTOMERGE"
        case .lambda: return "LAMBDA"
        case .none: return "NONE"
        case .optimisticConcurrency: return "OPTIMISTIC_CONCURRENCY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConflictHandlerType(rawValue: rawValue) ?? ConflictHandlerType.sdkUnknown(rawValue)
    }
}

public struct CreateApiCacheInputBodyMiddleware: Middleware {
    public let id: String = "CreateApiCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiCacheInput>
    public typealias MOutput = OperationOutput<CreateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiCacheOutputError>
}

extension CreateApiCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiCacheInput(apiCachingBehavior: \(String(describing: apiCachingBehavior)), apiId: \(String(describing: apiId)), atRestEncryptionEnabled: \(String(describing: atRestEncryptionEnabled)), transitEncryptionEnabled: \(String(describing: transitEncryptionEnabled)), ttl: \(String(describing: ttl)), type: \(String(describing: type)))"}
}

extension CreateApiCacheInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if atRestEncryptionEnabled != false {
            try encodeContainer.encode(atRestEncryptionEnabled, forKey: .atRestEncryptionEnabled)
        }
        if transitEncryptionEnabled != false {
            try encodeContainer.encode(transitEncryptionEnabled, forKey: .transitEncryptionEnabled)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateApiCacheInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiCacheInput>
    public typealias MOutput = OperationOutput<CreateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiCacheOutputError>
}

public struct CreateApiCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiCacheInput>
    public typealias MOutput = OperationOutput<CreateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiCacheOutputError>
}

/// <p>Represents the input of a <code>CreateApiCache</code> operation.</p>
public struct CreateApiCacheInput: Equatable {
    /// <p>Caching behavior.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>FULL_REQUEST_CACHING</b>: All requests are fully
    ///                cached.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PER_RESOLVER_CACHING</b>: Individual resolvers
    ///                that you specify are cached.</p>
    ///             </li>
    ///          </ul>
    public let apiCachingBehavior: ApiCachingBehavior?
    /// <p>The GraphQL API Id.</p>
    public let apiId: String?
    /// <p>At rest encryption flag for cache. This setting cannot be updated after creation.</p>
    public let atRestEncryptionEnabled: Bool
    /// <p>Transit encryption flag when connecting to cache. This setting cannot be updated after
    ///          creation.</p>
    public let transitEncryptionEnabled: Bool
    /// <p>TTL in seconds for cache entries.</p>
    ///          <p>Valid values are between 1 and 3600 seconds.</p>
    public let ttl: Int
    /// <p>The cache instance type. Valid values are </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SMALL</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MEDIUM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>XLARGE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_2X</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_4X</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_8X</code> (not available in all regions)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_12X</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p>
    ///          <p>The following legacy instance types are available, but their use is discouraged:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>T2_SMALL</b>: A t2.small instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>T2_MEDIUM</b>: A t2.medium instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_LARGE</b>: A r4.large instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_XLARGE</b>: A r4.xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p>
    ///             </li>
    ///          </ul>
    public let type: ApiCacheType?

    public init (
        apiCachingBehavior: ApiCachingBehavior? = nil,
        apiId: String? = nil,
        atRestEncryptionEnabled: Bool = false,
        transitEncryptionEnabled: Bool = false,
        ttl: Int = 0,
        type: ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.atRestEncryptionEnabled = atRestEncryptionEnabled
        self.transitEncryptionEnabled = transitEncryptionEnabled
        self.ttl = ttl
        self.type = type
    }
}

struct CreateApiCacheInputBody: Equatable {
    public let ttl: Int
    public let transitEncryptionEnabled: Bool
    public let atRestEncryptionEnabled: Bool
    public let apiCachingBehavior: ApiCachingBehavior?
    public let type: ApiCacheType?
}

extension CreateApiCacheInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiCachingBehavior
        case atRestEncryptionEnabled
        case transitEncryptionEnabled
        case ttl
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let transitEncryptionEnabledDecoded = try containerValues.decode(Bool.self, forKey: .transitEncryptionEnabled)
        transitEncryptionEnabled = transitEncryptionEnabledDecoded
        let atRestEncryptionEnabledDecoded = try containerValues.decode(Bool.self, forKey: .atRestEncryptionEnabled)
        atRestEncryptionEnabled = atRestEncryptionEnabledDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ApiCacheType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateApiCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiCacheOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiCacheOutputResponse(apiCache: \(String(describing: apiCache)))"}
}

extension CreateApiCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// <p>Represents the output of a <code>CreateApiCache</code> operation.</p>
public struct CreateApiCacheOutputResponse: Equatable {
    /// <p>The <code>ApiCache</code> object.</p>
    public let apiCache: ApiCache?

    public init (
        apiCache: ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct CreateApiCacheOutputResponseBody: Equatable {
    public let apiCache: ApiCache?
}

extension CreateApiCacheOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiCache
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

public struct CreateApiKeyInputBodyMiddleware: Middleware {
    public let id: String = "CreateApiKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiKeyOutputError>
}

extension CreateApiKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiKeyInput(apiId: \(String(describing: apiId)), description: \(String(describing: description)), expires: \(String(describing: expires)))"}
}

extension CreateApiKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case expires
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
    }
}

public struct CreateApiKeyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiKeyOutputError>
}

public struct CreateApiKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiKeyInput>
    public typealias MOutput = OperationOutput<CreateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiKeyOutputError>
}

public struct CreateApiKeyInput: Equatable {
    /// <p>The ID for your GraphQL API.</p>
    public let apiId: String?
    /// <p>A description of the purpose of the API key.</p>
    public let description: String?
    /// <p>The time from creation time after which the API key expires. The date is represented as
    ///          seconds since the epoch, rounded down to the nearest hour. The default value for this
    ///          parameter is 7 days from creation time. For more information, see .</p>
    public let expires: Int

    public init (
        apiId: String? = nil,
        description: String? = nil,
        expires: Int = 0
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
    }
}

struct CreateApiKeyInputBody: Equatable {
    public let description: String?
    public let expires: Int
}

extension CreateApiKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case expires
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Int.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension CreateApiKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApiKeyLimitExceededException" : self = .apiKeyLimitExceededException(try ApiKeyLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApiKeyValidityOutOfBoundsException" : self = .apiKeyValidityOutOfBoundsException(try ApiKeyValidityOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiKeyOutputError: Equatable {
    case apiKeyLimitExceededException(ApiKeyLimitExceededException)
    case apiKeyValidityOutOfBoundsException(ApiKeyValidityOutOfBoundsException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiKeyOutputResponse(apiKey: \(String(describing: apiKey)))"}
}

extension CreateApiKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKey = output.apiKey
        } else {
            self.apiKey = nil
        }
    }
}

public struct CreateApiKeyOutputResponse: Equatable {
    /// <p>The API key.</p>
    public let apiKey: ApiKey?

    public init (
        apiKey: ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct CreateApiKeyOutputResponseBody: Equatable {
    public let apiKey: ApiKey?
}

extension CreateApiKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKey
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(ApiKey.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

public struct CreateDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

extension CreateDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSourceInput(apiId: \(String(describing: apiId)), description: \(String(describing: description)), dynamodbConfig: \(String(describing: dynamodbConfig)), elasticsearchConfig: \(String(describing: elasticsearchConfig)), httpConfig: \(String(describing: httpConfig)), lambdaConfig: \(String(describing: lambdaConfig)), name: \(String(describing: name)), relationalDatabaseConfig: \(String(describing: relationalDatabaseConfig)), serviceRoleArn: \(String(describing: serviceRoleArn)), type: \(String(describing: type)))"}
}

extension CreateDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDataSourceInput>
    public typealias MOutput = OperationOutput<CreateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDataSourceOutputError>
}

public struct CreateDataSourceInput: Equatable {
    /// <p>The API ID for the GraphQL API for the <code>DataSource</code>.</p>
    public let apiId: String?
    /// <p>A description of the <code>DataSource</code>.</p>
    public let description: String?
    /// <p>Amazon DynamoDB settings.</p>
    public let dynamodbConfig: DynamodbDataSourceConfig?
    /// <p>Amazon Elasticsearch Service settings.</p>
    public let elasticsearchConfig: ElasticsearchDataSourceConfig?
    /// <p>HTTP endpoint settings.</p>
    public let httpConfig: HttpDataSourceConfig?
    /// <p>AWS Lambda settings.</p>
    public let lambdaConfig: LambdaDataSourceConfig?
    /// <p>A user-supplied name for the <code>DataSource</code>.</p>
    public let name: String?
    /// <p>Relational database settings.</p>
    public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
    /// <p>The AWS IAM service role ARN for the data source. The system assumes this role when
    ///          accessing the data source.</p>
    public let serviceRoleArn: String?
    /// <p>The type of the <code>DataSource</code>.</p>
    public let type: DataSourceType?

    public init (
        apiId: String? = nil,
        description: String? = nil,
        dynamodbConfig: DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: ElasticsearchDataSourceConfig? = nil,
        httpConfig: HttpDataSourceConfig? = nil,
        lambdaConfig: LambdaDataSourceConfig? = nil,
        name: String? = nil,
        relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: String? = nil,
        type: DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

struct CreateDataSourceInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let type: DataSourceType?
    public let serviceRoleArn: String?
    public let dynamodbConfig: DynamodbDataSourceConfig?
    public let lambdaConfig: LambdaDataSourceConfig?
    public let elasticsearchConfig: ElasticsearchDataSourceConfig?
    public let httpConfig: HttpDataSourceConfig?
    public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
}

extension CreateDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension CreateDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDataSourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDataSourceOutputResponse(dataSource: \(String(describing: dataSource)))"}
}

extension CreateDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct CreateDataSourceOutputResponse: Equatable {
    /// <p>The <code>DataSource</code> object.</p>
    public let dataSource: DataSource?

    public init (
        dataSource: DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct CreateDataSourceOutputResponseBody: Equatable {
    public let dataSource: DataSource?
}

extension CreateDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSource
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

public struct CreateFunctionInputBodyMiddleware: Middleware {
    public let id: String = "CreateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

extension CreateFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionInput(apiId: \(String(describing: apiId)), dataSourceName: \(String(describing: dataSourceName)), description: \(String(describing: description)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), requestMappingTemplate: \(String(describing: requestMappingTemplate)), responseMappingTemplate: \(String(describing: responseMappingTemplate)), syncConfig: \(String(describing: syncConfig)))"}
}

extension CreateFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

public struct CreateFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInput: Equatable {
    /// <p>The GraphQL API ID.</p>
    public let apiId: String?
    /// <p>The <code>Function</code>
    ///             <code>DataSource</code> name.</p>
    public let dataSourceName: String?
    /// <p>The <code>Function</code> description.</p>
    public let description: String?
    /// <p>The <code>version</code> of the request mapping template. Currently the supported value
    ///          is 2018-05-29. </p>
    public let functionVersion: String?
    /// <p>The <code>Function</code> name. The function name does not have to be unique.</p>
    public let name: String?
    /// <p>The <code>Function</code> request mapping template. Functions support only the
    ///          2018-05-29 version of the request mapping template.</p>
    public let requestMappingTemplate: String?
    /// <p>The <code>Function</code> response mapping template. </p>
    public let responseMappingTemplate: String?
    /// <p>Describes a Sync configuration for a resolver.</p>
    ///          <p>Contains information on which Conflict Detection as well as Resolution strategy should
    ///          be performed when the resolver is invoked.</p>
    public let syncConfig: SyncConfig?

    public init (
        apiId: String? = nil,
        dataSourceName: String? = nil,
        description: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        requestMappingTemplate: String? = nil,
        responseMappingTemplate: String? = nil,
        syncConfig: SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
    }
}

struct CreateFunctionInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let dataSourceName: String?
    public let requestMappingTemplate: String?
    public let responseMappingTemplate: String?
    public let functionVersion: String?
    public let syncConfig: SyncConfig?
}

extension CreateFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension CreateFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionOutputResponse(functionConfiguration: \(String(describing: functionConfiguration)))"}
}

extension CreateFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct CreateFunctionOutputResponse: Equatable {
    /// <p>The <code>Function</code> object.</p>
    public let functionConfiguration: FunctionConfiguration?

    public init (
        functionConfiguration: FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct CreateFunctionOutputResponseBody: Equatable {
    public let functionConfiguration: FunctionConfiguration?
}

extension CreateFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

public struct CreateGraphqlApiInputBodyMiddleware: Middleware {
    public let id: String = "CreateGraphqlApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGraphqlApiInput>
    public typealias MOutput = OperationOutput<CreateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGraphqlApiOutputError>
}

extension CreateGraphqlApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGraphqlApiInput(additionalAuthenticationProviders: \(String(describing: additionalAuthenticationProviders)), authenticationType: \(String(describing: authenticationType)), logConfig: \(String(describing: logConfig)), name: \(String(describing: name)), openIDConnectConfig: \(String(describing: openIDConnectConfig)), tags: \(String(describing: tags)), userPoolConfig: \(String(describing: userPoolConfig)), xrayEnabled: \(String(describing: xrayEnabled)))"}
}

extension CreateGraphqlApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case userPoolConfig
        case xrayEnabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }
}

public struct CreateGraphqlApiInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGraphqlApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGraphqlApiInput>
    public typealias MOutput = OperationOutput<CreateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGraphqlApiOutputError>
}

public struct CreateGraphqlApiInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGraphqlApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGraphqlApiInput>
    public typealias MOutput = OperationOutput<CreateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGraphqlApiOutputError>
}

public struct CreateGraphqlApiInput: Equatable {
    /// <p>A list of additional authentication providers for the <code>GraphqlApi</code>
    ///          API.</p>
    public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
    /// <p>The authentication type: API key, AWS IAM, OIDC, or Amazon Cognito user pools.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The Amazon CloudWatch Logs configuration.</p>
    public let logConfig: LogConfig?
    /// <p>A user-supplied name for the <code>GraphqlApi</code>.</p>
    public let name: String?
    /// <p>The OpenID Connect configuration.</p>
    public let openIDConnectConfig: OpenIDConnectConfig?
    /// <p>A <code>TagMap</code> object.</p>
    public let tags: [String:String]?
    /// <p>The Amazon Cognito user pool configuration.</p>
    public let userPoolConfig: UserPoolConfig?
    /// <p>A flag indicating whether to enable X-Ray tracing for the
    ///          <code>GraphqlApi</code>.</p>
    public let xrayEnabled: Bool

    public init (
        additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil,
        authenticationType: AuthenticationType? = nil,
        logConfig: LogConfig? = nil,
        name: String? = nil,
        openIDConnectConfig: OpenIDConnectConfig? = nil,
        tags: [String:String]? = nil,
        userPoolConfig: UserPoolConfig? = nil,
        xrayEnabled: Bool = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.authenticationType = authenticationType
        self.logConfig = logConfig
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.tags = tags
        self.userPoolConfig = userPoolConfig
        self.xrayEnabled = xrayEnabled
    }
}

struct CreateGraphqlApiInputBody: Equatable {
    public let name: String?
    public let logConfig: LogConfig?
    public let authenticationType: AuthenticationType?
    public let userPoolConfig: UserPoolConfig?
    public let openIDConnectConfig: OpenIDConnectConfig?
    public let tags: [String:String]?
    public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
    public let xrayEnabled: Bool
}

extension CreateGraphqlApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case userPoolConfig
        case xrayEnabled
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
    }
}

extension CreateGraphqlApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGraphqlApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApiLimitExceededException" : self = .apiLimitExceededException(try ApiLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGraphqlApiOutputError: Equatable {
    case apiLimitExceededException(ApiLimitExceededException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGraphqlApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGraphqlApiOutputResponse(graphqlApi: \(String(describing: graphqlApi)))"}
}

extension CreateGraphqlApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct CreateGraphqlApiOutputResponse: Equatable {
    /// <p>The <code>GraphqlApi</code>.</p>
    public let graphqlApi: GraphqlApi?

    public init (
        graphqlApi: GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct CreateGraphqlApiOutputResponseBody: Equatable {
    public let graphqlApi: GraphqlApi?
}

extension CreateGraphqlApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphqlApi
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

public struct CreateResolverInputBodyMiddleware: Middleware {
    public let id: String = "CreateResolverInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverInput>
    public typealias MOutput = OperationOutput<CreateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverOutputError>
}

extension CreateResolverInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResolverInput(apiId: \(String(describing: apiId)), cachingConfig: \(String(describing: cachingConfig)), dataSourceName: \(String(describing: dataSourceName)), fieldName: \(String(describing: fieldName)), kind: \(String(describing: kind)), pipelineConfig: \(String(describing: pipelineConfig)), requestMappingTemplate: \(String(describing: requestMappingTemplate)), responseMappingTemplate: \(String(describing: responseMappingTemplate)), syncConfig: \(String(describing: syncConfig)), typeName: \(String(describing: typeName)))"}
}

extension CreateResolverInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

public struct CreateResolverInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResolverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverInput>
    public typealias MOutput = OperationOutput<CreateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverOutputError>
}

public struct CreateResolverInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResolverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResolverInput>
    public typealias MOutput = OperationOutput<CreateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResolverOutputError>
}

public struct CreateResolverInput: Equatable {
    /// <p>The ID for the GraphQL API for which the resolver is being created.</p>
    public let apiId: String?
    /// <p>The caching configuration for the resolver.</p>
    public let cachingConfig: CachingConfig?
    /// <p>The name of the data source for which the resolver is being created.</p>
    public let dataSourceName: String?
    /// <p>The name of the field to attach the resolver to.</p>
    public let fieldName: String?
    /// <p>The resolver type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is
    ///                the default resolver type. A UNIT resolver enables you to execute a GraphQL query
    ///                against a single data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PIPELINE</b>: A PIPELINE resolver type. A PIPELINE
    ///                resolver enables you to execute a series of <code>Function</code> in a serial manner.
    ///                You can use a pipeline resolver to execute a GraphQL query against multiple data
    ///                sources.</p>
    ///             </li>
    ///          </ul>
    public let kind: ResolverKind?
    /// <p>The <code>PipelineConfig</code>.</p>
    public let pipelineConfig: PipelineConfig?
    /// <p>The mapping template to be used for requests.</p>
    ///          <p>A resolver uses a request mapping template to convert a GraphQL expression into a format
    ///          that a data source can understand. Mapping templates are written in Apache Velocity
    ///          Template Language (VTL).</p>
    ///          <p>VTL request mapping templates are optional when using a Lambda data source. For all
    ///          other data sources, VTL request and response mapping templates are required.</p>
    public let requestMappingTemplate: String?
    /// <p>The mapping template to be used for responses from the data source.</p>
    public let responseMappingTemplate: String?
    /// <p>The <code>SyncConfig</code> for a resolver attached to a versioned datasource.</p>
    public let syncConfig: SyncConfig?
    /// <p>The name of the <code>Type</code>.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        cachingConfig: CachingConfig? = nil,
        dataSourceName: String? = nil,
        fieldName: String? = nil,
        kind: ResolverKind? = nil,
        pipelineConfig: PipelineConfig? = nil,
        requestMappingTemplate: String? = nil,
        responseMappingTemplate: String? = nil,
        syncConfig: SyncConfig? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

struct CreateResolverInputBody: Equatable {
    public let fieldName: String?
    public let dataSourceName: String?
    public let requestMappingTemplate: String?
    public let responseMappingTemplate: String?
    public let kind: ResolverKind?
    public let pipelineConfig: PipelineConfig?
    public let syncConfig: SyncConfig?
    public let cachingConfig: CachingConfig?
}

extension CreateResolverInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension CreateResolverOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResolverOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResolverOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResolverOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResolverOutputResponse(resolver: \(String(describing: resolver)))"}
}

extension CreateResolverOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResolverOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct CreateResolverOutputResponse: Equatable {
    /// <p>The <code>Resolver</code> object.</p>
    public let resolver: Resolver?

    public init (
        resolver: Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct CreateResolverOutputResponseBody: Equatable {
    public let resolver: Resolver?
}

extension CreateResolverOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolver
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

public struct CreateTypeInputBodyMiddleware: Middleware {
    public let id: String = "CreateTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTypeInput>
    public typealias MOutput = OperationOutput<CreateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTypeOutputError>
}

extension CreateTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTypeInput(apiId: \(String(describing: apiId)), definition: \(String(describing: definition)), format: \(String(describing: format)))"}
}

extension CreateTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
        case format
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }
}

public struct CreateTypeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTypeInput>
    public typealias MOutput = OperationOutput<CreateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTypeOutputError>
}

public struct CreateTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTypeInput>
    public typealias MOutput = OperationOutput<CreateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTypeOutputError>
}

public struct CreateTypeInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The type definition, in GraphQL Schema Definition Language (SDL) format.</p>
    ///          <p>For more information, see the <a href="http://graphql.org/learn/schema/">GraphQL SDL
    ///             documentation</a>.</p>
    public let definition: String?
    /// <p>The type format: SDL or JSON.</p>
    public let format: TypeDefinitionFormat?

    public init (
        apiId: String? = nil,
        definition: String? = nil,
        format: TypeDefinitionFormat? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
    }
}

struct CreateTypeInputBody: Equatable {
    public let definition: String?
    public let format: TypeDefinitionFormat?
}

extension CreateTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definition
        case format
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension CreateTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTypeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTypeOutputResponse(type: \(String(describing: type)))"}
}

extension CreateTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct CreateTypeOutputResponse: Equatable {
    /// <p>The <code>Type</code> object.</p>
    public let type: `Type`?

    public init (
        type: `Type`? = nil
    )
    {
        self.type = type
    }
}

struct CreateTypeOutputResponseBody: Equatable {
    public let type: `Type`?
}

extension CreateTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension DataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceArn
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case name
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceArn = dataSourceArn {
            try encodeContainer.encode(dataSourceArn, forKey: .dataSourceArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceArn)
        dataSourceArn = dataSourceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension DataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSource(dataSourceArn: \(String(describing: dataSourceArn)), description: \(String(describing: description)), dynamodbConfig: \(String(describing: dynamodbConfig)), elasticsearchConfig: \(String(describing: elasticsearchConfig)), httpConfig: \(String(describing: httpConfig)), lambdaConfig: \(String(describing: lambdaConfig)), name: \(String(describing: name)), relationalDatabaseConfig: \(String(describing: relationalDatabaseConfig)), serviceRoleArn: \(String(describing: serviceRoleArn)), type: \(String(describing: type)))"}
}

/// <p>Describes a data source.</p>
public struct DataSource: Equatable {
    /// <p>The data source ARN.</p>
    public let dataSourceArn: String?
    /// <p>The description of the data source.</p>
    public let description: String?
    /// <p>Amazon DynamoDB settings.</p>
    public let dynamodbConfig: DynamodbDataSourceConfig?
    /// <p>Amazon Elasticsearch Service settings.</p>
    public let elasticsearchConfig: ElasticsearchDataSourceConfig?
    /// <p>HTTP endpoint settings.</p>
    public let httpConfig: HttpDataSourceConfig?
    /// <p>AWS Lambda settings.</p>
    public let lambdaConfig: LambdaDataSourceConfig?
    /// <p>The name of the data source.</p>
    public let name: String?
    /// <p>Relational database settings.</p>
    public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
    /// <p>The AWS IAM service role ARN for the data source. The system assumes this role when
    ///          accessing the data source.</p>
    public let serviceRoleArn: String?
    /// <p>The type of the data source.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>AMAZON_DYNAMODB</b>: The data source is an Amazon
    ///                DynamoDB table.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>AMAZON_ELASTICSEARCH</b>: The data source is an
    ///                Amazon Elasticsearch Service domain.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>AWS_LAMBDA</b>: The data source is an AWS Lambda
    ///                function.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>NONE</b>: There is no data source. This type is
    ///                used when you wish to invoke a GraphQL operation without connecting to a data source,
    ///                such as performing data transformation with resolvers or triggering a subscription to
    ///                be invoked from a mutation.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>HTTP</b>: The data source is an HTTP
    ///                endpoint.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>RELATIONAL_DATABASE</b>: The data source is a
    ///                relational database.</p>
    ///             </li>
    ///          </ul>
    public let type: DataSourceType?

    public init (
        dataSourceArn: String? = nil,
        description: String? = nil,
        dynamodbConfig: DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: ElasticsearchDataSourceConfig? = nil,
        httpConfig: HttpDataSourceConfig? = nil,
        lambdaConfig: LambdaDataSourceConfig? = nil,
        name: String? = nil,
        relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: String? = nil,
        type: DataSourceType? = nil
    )
    {
        self.dataSourceArn = dataSourceArn
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

public enum DataSourceType {
    case amazonDynamodb
    case amazonElasticsearch
    case awsLambda
    case http
    case `none`
    case relationalDatabase
    case sdkUnknown(String)
}

extension DataSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSourceType] {
        return [
            .amazonDynamodb,
            .amazonElasticsearch,
            .awsLambda,
            .http,
            .none,
            .relationalDatabase,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazonDynamodb: return "AMAZON_DYNAMODB"
        case .amazonElasticsearch: return "AMAZON_ELASTICSEARCH"
        case .awsLambda: return "AWS_LAMBDA"
        case .http: return "HTTP"
        case .none: return "NONE"
        case .relationalDatabase: return "RELATIONAL_DATABASE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
    }
}

public enum DefaultAction {
    case allow
    case deny
    case sdkUnknown(String)
}

extension DefaultAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DefaultAction] {
        return [
            .allow,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .deny: return "DENY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DefaultAction(rawValue: rawValue) ?? DefaultAction.sdkUnknown(rawValue)
    }
}

extension DeleteApiCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiCacheInput(apiId: \(String(describing: apiId)))"}
}

extension DeleteApiCacheInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApiCacheInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiCacheInput>
    public typealias MOutput = OperationOutput<DeleteApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiCacheOutputError>
}

public struct DeleteApiCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiCacheInput>
    public typealias MOutput = OperationOutput<DeleteApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiCacheOutputError>
}

/// <p>Represents the input of a <code>DeleteApiCache</code> operation.</p>
public struct DeleteApiCacheInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteApiCacheInputBody: Equatable {
}

extension DeleteApiCacheInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApiCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiCacheOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiCacheOutputResponse()"}
}

extension DeleteApiCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the output of a <code>DeleteApiCache</code> operation.</p>
public struct DeleteApiCacheOutputResponse: Equatable {

    public init() {}
}

struct DeleteApiCacheOutputResponseBody: Equatable {
}

extension DeleteApiCacheOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApiKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiKeyInput(apiId: \(String(describing: apiId)), id: \(String(describing: id)))"}
}

extension DeleteApiKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApiKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiKeyInput>
    public typealias MOutput = OperationOutput<DeleteApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiKeyOutputError>
}

public struct DeleteApiKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiKeyInput>
    public typealias MOutput = OperationOutput<DeleteApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiKeyOutputError>
}

public struct DeleteApiKeyInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The ID for the API key.</p>
    public let id: String?

    public init (
        apiId: String? = nil,
        id: String? = nil
    )
    {
        self.apiId = apiId
        self.id = id
    }
}

struct DeleteApiKeyInputBody: Equatable {
}

extension DeleteApiKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApiKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiKeyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiKeyOutputResponse()"}
}

extension DeleteApiKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiKeyOutputResponse: Equatable {

    public init() {}
}

struct DeleteApiKeyOutputResponseBody: Equatable {
}

extension DeleteApiKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSourceInput(apiId: \(String(describing: apiId)), name: \(String(describing: name)))"}
}

extension DeleteDataSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDataSourceInput>
    public typealias MOutput = OperationOutput<DeleteDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDataSourceOutputError>
}

public struct DeleteDataSourceInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The name of the data source.</p>
    public let name: String?

    public init (
        apiId: String? = nil,
        name: String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

struct DeleteDataSourceInputBody: Equatable {
}

extension DeleteDataSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDataSourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDataSourceOutputResponse()"}
}

extension DeleteDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDataSourceOutputResponse: Equatable {

    public init() {}
}

struct DeleteDataSourceOutputResponseBody: Equatable {
}

extension DeleteDataSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionInput(apiId: \(String(describing: apiId)), functionId: \(String(describing: functionId)))"}
}

extension DeleteFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInput: Equatable {
    /// <p>The GraphQL API ID.</p>
    public let apiId: String?
    /// <p>The <code>Function</code> ID.</p>
    public let functionId: String?

    public init (
        apiId: String? = nil,
        functionId: String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

struct DeleteFunctionInputBody: Equatable {
}

extension DeleteFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionOutputResponse()"}
}

extension DeleteFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Equatable {

    public init() {}
}

struct DeleteFunctionOutputResponseBody: Equatable {
}

extension DeleteFunctionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGraphqlApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGraphqlApiInput(apiId: \(String(describing: apiId)))"}
}

extension DeleteGraphqlApiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGraphqlApiInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGraphqlApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGraphqlApiInput>
    public typealias MOutput = OperationOutput<DeleteGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGraphqlApiOutputError>
}

public struct DeleteGraphqlApiInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGraphqlApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGraphqlApiInput>
    public typealias MOutput = OperationOutput<DeleteGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGraphqlApiOutputError>
}

public struct DeleteGraphqlApiInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct DeleteGraphqlApiInputBody: Equatable {
}

extension DeleteGraphqlApiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGraphqlApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGraphqlApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGraphqlApiOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGraphqlApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGraphqlApiOutputResponse()"}
}

extension DeleteGraphqlApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGraphqlApiOutputResponse: Equatable {

    public init() {}
}

struct DeleteGraphqlApiOutputResponseBody: Equatable {
}

extension DeleteGraphqlApiOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResolverInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResolverInput(apiId: \(String(describing: apiId)), fieldName: \(String(describing: fieldName)), typeName: \(String(describing: typeName)))"}
}

extension DeleteResolverInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteResolverInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResolverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverInput>
    public typealias MOutput = OperationOutput<DeleteResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverOutputError>
}

public struct DeleteResolverInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResolverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResolverInput>
    public typealias MOutput = OperationOutput<DeleteResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResolverOutputError>
}

public struct DeleteResolverInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The resolver field name.</p>
    public let fieldName: String?
    /// <p>The name of the resolver type.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        fieldName: String? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

struct DeleteResolverInputBody: Equatable {
}

extension DeleteResolverInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteResolverOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResolverOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResolverOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResolverOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResolverOutputResponse()"}
}

extension DeleteResolverOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResolverOutputResponse: Equatable {

    public init() {}
}

struct DeleteResolverOutputResponseBody: Equatable {
}

extension DeleteResolverOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTypeInput(apiId: \(String(describing: apiId)), typeName: \(String(describing: typeName)))"}
}

extension DeleteTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTypeInput>
    public typealias MOutput = OperationOutput<DeleteTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTypeOutputError>
}

public struct DeleteTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTypeInput>
    public typealias MOutput = OperationOutput<DeleteTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTypeOutputError>
}

public struct DeleteTypeInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The type name.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.typeName = typeName
    }
}

struct DeleteTypeInputBody: Equatable {
}

extension DeleteTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTypeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTypeOutputResponse()"}
}

extension DeleteTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTypeOutputResponse: Equatable {

    public init() {}
}

struct DeleteTypeOutputResponseBody: Equatable {
}

extension DeleteTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeltaSyncConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseTableTTL
        case deltaSyncTableName
        case deltaSyncTableTTL
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseTableTTL != 0 {
            try encodeContainer.encode(baseTableTTL, forKey: .baseTableTTL)
        }
        if let deltaSyncTableName = deltaSyncTableName {
            try encodeContainer.encode(deltaSyncTableName, forKey: .deltaSyncTableName)
        }
        if deltaSyncTableTTL != 0 {
            try encodeContainer.encode(deltaSyncTableTTL, forKey: .deltaSyncTableTTL)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseTableTTLDecoded = try containerValues.decode(Int.self, forKey: .baseTableTTL)
        baseTableTTL = baseTableTTLDecoded
        let deltaSyncTableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deltaSyncTableName)
        deltaSyncTableName = deltaSyncTableNameDecoded
        let deltaSyncTableTTLDecoded = try containerValues.decode(Int.self, forKey: .deltaSyncTableTTL)
        deltaSyncTableTTL = deltaSyncTableTTLDecoded
    }
}

extension DeltaSyncConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeltaSyncConfig(baseTableTTL: \(String(describing: baseTableTTL)), deltaSyncTableName: \(String(describing: deltaSyncTableName)), deltaSyncTableTTL: \(String(describing: deltaSyncTableTTL)))"}
}

/// <p>Describes a Delta Sync configuration.</p>
public struct DeltaSyncConfig: Equatable {
    /// <p>The number of minutes an Item is stored in the datasource.</p>
    public let baseTableTTL: Int
    /// <p>The Delta Sync table name.</p>
    public let deltaSyncTableName: String?
    /// <p>The number of minutes a Delta Sync log entry is stored in the Delta Sync table.</p>
    public let deltaSyncTableTTL: Int

    public init (
        baseTableTTL: Int = 0,
        deltaSyncTableName: String? = nil,
        deltaSyncTableTTL: Int = 0
    )
    {
        self.baseTableTTL = baseTableTTL
        self.deltaSyncTableName = deltaSyncTableName
        self.deltaSyncTableTTL = deltaSyncTableTTL
    }
}

extension DynamodbDataSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion
        case deltaSyncConfig
        case tableName
        case useCallerCredentials
        case versioned
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let deltaSyncConfig = deltaSyncConfig {
            try encodeContainer.encode(deltaSyncConfig, forKey: .deltaSyncConfig)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if useCallerCredentials != false {
            try encodeContainer.encode(useCallerCredentials, forKey: .useCallerCredentials)
        }
        if versioned != false {
            try encodeContainer.encode(versioned, forKey: .versioned)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let useCallerCredentialsDecoded = try containerValues.decode(Bool.self, forKey: .useCallerCredentials)
        useCallerCredentials = useCallerCredentialsDecoded
        let deltaSyncConfigDecoded = try containerValues.decodeIfPresent(DeltaSyncConfig.self, forKey: .deltaSyncConfig)
        deltaSyncConfig = deltaSyncConfigDecoded
        let versionedDecoded = try containerValues.decode(Bool.self, forKey: .versioned)
        versioned = versionedDecoded
    }
}

extension DynamodbDataSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DynamodbDataSourceConfig(awsRegion: \(String(describing: awsRegion)), deltaSyncConfig: \(String(describing: deltaSyncConfig)), tableName: \(String(describing: tableName)), useCallerCredentials: \(String(describing: useCallerCredentials)), versioned: \(String(describing: versioned)))"}
}

/// <p>Describes an Amazon DynamoDB data source configuration.</p>
public struct DynamodbDataSourceConfig: Equatable {
    /// <p>The AWS Region.</p>
    public let awsRegion: String?
    /// <p>The <code>DeltaSyncConfig</code> for a versioned datasource.</p>
    public let deltaSyncConfig: DeltaSyncConfig?
    /// <p>The table name.</p>
    public let tableName: String?
    /// <p>Set to TRUE to use Amazon Cognito credentials with this data source.</p>
    public let useCallerCredentials: Bool
    /// <p>Set to TRUE to use Conflict Detection and Resolution with this data source.</p>
    public let versioned: Bool

    public init (
        awsRegion: String? = nil,
        deltaSyncConfig: DeltaSyncConfig? = nil,
        tableName: String? = nil,
        useCallerCredentials: Bool = false,
        versioned: Bool = false
    )
    {
        self.awsRegion = awsRegion
        self.deltaSyncConfig = deltaSyncConfig
        self.tableName = tableName
        self.useCallerCredentials = useCallerCredentials
        self.versioned = versioned
    }
}

extension ElasticsearchDataSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion
        case endpoint
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
    }
}

extension ElasticsearchDataSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElasticsearchDataSourceConfig(awsRegion: \(String(describing: awsRegion)), endpoint: \(String(describing: endpoint)))"}
}

/// <p>Describes an Elasticsearch data source configuration.</p>
public struct ElasticsearchDataSourceConfig: Equatable {
    /// <p>The AWS Region.</p>
    public let awsRegion: String?
    /// <p>The endpoint.</p>
    public let endpoint: String?

    public init (
        awsRegion: String? = nil,
        endpoint: String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.endpoint = endpoint
    }
}

public enum FieldLogLevel {
    case all
    case error
    case `none`
    case sdkUnknown(String)
}

extension FieldLogLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FieldLogLevel] {
        return [
            .all,
            .error,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .error: return "ERROR"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FieldLogLevel(rawValue: rawValue) ?? FieldLogLevel.sdkUnknown(rawValue)
    }
}

extension FlushApiCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlushApiCacheInput(apiId: \(String(describing: apiId)))"}
}

extension FlushApiCacheInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct FlushApiCacheInputHeadersMiddleware: Middleware {
    public let id: String = "FlushApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FlushApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<FlushApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FlushApiCacheInput>
    public typealias MOutput = OperationOutput<FlushApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FlushApiCacheOutputError>
}

public struct FlushApiCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "FlushApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<FlushApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<FlushApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<FlushApiCacheInput>
    public typealias MOutput = OperationOutput<FlushApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<FlushApiCacheOutputError>
}

/// <p>Represents the input of a <code>FlushApiCache</code> operation.</p>
public struct FlushApiCacheInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct FlushApiCacheInputBody: Equatable {
}

extension FlushApiCacheInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension FlushApiCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FlushApiCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FlushApiCacheOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FlushApiCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlushApiCacheOutputResponse()"}
}

extension FlushApiCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Represents the output of a <code>FlushApiCache</code> operation.</p>
public struct FlushApiCacheOutputResponse: Equatable {

    public init() {}
}

struct FlushApiCacheOutputResponseBody: Equatable {
}

extension FlushApiCacheOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension FunctionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceName
        case description
        case functionArn
        case functionId
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionId = functionId {
            try encodeContainer.encode(functionId, forKey: .functionId)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionId)
        functionId = functionIdDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension FunctionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionConfiguration(dataSourceName: \(String(describing: dataSourceName)), description: \(String(describing: description)), functionArn: \(String(describing: functionArn)), functionId: \(String(describing: functionId)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), requestMappingTemplate: \(String(describing: requestMappingTemplate)), responseMappingTemplate: \(String(describing: responseMappingTemplate)), syncConfig: \(String(describing: syncConfig)))"}
}

/// <p>A function is a reusable entity. Multiple functions can be used to compose the resolver
///          logic.</p>
public struct FunctionConfiguration: Equatable {
    /// <p>The name of the <code>DataSource</code>.</p>
    public let dataSourceName: String?
    /// <p>The <code>Function</code> description.</p>
    public let description: String?
    /// <p>The ARN of the <code>Function</code> object.</p>
    public let functionArn: String?
    /// <p>A unique ID representing the <code>Function</code> object.</p>
    public let functionId: String?
    /// <p>The version of the request mapping template. Currently only the 2018-05-29 version of
    ///          the template is supported.</p>
    public let functionVersion: String?
    /// <p>The name of the <code>Function</code> object.</p>
    public let name: String?
    /// <p>The <code>Function</code> request mapping template. Functions support only the
    ///          2018-05-29 version of the request mapping template.</p>
    public let requestMappingTemplate: String?
    /// <p>The <code>Function</code> response mapping template.</p>
    public let responseMappingTemplate: String?
    /// <p>Describes a Sync configuration for a resolver.</p>
    ///          <p>Contains information on which Conflict Detection as well as Resolution strategy should
    ///          be performed when the resolver is invoked.</p>
    public let syncConfig: SyncConfig?

    public init (
        dataSourceName: String? = nil,
        description: String? = nil,
        functionArn: String? = nil,
        functionId: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        requestMappingTemplate: String? = nil,
        responseMappingTemplate: String? = nil,
        syncConfig: SyncConfig? = nil
    )
    {
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionArn = functionArn
        self.functionId = functionId
        self.functionVersion = functionVersion
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
    }
}

extension GetApiCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiCacheInput(apiId: \(String(describing: apiId)))"}
}

extension GetApiCacheInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApiCacheInputHeadersMiddleware: Middleware {
    public let id: String = "GetApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiCacheInput>
    public typealias MOutput = OperationOutput<GetApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiCacheOutputError>
}

public struct GetApiCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApiCacheInput>
    public typealias MOutput = OperationOutput<GetApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApiCacheOutputError>
}

/// <p>Represents the input of a <code>GetApiCache</code> operation.</p>
public struct GetApiCacheInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetApiCacheInputBody: Equatable {
}

extension GetApiCacheInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApiCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiCacheOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApiCacheOutputResponse(apiCache: \(String(describing: apiCache)))"}
}

extension GetApiCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// <p>Represents the output of a <code>GetApiCache</code> operation.</p>
public struct GetApiCacheOutputResponse: Equatable {
    /// <p>The <code>ApiCache</code> object.</p>
    public let apiCache: ApiCache?

    public init (
        apiCache: ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct GetApiCacheOutputResponseBody: Equatable {
    public let apiCache: ApiCache?
}

extension GetApiCacheOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiCache
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

extension GetDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataSourceInput(apiId: \(String(describing: apiId)), name: \(String(describing: name)))"}
}

extension GetDataSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "GetDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataSourceInput>
    public typealias MOutput = OperationOutput<GetDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataSourceOutputError>
}

public struct GetDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDataSourceInput>
    public typealias MOutput = OperationOutput<GetDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDataSourceOutputError>
}

public struct GetDataSourceInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The name of the data source.</p>
    public let name: String?

    public init (
        apiId: String? = nil,
        name: String? = nil
    )
    {
        self.apiId = apiId
        self.name = name
    }
}

struct GetDataSourceInputBody: Equatable {
}

extension GetDataSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDataSourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDataSourceOutputResponse(dataSource: \(String(describing: dataSource)))"}
}

extension GetDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct GetDataSourceOutputResponse: Equatable {
    /// <p>The <code>DataSource</code> object.</p>
    public let dataSource: DataSource?

    public init (
        dataSource: DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct GetDataSourceOutputResponseBody: Equatable {
    public let dataSource: DataSource?
}

extension GetDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSource
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension GetFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionInput(apiId: \(String(describing: apiId)), functionId: \(String(describing: functionId)))"}
}

extension GetFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionInput>
    public typealias MOutput = OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionInput>
    public typealias MOutput = OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionOutputError>
}

public struct GetFunctionInput: Equatable {
    /// <p>The GraphQL API ID.</p>
    public let apiId: String?
    /// <p>The <code>Function</code> ID.</p>
    public let functionId: String?

    public init (
        apiId: String? = nil,
        functionId: String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
    }
}

struct GetFunctionInputBody: Equatable {
}

extension GetFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionOutputResponse(functionConfiguration: \(String(describing: functionConfiguration)))"}
}

extension GetFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFunctionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct GetFunctionOutputResponse: Equatable {
    /// <p>The <code>Function</code> object.</p>
    public let functionConfiguration: FunctionConfiguration?

    public init (
        functionConfiguration: FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct GetFunctionOutputResponseBody: Equatable {
    public let functionConfiguration: FunctionConfiguration?
}

extension GetFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

extension GetGraphqlApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGraphqlApiInput(apiId: \(String(describing: apiId)))"}
}

extension GetGraphqlApiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGraphqlApiInputHeadersMiddleware: Middleware {
    public let id: String = "GetGraphqlApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGraphqlApiInput>
    public typealias MOutput = OperationOutput<GetGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGraphqlApiOutputError>
}

public struct GetGraphqlApiInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGraphqlApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGraphqlApiInput>
    public typealias MOutput = OperationOutput<GetGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGraphqlApiOutputError>
}

public struct GetGraphqlApiInput: Equatable {
    /// <p>The API ID for the GraphQL API.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetGraphqlApiInputBody: Equatable {
}

extension GetGraphqlApiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGraphqlApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGraphqlApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGraphqlApiOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGraphqlApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGraphqlApiOutputResponse(graphqlApi: \(String(describing: graphqlApi)))"}
}

extension GetGraphqlApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct GetGraphqlApiOutputResponse: Equatable {
    /// <p>The <code>GraphqlApi</code> object.</p>
    public let graphqlApi: GraphqlApi?

    public init (
        graphqlApi: GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct GetGraphqlApiOutputResponseBody: Equatable {
    public let graphqlApi: GraphqlApi?
}

extension GetGraphqlApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphqlApi
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

extension GetIntrospectionSchemaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntrospectionSchemaInput(apiId: \(String(describing: apiId)), format: \(String(describing: format)), includeDirectives: \(String(describing: includeDirectives)))"}
}

extension GetIntrospectionSchemaInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIntrospectionSchemaInputHeadersMiddleware: Middleware {
    public let id: String = "GetIntrospectionSchemaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntrospectionSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntrospectionSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntrospectionSchemaInput>
    public typealias MOutput = OperationOutput<GetIntrospectionSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntrospectionSchemaOutputError>
}

public struct GetIntrospectionSchemaInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIntrospectionSchemaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIntrospectionSchemaInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIntrospectionSchemaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let includeDirectives = input.operationInput.includeDirectives {
            let includeDirectivesQueryItem = URLQueryItem(name: "includeDirectives".urlPercentEncoding(), value: String(includeDirectives).urlPercentEncoding())
            input.builder.withQueryItem(includeDirectivesQueryItem)
        }
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIntrospectionSchemaInput>
    public typealias MOutput = OperationOutput<GetIntrospectionSchemaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIntrospectionSchemaOutputError>
}

public struct GetIntrospectionSchemaInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The schema format: SDL or JSON.</p>
    public let format: OutputType?
    /// <p>A flag that specifies whether the schema introspection should contain directives.</p>
    public let includeDirectives: Bool?

    public init (
        apiId: String? = nil,
        format: OutputType? = nil,
        includeDirectives: Bool? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.includeDirectives = includeDirectives
    }
}

struct GetIntrospectionSchemaInputBody: Equatable {
}

extension GetIntrospectionSchemaInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIntrospectionSchemaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntrospectionSchemaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "GraphQLSchemaException" : self = .graphQLSchemaException(try GraphQLSchemaException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntrospectionSchemaOutputError: Equatable {
    case graphQLSchemaException(GraphQLSchemaException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntrospectionSchemaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIntrospectionSchemaOutputResponse(schema: \(String(describing: schema)))"}
}

extension GetIntrospectionSchemaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.schema = unwrappedData
        } else {
            self.schema = nil
        }
    }
}

public struct GetIntrospectionSchemaOutputResponse: Equatable {
    /// <p>The schema, in GraphQL Schema Definition Language (SDL) format.</p>
    ///          <p>For more information, see the <a href="http://graphql.org/learn/schema/">GraphQL SDL
    ///             documentation</a>.</p>
    public let schema: Data?

    public init (
        schema: Data? = nil
    )
    {
        self.schema = schema
    }
}

struct GetIntrospectionSchemaOutputResponseBody: Equatable {
    public let schema: Data?
}

extension GetIntrospectionSchemaOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case schema
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension GetResolverInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverInput(apiId: \(String(describing: apiId)), fieldName: \(String(describing: fieldName)), typeName: \(String(describing: typeName)))"}
}

extension GetResolverInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResolverInputHeadersMiddleware: Middleware {
    public let id: String = "GetResolverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverInput>
    public typealias MOutput = OperationOutput<GetResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverOutputError>
}

public struct GetResolverInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResolverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResolverInput>
    public typealias MOutput = OperationOutput<GetResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResolverOutputError>
}

public struct GetResolverInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The resolver field name.</p>
    public let fieldName: String?
    /// <p>The resolver type name.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        fieldName: String? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.fieldName = fieldName
        self.typeName = typeName
    }
}

struct GetResolverInputBody: Equatable {
}

extension GetResolverInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResolverOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResolverOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResolverOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResolverOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResolverOutputResponse(resolver: \(String(describing: resolver)))"}
}

extension GetResolverOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResolverOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct GetResolverOutputResponse: Equatable {
    /// <p>The <code>Resolver</code> object.</p>
    public let resolver: Resolver?

    public init (
        resolver: Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct GetResolverOutputResponseBody: Equatable {
    public let resolver: Resolver?
}

extension GetResolverOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolver
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

extension GetSchemaCreationStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaCreationStatusInput(apiId: \(String(describing: apiId)))"}
}

extension GetSchemaCreationStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSchemaCreationStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetSchemaCreationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaCreationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaCreationStatusInput>
    public typealias MOutput = OperationOutput<GetSchemaCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaCreationStatusOutputError>
}

public struct GetSchemaCreationStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSchemaCreationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSchemaCreationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSchemaCreationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSchemaCreationStatusInput>
    public typealias MOutput = OperationOutput<GetSchemaCreationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSchemaCreationStatusOutputError>
}

public struct GetSchemaCreationStatusInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?

    public init (
        apiId: String? = nil
    )
    {
        self.apiId = apiId
    }
}

struct GetSchemaCreationStatusInputBody: Equatable {
}

extension GetSchemaCreationStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSchemaCreationStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSchemaCreationStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSchemaCreationStatusOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSchemaCreationStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSchemaCreationStatusOutputResponse(details: \(String(describing: details)), status: \(String(describing: status)))"}
}

extension GetSchemaCreationStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSchemaCreationStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.details = output.details
            self.status = output.status
        } else {
            self.details = nil
            self.status = nil
        }
    }
}

public struct GetSchemaCreationStatusOutputResponse: Equatable {
    /// <p>Detailed information about the status of the schema creation operation.</p>
    public let details: String?
    /// <p>The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When
    ///          the schema is in the ACTIVE state, you can add data.</p>
    public let status: SchemaStatus?

    public init (
        details: String? = nil,
        status: SchemaStatus? = nil
    )
    {
        self.details = details
        self.status = status
    }
}

struct GetSchemaCreationStatusOutputResponseBody: Equatable {
    public let status: SchemaStatus?
    public let details: String?
}

extension GetSchemaCreationStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case details
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SchemaStatus.self, forKey: .status)
        status = statusDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .details)
        details = detailsDecoded
    }
}

extension GetTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTypeInput(apiId: \(String(describing: apiId)), format: \(String(describing: format)), typeName: \(String(describing: typeName)))"}
}

extension GetTypeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTypeInputHeadersMiddleware: Middleware {
    public let id: String = "GetTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTypeInput>
    public typealias MOutput = OperationOutput<GetTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTypeOutputError>
}

public struct GetTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTypeInput>
    public typealias MOutput = OperationOutput<GetTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTypeOutputError>
}

public struct GetTypeInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The type format: SDL or JSON.</p>
    public let format: TypeDefinitionFormat?
    /// <p>The type name.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        format: TypeDefinitionFormat? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.typeName = typeName
    }
}

struct GetTypeInputBody: Equatable {
}

extension GetTypeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTypeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTypeOutputResponse(type: \(String(describing: type)))"}
}

extension GetTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct GetTypeOutputResponse: Equatable {
    /// <p>The <code>Type</code> object.</p>
    public let type: `Type`?

    public init (
        type: `Type`? = nil
    )
    {
        self.type = type
    }
}

struct GetTypeOutputResponseBody: Equatable {
    public let type: `Type`?
}

extension GetTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension GraphQLSchemaException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GraphQLSchemaException(message: \(String(describing: message)))"}
}

extension GraphQLSchemaException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GraphQLSchemaExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The GraphQL schema is not valid.</p>
public struct GraphQLSchemaException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct GraphQLSchemaExceptionBody: Equatable {
    public let message: String?
}

extension GraphQLSchemaExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GraphqlApi: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalAuthenticationProviders
        case apiId
        case arn
        case authenticationType
        case logConfig
        case name
        case openIDConnectConfig
        case tags
        case uris
        case userPoolConfig
        case wafWebAclArn
        case xrayEnabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let uris = uris {
            var urisContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .uris)
            for (dictKey0, mapofstringtostring0) in uris {
                try urisContainer.encode(mapofstringtostring0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if let wafWebAclArn = wafWebAclArn {
            try encodeContainer.encode(wafWebAclArn, forKey: .wafWebAclArn)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let apiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let urisContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .uris)
        var urisDecoded0: [String:String]? = nil
        if let urisContainer = urisContainer {
            urisDecoded0 = [String:String]()
            for (key0, string0) in urisContainer {
                if let string0 = string0 {
                    urisDecoded0?[key0] = string0
                }
            }
        }
        uris = urisDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
        let wafWebAclArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .wafWebAclArn)
        wafWebAclArn = wafWebAclArnDecoded
    }
}

extension GraphqlApi: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GraphqlApi(additionalAuthenticationProviders: \(String(describing: additionalAuthenticationProviders)), apiId: \(String(describing: apiId)), arn: \(String(describing: arn)), authenticationType: \(String(describing: authenticationType)), logConfig: \(String(describing: logConfig)), name: \(String(describing: name)), openIDConnectConfig: \(String(describing: openIDConnectConfig)), tags: \(String(describing: tags)), uris: \(String(describing: uris)), userPoolConfig: \(String(describing: userPoolConfig)), wafWebAclArn: \(String(describing: wafWebAclArn)), xrayEnabled: \(String(describing: xrayEnabled)))"}
}

/// <p>Describes a GraphQL API.</p>
public struct GraphqlApi: Equatable {
    /// <p>A list of additional authentication providers for the <code>GraphqlApi</code>
    ///          API.</p>
    public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The ARN.</p>
    public let arn: String?
    /// <p>The authentication type.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The Amazon CloudWatch Logs configuration.</p>
    public let logConfig: LogConfig?
    /// <p>The API name.</p>
    public let name: String?
    /// <p>The OpenID Connect configuration.</p>
    public let openIDConnectConfig: OpenIDConnectConfig?
    /// <p>The tags.</p>
    public let tags: [String:String]?
    /// <p>The URIs.</p>
    public let uris: [String:String]?
    /// <p>The Amazon Cognito user pool configuration.</p>
    public let userPoolConfig: UserPoolConfig?
    /// <p>The ARN of the AWS Web Application Firewall (WAF) ACL associated with this
    ///          <code>GraphqlApi</code>, if one exists.</p>
    public let wafWebAclArn: String?
    /// <p>A flag representing whether X-Ray tracing is enabled for this
    ///          <code>GraphqlApi</code>.</p>
    public let xrayEnabled: Bool

    public init (
        additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil,
        apiId: String? = nil,
        arn: String? = nil,
        authenticationType: AuthenticationType? = nil,
        logConfig: LogConfig? = nil,
        name: String? = nil,
        openIDConnectConfig: OpenIDConnectConfig? = nil,
        tags: [String:String]? = nil,
        uris: [String:String]? = nil,
        userPoolConfig: UserPoolConfig? = nil,
        wafWebAclArn: String? = nil,
        xrayEnabled: Bool = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.apiId = apiId
        self.arn = arn
        self.authenticationType = authenticationType
        self.logConfig = logConfig
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.tags = tags
        self.uris = uris
        self.userPoolConfig = userPoolConfig
        self.wafWebAclArn = wafWebAclArn
        self.xrayEnabled = xrayEnabled
    }
}

extension HttpDataSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationConfig
        case endpoint
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationConfig = authorizationConfig {
            try encodeContainer.encode(authorizationConfig, forKey: .authorizationConfig)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let authorizationConfigDecoded = try containerValues.decodeIfPresent(AuthorizationConfig.self, forKey: .authorizationConfig)
        authorizationConfig = authorizationConfigDecoded
    }
}

extension HttpDataSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpDataSourceConfig(authorizationConfig: \(String(describing: authorizationConfig)), endpoint: \(String(describing: endpoint)))"}
}

/// <p>Describes an HTTP data source configuration.</p>
public struct HttpDataSourceConfig: Equatable {
    /// <p>The authorization config in case the HTTP endpoint requires authorization.</p>
    public let authorizationConfig: AuthorizationConfig?
    /// <p>The HTTP URL endpoint. You can either specify the domain name or IP, and port
    ///          combination, and the URL scheme must be HTTP or HTTPS. If the port is not specified, AWS
    ///          AppSync uses the default port 80 for the HTTP endpoint and port 443 for HTTPS
    ///          endpoints.</p>
    public let endpoint: String?

    public init (
        authorizationConfig: AuthorizationConfig? = nil,
        endpoint: String? = nil
    )
    {
        self.authorizationConfig = authorizationConfig
        self.endpoint = endpoint
    }
}

extension InternalFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalFailureException(message: \(String(describing: message)))"}
}

extension InternalFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal AWS AppSync error occurred. Try your request again.</p>
public struct InternalFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Equatable {
    public let message: String?
}

extension InternalFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LambdaConflictHandlerConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaConflictHandlerArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaConflictHandlerArn = lambdaConflictHandlerArn {
            try encodeContainer.encode(lambdaConflictHandlerArn, forKey: .lambdaConflictHandlerArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaConflictHandlerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaConflictHandlerArn)
        lambdaConflictHandlerArn = lambdaConflictHandlerArnDecoded
    }
}

extension LambdaConflictHandlerConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaConflictHandlerConfig(lambdaConflictHandlerArn: \(String(describing: lambdaConflictHandlerArn)))"}
}

/// <p>The <code>LambdaConflictHandlerConfig</code> object when configuring LAMBDA as the
///          Conflict Handler.</p>
public struct LambdaConflictHandlerConfig: Equatable {
    /// <p>The Arn for the Lambda function to use as the Conflict Handler.</p>
    public let lambdaConflictHandlerArn: String?

    public init (
        lambdaConflictHandlerArn: String? = nil
    )
    {
        self.lambdaConflictHandlerArn = lambdaConflictHandlerArn
    }
}

extension LambdaDataSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaFunctionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension LambdaDataSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaDataSourceConfig(lambdaFunctionArn: \(String(describing: lambdaFunctionArn)))"}
}

/// <p>Describes an AWS Lambda data source configuration.</p>
public struct LambdaDataSourceConfig: Equatable {
    /// <p>The ARN for the Lambda function.</p>
    public let lambdaFunctionArn: String?

    public init (
        lambdaFunctionArn: String? = nil
    )
    {
        self.lambdaFunctionArn = lambdaFunctionArn
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request exceeded a limit. Try your request again.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApiKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApiKeysInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApiKeysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListApiKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ListApiKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApiKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApiKeysInput>
    public typealias MOutput = OperationOutput<ListApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApiKeysOutputError>
}

public struct ListApiKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApiKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApiKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApiKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApiKeysInput>
    public typealias MOutput = OperationOutput<ListApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApiKeysOutputError>
}

public struct ListApiKeysInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The maximum number of results you want the request to return.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApiKeysInputBody: Equatable {
}

extension ListApiKeysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListApiKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApiKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApiKeysOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApiKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApiKeysOutputResponse(apiKeys: \(String(describing: apiKeys)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApiKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApiKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKeys = output.apiKeys
            self.nextToken = output.nextToken
        } else {
            self.apiKeys = nil
            self.nextToken = nil
        }
    }
}

public struct ListApiKeysOutputResponse: Equatable {
    /// <p>The <code>ApiKey</code> objects.</p>
    public let apiKeys: [ApiKey]?
    /// <p>An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.</p>
    public let nextToken: String?

    public init (
        apiKeys: [ApiKey]? = nil,
        nextToken: String? = nil
    )
    {
        self.apiKeys = apiKeys
        self.nextToken = nextToken
    }
}

struct ListApiKeysOutputResponseBody: Equatable {
    public let apiKeys: [ApiKey]?
    public let nextToken: String?
}

extension ListApiKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKeys
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeysContainer = try containerValues.decodeIfPresent([ApiKey?].self, forKey: .apiKeys)
        var apiKeysDecoded0:[ApiKey]? = nil
        if let apiKeysContainer = apiKeysContainer {
            apiKeysDecoded0 = [ApiKey]()
            for structure0 in apiKeysContainer {
                if let structure0 = structure0 {
                    apiKeysDecoded0?.append(structure0)
                }
            }
        }
        apiKeys = apiKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDataSourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSourcesInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataSourcesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDataSourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDataSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDataSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDataSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDataSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDataSourcesInput>
    public typealias MOutput = OperationOutput<ListDataSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDataSourcesOutputError>
}

public struct ListDataSourcesInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The maximum number of results you want the request to return.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list. </p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataSourcesInputBody: Equatable {
}

extension ListDataSourcesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDataSourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataSourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDataSourcesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataSourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDataSourcesOutputResponse(dataSources: \(String(describing: dataSources)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDataSourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDataSourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSources = output.dataSources
            self.nextToken = output.nextToken
        } else {
            self.dataSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataSourcesOutputResponse: Equatable {
    /// <p>The <code>DataSource</code> objects.</p>
    public let dataSources: [DataSource]?
    /// <p>An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.</p>
    public let nextToken: String?

    public init (
        dataSources: [DataSource]? = nil,
        nextToken: String? = nil
    )
    {
        self.dataSources = dataSources
        self.nextToken = nextToken
    }
}

struct ListDataSourcesOutputResponseBody: Equatable {
    public let dataSources: [DataSource]?
    public let nextToken: String?
}

extension ListDataSourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSources
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for structure0 in dataSourcesContainer {
                if let structure0 = structure0 {
                    dataSourcesDecoded0?.append(structure0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFunctionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionsInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFunctionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFunctionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInput: Equatable {
    /// <p>The GraphQL API ID.</p>
    public let apiId: String?
    /// <p>The maximum number of results you want the request to return.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionsInputBody: Equatable {
}

extension ListFunctionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFunctionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionsOutputResponse(functions: \(String(describing: functions)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFunctionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.functions = output.functions
            self.nextToken = output.nextToken
        } else {
            self.functions = nil
            self.nextToken = nil
        }
    }
}

public struct ListFunctionsOutputResponse: Equatable {
    /// <p>A list of <code>Function</code> objects.</p>
    public let functions: [FunctionConfiguration]?
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        functions: [FunctionConfiguration]? = nil,
        nextToken: String? = nil
    )
    {
        self.functions = functions
        self.nextToken = nextToken
    }
}

struct ListFunctionsOutputResponseBody: Equatable {
    public let functions: [FunctionConfiguration]?
    public let nextToken: String?
}

extension ListFunctionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functions
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try containerValues.decodeIfPresent([FunctionConfiguration?].self, forKey: .functions)
        var functionsDecoded0:[FunctionConfiguration]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [FunctionConfiguration]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGraphqlApisInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGraphqlApisInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGraphqlApisInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGraphqlApisInputHeadersMiddleware: Middleware {
    public let id: String = "ListGraphqlApisInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGraphqlApisInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGraphqlApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGraphqlApisInput>
    public typealias MOutput = OperationOutput<ListGraphqlApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGraphqlApisOutputError>
}

public struct ListGraphqlApisInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGraphqlApisInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGraphqlApisInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGraphqlApisOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGraphqlApisInput>
    public typealias MOutput = OperationOutput<ListGraphqlApisOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGraphqlApisOutputError>
}

public struct ListGraphqlApisInput: Equatable {
    /// <p>The maximum number of results you want the request to return.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list. </p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGraphqlApisInputBody: Equatable {
}

extension ListGraphqlApisInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGraphqlApisOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGraphqlApisOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGraphqlApisOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGraphqlApisOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGraphqlApisOutputResponse(graphqlApis: \(String(describing: graphqlApis)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGraphqlApisOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGraphqlApisOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.graphqlApis = output.graphqlApis
            self.nextToken = output.nextToken
        } else {
            self.graphqlApis = nil
            self.nextToken = nil
        }
    }
}

public struct ListGraphqlApisOutputResponse: Equatable {
    /// <p>The <code>GraphqlApi</code> objects.</p>
    public let graphqlApis: [GraphqlApi]?
    /// <p>An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.</p>
    public let nextToken: String?

    public init (
        graphqlApis: [GraphqlApi]? = nil,
        nextToken: String? = nil
    )
    {
        self.graphqlApis = graphqlApis
        self.nextToken = nextToken
    }
}

struct ListGraphqlApisOutputResponseBody: Equatable {
    public let graphqlApis: [GraphqlApi]?
    public let nextToken: String?
}

extension ListGraphqlApisOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphqlApis
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApisContainer = try containerValues.decodeIfPresent([GraphqlApi?].self, forKey: .graphqlApis)
        var graphqlApisDecoded0:[GraphqlApi]? = nil
        if let graphqlApisContainer = graphqlApisContainer {
            graphqlApisDecoded0 = [GraphqlApi]()
            for structure0 in graphqlApisContainer {
                if let structure0 = structure0 {
                    graphqlApisDecoded0?.append(structure0)
                }
            }
        }
        graphqlApis = graphqlApisDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolversByFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolversByFunctionInput(apiId: \(String(describing: apiId)), functionId: \(String(describing: functionId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResolversByFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListResolversByFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolversByFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolversByFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolversByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolversByFunctionInput>
    public typealias MOutput = OperationOutput<ListResolversByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolversByFunctionOutputError>
}

public struct ListResolversByFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolversByFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolversByFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolversByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolversByFunctionInput>
    public typealias MOutput = OperationOutput<ListResolversByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolversByFunctionOutputError>
}

public struct ListResolversByFunctionInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The Function ID.</p>
    public let functionId: String?
    /// <p>The maximum number of results you want the request to return.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which you can
    ///          use to return the next set of items in the list.</p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        functionId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.functionId = functionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResolversByFunctionInputBody: Equatable {
}

extension ListResolversByFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListResolversByFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolversByFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolversByFunctionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolversByFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolversByFunctionOutputResponse(nextToken: \(String(describing: nextToken)), resolvers: \(String(describing: resolvers)))"}
}

extension ListResolversByFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolversByFunctionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resolvers = output.resolvers
        } else {
            self.nextToken = nil
            self.resolvers = nil
        }
    }
}

public struct ListResolversByFunctionOutputResponse: Equatable {
    /// <p>An identifier that can be used to return the next set of items in the list.</p>
    public let nextToken: String?
    /// <p>The list of resolvers.</p>
    public let resolvers: [Resolver]?

    public init (
        nextToken: String? = nil,
        resolvers: [Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

struct ListResolversByFunctionOutputResponseBody: Equatable {
    public let resolvers: [Resolver]?
    public let nextToken: String?
}

extension ListResolversByFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resolvers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolversContainer = try containerValues.decodeIfPresent([Resolver?].self, forKey: .resolvers)
        var resolversDecoded0:[Resolver]? = nil
        if let resolversContainer = resolversContainer {
            resolversDecoded0 = [Resolver]()
            for structure0 in resolversContainer {
                if let structure0 = structure0 {
                    resolversDecoded0?.append(structure0)
                }
            }
        }
        resolvers = resolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResolversInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolversInput(apiId: \(String(describing: apiId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), typeName: \(String(describing: typeName)))"}
}

extension ListResolversInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListResolversInputHeadersMiddleware: Middleware {
    public let id: String = "ListResolversInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolversInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolversOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolversInput>
    public typealias MOutput = OperationOutput<ListResolversOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolversOutputError>
}

public struct ListResolversInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResolversInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResolversInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResolversOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResolversInput>
    public typealias MOutput = OperationOutput<ListResolversOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResolversOutputError>
}

public struct ListResolversInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The maximum number of results you want the request to return.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list. </p>
    public let nextToken: String?
    /// <p>The type name.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.typeName = typeName
    }
}

struct ListResolversInputBody: Equatable {
}

extension ListResolversInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListResolversOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResolversOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResolversOutputError: Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResolversOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResolversOutputResponse(nextToken: \(String(describing: nextToken)), resolvers: \(String(describing: resolvers)))"}
}

extension ListResolversOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResolversOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resolvers = output.resolvers
        } else {
            self.nextToken = nil
            self.resolvers = nil
        }
    }
}

public struct ListResolversOutputResponse: Equatable {
    /// <p>An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.</p>
    public let nextToken: String?
    /// <p>The <code>Resolver</code> objects.</p>
    public let resolvers: [Resolver]?

    public init (
        nextToken: String? = nil,
        resolvers: [Resolver]? = nil
    )
    {
        self.nextToken = nextToken
        self.resolvers = resolvers
    }
}

struct ListResolversOutputResponseBody: Equatable {
    public let resolvers: [Resolver]?
    public let nextToken: String?
}

extension ListResolversOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resolvers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolversContainer = try containerValues.decodeIfPresent([Resolver?].self, forKey: .resolvers)
        var resolversDecoded0:[Resolver]? = nil
        if let resolversContainer = resolversContainer {
            resolversDecoded0 = [Resolver]()
            for structure0 in resolversContainer {
                if let structure0 = structure0 {
                    resolversDecoded0?.append(structure0)
                }
            }
        }
        resolvers = resolversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The <code>GraphqlApi</code> ARN.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A <code>TagMap</code> object.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypesInput(apiId: \(String(describing: apiId)), format: \(String(describing: format)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTypesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypesInput>
    public typealias MOutput = OperationOutput<ListTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypesOutputError>
}

public struct ListTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let format = input.operationInput.format {
            let formatQueryItem = URLQueryItem(name: "format".urlPercentEncoding(), value: String(format.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(formatQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTypesInput>
    public typealias MOutput = OperationOutput<ListTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTypesOutputError>
}

public struct ListTypesInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The type format: SDL or JSON.</p>
    public let format: TypeDefinitionFormat?
    /// <p>The maximum number of results you want the request to return.</p>
    public let maxResults: Int
    /// <p>An identifier that was returned from the previous call to this operation, which can be
    ///          used to return the next set of items in the list. </p>
    public let nextToken: String?

    public init (
        apiId: String? = nil,
        format: TypeDefinitionFormat? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.apiId = apiId
        self.format = format
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTypesInputBody: Equatable {
}

extension ListTypesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTypesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTypesOutputResponse(nextToken: \(String(describing: nextToken)), types: \(String(describing: types)))"}
}

extension ListTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.types = output.types
        } else {
            self.nextToken = nil
            self.types = nil
        }
    }
}

public struct ListTypesOutputResponse: Equatable {
    /// <p>An identifier to be passed in the next request to this operation to return the next set
    ///          of items in the list.</p>
    public let nextToken: String?
    /// <p>The <code>Type</code> objects.</p>
    public let types: [`Type`]?

    public init (
        nextToken: String? = nil,
        types: [`Type`]? = nil
    )
    {
        self.nextToken = nextToken
        self.types = types
    }
}

struct ListTypesOutputResponseBody: Equatable {
    public let types: [`Type`]?
    public let nextToken: String?
}

extension ListTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case types
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([`Type`?].self, forKey: .types)
        var typesDecoded0:[`Type`]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [`Type`]()
            for structure0 in typesContainer {
                if let structure0 = structure0 {
                    typesDecoded0?.append(structure0)
                }
            }
        }
        types = typesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LogConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsRoleArn
        case excludeVerboseContent
        case fieldLogLevel
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if excludeVerboseContent != false {
            try encodeContainer.encode(excludeVerboseContent, forKey: .excludeVerboseContent)
        }
        if let fieldLogLevel = fieldLogLevel {
            try encodeContainer.encode(fieldLogLevel.rawValue, forKey: .fieldLogLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLogLevelDecoded = try containerValues.decodeIfPresent(FieldLogLevel.self, forKey: .fieldLogLevel)
        fieldLogLevel = fieldLogLevelDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let excludeVerboseContentDecoded = try containerValues.decode(Bool.self, forKey: .excludeVerboseContent)
        excludeVerboseContent = excludeVerboseContentDecoded
    }
}

extension LogConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogConfig(cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), excludeVerboseContent: \(String(describing: excludeVerboseContent)), fieldLogLevel: \(String(describing: fieldLogLevel)))"}
}

/// <p>The CloudWatch Logs configuration.</p>
public struct LogConfig: Equatable {
    /// <p>The service role that AWS AppSync will assume to publish to Amazon CloudWatch logs in
    ///          your account. </p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>Set to TRUE to exclude sections that contain information such as headers, context, and
    ///          evaluated mapping templates, regardless of logging level.</p>
    public let excludeVerboseContent: Bool
    /// <p>The field logging level. Values can be NONE, ERROR, or ALL. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>NONE</b>: No field-level logs are
    ///                captured.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>ERROR</b>: Logs the following information only for
    ///                the fields that are in error:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The error section in the server response.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Field-level errors.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The generated request/response functions that got resolved for error
    ///                      fields.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>ALL</b>: The following information is logged for
    ///                all fields in the query:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Field-level tracing information.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The generated request/response functions that got resolved for each
    ///                      field.</p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let fieldLogLevel: FieldLogLevel?

    public init (
        cloudWatchLogsRoleArn: String? = nil,
        excludeVerboseContent: Bool = false,
        fieldLogLevel: FieldLogLevel? = nil
    )
    {
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.excludeVerboseContent = excludeVerboseContent
        self.fieldLogLevel = fieldLogLevel
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in the request was not found. Check the resource, and then try
///          again.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OpenIDConnectConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authTTL
        case clientId
        case iatTTL
        case issuer
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authTTL != 0 {
            try encodeContainer.encode(authTTL, forKey: .authTTL)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if iatTTL != 0 {
            try encodeContainer.encode(iatTTL, forKey: .iatTTL)
        }
        if let issuer = issuer {
            try encodeContainer.encode(issuer, forKey: .issuer)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let iatTTLDecoded = try containerValues.decode(Int.self, forKey: .iatTTL)
        iatTTL = iatTTLDecoded
        let authTTLDecoded = try containerValues.decode(Int.self, forKey: .authTTL)
        authTTL = authTTLDecoded
    }
}

extension OpenIDConnectConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OpenIDConnectConfig(authTTL: \(String(describing: authTTL)), clientId: \(String(describing: clientId)), iatTTL: \(String(describing: iatTTL)), issuer: \(String(describing: issuer)))"}
}

/// <p>Describes an OpenID Connect configuration.</p>
public struct OpenIDConnectConfig: Equatable {
    /// <p>The number of milliseconds a token is valid after being authenticated.</p>
    public let authTTL: Int
    /// <p>The client identifier of the Relying party at the OpenID identity provider. This
    ///          identifier is typically obtained when the Relying party is registered with the OpenID
    ///          identity provider. You can specify a regular expression so the AWS AppSync can validate
    ///          against multiple client identifiers at a time.</p>
    public let clientId: String?
    /// <p>The number of milliseconds a token is valid after being issued to a user.</p>
    public let iatTTL: Int
    /// <p>The issuer for the OpenID Connect configuration. The issuer returned by discovery must
    ///          exactly match the value of <code>iss</code> in the ID token.</p>
    public let issuer: String?

    public init (
        authTTL: Int = 0,
        clientId: String? = nil,
        iatTTL: Int = 0,
        issuer: String? = nil
    )
    {
        self.authTTL = authTTL
        self.clientId = clientId
        self.iatTTL = iatTTL
        self.issuer = issuer
    }
}

public enum OutputType {
    case json
    case sdl
    case sdkUnknown(String)
}

extension OutputType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OutputType] {
        return [
            .json,
            .sdl,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .sdl: return "SDL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OutputType(rawValue: rawValue) ?? OutputType.sdkUnknown(rawValue)
    }
}

extension PipelineConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for functionsids0 in functions {
                try functionsContainer.encode(functionsids0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .functions)
        var functionsDecoded0:[String]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [String]()
            for string0 in functionsContainer {
                if let string0 = string0 {
                    functionsDecoded0?.append(string0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension PipelineConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineConfig(functions: \(String(describing: functions)))"}
}

/// <p>The pipeline configuration for a resolver of kind <code>PIPELINE</code>.</p>
public struct PipelineConfig: Equatable {
    /// <p>A list of <code>Function</code> objects.</p>
    public let functions: [String]?

    public init (
        functions: [String]? = nil
    )
    {
        self.functions = functions
    }
}

extension RdsHttpEndpointConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsRegion
        case awsSecretStoreArn
        case databaseName
        case dbClusterIdentifier
        case schema
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let awsSecretStoreArn = awsSecretStoreArn {
            try encodeContainer.encode(awsSecretStoreArn, forKey: .awsSecretStoreArn)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let dbClusterIdentifier = dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schema)
        schema = schemaDecoded
        let awsSecretStoreArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsSecretStoreArn)
        awsSecretStoreArn = awsSecretStoreArnDecoded
    }
}

extension RdsHttpEndpointConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RdsHttpEndpointConfig(awsRegion: \(String(describing: awsRegion)), awsSecretStoreArn: \(String(describing: awsSecretStoreArn)), databaseName: \(String(describing: databaseName)), dbClusterIdentifier: \(String(describing: dbClusterIdentifier)), schema: \(String(describing: schema)))"}
}

/// <p>The Amazon RDS HTTP endpoint configuration.</p>
public struct RdsHttpEndpointConfig: Equatable {
    /// <p>AWS Region for RDS HTTP endpoint.</p>
    public let awsRegion: String?
    /// <p>AWS secret store ARN for database credentials.</p>
    public let awsSecretStoreArn: String?
    /// <p>Logical database name.</p>
    public let databaseName: String?
    /// <p>Amazon RDS cluster ARN.</p>
    public let dbClusterIdentifier: String?
    /// <p>Logical schema name.</p>
    public let schema: String?

    public init (
        awsRegion: String? = nil,
        awsSecretStoreArn: String? = nil,
        databaseName: String? = nil,
        dbClusterIdentifier: String? = nil,
        schema: String? = nil
    )
    {
        self.awsRegion = awsRegion
        self.awsSecretStoreArn = awsSecretStoreArn
        self.databaseName = databaseName
        self.dbClusterIdentifier = dbClusterIdentifier
        self.schema = schema
    }
}

extension RelationalDatabaseDataSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rdsHttpEndpointConfig
        case relationalDatabaseSourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rdsHttpEndpointConfig = rdsHttpEndpointConfig {
            try encodeContainer.encode(rdsHttpEndpointConfig, forKey: .rdsHttpEndpointConfig)
        }
        if let relationalDatabaseSourceType = relationalDatabaseSourceType {
            try encodeContainer.encode(relationalDatabaseSourceType.rawValue, forKey: .relationalDatabaseSourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationalDatabaseSourceTypeDecoded = try containerValues.decodeIfPresent(RelationalDatabaseSourceType.self, forKey: .relationalDatabaseSourceType)
        relationalDatabaseSourceType = relationalDatabaseSourceTypeDecoded
        let rdsHttpEndpointConfigDecoded = try containerValues.decodeIfPresent(RdsHttpEndpointConfig.self, forKey: .rdsHttpEndpointConfig)
        rdsHttpEndpointConfig = rdsHttpEndpointConfigDecoded
    }
}

extension RelationalDatabaseDataSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RelationalDatabaseDataSourceConfig(rdsHttpEndpointConfig: \(String(describing: rdsHttpEndpointConfig)), relationalDatabaseSourceType: \(String(describing: relationalDatabaseSourceType)))"}
}

/// <p>Describes a relational database data source configuration.</p>
public struct RelationalDatabaseDataSourceConfig: Equatable {
    /// <p>Amazon RDS HTTP endpoint settings.</p>
    public let rdsHttpEndpointConfig: RdsHttpEndpointConfig?
    /// <p>Source type for the relational database.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>RDS_HTTP_ENDPOINT</b>: The relational database
    ///                source type is an Amazon RDS HTTP endpoint.</p>
    ///             </li>
    ///          </ul>
    public let relationalDatabaseSourceType: RelationalDatabaseSourceType?

    public init (
        rdsHttpEndpointConfig: RdsHttpEndpointConfig? = nil,
        relationalDatabaseSourceType: RelationalDatabaseSourceType? = nil
    )
    {
        self.rdsHttpEndpointConfig = rdsHttpEndpointConfig
        self.relationalDatabaseSourceType = relationalDatabaseSourceType
    }
}

public enum RelationalDatabaseSourceType {
    case rdsHttpEndpoint
    case sdkUnknown(String)
}

extension RelationalDatabaseSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RelationalDatabaseSourceType] {
        return [
            .rdsHttpEndpoint,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rdsHttpEndpoint: return "RDS_HTTP_ENDPOINT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RelationalDatabaseSourceType(rawValue: rawValue) ?? RelationalDatabaseSourceType.sdkUnknown(rawValue)
    }
}

extension Resolver: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachingConfig
        case dataSourceName
        case fieldName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case resolverArn
        case responseMappingTemplate
        case syncConfig
        case typeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let fieldName = fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let resolverArn = resolverArn {
            try encodeContainer.encode(resolverArn, forKey: .resolverArn)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let fieldNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let resolverArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolverArn)
        resolverArn = resolverArnDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension Resolver: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resolver(cachingConfig: \(String(describing: cachingConfig)), dataSourceName: \(String(describing: dataSourceName)), fieldName: \(String(describing: fieldName)), kind: \(String(describing: kind)), pipelineConfig: \(String(describing: pipelineConfig)), requestMappingTemplate: \(String(describing: requestMappingTemplate)), resolverArn: \(String(describing: resolverArn)), responseMappingTemplate: \(String(describing: responseMappingTemplate)), syncConfig: \(String(describing: syncConfig)), typeName: \(String(describing: typeName)))"}
}

/// <p>Describes a resolver.</p>
public struct Resolver: Equatable {
    /// <p>The caching configuration for the resolver.</p>
    public let cachingConfig: CachingConfig?
    /// <p>The resolver data source name.</p>
    public let dataSourceName: String?
    /// <p>The resolver field name.</p>
    public let fieldName: String?
    /// <p>The resolver type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is
    ///                the default resolver type. A UNIT resolver enables you to execute a GraphQL query
    ///                against a single data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PIPELINE</b>: A PIPELINE resolver type. A PIPELINE
    ///                resolver enables you to execute a series of <code>Function</code> in a serial manner.
    ///                You can use a pipeline resolver to execute a GraphQL query against multiple data
    ///                sources.</p>
    ///             </li>
    ///          </ul>
    public let kind: ResolverKind?
    /// <p>The <code>PipelineConfig</code>.</p>
    public let pipelineConfig: PipelineConfig?
    /// <p>The request mapping template.</p>
    public let requestMappingTemplate: String?
    /// <p>The resolver ARN.</p>
    public let resolverArn: String?
    /// <p>The response mapping template.</p>
    public let responseMappingTemplate: String?
    /// <p>The <code>SyncConfig</code> for a resolver attached to a versioned datasource.</p>
    public let syncConfig: SyncConfig?
    /// <p>The resolver type name.</p>
    public let typeName: String?

    public init (
        cachingConfig: CachingConfig? = nil,
        dataSourceName: String? = nil,
        fieldName: String? = nil,
        kind: ResolverKind? = nil,
        pipelineConfig: PipelineConfig? = nil,
        requestMappingTemplate: String? = nil,
        resolverArn: String? = nil,
        responseMappingTemplate: String? = nil,
        syncConfig: SyncConfig? = nil,
        typeName: String? = nil
    )
    {
        self.cachingConfig = cachingConfig
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.resolverArn = resolverArn
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

public enum ResolverKind {
    case pipeline
    case unit
    case sdkUnknown(String)
}

extension ResolverKind : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResolverKind] {
        return [
            .pipeline,
            .unit,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pipeline: return "PIPELINE"
        case .unit: return "UNIT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResolverKind(rawValue: rawValue) ?? ResolverKind.sdkUnknown(rawValue)
    }
}

public enum SchemaStatus {
    case active
    case deleting
    case failed
    case notapplicable
    case processing
    case success
    case sdkUnknown(String)
}

extension SchemaStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SchemaStatus] {
        return [
            .active,
            .deleting,
            .failed,
            .notapplicable,
            .processing,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .notapplicable: return "NOT_APPLICABLE"
        case .processing: return "PROCESSING"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SchemaStatus(rawValue: rawValue) ?? SchemaStatus.sdkUnknown(rawValue)
    }
}

public struct StartSchemaCreationInputBodyMiddleware: Middleware {
    public let id: String = "StartSchemaCreationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSchemaCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSchemaCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSchemaCreationInput>
    public typealias MOutput = OperationOutput<StartSchemaCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSchemaCreationOutputError>
}

extension StartSchemaCreationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSchemaCreationInput(apiId: \(String(describing: apiId)), definition: \(String(describing: definition)))"}
}

extension StartSchemaCreationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition.base64EncodedString(), forKey: .definition)
        }
    }
}

public struct StartSchemaCreationInputHeadersMiddleware: Middleware {
    public let id: String = "StartSchemaCreationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSchemaCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSchemaCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSchemaCreationInput>
    public typealias MOutput = OperationOutput<StartSchemaCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSchemaCreationOutputError>
}

public struct StartSchemaCreationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSchemaCreationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSchemaCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSchemaCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSchemaCreationInput>
    public typealias MOutput = OperationOutput<StartSchemaCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSchemaCreationOutputError>
}

public struct StartSchemaCreationInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The schema definition, in GraphQL schema language format.</p>
    public let definition: Data?

    public init (
        apiId: String? = nil,
        definition: Data? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
    }
}

struct StartSchemaCreationInputBody: Equatable {
    public let definition: Data?
}

extension StartSchemaCreationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definition
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .definition)
        definition = definitionDecoded
    }
}

extension StartSchemaCreationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSchemaCreationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSchemaCreationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSchemaCreationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSchemaCreationOutputResponse(status: \(String(describing: status)))"}
}

extension StartSchemaCreationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSchemaCreationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StartSchemaCreationOutputResponse: Equatable {
    /// <p>The current state of the schema (PROCESSING, FAILED, SUCCESS, or NOT_APPLICABLE). When
    ///          the schema is in the ACTIVE state, you can add data.</p>
    public let status: SchemaStatus?

    public init (
        status: SchemaStatus? = nil
    )
    {
        self.status = status
    }
}

struct StartSchemaCreationOutputResponseBody: Equatable {
    public let status: SchemaStatus?
}

extension StartSchemaCreationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SchemaStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SyncConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conflictDetection
        case conflictHandler
        case lambdaConflictHandlerConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conflictDetection = conflictDetection {
            try encodeContainer.encode(conflictDetection.rawValue, forKey: .conflictDetection)
        }
        if let conflictHandler = conflictHandler {
            try encodeContainer.encode(conflictHandler.rawValue, forKey: .conflictHandler)
        }
        if let lambdaConflictHandlerConfig = lambdaConflictHandlerConfig {
            try encodeContainer.encode(lambdaConflictHandlerConfig, forKey: .lambdaConflictHandlerConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictHandlerDecoded = try containerValues.decodeIfPresent(ConflictHandlerType.self, forKey: .conflictHandler)
        conflictHandler = conflictHandlerDecoded
        let conflictDetectionDecoded = try containerValues.decodeIfPresent(ConflictDetectionType.self, forKey: .conflictDetection)
        conflictDetection = conflictDetectionDecoded
        let lambdaConflictHandlerConfigDecoded = try containerValues.decodeIfPresent(LambdaConflictHandlerConfig.self, forKey: .lambdaConflictHandlerConfig)
        lambdaConflictHandlerConfig = lambdaConflictHandlerConfigDecoded
    }
}

extension SyncConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SyncConfig(conflictDetection: \(String(describing: conflictDetection)), conflictHandler: \(String(describing: conflictHandler)), lambdaConflictHandlerConfig: \(String(describing: lambdaConflictHandlerConfig)))"}
}

/// <p>Describes a Sync configuration for a resolver.</p>
///          <p>Contains information on which Conflict Detection as well as Resolution strategy should
///          be performed when the resolver is invoked.</p>
public struct SyncConfig: Equatable {
    /// <p>The Conflict Detection strategy to use.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>VERSION</b>: Detect conflicts based on object
    ///                versions for this resolver.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>NONE</b>: Do not detect conflicts when executing
    ///                this resolver.</p>
    ///             </li>
    ///          </ul>
    public let conflictDetection: ConflictDetectionType?
    /// <p>The Conflict Resolution strategy to perform in the event of a conflict.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>OPTIMISTIC_CONCURRENCY</b>: Resolve conflicts by
    ///                rejecting mutations when versions do not match the latest version at the
    ///                server.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>AUTOMERGE</b>: Resolve conflicts with the
    ///                Automerge conflict resolution strategy.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>LAMBDA</b>: Resolve conflicts with a Lambda
    ///                function supplied in the LambdaConflictHandlerConfig.</p>
    ///             </li>
    ///          </ul>
    public let conflictHandler: ConflictHandlerType?
    /// <p>The <code>LambdaConflictHandlerConfig</code> when configuring LAMBDA as the Conflict
    ///          Handler.</p>
    public let lambdaConflictHandlerConfig: LambdaConflictHandlerConfig?

    public init (
        conflictDetection: ConflictDetectionType? = nil,
        conflictHandler: ConflictHandlerType? = nil,
        lambdaConflictHandlerConfig: LambdaConflictHandlerConfig? = nil
    )
    {
        self.conflictDetection = conflictDetection
        self.conflictHandler = conflictHandler
        self.lambdaConflictHandlerConfig = lambdaConflictHandlerConfig
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The <code>GraphqlApi</code> ARN.</p>
    public let resourceArn: String?
    /// <p>A <code>TagMap</code> object.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension `Type`: CustomDebugStringConvertible {
    public var debugDescription: String {
        "`Type`(arn: \(String(describing: arn)), definition: \(String(describing: definition)), description: \(String(describing: description)), format: \(String(describing: format)), name: \(String(describing: name)))"}
}

/// <p>Describes a type.</p>
public struct `Type`: Equatable {
    /// <p>The type ARN.</p>
    public let arn: String?
    /// <p>The type definition.</p>
    public let definition: String?
    /// <p>The type description.</p>
    public let description: String?
    /// <p>The type format: SDL or JSON.</p>
    public let format: TypeDefinitionFormat?
    /// <p>The type name.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        definition: String? = nil,
        description: String? = nil,
        format: TypeDefinitionFormat? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.definition = definition
        self.description = description
        self.format = format
        self.name = name
    }
}

public enum TypeDefinitionFormat {
    case json
    case sdl
    case sdkUnknown(String)
}

extension TypeDefinitionFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TypeDefinitionFormat] {
        return [
            .json,
            .sdl,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .json: return "JSON"
        case .sdl: return "SDL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TypeDefinitionFormat(rawValue: rawValue) ?? TypeDefinitionFormat.sdkUnknown(rawValue)
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to perform this operation.</p>
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The <code>GraphqlApi</code> ARN.</p>
    public let resourceArn: String?
    /// <p>A list of <code>TagKey</code> objects.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApiCacheInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApiCacheInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiCacheInput>
    public typealias MOutput = OperationOutput<UpdateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiCacheOutputError>
}

extension UpdateApiCacheInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiCacheInput(apiCachingBehavior: \(String(describing: apiCachingBehavior)), apiId: \(String(describing: apiId)), ttl: \(String(describing: ttl)), type: \(String(describing: type)))"}
}

extension UpdateApiCacheInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiCachingBehavior
        case ttl
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCachingBehavior = apiCachingBehavior {
            try encodeContainer.encode(apiCachingBehavior.rawValue, forKey: .apiCachingBehavior)
        }
        if ttl != 0 {
            try encodeContainer.encode(ttl, forKey: .ttl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateApiCacheInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApiCacheInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiCacheInput>
    public typealias MOutput = OperationOutput<UpdateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiCacheOutputError>
}

public struct UpdateApiCacheInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApiCacheInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiCacheInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiCacheOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiCacheInput>
    public typealias MOutput = OperationOutput<UpdateApiCacheOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiCacheOutputError>
}

/// <p>Represents the input of a <code>UpdateApiCache</code> operation.</p>
public struct UpdateApiCacheInput: Equatable {
    /// <p>Caching behavior.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>FULL_REQUEST_CACHING</b>: All requests are fully
    ///                cached.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PER_RESOLVER_CACHING</b>: Individual resolvers
    ///                that you specify are cached.</p>
    ///             </li>
    ///          </ul>
    public let apiCachingBehavior: ApiCachingBehavior?
    /// <p>The GraphQL API Id.</p>
    public let apiId: String?
    /// <p>TTL in seconds for cache entries.</p>
    ///          <p>Valid values are between 1 and 3600 seconds.</p>
    public let ttl: Int
    /// <p>The cache instance type. Valid values are </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SMALL</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MEDIUM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>XLARGE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_2X</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_4X</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_8X</code> (not available in all regions)</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LARGE_12X</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Historically, instance types were identified by an EC2-style value. As of July 2020, this is deprecated, and the generic identifiers above should be used.</p>
    ///          <p>The following legacy instance types are available, but their use is discouraged:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>T2_SMALL</b>: A t2.small instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>T2_MEDIUM</b>: A t2.medium instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_LARGE</b>: A r4.large instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_XLARGE</b>: A r4.xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_2XLARGE</b>: A r4.2xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_4XLARGE</b>: A r4.4xlarge instance type.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>R4_8XLARGE</b>: A r4.8xlarge instance type.</p>
    ///             </li>
    ///          </ul>
    public let type: ApiCacheType?

    public init (
        apiCachingBehavior: ApiCachingBehavior? = nil,
        apiId: String? = nil,
        ttl: Int = 0,
        type: ApiCacheType? = nil
    )
    {
        self.apiCachingBehavior = apiCachingBehavior
        self.apiId = apiId
        self.ttl = ttl
        self.type = type
    }
}

struct UpdateApiCacheInputBody: Equatable {
    public let ttl: Int
    public let apiCachingBehavior: ApiCachingBehavior?
    public let type: ApiCacheType?
}

extension UpdateApiCacheInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiCachingBehavior
        case ttl
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ttlDecoded = try containerValues.decode(Int.self, forKey: .ttl)
        ttl = ttlDecoded
        let apiCachingBehaviorDecoded = try containerValues.decodeIfPresent(ApiCachingBehavior.self, forKey: .apiCachingBehavior)
        apiCachingBehavior = apiCachingBehaviorDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ApiCacheType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateApiCacheOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiCacheOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiCacheOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiCacheOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiCacheOutputResponse(apiCache: \(String(describing: apiCache)))"}
}

extension UpdateApiCacheOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApiCacheOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiCache = output.apiCache
        } else {
            self.apiCache = nil
        }
    }
}

/// <p>Represents the output of a <code>UpdateApiCache</code> operation.</p>
public struct UpdateApiCacheOutputResponse: Equatable {
    /// <p>The <code>ApiCache</code> object.</p>
    public let apiCache: ApiCache?

    public init (
        apiCache: ApiCache? = nil
    )
    {
        self.apiCache = apiCache
    }
}

struct UpdateApiCacheOutputResponseBody: Equatable {
    public let apiCache: ApiCache?
}

extension UpdateApiCacheOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiCache
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCacheDecoded = try containerValues.decodeIfPresent(ApiCache.self, forKey: .apiCache)
        apiCache = apiCacheDecoded
    }
}

public struct UpdateApiKeyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApiKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiKeyOutputError>
}

extension UpdateApiKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiKeyInput(apiId: \(String(describing: apiId)), description: \(String(describing: description)), expires: \(String(describing: expires)), id: \(String(describing: id)))"}
}

extension UpdateApiKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case expires
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if expires != 0 {
            try encodeContainer.encode(expires, forKey: .expires)
        }
    }
}

public struct UpdateApiKeyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApiKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiKeyOutputError>
}

public struct UpdateApiKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApiKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiKeyInput>
    public typealias MOutput = OperationOutput<UpdateApiKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiKeyOutputError>
}

public struct UpdateApiKeyInput: Equatable {
    /// <p>The ID for the GraphQL API.</p>
    public let apiId: String?
    /// <p>A description of the purpose of the API key.</p>
    public let description: String?
    /// <p>The time from update time after which the API key expires. The date is represented as
    ///          seconds since the epoch. For more information, see .</p>
    public let expires: Int
    /// <p>The API key ID.</p>
    public let id: String?

    public init (
        apiId: String? = nil,
        description: String? = nil,
        expires: Int = 0,
        id: String? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.expires = expires
        self.id = id
    }
}

struct UpdateApiKeyInputBody: Equatable {
    public let description: String?
    public let expires: Int
}

extension UpdateApiKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case expires
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let expiresDecoded = try containerValues.decode(Int.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension UpdateApiKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ApiKeyValidityOutOfBoundsException" : self = .apiKeyValidityOutOfBoundsException(try ApiKeyValidityOutOfBoundsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiKeyOutputError: Equatable {
    case apiKeyValidityOutOfBoundsException(ApiKeyValidityOutOfBoundsException)
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiKeyOutputResponse(apiKey: \(String(describing: apiKey)))"}
}

extension UpdateApiKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiKey = output.apiKey
        } else {
            self.apiKey = nil
        }
    }
}

public struct UpdateApiKeyOutputResponse: Equatable {
    /// <p>The API key.</p>
    public let apiKey: ApiKey?

    public init (
        apiKey: ApiKey? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct UpdateApiKeyOutputResponseBody: Equatable {
    public let apiKey: ApiKey?
}

extension UpdateApiKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiKey
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(ApiKey.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

public struct UpdateDataSourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

extension UpdateDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSourceInput(apiId: \(String(describing: apiId)), description: \(String(describing: description)), dynamodbConfig: \(String(describing: dynamodbConfig)), elasticsearchConfig: \(String(describing: elasticsearchConfig)), httpConfig: \(String(describing: httpConfig)), lambdaConfig: \(String(describing: lambdaConfig)), name: \(String(describing: name)), relationalDatabaseConfig: \(String(describing: relationalDatabaseConfig)), serviceRoleArn: \(String(describing: serviceRoleArn)), type: \(String(describing: type)))"}
}

extension UpdateDataSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dynamodbConfig = dynamodbConfig {
            try encodeContainer.encode(dynamodbConfig, forKey: .dynamodbConfig)
        }
        if let elasticsearchConfig = elasticsearchConfig {
            try encodeContainer.encode(elasticsearchConfig, forKey: .elasticsearchConfig)
        }
        if let httpConfig = httpConfig {
            try encodeContainer.encode(httpConfig, forKey: .httpConfig)
        }
        if let lambdaConfig = lambdaConfig {
            try encodeContainer.encode(lambdaConfig, forKey: .lambdaConfig)
        }
        if let relationalDatabaseConfig = relationalDatabaseConfig {
            try encodeContainer.encode(relationalDatabaseConfig, forKey: .relationalDatabaseConfig)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDataSourceInput>
    public typealias MOutput = OperationOutput<UpdateDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDataSourceOutputError>
}

public struct UpdateDataSourceInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The new description for the data source.</p>
    public let description: String?
    /// <p>The new Amazon DynamoDB configuration.</p>
    public let dynamodbConfig: DynamodbDataSourceConfig?
    /// <p>The new Elasticsearch Service configuration.</p>
    public let elasticsearchConfig: ElasticsearchDataSourceConfig?
    /// <p>The new HTTP endpoint configuration.</p>
    public let httpConfig: HttpDataSourceConfig?
    /// <p>The new AWS Lambda configuration.</p>
    public let lambdaConfig: LambdaDataSourceConfig?
    /// <p>The new name for the data source.</p>
    public let name: String?
    /// <p>The new relational database configuration.</p>
    public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
    /// <p>The new service role ARN for the data source.</p>
    public let serviceRoleArn: String?
    /// <p>The new data source type.</p>
    public let type: DataSourceType?

    public init (
        apiId: String? = nil,
        description: String? = nil,
        dynamodbConfig: DynamodbDataSourceConfig? = nil,
        elasticsearchConfig: ElasticsearchDataSourceConfig? = nil,
        httpConfig: HttpDataSourceConfig? = nil,
        lambdaConfig: LambdaDataSourceConfig? = nil,
        name: String? = nil,
        relationalDatabaseConfig: RelationalDatabaseDataSourceConfig? = nil,
        serviceRoleArn: String? = nil,
        type: DataSourceType? = nil
    )
    {
        self.apiId = apiId
        self.description = description
        self.dynamodbConfig = dynamodbConfig
        self.elasticsearchConfig = elasticsearchConfig
        self.httpConfig = httpConfig
        self.lambdaConfig = lambdaConfig
        self.name = name
        self.relationalDatabaseConfig = relationalDatabaseConfig
        self.serviceRoleArn = serviceRoleArn
        self.type = type
    }
}

struct UpdateDataSourceInputBody: Equatable {
    public let description: String?
    public let type: DataSourceType?
    public let serviceRoleArn: String?
    public let dynamodbConfig: DynamodbDataSourceConfig?
    public let lambdaConfig: LambdaDataSourceConfig?
    public let elasticsearchConfig: ElasticsearchDataSourceConfig?
    public let httpConfig: HttpDataSourceConfig?
    public let relationalDatabaseConfig: RelationalDatabaseDataSourceConfig?
}

extension UpdateDataSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case dynamodbConfig
        case elasticsearchConfig
        case httpConfig
        case lambdaConfig
        case relationalDatabaseConfig
        case serviceRoleArn
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DataSourceType.self, forKey: .type)
        type = typeDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let dynamodbConfigDecoded = try containerValues.decodeIfPresent(DynamodbDataSourceConfig.self, forKey: .dynamodbConfig)
        dynamodbConfig = dynamodbConfigDecoded
        let lambdaConfigDecoded = try containerValues.decodeIfPresent(LambdaDataSourceConfig.self, forKey: .lambdaConfig)
        lambdaConfig = lambdaConfigDecoded
        let elasticsearchConfigDecoded = try containerValues.decodeIfPresent(ElasticsearchDataSourceConfig.self, forKey: .elasticsearchConfig)
        elasticsearchConfig = elasticsearchConfigDecoded
        let httpConfigDecoded = try containerValues.decodeIfPresent(HttpDataSourceConfig.self, forKey: .httpConfig)
        httpConfig = httpConfigDecoded
        let relationalDatabaseConfigDecoded = try containerValues.decodeIfPresent(RelationalDatabaseDataSourceConfig.self, forKey: .relationalDatabaseConfig)
        relationalDatabaseConfig = relationalDatabaseConfigDecoded
    }
}

extension UpdateDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDataSourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDataSourceOutputResponse(dataSource: \(String(describing: dataSource)))"}
}

extension UpdateDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dataSource = output.dataSource
        } else {
            self.dataSource = nil
        }
    }
}

public struct UpdateDataSourceOutputResponse: Equatable {
    /// <p>The updated <code>DataSource</code> object.</p>
    public let dataSource: DataSource?

    public init (
        dataSource: DataSource? = nil
    )
    {
        self.dataSource = dataSource
    }
}

struct UpdateDataSourceOutputResponseBody: Equatable {
    public let dataSource: DataSource?
}

extension UpdateDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSource
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

public struct UpdateFunctionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionOutputError>
}

extension UpdateFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionInput(apiId: \(String(describing: apiId)), dataSourceName: \(String(describing: dataSourceName)), description: \(String(describing: description)), functionId: \(String(describing: functionId)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), requestMappingTemplate: \(String(describing: requestMappingTemplate)), responseMappingTemplate: \(String(describing: responseMappingTemplate)), syncConfig: \(String(describing: syncConfig)))"}
}

extension UpdateFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

public struct UpdateFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInput: Equatable {
    /// <p>The GraphQL API ID.</p>
    public let apiId: String?
    /// <p>The <code>Function</code>
    ///             <code>DataSource</code> name.</p>
    public let dataSourceName: String?
    /// <p>The <code>Function</code> description.</p>
    public let description: String?
    /// <p>The function ID.</p>
    public let functionId: String?
    /// <p>The <code>version</code> of the request mapping template. Currently the supported value
    ///          is 2018-05-29. </p>
    public let functionVersion: String?
    /// <p>The <code>Function</code> name.</p>
    public let name: String?
    /// <p>The <code>Function</code> request mapping template. Functions support only the
    ///          2018-05-29 version of the request mapping template.</p>
    public let requestMappingTemplate: String?
    /// <p>The <code>Function</code> request mapping template. </p>
    public let responseMappingTemplate: String?
    /// <p>Describes a Sync configuration for a resolver.</p>
    ///          <p>Contains information on which Conflict Detection as well as Resolution strategy should
    ///          be performed when the resolver is invoked.</p>
    public let syncConfig: SyncConfig?

    public init (
        apiId: String? = nil,
        dataSourceName: String? = nil,
        description: String? = nil,
        functionId: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        requestMappingTemplate: String? = nil,
        responseMappingTemplate: String? = nil,
        syncConfig: SyncConfig? = nil
    )
    {
        self.apiId = apiId
        self.dataSourceName = dataSourceName
        self.description = description
        self.functionId = functionId
        self.functionVersion = functionVersion
        self.name = name
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
    }
}

struct UpdateFunctionInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let dataSourceName: String?
    public let requestMappingTemplate: String?
    public let responseMappingTemplate: String?
    public let functionVersion: String?
    public let syncConfig: SyncConfig?
}

extension UpdateFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSourceName
        case description
        case functionVersion
        case name
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
    }
}

extension UpdateFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionOutputResponse(functionConfiguration: \(String(describing: functionConfiguration)))"}
}

extension UpdateFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.functionConfiguration = output.functionConfiguration
        } else {
            self.functionConfiguration = nil
        }
    }
}

public struct UpdateFunctionOutputResponse: Equatable {
    /// <p>The <code>Function</code> object.</p>
    public let functionConfiguration: FunctionConfiguration?

    public init (
        functionConfiguration: FunctionConfiguration? = nil
    )
    {
        self.functionConfiguration = functionConfiguration
    }
}

struct UpdateFunctionOutputResponseBody: Equatable {
    public let functionConfiguration: FunctionConfiguration?
}

extension UpdateFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
    }
}

public struct UpdateGraphqlApiInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGraphqlApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGraphqlApiInput>
    public typealias MOutput = OperationOutput<UpdateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGraphqlApiOutputError>
}

extension UpdateGraphqlApiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGraphqlApiInput(additionalAuthenticationProviders: \(String(describing: additionalAuthenticationProviders)), apiId: \(String(describing: apiId)), authenticationType: \(String(describing: authenticationType)), logConfig: \(String(describing: logConfig)), name: \(String(describing: name)), openIDConnectConfig: \(String(describing: openIDConnectConfig)), userPoolConfig: \(String(describing: userPoolConfig)), xrayEnabled: \(String(describing: xrayEnabled)))"}
}

extension UpdateGraphqlApiInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case logConfig
        case name
        case openIDConnectConfig
        case userPoolConfig
        case xrayEnabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalAuthenticationProviders = additionalAuthenticationProviders {
            var additionalAuthenticationProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalAuthenticationProviders)
            for additionalauthenticationproviders0 in additionalAuthenticationProviders {
                try additionalAuthenticationProvidersContainer.encode(additionalauthenticationproviders0)
            }
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let logConfig = logConfig {
            try encodeContainer.encode(logConfig, forKey: .logConfig)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let openIDConnectConfig = openIDConnectConfig {
            try encodeContainer.encode(openIDConnectConfig, forKey: .openIDConnectConfig)
        }
        if let userPoolConfig = userPoolConfig {
            try encodeContainer.encode(userPoolConfig, forKey: .userPoolConfig)
        }
        if xrayEnabled != false {
            try encodeContainer.encode(xrayEnabled, forKey: .xrayEnabled)
        }
    }
}

public struct UpdateGraphqlApiInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGraphqlApiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGraphqlApiInput>
    public typealias MOutput = OperationOutput<UpdateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGraphqlApiOutputError>
}

public struct UpdateGraphqlApiInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGraphqlApiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGraphqlApiInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGraphqlApiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGraphqlApiInput>
    public typealias MOutput = OperationOutput<UpdateGraphqlApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGraphqlApiOutputError>
}

public struct UpdateGraphqlApiInput: Equatable {
    /// <p>A list of additional authentication providers for the <code>GraphqlApi</code>
    ///          API.</p>
    public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The new authentication type for the <code>GraphqlApi</code> object.</p>
    public let authenticationType: AuthenticationType?
    /// <p>The Amazon CloudWatch Logs configuration for the <code>GraphqlApi</code> object.</p>
    public let logConfig: LogConfig?
    /// <p>The new name for the <code>GraphqlApi</code> object.</p>
    public let name: String?
    /// <p>The OpenID Connect configuration for the <code>GraphqlApi</code> object.</p>
    public let openIDConnectConfig: OpenIDConnectConfig?
    /// <p>The new Amazon Cognito user pool configuration for the <code>GraphqlApi</code>
    ///          object.</p>
    public let userPoolConfig: UserPoolConfig?
    /// <p>A flag indicating whether to enable X-Ray tracing for the
    ///          <code>GraphqlApi</code>.</p>
    public let xrayEnabled: Bool

    public init (
        additionalAuthenticationProviders: [AdditionalAuthenticationProvider]? = nil,
        apiId: String? = nil,
        authenticationType: AuthenticationType? = nil,
        logConfig: LogConfig? = nil,
        name: String? = nil,
        openIDConnectConfig: OpenIDConnectConfig? = nil,
        userPoolConfig: UserPoolConfig? = nil,
        xrayEnabled: Bool = false
    )
    {
        self.additionalAuthenticationProviders = additionalAuthenticationProviders
        self.apiId = apiId
        self.authenticationType = authenticationType
        self.logConfig = logConfig
        self.name = name
        self.openIDConnectConfig = openIDConnectConfig
        self.userPoolConfig = userPoolConfig
        self.xrayEnabled = xrayEnabled
    }
}

struct UpdateGraphqlApiInputBody: Equatable {
    public let name: String?
    public let logConfig: LogConfig?
    public let authenticationType: AuthenticationType?
    public let userPoolConfig: UserPoolConfig?
    public let openIDConnectConfig: OpenIDConnectConfig?
    public let additionalAuthenticationProviders: [AdditionalAuthenticationProvider]?
    public let xrayEnabled: Bool
}

extension UpdateGraphqlApiInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case additionalAuthenticationProviders
        case authenticationType
        case logConfig
        case name
        case openIDConnectConfig
        case userPoolConfig
        case xrayEnabled
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let logConfigDecoded = try containerValues.decodeIfPresent(LogConfig.self, forKey: .logConfig)
        logConfig = logConfigDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let userPoolConfigDecoded = try containerValues.decodeIfPresent(UserPoolConfig.self, forKey: .userPoolConfig)
        userPoolConfig = userPoolConfigDecoded
        let openIDConnectConfigDecoded = try containerValues.decodeIfPresent(OpenIDConnectConfig.self, forKey: .openIDConnectConfig)
        openIDConnectConfig = openIDConnectConfigDecoded
        let additionalAuthenticationProvidersContainer = try containerValues.decodeIfPresent([AdditionalAuthenticationProvider?].self, forKey: .additionalAuthenticationProviders)
        var additionalAuthenticationProvidersDecoded0:[AdditionalAuthenticationProvider]? = nil
        if let additionalAuthenticationProvidersContainer = additionalAuthenticationProvidersContainer {
            additionalAuthenticationProvidersDecoded0 = [AdditionalAuthenticationProvider]()
            for structure0 in additionalAuthenticationProvidersContainer {
                if let structure0 = structure0 {
                    additionalAuthenticationProvidersDecoded0?.append(structure0)
                }
            }
        }
        additionalAuthenticationProviders = additionalAuthenticationProvidersDecoded0
        let xrayEnabledDecoded = try containerValues.decode(Bool.self, forKey: .xrayEnabled)
        xrayEnabled = xrayEnabledDecoded
    }
}

extension UpdateGraphqlApiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGraphqlApiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGraphqlApiOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGraphqlApiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGraphqlApiOutputResponse(graphqlApi: \(String(describing: graphqlApi)))"}
}

extension UpdateGraphqlApiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGraphqlApiOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.graphqlApi = output.graphqlApi
        } else {
            self.graphqlApi = nil
        }
    }
}

public struct UpdateGraphqlApiOutputResponse: Equatable {
    /// <p>The updated <code>GraphqlApi</code> object.</p>
    public let graphqlApi: GraphqlApi?

    public init (
        graphqlApi: GraphqlApi? = nil
    )
    {
        self.graphqlApi = graphqlApi
    }
}

struct UpdateGraphqlApiOutputResponseBody: Equatable {
    public let graphqlApi: GraphqlApi?
}

extension UpdateGraphqlApiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case graphqlApi
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let graphqlApiDecoded = try containerValues.decodeIfPresent(GraphqlApi.self, forKey: .graphqlApi)
        graphqlApi = graphqlApiDecoded
    }
}

public struct UpdateResolverInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResolverInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverInput>
    public typealias MOutput = OperationOutput<UpdateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverOutputError>
}

extension UpdateResolverInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResolverInput(apiId: \(String(describing: apiId)), cachingConfig: \(String(describing: cachingConfig)), dataSourceName: \(String(describing: dataSourceName)), fieldName: \(String(describing: fieldName)), kind: \(String(describing: kind)), pipelineConfig: \(String(describing: pipelineConfig)), requestMappingTemplate: \(String(describing: requestMappingTemplate)), responseMappingTemplate: \(String(describing: responseMappingTemplate)), syncConfig: \(String(describing: syncConfig)), typeName: \(String(describing: typeName)))"}
}

extension UpdateResolverInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachingConfig
        case dataSourceName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cachingConfig = cachingConfig {
            try encodeContainer.encode(cachingConfig, forKey: .cachingConfig)
        }
        if let dataSourceName = dataSourceName {
            try encodeContainer.encode(dataSourceName, forKey: .dataSourceName)
        }
        if let kind = kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let pipelineConfig = pipelineConfig {
            try encodeContainer.encode(pipelineConfig, forKey: .pipelineConfig)
        }
        if let requestMappingTemplate = requestMappingTemplate {
            try encodeContainer.encode(requestMappingTemplate, forKey: .requestMappingTemplate)
        }
        if let responseMappingTemplate = responseMappingTemplate {
            try encodeContainer.encode(responseMappingTemplate, forKey: .responseMappingTemplate)
        }
        if let syncConfig = syncConfig {
            try encodeContainer.encode(syncConfig, forKey: .syncConfig)
        }
    }
}

public struct UpdateResolverInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResolverInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverInput>
    public typealias MOutput = OperationOutput<UpdateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverOutputError>
}

public struct UpdateResolverInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResolverInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResolverInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResolverOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResolverInput>
    public typealias MOutput = OperationOutput<UpdateResolverOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResolverOutputError>
}

public struct UpdateResolverInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The caching configuration for the resolver.</p>
    public let cachingConfig: CachingConfig?
    /// <p>The new data source name.</p>
    public let dataSourceName: String?
    /// <p>The new field name.</p>
    public let fieldName: String?
    /// <p>The resolver type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>UNIT</b>: A UNIT resolver type. A UNIT resolver is
    ///                the default resolver type. A UNIT resolver enables you to execute a GraphQL query
    ///                against a single data source.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PIPELINE</b>: A PIPELINE resolver type. A PIPELINE
    ///                resolver enables you to execute a series of <code>Function</code> in a serial manner.
    ///                You can use a pipeline resolver to execute a GraphQL query against multiple data
    ///                sources.</p>
    ///             </li>
    ///          </ul>
    public let kind: ResolverKind?
    /// <p>The <code>PipelineConfig</code>.</p>
    public let pipelineConfig: PipelineConfig?
    /// <p>The new request mapping template.</p>
    ///          <p>A resolver uses a request mapping template to convert a GraphQL expression into a format
    ///          that a data source can understand. Mapping templates are written in Apache Velocity
    ///          Template Language (VTL).</p>
    ///          <p>VTL request mapping templates are optional when using a Lambda data source. For all
    ///          other data sources, VTL request and response mapping templates are required.</p>
    public let requestMappingTemplate: String?
    /// <p>The new response mapping template.</p>
    public let responseMappingTemplate: String?
    /// <p>The <code>SyncConfig</code> for a resolver attached to a versioned datasource.</p>
    public let syncConfig: SyncConfig?
    /// <p>The new type name.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        cachingConfig: CachingConfig? = nil,
        dataSourceName: String? = nil,
        fieldName: String? = nil,
        kind: ResolverKind? = nil,
        pipelineConfig: PipelineConfig? = nil,
        requestMappingTemplate: String? = nil,
        responseMappingTemplate: String? = nil,
        syncConfig: SyncConfig? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.cachingConfig = cachingConfig
        self.dataSourceName = dataSourceName
        self.fieldName = fieldName
        self.kind = kind
        self.pipelineConfig = pipelineConfig
        self.requestMappingTemplate = requestMappingTemplate
        self.responseMappingTemplate = responseMappingTemplate
        self.syncConfig = syncConfig
        self.typeName = typeName
    }
}

struct UpdateResolverInputBody: Equatable {
    public let dataSourceName: String?
    public let requestMappingTemplate: String?
    public let responseMappingTemplate: String?
    public let kind: ResolverKind?
    public let pipelineConfig: PipelineConfig?
    public let syncConfig: SyncConfig?
    public let cachingConfig: CachingConfig?
}

extension UpdateResolverInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachingConfig
        case dataSourceName
        case kind
        case pipelineConfig
        case requestMappingTemplate
        case responseMappingTemplate
        case syncConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceName)
        dataSourceName = dataSourceNameDecoded
        let requestMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestMappingTemplate)
        requestMappingTemplate = requestMappingTemplateDecoded
        let responseMappingTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseMappingTemplate)
        responseMappingTemplate = responseMappingTemplateDecoded
        let kindDecoded = try containerValues.decodeIfPresent(ResolverKind.self, forKey: .kind)
        kind = kindDecoded
        let pipelineConfigDecoded = try containerValues.decodeIfPresent(PipelineConfig.self, forKey: .pipelineConfig)
        pipelineConfig = pipelineConfigDecoded
        let syncConfigDecoded = try containerValues.decodeIfPresent(SyncConfig.self, forKey: .syncConfig)
        syncConfig = syncConfigDecoded
        let cachingConfigDecoded = try containerValues.decodeIfPresent(CachingConfig.self, forKey: .cachingConfig)
        cachingConfig = cachingConfigDecoded
    }
}

extension UpdateResolverOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResolverOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResolverOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResolverOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResolverOutputResponse(resolver: \(String(describing: resolver)))"}
}

extension UpdateResolverOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateResolverOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resolver = output.resolver
        } else {
            self.resolver = nil
        }
    }
}

public struct UpdateResolverOutputResponse: Equatable {
    /// <p>The updated <code>Resolver</code> object.</p>
    public let resolver: Resolver?

    public init (
        resolver: Resolver? = nil
    )
    {
        self.resolver = resolver
    }
}

struct UpdateResolverOutputResponseBody: Equatable {
    public let resolver: Resolver?
}

extension UpdateResolverOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resolver
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resolverDecoded = try containerValues.decodeIfPresent(Resolver.self, forKey: .resolver)
        resolver = resolverDecoded
    }
}

public struct UpdateTypeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTypeInput>
    public typealias MOutput = OperationOutput<UpdateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTypeOutputError>
}

extension UpdateTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTypeInput(apiId: \(String(describing: apiId)), definition: \(String(describing: definition)), format: \(String(describing: format)), typeName: \(String(describing: typeName)))"}
}

extension UpdateTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition
        case format
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
    }
}

public struct UpdateTypeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTypeInput>
    public typealias MOutput = OperationOutput<UpdateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTypeOutputError>
}

public struct UpdateTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTypeInput>
    public typealias MOutput = OperationOutput<UpdateTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTypeOutputError>
}

public struct UpdateTypeInput: Equatable {
    /// <p>The API ID.</p>
    public let apiId: String?
    /// <p>The new definition.</p>
    public let definition: String?
    /// <p>The new type format: SDL or JSON.</p>
    public let format: TypeDefinitionFormat?
    /// <p>The new type name.</p>
    public let typeName: String?

    public init (
        apiId: String? = nil,
        definition: String? = nil,
        format: TypeDefinitionFormat? = nil,
        typeName: String? = nil
    )
    {
        self.apiId = apiId
        self.definition = definition
        self.format = format
        self.typeName = typeName
    }
}

struct UpdateTypeInputBody: Equatable {
    public let definition: String?
    public let format: TypeDefinitionFormat?
}

extension UpdateTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case definition
        case format
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}

extension UpdateTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTypeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case concurrentModificationException(ConcurrentModificationException)
    case internalFailureException(InternalFailureException)
    case notFoundException(NotFoundException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTypeOutputResponse(type: \(String(describing: type)))"}
}

extension UpdateTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.type = output.type
        } else {
            self.type = nil
        }
    }
}

public struct UpdateTypeOutputResponse: Equatable {
    /// <p>The updated <code>Type</code> object.</p>
    public let type: `Type`?

    public init (
        type: `Type`? = nil
    )
    {
        self.type = type
    }
}

struct UpdateTypeOutputResponseBody: Equatable {
    public let type: `Type`?
}

extension UpdateTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension UserPoolConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appIdClientRegex
        case awsRegion
        case defaultAction
        case userPoolId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIdClientRegex = appIdClientRegex {
            try encodeContainer.encode(appIdClientRegex, forKey: .appIdClientRegex)
        }
        if let awsRegion = awsRegion {
            try encodeContainer.encode(awsRegion, forKey: .awsRegion)
        }
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction.rawValue, forKey: .defaultAction)
        }
        if let userPoolId = userPoolId {
            try encodeContainer.encode(userPoolId, forKey: .userPoolId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolId)
        userPoolId = userPoolIdDecoded
        let awsRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsRegion)
        awsRegion = awsRegionDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(DefaultAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let appIdClientRegexDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appIdClientRegex)
        appIdClientRegex = appIdClientRegexDecoded
    }
}

extension UserPoolConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPoolConfig(appIdClientRegex: \(String(describing: appIdClientRegex)), awsRegion: \(String(describing: awsRegion)), defaultAction: \(String(describing: defaultAction)), userPoolId: \(String(describing: userPoolId)))"}
}

/// <p>Describes an Amazon Cognito user pool configuration.</p>
public struct UserPoolConfig: Equatable {
    /// <p>A regular expression for validating the incoming Amazon Cognito user pool app client
    ///          ID.</p>
    public let appIdClientRegex: String?
    /// <p>The AWS Region in which the user pool was created.</p>
    public let awsRegion: String?
    /// <p>The action that you want your GraphQL API to take when a request that uses Amazon
    ///          Cognito user pool authentication doesn't match the Amazon Cognito user pool
    ///          configuration.</p>
    public let defaultAction: DefaultAction?
    /// <p>The user pool ID.</p>
    public let userPoolId: String?

    public init (
        appIdClientRegex: String? = nil,
        awsRegion: String? = nil,
        defaultAction: DefaultAction? = nil,
        userPoolId: String? = nil
    )
    {
        self.appIdClientRegex = appIdClientRegex
        self.awsRegion = awsRegion
        self.defaultAction = defaultAction
        self.userPoolId = userPoolId
    }
}

extension `Type`: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case definition
        case description
        case format
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .definition)
        definition = definitionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(TypeDefinitionFormat.self, forKey: .format)
        format = formatDecoded
    }
}
