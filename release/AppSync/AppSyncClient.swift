// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class AppSyncClient {
    let client: SdkHttpClient
    let config: AppSyncClientConfiguration
    let serviceName = "AppSync"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: AppSyncClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class AppSyncClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> AppSyncClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try AppSyncClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension AppSyncClient: AppSyncClientProtocol {
    /// <p>Creates a cache for the GraphQL API.</p>
    public func createApiCache(input: CreateApiCacheInput, completion: @escaping (SdkResult<CreateApiCacheOutputResponse, CreateApiCacheOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/ApiCaches"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createApiCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateApiCacheInput, CreateApiCacheOutputResponse, CreateApiCacheOutputError>(id: "createApiCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateApiCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateApiCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateApiCacheInput, CreateApiCacheOutputResponse, CreateApiCacheOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateApiCacheInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a unique key that you can distribute to clients who are executing your
    ///          API.</p>
    public func createApiKey(input: CreateApiKeyInput, completion: @escaping (SdkResult<CreateApiKeyOutputResponse, CreateApiKeyOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/apikeys"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createApiKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateApiKeyInput, CreateApiKeyOutputResponse, CreateApiKeyOutputError>(id: "createApiKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateApiKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateApiKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateApiKeyInput, CreateApiKeyOutputResponse, CreateApiKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateApiKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a <code>DataSource</code> object.</p>
    public func createDataSource(input: CreateDataSourceInput, completion: @escaping (SdkResult<CreateDataSourceOutputResponse, CreateDataSourceOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/datasources"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDataSource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDataSourceInput, CreateDataSourceOutputResponse, CreateDataSourceOutputError>(id: "createDataSource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDataSourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDataSourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDataSourceInput, CreateDataSourceOutputResponse, CreateDataSourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDataSourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a <code>Function</code> object.</p>
    ///          <p>A function is a reusable entity. Multiple functions can be used to compose the resolver
    ///          logic.</p>
    public func createFunction(input: CreateFunctionInput, completion: @escaping (SdkResult<CreateFunctionOutputResponse, CreateFunctionOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/functions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFunctionInput, CreateFunctionOutputResponse, CreateFunctionOutputError>(id: "createFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFunctionInput, CreateFunctionOutputResponse, CreateFunctionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a <code>GraphqlApi</code> object.</p>
    public func createGraphqlApi(input: CreateGraphqlApiInput, completion: @escaping (SdkResult<CreateGraphqlApiOutputResponse, CreateGraphqlApiOutputError>) -> Void)
    {
        let urlPath = "/v1/apis"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createGraphqlApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateGraphqlApiInput, CreateGraphqlApiOutputResponse, CreateGraphqlApiOutputError>(id: "createGraphqlApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateGraphqlApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateGraphqlApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateGraphqlApiInput, CreateGraphqlApiOutputResponse, CreateGraphqlApiOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateGraphqlApiInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a <code>Resolver</code> object.</p>
    ///          <p>A resolver converts incoming requests into a format that a data source can understand
    ///          and converts the data source's responses into GraphQL.</p>
    public func createResolver(input: CreateResolverInput, completion: @escaping (SdkResult<CreateResolverOutputResponse, CreateResolverOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let typeName = input.typeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component typeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types/\(typeName)/resolvers"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createResolver")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateResolverInput, CreateResolverOutputResponse, CreateResolverOutputError>(id: "createResolver")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateResolverInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateResolverInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateResolverInput, CreateResolverOutputResponse, CreateResolverOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateResolverInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a <code>Type</code> object.</p>
    public func createType(input: CreateTypeInput, completion: @escaping (SdkResult<CreateTypeOutputResponse, CreateTypeOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateTypeInput, CreateTypeOutputResponse, CreateTypeOutputError>(id: "createType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateTypeInput, CreateTypeOutputResponse, CreateTypeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an <code>ApiCache</code> object.</p>
    public func deleteApiCache(input: DeleteApiCacheInput, completion: @escaping (SdkResult<DeleteApiCacheOutputResponse, DeleteApiCacheOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/ApiCaches"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteApiCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteApiCacheInput, DeleteApiCacheOutputResponse, DeleteApiCacheOutputError>(id: "deleteApiCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteApiCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteApiCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteApiCacheInput, DeleteApiCacheOutputResponse, DeleteApiCacheOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an API key.</p>
    public func deleteApiKey(input: DeleteApiKeyInput, completion: @escaping (SdkResult<DeleteApiKeyOutputResponse, DeleteApiKeyOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/apikeys/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteApiKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteApiKeyInput, DeleteApiKeyOutputResponse, DeleteApiKeyOutputError>(id: "deleteApiKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteApiKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteApiKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteApiKeyInput, DeleteApiKeyOutputResponse, DeleteApiKeyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a <code>DataSource</code> object.</p>
    public func deleteDataSource(input: DeleteDataSourceInput, completion: @escaping (SdkResult<DeleteDataSourceOutputResponse, DeleteDataSourceOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/datasources/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDataSource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDataSourceInput, DeleteDataSourceOutputResponse, DeleteDataSourceOutputError>(id: "deleteDataSource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDataSourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDataSourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDataSourceInput, DeleteDataSourceOutputResponse, DeleteDataSourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a <code>Function</code>.</p>
    public func deleteFunction(input: DeleteFunctionInput, completion: @escaping (SdkResult<DeleteFunctionOutputResponse, DeleteFunctionOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let functionId = input.functionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/functions/\(functionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFunctionInput, DeleteFunctionOutputResponse, DeleteFunctionOutputError>(id: "deleteFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFunctionInput, DeleteFunctionOutputResponse, DeleteFunctionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a <code>GraphqlApi</code> object.</p>
    public func deleteGraphqlApi(input: DeleteGraphqlApiInput, completion: @escaping (SdkResult<DeleteGraphqlApiOutputResponse, DeleteGraphqlApiOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteGraphqlApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteGraphqlApiInput, DeleteGraphqlApiOutputResponse, DeleteGraphqlApiOutputError>(id: "deleteGraphqlApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteGraphqlApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteGraphqlApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteGraphqlApiInput, DeleteGraphqlApiOutputResponse, DeleteGraphqlApiOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a <code>Resolver</code> object.</p>
    public func deleteResolver(input: DeleteResolverInput, completion: @escaping (SdkResult<DeleteResolverOutputResponse, DeleteResolverOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let typeName = input.typeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component typeName unexpectedly nil"))))
            return
        }
        guard let fieldName = input.fieldName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fieldName unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types/\(typeName)/resolvers/\(fieldName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteResolver")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteResolverInput, DeleteResolverOutputResponse, DeleteResolverOutputError>(id: "deleteResolver")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteResolverInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteResolverInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteResolverInput, DeleteResolverOutputResponse, DeleteResolverOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a <code>Type</code> object.</p>
    public func deleteType(input: DeleteTypeInput, completion: @escaping (SdkResult<DeleteTypeOutputResponse, DeleteTypeOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let typeName = input.typeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component typeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types/\(typeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteTypeInput, DeleteTypeOutputResponse, DeleteTypeOutputError>(id: "deleteType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteTypeInput, DeleteTypeOutputResponse, DeleteTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Flushes an <code>ApiCache</code> object.</p>
    public func flushApiCache(input: FlushApiCacheInput, completion: @escaping (SdkResult<FlushApiCacheOutputResponse, FlushApiCacheOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/FlushCache"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "flushApiCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<FlushApiCacheInput, FlushApiCacheOutputResponse, FlushApiCacheOutputError>(id: "flushApiCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: FlushApiCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: FlushApiCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<FlushApiCacheInput, FlushApiCacheOutputResponse, FlushApiCacheOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves an <code>ApiCache</code> object.</p>
    public func getApiCache(input: GetApiCacheInput, completion: @escaping (SdkResult<GetApiCacheOutputResponse, GetApiCacheOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/ApiCaches"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getApiCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetApiCacheInput, GetApiCacheOutputResponse, GetApiCacheOutputError>(id: "getApiCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetApiCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetApiCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetApiCacheInput, GetApiCacheOutputResponse, GetApiCacheOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a <code>DataSource</code> object.</p>
    public func getDataSource(input: GetDataSourceInput, completion: @escaping (SdkResult<GetDataSourceOutputResponse, GetDataSourceOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/datasources/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDataSource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDataSourceInput, GetDataSourceOutputResponse, GetDataSourceOutputError>(id: "getDataSource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDataSourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDataSourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDataSourceInput, GetDataSourceOutputResponse, GetDataSourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get a <code>Function</code>.</p>
    public func getFunction(input: GetFunctionInput, completion: @escaping (SdkResult<GetFunctionOutputResponse, GetFunctionOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let functionId = input.functionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/functions/\(functionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFunctionInput, GetFunctionOutputResponse, GetFunctionOutputError>(id: "getFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFunctionInput, GetFunctionOutputResponse, GetFunctionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a <code>GraphqlApi</code> object.</p>
    public func getGraphqlApi(input: GetGraphqlApiInput, completion: @escaping (SdkResult<GetGraphqlApiOutputResponse, GetGraphqlApiOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGraphqlApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGraphqlApiInput, GetGraphqlApiOutputResponse, GetGraphqlApiOutputError>(id: "getGraphqlApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGraphqlApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGraphqlApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetGraphqlApiInput, GetGraphqlApiOutputResponse, GetGraphqlApiOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the introspection schema for a GraphQL API.</p>
    public func getIntrospectionSchema(input: GetIntrospectionSchemaInput, completion: @escaping (SdkResult<GetIntrospectionSchemaOutputResponse, GetIntrospectionSchemaOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/schema"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getIntrospectionSchema")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetIntrospectionSchemaInput, GetIntrospectionSchemaOutputResponse, GetIntrospectionSchemaOutputError>(id: "getIntrospectionSchema")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetIntrospectionSchemaInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetIntrospectionSchemaInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetIntrospectionSchemaInput, GetIntrospectionSchemaOutputResponse, GetIntrospectionSchemaOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a <code>Resolver</code> object.</p>
    public func getResolver(input: GetResolverInput, completion: @escaping (SdkResult<GetResolverOutputResponse, GetResolverOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let typeName = input.typeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component typeName unexpectedly nil"))))
            return
        }
        guard let fieldName = input.fieldName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fieldName unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types/\(typeName)/resolvers/\(fieldName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getResolver")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetResolverInput, GetResolverOutputResponse, GetResolverOutputError>(id: "getResolver")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetResolverInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetResolverInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetResolverInput, GetResolverOutputResponse, GetResolverOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the current status of a schema creation operation.</p>
    public func getSchemaCreationStatus(input: GetSchemaCreationStatusInput, completion: @escaping (SdkResult<GetSchemaCreationStatusOutputResponse, GetSchemaCreationStatusOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/schemacreation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSchemaCreationStatus")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSchemaCreationStatusInput, GetSchemaCreationStatusOutputResponse, GetSchemaCreationStatusOutputError>(id: "getSchemaCreationStatus")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSchemaCreationStatusInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSchemaCreationStatusInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSchemaCreationStatusInput, GetSchemaCreationStatusOutputResponse, GetSchemaCreationStatusOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a <code>Type</code> object.</p>
    public func getType(input: GetTypeInput, completion: @escaping (SdkResult<GetTypeOutputResponse, GetTypeOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let typeName = input.typeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component typeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types/\(typeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetTypeInput, GetTypeOutputResponse, GetTypeOutputError>(id: "getType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetTypeInput, GetTypeOutputResponse, GetTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the API keys for a given API.</p>
    ///          <note>
    ///             <p>API keys are deleted automatically 60 days after they expire. However, they may
    ///             still be included in the response until they have actually been deleted. You can safely
    ///             call <code>DeleteApiKey</code> to manually delete a key before it's automatically
    ///             deleted.</p>
    ///          </note>
    public func listApiKeys(input: ListApiKeysInput, completion: @escaping (SdkResult<ListApiKeysOutputResponse, ListApiKeysOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/apikeys"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listApiKeys")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListApiKeysInput, ListApiKeysOutputResponse, ListApiKeysOutputError>(id: "listApiKeys")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListApiKeysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListApiKeysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListApiKeysInput, ListApiKeysOutputResponse, ListApiKeysOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the data sources for a given API.</p>
    public func listDataSources(input: ListDataSourcesInput, completion: @escaping (SdkResult<ListDataSourcesOutputResponse, ListDataSourcesOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/datasources"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDataSources")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDataSourcesInput, ListDataSourcesOutputResponse, ListDataSourcesOutputError>(id: "listDataSources")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDataSourcesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDataSourcesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDataSourcesInput, ListDataSourcesOutputResponse, ListDataSourcesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List multiple functions.</p>
    public func listFunctions(input: ListFunctionsInput, completion: @escaping (SdkResult<ListFunctionsOutputResponse, ListFunctionsOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/functions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFunctions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFunctionsInput, ListFunctionsOutputResponse, ListFunctionsOutputError>(id: "listFunctions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFunctionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFunctionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFunctionsInput, ListFunctionsOutputResponse, ListFunctionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists your GraphQL APIs.</p>
    public func listGraphqlApis(input: ListGraphqlApisInput, completion: @escaping (SdkResult<ListGraphqlApisOutputResponse, ListGraphqlApisOutputError>) -> Void)
    {
        let urlPath = "/v1/apis"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGraphqlApis")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListGraphqlApisInput, ListGraphqlApisOutputResponse, ListGraphqlApisOutputError>(id: "listGraphqlApis")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListGraphqlApisInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListGraphqlApisInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListGraphqlApisInput, ListGraphqlApisOutputResponse, ListGraphqlApisOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the resolvers for a given API and type.</p>
    public func listResolvers(input: ListResolversInput, completion: @escaping (SdkResult<ListResolversOutputResponse, ListResolversOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let typeName = input.typeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component typeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types/\(typeName)/resolvers"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listResolvers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListResolversInput, ListResolversOutputResponse, ListResolversOutputError>(id: "listResolvers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListResolversInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListResolversInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListResolversInput, ListResolversOutputResponse, ListResolversOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the resolvers that are associated with a specific function.</p>
    public func listResolversByFunction(input: ListResolversByFunctionInput, completion: @escaping (SdkResult<ListResolversByFunctionOutputResponse, ListResolversByFunctionOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let functionId = input.functionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/functions/\(functionId)/resolvers"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listResolversByFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListResolversByFunctionInput, ListResolversByFunctionOutputResponse, ListResolversByFunctionOutputError>(id: "listResolversByFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListResolversByFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListResolversByFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListResolversByFunctionInput, ListResolversByFunctionOutputResponse, ListResolversByFunctionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the tags for a resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists the types for a given API.</p>
    public func listTypes(input: ListTypesInput, completion: @escaping (SdkResult<ListTypesOutputResponse, ListTypesOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTypesInput, ListTypesOutputResponse, ListTypesOutputError>(id: "listTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTypesInput, ListTypesOutputResponse, ListTypesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds a new schema to your GraphQL API.</p>
    ///          <p>This operation is asynchronous. Use  to
    ///          determine when it has completed.</p>
    public func startSchemaCreation(input: StartSchemaCreationInput, completion: @escaping (SdkResult<StartSchemaCreationOutputResponse, StartSchemaCreationOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/schemacreation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startSchemaCreation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartSchemaCreationInput, StartSchemaCreationOutputResponse, StartSchemaCreationOutputError>(id: "startSchemaCreation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartSchemaCreationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartSchemaCreationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartSchemaCreationInput, StartSchemaCreationOutputResponse, StartSchemaCreationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartSchemaCreationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Tags a resource with user-supplied tags.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Untags a resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the cache for the GraphQL API.</p>
    public func updateApiCache(input: UpdateApiCacheInput, completion: @escaping (SdkResult<UpdateApiCacheOutputResponse, UpdateApiCacheOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/ApiCaches/update"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateApiCache")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateApiCacheInput, UpdateApiCacheOutputResponse, UpdateApiCacheOutputError>(id: "updateApiCache")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiCacheInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiCacheInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateApiCacheInput, UpdateApiCacheOutputResponse, UpdateApiCacheOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiCacheInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an API key. The key can be updated while it is not deleted.</p>
    public func updateApiKey(input: UpdateApiKeyInput, completion: @escaping (SdkResult<UpdateApiKeyOutputResponse, UpdateApiKeyOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/apikeys/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateApiKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateApiKeyInput, UpdateApiKeyOutputResponse, UpdateApiKeyOutputError>(id: "updateApiKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateApiKeyInput, UpdateApiKeyOutputResponse, UpdateApiKeyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateApiKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a <code>DataSource</code> object.</p>
    public func updateDataSource(input: UpdateDataSourceInput, completion: @escaping (SdkResult<UpdateDataSourceOutputResponse, UpdateDataSourceOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/datasources/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDataSource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDataSourceInput, UpdateDataSourceOutputResponse, UpdateDataSourceOutputError>(id: "updateDataSource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDataSourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDataSourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDataSourceInput, UpdateDataSourceOutputResponse, UpdateDataSourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDataSourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a <code>Function</code> object.</p>
    public func updateFunction(input: UpdateFunctionInput, completion: @escaping (SdkResult<UpdateFunctionOutputResponse, UpdateFunctionOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let functionId = input.functionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component functionId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/functions/\(functionId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFunctionInput, UpdateFunctionOutputResponse, UpdateFunctionOutputError>(id: "updateFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFunctionInput, UpdateFunctionOutputResponse, UpdateFunctionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a <code>GraphqlApi</code> object.</p>
    public func updateGraphqlApi(input: UpdateGraphqlApiInput, completion: @escaping (SdkResult<UpdateGraphqlApiOutputResponse, UpdateGraphqlApiOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateGraphqlApi")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateGraphqlApiInput, UpdateGraphqlApiOutputResponse, UpdateGraphqlApiOutputError>(id: "updateGraphqlApi")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateGraphqlApiInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateGraphqlApiInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateGraphqlApiInput, UpdateGraphqlApiOutputResponse, UpdateGraphqlApiOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateGraphqlApiInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a <code>Resolver</code> object.</p>
    public func updateResolver(input: UpdateResolverInput, completion: @escaping (SdkResult<UpdateResolverOutputResponse, UpdateResolverOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let typeName = input.typeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component typeName unexpectedly nil"))))
            return
        }
        guard let fieldName = input.fieldName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component fieldName unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types/\(typeName)/resolvers/\(fieldName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateResolver")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateResolverInput, UpdateResolverOutputResponse, UpdateResolverOutputError>(id: "updateResolver")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateResolverInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateResolverInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateResolverInput, UpdateResolverOutputResponse, UpdateResolverOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateResolverInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a <code>Type</code> object.</p>
    public func updateType(input: UpdateTypeInput, completion: @escaping (SdkResult<UpdateTypeOutputResponse, UpdateTypeOutputError>) -> Void)
    {
        guard let apiId = input.apiId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component apiId unexpectedly nil"))))
            return
        }
        guard let typeName = input.typeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component typeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v1/apis/\(apiId)/types/\(typeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appsync.\(config.region).amazonaws.com")
                      .withSigningName(value: "appsync")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateTypeInput, UpdateTypeOutputResponse, UpdateTypeOutputError>(id: "updateType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateTypeInput, UpdateTypeOutputResponse, UpdateTypeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
