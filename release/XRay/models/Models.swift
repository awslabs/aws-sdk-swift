// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Alias: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for aliasnames0 in names {
                try namesContainer.encode(aliasnames0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Alias: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Alias(name: \(String(describing: name)), names: \(String(describing: names)), type: \(String(describing: type)))"}
}

/// <p>An alias for an edge.</p>
public struct Alias: Equatable {
    /// <p>The canonical name of the alias.</p>
    public let name: String?
    /// <p>A list of names for the alias, including the canonical name.</p>
    public let names: [String]?
    /// <p>The type of the alias.</p>
    public let type: String?

    public init (
        name: String? = nil,
        names: [String]? = nil,
        type: String? = nil
    )
    {
        self.name = name
        self.names = names
        self.type = type
    }
}

extension AnnotationValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case booleanValue = "BooleanValue"
        case numberValue = "NumberValue"
        case stringValue = "StringValue"
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .booleanValue(booleanValue):
                if let booleanValue = booleanValue {
                    try container.encode(booleanValue, forKey: .booleanValue)
                }
            case let .numberValue(numberValue):
                if let numberValue = numberValue {
                    try container.encode(numberValue, forKey: .numberValue)
                }
            case let .stringValue(stringValue):
                if let stringValue = stringValue {
                    try container.encode(stringValue, forKey: .stringValue)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let numberValueDecoded = try values.decodeIfPresent(Double.self, forKey: .numberValue)
        if let numberValue = numberValueDecoded {
            self = .numberValue(numberValue)
            return
        }
        let booleanValueDecoded = try values.decodeIfPresent(Bool.self, forKey: .booleanValue)
        if let booleanValue = booleanValueDecoded {
            self = .booleanValue(booleanValue)
            return
        }
        let stringValueDecoded = try values.decodeIfPresent(String.self, forKey: .stringValue)
        if let stringValue = stringValueDecoded {
            self = .stringValue(stringValue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Value of a segment annotation. Has one of three value types: Number, Boolean, or String.</p>
public enum AnnotationValue: Equatable {
    /// <p>Value for a Number annotation.</p>
    case numberValue(Double?)
    /// <p>Value for a Boolean annotation.</p>
    case booleanValue(Bool?)
    /// <p>Value for a String annotation.</p>
    case stringValue(String?)
    case sdkUnknown(String?)
}

extension AnomalousService: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceId = "ServiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceId = serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceIdDecoded = try containerValues.decodeIfPresent(ServiceId.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
    }
}

extension AnomalousService: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalousService(serviceId: \(String(describing: serviceId)))"}
}

/// <p>The service within the service graph that has anomalously high fault rates. </p>
public struct AnomalousService: Equatable {
    /// <p></p>
    public let serviceId: ServiceId?

    public init (
        serviceId: ServiceId? = nil
    )
    {
        self.serviceId = serviceId
    }
}

extension AvailabilityZoneDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AvailabilityZoneDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZoneDetail(name: \(String(describing: name)))"}
}

/// <p>A list of Availability Zones corresponding to the segments in a trace.</p>
public struct AvailabilityZoneDetail: Equatable {
    /// <p>The name of a corresponding Availability Zone.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension BackendConnectionErrors: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionRefusedCount = "ConnectionRefusedCount"
        case hTTPCode4XXCount = "HTTPCode4XXCount"
        case hTTPCode5XXCount = "HTTPCode5XXCount"
        case otherCount = "OtherCount"
        case timeoutCount = "TimeoutCount"
        case unknownHostCount = "UnknownHostCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionRefusedCount = connectionRefusedCount {
            try encodeContainer.encode(connectionRefusedCount, forKey: .connectionRefusedCount)
        }
        if let hTTPCode4XXCount = hTTPCode4XXCount {
            try encodeContainer.encode(hTTPCode4XXCount, forKey: .hTTPCode4XXCount)
        }
        if let hTTPCode5XXCount = hTTPCode5XXCount {
            try encodeContainer.encode(hTTPCode5XXCount, forKey: .hTTPCode5XXCount)
        }
        if let otherCount = otherCount {
            try encodeContainer.encode(otherCount, forKey: .otherCount)
        }
        if let timeoutCount = timeoutCount {
            try encodeContainer.encode(timeoutCount, forKey: .timeoutCount)
        }
        if let unknownHostCount = unknownHostCount {
            try encodeContainer.encode(unknownHostCount, forKey: .unknownHostCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutCount)
        timeoutCount = timeoutCountDecoded
        let connectionRefusedCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectionRefusedCount)
        connectionRefusedCount = connectionRefusedCountDecoded
        let hTTPCode4XXCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .hTTPCode4XXCount)
        hTTPCode4XXCount = hTTPCode4XXCountDecoded
        let hTTPCode5XXCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .hTTPCode5XXCount)
        hTTPCode5XXCount = hTTPCode5XXCountDecoded
        let unknownHostCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .unknownHostCount)
        unknownHostCount = unknownHostCountDecoded
        let otherCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .otherCount)
        otherCount = otherCountDecoded
    }
}

extension BackendConnectionErrors: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendConnectionErrors(connectionRefusedCount: \(String(describing: connectionRefusedCount)), hTTPCode4XXCount: \(String(describing: hTTPCode4XXCount)), hTTPCode5XXCount: \(String(describing: hTTPCode5XXCount)), otherCount: \(String(describing: otherCount)), timeoutCount: \(String(describing: timeoutCount)), unknownHostCount: \(String(describing: unknownHostCount)))"}
}

/// <p></p>
public struct BackendConnectionErrors: Equatable {
    /// <p></p>
    public let connectionRefusedCount: Int?
    /// <p></p>
    public let hTTPCode4XXCount: Int?
    /// <p></p>
    public let hTTPCode5XXCount: Int?
    /// <p></p>
    public let otherCount: Int?
    /// <p></p>
    public let timeoutCount: Int?
    /// <p></p>
    public let unknownHostCount: Int?

    public init (
        connectionRefusedCount: Int? = nil,
        hTTPCode4XXCount: Int? = nil,
        hTTPCode5XXCount: Int? = nil,
        otherCount: Int? = nil,
        timeoutCount: Int? = nil,
        unknownHostCount: Int? = nil
    )
    {
        self.connectionRefusedCount = connectionRefusedCount
        self.hTTPCode4XXCount = hTTPCode4XXCount
        self.hTTPCode5XXCount = hTTPCode5XXCount
        self.otherCount = otherCount
        self.timeoutCount = timeoutCount
        self.unknownHostCount = unknownHostCount
    }
}

public struct BatchGetTracesInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetTracesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetTracesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetTracesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetTracesInput>
    public typealias MOutput = OperationOutput<BatchGetTracesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetTracesOutputError>
}

extension BatchGetTracesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetTracesInput(nextToken: \(String(describing: nextToken)), traceIds: \(String(describing: traceIds)))"}
}

extension BatchGetTracesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case traceIds = "TraceIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let traceIds = traceIds {
            var traceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traceIds)
            for traceidlist0 in traceIds {
                try traceIdsContainer.encode(traceidlist0)
            }
        }
    }
}

public struct BatchGetTracesInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetTracesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetTracesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetTracesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetTracesInput>
    public typealias MOutput = OperationOutput<BatchGetTracesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetTracesOutputError>
}

public struct BatchGetTracesInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetTracesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetTracesInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetTracesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetTracesInput>
    public typealias MOutput = OperationOutput<BatchGetTracesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetTracesOutputError>
}

public struct BatchGetTracesInput: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>Specify the trace IDs of requests for which to retrieve segments.</p>
    public let traceIds: [String]?

    public init (
        nextToken: String? = nil,
        traceIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traceIds = traceIds
    }
}

struct BatchGetTracesInputBody: Equatable {
    public let traceIds: [String]?
    public let nextToken: String?
}

extension BatchGetTracesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case traceIds = "TraceIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .traceIds)
        var traceIdsDecoded0:[String]? = nil
        if let traceIdsContainer = traceIdsContainer {
            traceIdsDecoded0 = [String]()
            for string0 in traceIdsContainer {
                if let string0 = string0 {
                    traceIdsDecoded0?.append(string0)
                }
            }
        }
        traceIds = traceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchGetTracesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetTracesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetTracesOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetTracesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetTracesOutputResponse(nextToken: \(String(describing: nextToken)), traces: \(String(describing: traces)), unprocessedTraceIds: \(String(describing: unprocessedTraceIds)))"}
}

extension BatchGetTracesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetTracesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.traces = output.traces
            self.unprocessedTraceIds = output.unprocessedTraceIds
        } else {
            self.nextToken = nil
            self.traces = nil
            self.unprocessedTraceIds = nil
        }
    }
}

public struct BatchGetTracesOutputResponse: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>Full traces for the specified requests.</p>
    public let traces: [Trace]?
    /// <p>Trace IDs of requests that haven't been processed.</p>
    public let unprocessedTraceIds: [String]?

    public init (
        nextToken: String? = nil,
        traces: [Trace]? = nil,
        unprocessedTraceIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traces = traces
        self.unprocessedTraceIds = unprocessedTraceIds
    }
}

struct BatchGetTracesOutputResponseBody: Equatable {
    public let traces: [Trace]?
    public let unprocessedTraceIds: [String]?
    public let nextToken: String?
}

extension BatchGetTracesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case traces = "Traces"
        case unprocessedTraceIds = "UnprocessedTraceIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tracesContainer = try containerValues.decodeIfPresent([Trace?].self, forKey: .traces)
        var tracesDecoded0:[Trace]? = nil
        if let tracesContainer = tracesContainer {
            tracesDecoded0 = [Trace]()
            for structure0 in tracesContainer {
                if let structure0 = structure0 {
                    tracesDecoded0?.append(structure0)
                }
            }
        }
        traces = tracesDecoded0
        let unprocessedTraceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .unprocessedTraceIds)
        var unprocessedTraceIdsDecoded0:[String]? = nil
        if let unprocessedTraceIdsContainer = unprocessedTraceIdsContainer {
            unprocessedTraceIdsDecoded0 = [String]()
            for string0 in unprocessedTraceIdsContainer {
                if let string0 = string0 {
                    unprocessedTraceIdsDecoded0?.append(string0)
                }
            }
        }
        unprocessedTraceIds = unprocessedTraceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct CreateGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

extension CreateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupInput(filterExpression: \(String(describing: filterExpression)), groupName: \(String(describing: groupName)), insightsConfiguration: \(String(describing: insightsConfiguration)), tags: \(String(describing: tags)))"}
}

extension CreateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterExpression = "FilterExpression"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightsConfiguration = insightsConfiguration {
            try encodeContainer.encode(insightsConfiguration, forKey: .insightsConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInput: Equatable {
    /// <p>The filter expression defining criteria by which to group traces.</p>
    public let filterExpression: String?
    /// <p>The case-sensitive name of the new group. Default is a reserved name and names must
    ///             be unique.</p>
    public let groupName: String?
    /// <p>The structure containing configurations related to insights.</p>
    ///             <ul>
    ///             <li>
    ///                     <p>The InsightsEnabled boolean can be set to true to enable insights for the
    ///                     new group or false to disable insights for the new group.</p>
    ///                 </li>
    ///             <li>
    ///                     <p>The NotifcationsEnabled boolean can be set to true to enable insights
    ///                     notifications for the new group. Notifications may only be enabled on a group
    ///                     with InsightsEnabled set to true.</p>
    ///                 </li>
    ///          </ul>
    public let insightsConfiguration: InsightsConfiguration?
    /// <p>A map that contains one or more tag keys and tag values to attach to an X-Ray group.
    ///             For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    ///                 resources</a> in the <i>AWS General Reference</i>.</p>
    ///         <p>The following restrictions apply to tags:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Maximum number of user-applied tags per resource: 50</p>
    ///             </li>
    ///             <li>
    ///                 <p>Maximum tag key length: 128 Unicode characters</p>
    ///             </li>
    ///             <li>
    ///                 <p>Maximum tag value length: 256 Unicode characters</p>
    ///             </li>
    ///             <li>
    ///                 <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . :
    ///                     / = + - and @</p>
    ///             </li>
    ///             <li>
    ///                 <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Don't use <code>aws:</code> as a prefix for keys; it's reserved for AWS
    ///                     use.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        filterExpression: String? = nil,
        groupName: String? = nil,
        insightsConfiguration: InsightsConfiguration? = nil,
        tags: [Tag]? = nil
    )
    {
        self.filterExpression = filterExpression
        self.groupName = groupName
        self.insightsConfiguration = insightsConfiguration
        self.tags = tags
    }
}

struct CreateGroupInputBody: Equatable {
    public let groupName: String?
    public let filterExpression: String?
    public let insightsConfiguration: InsightsConfiguration?
    public let tags: [Tag]?
}

extension CreateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterExpression = "FilterExpression"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let insightsConfigurationDecoded = try containerValues.decodeIfPresent(InsightsConfiguration.self, forKey: .insightsConfiguration)
        insightsConfiguration = insightsConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupOutputResponse(group: \(String(describing: group)))"}
}

extension CreateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct CreateGroupOutputResponse: Equatable {
    /// <p>The group that was created. Contains the name of the group that was created, the Amazon Resource Name
    ///             (ARN) of the group that was generated based on the group name, the filter expression, and the insight
    ///             configuration that was assigned to the group.</p>
    public let group: Group?

    public init (
        group: Group? = nil
    )
    {
        self.group = group
    }
}

struct CreateGroupOutputResponseBody: Equatable {
    public let group: Group?
}

extension CreateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
    }
}

public struct CreateSamplingRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateSamplingRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSamplingRuleInput>
    public typealias MOutput = OperationOutput<CreateSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSamplingRuleOutputError>
}

extension CreateSamplingRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSamplingRuleInput(samplingRule: \(String(describing: samplingRule)), tags: \(String(describing: tags)))"}
}

extension CreateSamplingRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case samplingRule = "SamplingRule"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let samplingRule = samplingRule {
            try encodeContainer.encode(samplingRule, forKey: .samplingRule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateSamplingRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSamplingRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSamplingRuleInput>
    public typealias MOutput = OperationOutput<CreateSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSamplingRuleOutputError>
}

public struct CreateSamplingRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSamplingRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSamplingRuleInput>
    public typealias MOutput = OperationOutput<CreateSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSamplingRuleOutputError>
}

public struct CreateSamplingRuleInput: Equatable {
    /// <p>The rule definition.</p>
    public let samplingRule: SamplingRule?
    /// <p>A map that contains one or more tag keys and tag values to attach to an X-Ray sampling
    ///          rule. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS
    ///             resources</a> in the <i>AWS General Reference</i>.</p>
    ///          <p>The following restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of user-applied tags per resource: 50</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum tag key length: 128 Unicode characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum tag value length: 256 Unicode characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . :
    ///                / = + - and @</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Don't use <code>aws:</code> as a prefix for keys; it's reserved for AWS
    ///                use.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        samplingRule: SamplingRule? = nil,
        tags: [Tag]? = nil
    )
    {
        self.samplingRule = samplingRule
        self.tags = tags
    }
}

struct CreateSamplingRuleInputBody: Equatable {
    public let samplingRule: SamplingRule?
    public let tags: [Tag]?
}

extension CreateSamplingRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case samplingRule = "SamplingRule"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleDecoded = try containerValues.decodeIfPresent(SamplingRule.self, forKey: .samplingRule)
        samplingRule = samplingRuleDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSamplingRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSamplingRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleLimitExceededException" : self = .ruleLimitExceededException(try RuleLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSamplingRuleOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case ruleLimitExceededException(RuleLimitExceededException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSamplingRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSamplingRuleOutputResponse(samplingRuleRecord: \(String(describing: samplingRuleRecord)))"}
}

extension CreateSamplingRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSamplingRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.samplingRuleRecord = output.samplingRuleRecord
        } else {
            self.samplingRuleRecord = nil
        }
    }
}

public struct CreateSamplingRuleOutputResponse: Equatable {
    /// <p>The saved rule definition and metadata.</p>
    public let samplingRuleRecord: SamplingRuleRecord?

    public init (
        samplingRuleRecord: SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

struct CreateSamplingRuleOutputResponseBody: Equatable {
    public let samplingRuleRecord: SamplingRuleRecord?
}

extension CreateSamplingRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case samplingRuleRecord = "SamplingRuleRecord"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleRecordDecoded = try containerValues.decodeIfPresent(SamplingRuleRecord.self, forKey: .samplingRuleRecord)
        samplingRuleRecord = samplingRuleRecordDecoded
    }
}

public struct DeleteGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

extension DeleteGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupInput(groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)))"}
}

extension DeleteGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupARN = "GroupARN"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

public struct DeleteGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInput: Equatable {
    /// <p>The ARN of the group that was generated on creation.</p>
    public let groupARN: String?
    /// <p>The case-sensitive name of the group.</p>
    public let groupName: String?

    public init (
        groupARN: String? = nil,
        groupName: String? = nil
    )
    {
        self.groupARN = groupARN
        self.groupName = groupName
    }
}

struct DeleteGroupInputBody: Equatable {
    public let groupName: String?
    public let groupARN: String?
}

extension DeleteGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupARN = "GroupARN"
        case groupName = "GroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
    }
}

extension DeleteGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupOutputResponse()"}
}

extension DeleteGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteGroupOutputResponseBody: Equatable {
}

extension DeleteGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSamplingRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSamplingRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSamplingRuleInput>
    public typealias MOutput = OperationOutput<DeleteSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSamplingRuleOutputError>
}

extension DeleteSamplingRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSamplingRuleInput(ruleARN: \(String(describing: ruleARN)), ruleName: \(String(describing: ruleName)))"}
}

extension DeleteSamplingRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleARN = "RuleARN"
        case ruleName = "RuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleARN = ruleARN {
            try encodeContainer.encode(ruleARN, forKey: .ruleARN)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }
}

public struct DeleteSamplingRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSamplingRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSamplingRuleInput>
    public typealias MOutput = OperationOutput<DeleteSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSamplingRuleOutputError>
}

public struct DeleteSamplingRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSamplingRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSamplingRuleInput>
    public typealias MOutput = OperationOutput<DeleteSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSamplingRuleOutputError>
}

public struct DeleteSamplingRuleInput: Equatable {
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    public let ruleARN: String?
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    public let ruleName: String?

    public init (
        ruleARN: String? = nil,
        ruleName: String? = nil
    )
    {
        self.ruleARN = ruleARN
        self.ruleName = ruleName
    }
}

struct DeleteSamplingRuleInputBody: Equatable {
    public let ruleName: String?
    public let ruleARN: String?
}

extension DeleteSamplingRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleARN = "RuleARN"
        case ruleName = "RuleName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleARN)
        ruleARN = ruleARNDecoded
    }
}

extension DeleteSamplingRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSamplingRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSamplingRuleOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSamplingRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSamplingRuleOutputResponse(samplingRuleRecord: \(String(describing: samplingRuleRecord)))"}
}

extension DeleteSamplingRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSamplingRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.samplingRuleRecord = output.samplingRuleRecord
        } else {
            self.samplingRuleRecord = nil
        }
    }
}

public struct DeleteSamplingRuleOutputResponse: Equatable {
    /// <p>The deleted rule definition and metadata.</p>
    public let samplingRuleRecord: SamplingRuleRecord?

    public init (
        samplingRuleRecord: SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

struct DeleteSamplingRuleOutputResponseBody: Equatable {
    public let samplingRuleRecord: SamplingRuleRecord?
}

extension DeleteSamplingRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case samplingRuleRecord = "SamplingRuleRecord"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleRecordDecoded = try containerValues.decodeIfPresent(SamplingRuleRecord.self, forKey: .samplingRuleRecord)
        samplingRuleRecord = samplingRuleRecordDecoded
    }
}

extension Edge: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case endTime = "EndTime"
        case referenceId = "ReferenceId"
        case responseTimeHistogram = "ResponseTimeHistogram"
        case startTime = "StartTime"
        case summaryStatistics = "SummaryStatistics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for aliaslist0 in aliases {
                try aliasesContainer.encode(aliaslist0)
            }
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let responseTimeHistogram = responseTimeHistogram {
            var responseTimeHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeHistogram)
            for histogram0 in responseTimeHistogram {
                try responseTimeHistogramContainer.encode(histogram0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let summaryStatistics = summaryStatistics {
            try encodeContainer.encode(summaryStatistics, forKey: .summaryStatistics)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let summaryStatisticsDecoded = try containerValues.decodeIfPresent(EdgeStatistics.self, forKey: .summaryStatistics)
        summaryStatistics = summaryStatisticsDecoded
        let responseTimeHistogramContainer = try containerValues.decodeIfPresent([HistogramEntry?].self, forKey: .responseTimeHistogram)
        var responseTimeHistogramDecoded0:[HistogramEntry]? = nil
        if let responseTimeHistogramContainer = responseTimeHistogramContainer {
            responseTimeHistogramDecoded0 = [HistogramEntry]()
            for structure0 in responseTimeHistogramContainer {
                if let structure0 = structure0 {
                    responseTimeHistogramDecoded0?.append(structure0)
                }
            }
        }
        responseTimeHistogram = responseTimeHistogramDecoded0
        let aliasesContainer = try containerValues.decodeIfPresent([Alias?].self, forKey: .aliases)
        var aliasesDecoded0:[Alias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Alias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension Edge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Edge(aliases: \(String(describing: aliases)), endTime: \(String(describing: endTime)), referenceId: \(String(describing: referenceId)), responseTimeHistogram: \(String(describing: responseTimeHistogram)), startTime: \(String(describing: startTime)), summaryStatistics: \(String(describing: summaryStatistics)))"}
}

/// <p>Information about a connection between two services.</p>
public struct Edge: Equatable {
    /// <p>Aliases for the edge.</p>
    public let aliases: [Alias]?
    /// <p>The end time of the last segment on the edge.</p>
    public let endTime: Date?
    /// <p>Identifier of the edge. Unique within a service map.</p>
    public let referenceId: Int?
    /// <p>A histogram that maps the spread of client response times on an edge.</p>
    public let responseTimeHistogram: [HistogramEntry]?
    /// <p>The start time of the first segment on the edge.</p>
    public let startTime: Date?
    /// <p>Response statistics for segments on the edge.</p>
    public let summaryStatistics: EdgeStatistics?

    public init (
        aliases: [Alias]? = nil,
        endTime: Date? = nil,
        referenceId: Int? = nil,
        responseTimeHistogram: [HistogramEntry]? = nil,
        startTime: Date? = nil,
        summaryStatistics: EdgeStatistics? = nil
    )
    {
        self.aliases = aliases
        self.endTime = endTime
        self.referenceId = referenceId
        self.responseTimeHistogram = responseTimeHistogram
        self.startTime = startTime
        self.summaryStatistics = summaryStatistics
    }
}

extension EdgeStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorStatistics = "ErrorStatistics"
        case faultStatistics = "FaultStatistics"
        case okCount = "OkCount"
        case totalCount = "TotalCount"
        case totalResponseTime = "TotalResponseTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorStatistics = errorStatistics {
            try encodeContainer.encode(errorStatistics, forKey: .errorStatistics)
        }
        if let faultStatistics = faultStatistics {
            try encodeContainer.encode(faultStatistics, forKey: .faultStatistics)
        }
        if let okCount = okCount {
            try encodeContainer.encode(okCount, forKey: .okCount)
        }
        if let totalCount = totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
        if let totalResponseTime = totalResponseTime {
            try encodeContainer.encode(totalResponseTime, forKey: .totalResponseTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let okCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .okCount)
        okCount = okCountDecoded
        let errorStatisticsDecoded = try containerValues.decodeIfPresent(ErrorStatistics.self, forKey: .errorStatistics)
        errorStatistics = errorStatisticsDecoded
        let faultStatisticsDecoded = try containerValues.decodeIfPresent(FaultStatistics.self, forKey: .faultStatistics)
        faultStatistics = faultStatisticsDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalResponseTimeDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .totalResponseTime)
        totalResponseTime = totalResponseTimeDecoded
    }
}

extension EdgeStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EdgeStatistics(errorStatistics: \(String(describing: errorStatistics)), faultStatistics: \(String(describing: faultStatistics)), okCount: \(String(describing: okCount)), totalCount: \(String(describing: totalCount)), totalResponseTime: \(String(describing: totalResponseTime)))"}
}

/// <p>Response statistics for an edge.</p>
public struct EdgeStatistics: Equatable {
    /// <p>Information about requests that failed with a 4xx Client Error status code.</p>
    public let errorStatistics: ErrorStatistics?
    /// <p>Information about requests that failed with a 5xx Server Error status code.</p>
    public let faultStatistics: FaultStatistics?
    /// <p>The number of requests that completed with a 2xx Success status code.</p>
    public let okCount: Int?
    /// <p>The total number of completed requests.</p>
    public let totalCount: Int?
    /// <p>The aggregate response time of completed requests.</p>
    public let totalResponseTime: Double?

    public init (
        errorStatistics: ErrorStatistics? = nil,
        faultStatistics: FaultStatistics? = nil,
        okCount: Int? = nil,
        totalCount: Int? = nil,
        totalResponseTime: Double? = nil
    )
    {
        self.errorStatistics = errorStatistics
        self.faultStatistics = faultStatistics
        self.okCount = okCount
        self.totalCount = totalCount
        self.totalResponseTime = totalResponseTime
    }
}

extension EncryptionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EncryptionStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EncryptionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfig(keyId: \(String(describing: keyId)), status: \(String(describing: status)), type: \(String(describing: type)))"}
}

/// <p>A configuration document that specifies encryption configuration settings.</p>
public struct EncryptionConfig: Equatable {
    /// <p>The ID of the customer master key (CMK) used for encryption, if applicable.</p>
    public let keyId: String?
    /// <p>The encryption status. While the status is <code>UPDATING</code>, X-Ray may encrypt data with a combination of the new and old settings.</p>
    public let status: EncryptionStatus?
    /// <p>The type of encryption. Set to <code>KMS</code> for encryption with CMKs. Set to <code>NONE</code> for
    ///       default encryption.</p>
    public let type: EncryptionType?

    public init (
        keyId: String? = nil,
        status: EncryptionStatus? = nil,
        type: EncryptionType? = nil
    )
    {
        self.keyId = keyId
        self.status = status
        self.type = type
    }
}

public enum EncryptionStatus {
    case active
    case updating
    case sdkUnknown(String)
}

extension EncryptionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionStatus] {
        return [
            .active,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionStatus(rawValue: rawValue) ?? EncryptionStatus.sdkUnknown(rawValue)
    }
}

public enum EncryptionType {
    case kms
    case `none`
    case sdkUnknown(String)
}

extension EncryptionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionType] {
        return [
            .kms,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kms: return "KMS"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
    }
}

extension ErrorRootCause: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientImpacting = "ClientImpacting"
        case services = "Services"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientImpacting = clientImpacting {
            try encodeContainer.encode(clientImpacting, forKey: .clientImpacting)
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for errorrootcauseservices0 in services {
                try servicesContainer.encode(errorrootcauseservices0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([ErrorRootCauseService?].self, forKey: .services)
        var servicesDecoded0:[ErrorRootCauseService]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ErrorRootCauseService]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let clientImpactingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .clientImpacting)
        clientImpacting = clientImpactingDecoded
    }
}

extension ErrorRootCause: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorRootCause(clientImpacting: \(String(describing: clientImpacting)), services: \(String(describing: services)))"}
}

/// <p>The root cause of a trace summary error.</p>
public struct ErrorRootCause: Equatable {
    /// <p>A flag that denotes that the root cause impacts the trace client.</p>
    public let clientImpacting: Bool?
    /// <p>A list of services corresponding to an error. A service identifies a segment and it
    ///       contains a name, account ID, type, and inferred flag.</p>
    public let services: [ErrorRootCauseService]?

    public init (
        clientImpacting: Bool? = nil,
        services: [ErrorRootCauseService]? = nil
    )
    {
        self.clientImpacting = clientImpacting
        self.services = services
    }
}

extension ErrorRootCauseEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exceptions = "Exceptions"
        case name = "Name"
        case remote = "Remote"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptions = exceptions {
            var exceptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exceptions)
            for rootcauseexceptions0 in exceptions {
                try exceptionsContainer.encode(rootcauseexceptions0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remote = remote {
            try encodeContainer.encode(remote, forKey: .remote)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let exceptionsContainer = try containerValues.decodeIfPresent([RootCauseException?].self, forKey: .exceptions)
        var exceptionsDecoded0:[RootCauseException]? = nil
        if let exceptionsContainer = exceptionsContainer {
            exceptionsDecoded0 = [RootCauseException]()
            for structure0 in exceptionsContainer {
                if let structure0 = structure0 {
                    exceptionsDecoded0?.append(structure0)
                }
            }
        }
        exceptions = exceptionsDecoded0
        let remoteDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remote)
        remote = remoteDecoded
    }
}

extension ErrorRootCauseEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorRootCauseEntity(exceptions: \(String(describing: exceptions)), name: \(String(describing: name)), remote: \(String(describing: remote)))"}
}

/// <p>A collection of segments and corresponding subsegments associated to a trace summary
///       error.</p>
public struct ErrorRootCauseEntity: Equatable {
    /// <p>The types and messages of the exceptions.</p>
    public let exceptions: [RootCauseException]?
    /// <p>The name of the entity.</p>
    public let name: String?
    /// <p>A flag that denotes a remote subsegment.</p>
    public let remote: Bool?

    public init (
        exceptions: [RootCauseException]? = nil,
        name: String? = nil,
        remote: Bool? = nil
    )
    {
        self.exceptions = exceptions
        self.name = name
        self.remote = remote
    }
}

extension ErrorRootCauseService: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case entityPath = "EntityPath"
        case inferred = "Inferred"
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let entityPath = entityPath {
            var entityPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityPath)
            for errorrootcauseentitypath0 in entityPath {
                try entityPathContainer.encode(errorrootcauseentitypath0)
            }
        }
        if let inferred = inferred {
            try encodeContainer.encode(inferred, forKey: .inferred)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for servicenames0 in names {
                try namesContainer.encode(servicenames0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let entityPathContainer = try containerValues.decodeIfPresent([ErrorRootCauseEntity?].self, forKey: .entityPath)
        var entityPathDecoded0:[ErrorRootCauseEntity]? = nil
        if let entityPathContainer = entityPathContainer {
            entityPathDecoded0 = [ErrorRootCauseEntity]()
            for structure0 in entityPathContainer {
                if let structure0 = structure0 {
                    entityPathDecoded0?.append(structure0)
                }
            }
        }
        entityPath = entityPathDecoded0
        let inferredDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .inferred)
        inferred = inferredDecoded
    }
}

extension ErrorRootCauseService: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorRootCauseService(accountId: \(String(describing: accountId)), entityPath: \(String(describing: entityPath)), inferred: \(String(describing: inferred)), name: \(String(describing: name)), names: \(String(describing: names)), type: \(String(describing: type)))"}
}

/// <p>A collection of fields identifying the services in a trace summary error.</p>
public struct ErrorRootCauseService: Equatable {
    /// <p>The account ID associated to the service.</p>
    public let accountId: String?
    /// <p>The path of root cause entities found on the service. </p>
    public let entityPath: [ErrorRootCauseEntity]?
    /// <p>A Boolean value indicating if the service is inferred from the trace.</p>
    public let inferred: Bool?
    /// <p>The service name.</p>
    public let name: String?
    /// <p>A collection of associated service names.</p>
    public let names: [String]?
    /// <p>The type associated to the service.</p>
    public let type: String?

    public init (
        accountId: String? = nil,
        entityPath: [ErrorRootCauseEntity]? = nil,
        inferred: Bool? = nil,
        name: String? = nil,
        names: [String]? = nil,
        type: String? = nil
    )
    {
        self.accountId = accountId
        self.entityPath = entityPath
        self.inferred = inferred
        self.name = name
        self.names = names
        self.type = type
    }
}

extension ErrorStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case otherCount = "OtherCount"
        case throttleCount = "ThrottleCount"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let otherCount = otherCount {
            try encodeContainer.encode(otherCount, forKey: .otherCount)
        }
        if let throttleCount = throttleCount {
            try encodeContainer.encode(throttleCount, forKey: .throttleCount)
        }
        if let totalCount = totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throttleCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .throttleCount)
        throttleCount = throttleCountDecoded
        let otherCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .otherCount)
        otherCount = otherCountDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension ErrorStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorStatistics(otherCount: \(String(describing: otherCount)), throttleCount: \(String(describing: throttleCount)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Information about requests that failed with a 4xx Client Error status code.</p>
public struct ErrorStatistics: Equatable {
    /// <p>The number of requests that failed with untracked 4xx Client Error status
    ///       codes.</p>
    public let otherCount: Int?
    /// <p>The number of requests that failed with a 419 throttling status code.</p>
    public let throttleCount: Int?
    /// <p>The total number of requests that failed with a 4xx Client Error status code.</p>
    public let totalCount: Int?

    public init (
        otherCount: Int? = nil,
        throttleCount: Int? = nil,
        totalCount: Int? = nil
    )
    {
        self.otherCount = otherCount
        self.throttleCount = throttleCount
        self.totalCount = totalCount
    }
}

extension FaultRootCause: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientImpacting = "ClientImpacting"
        case services = "Services"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientImpacting = clientImpacting {
            try encodeContainer.encode(clientImpacting, forKey: .clientImpacting)
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for faultrootcauseservices0 in services {
                try servicesContainer.encode(faultrootcauseservices0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([FaultRootCauseService?].self, forKey: .services)
        var servicesDecoded0:[FaultRootCauseService]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [FaultRootCauseService]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let clientImpactingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .clientImpacting)
        clientImpacting = clientImpactingDecoded
    }
}

extension FaultRootCause: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FaultRootCause(clientImpacting: \(String(describing: clientImpacting)), services: \(String(describing: services)))"}
}

/// <p>The root cause information for a trace summary fault.</p>
public struct FaultRootCause: Equatable {
    /// <p>A flag that denotes that the root cause impacts the trace client.</p>
    public let clientImpacting: Bool?
    /// <p>A list of corresponding services. A service identifies a segment and it contains a
    ///       name, account ID, type, and inferred flag.</p>
    public let services: [FaultRootCauseService]?

    public init (
        clientImpacting: Bool? = nil,
        services: [FaultRootCauseService]? = nil
    )
    {
        self.clientImpacting = clientImpacting
        self.services = services
    }
}

extension FaultRootCauseEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exceptions = "Exceptions"
        case name = "Name"
        case remote = "Remote"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exceptions = exceptions {
            var exceptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exceptions)
            for rootcauseexceptions0 in exceptions {
                try exceptionsContainer.encode(rootcauseexceptions0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remote = remote {
            try encodeContainer.encode(remote, forKey: .remote)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let exceptionsContainer = try containerValues.decodeIfPresent([RootCauseException?].self, forKey: .exceptions)
        var exceptionsDecoded0:[RootCauseException]? = nil
        if let exceptionsContainer = exceptionsContainer {
            exceptionsDecoded0 = [RootCauseException]()
            for structure0 in exceptionsContainer {
                if let structure0 = structure0 {
                    exceptionsDecoded0?.append(structure0)
                }
            }
        }
        exceptions = exceptionsDecoded0
        let remoteDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remote)
        remote = remoteDecoded
    }
}

extension FaultRootCauseEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FaultRootCauseEntity(exceptions: \(String(describing: exceptions)), name: \(String(describing: name)), remote: \(String(describing: remote)))"}
}

/// <p>A collection of segments and corresponding subsegments associated to a trace summary
///       fault error.</p>
public struct FaultRootCauseEntity: Equatable {
    /// <p>The types and messages of the exceptions.</p>
    public let exceptions: [RootCauseException]?
    /// <p>The name of the entity.</p>
    public let name: String?
    /// <p>A flag that denotes a remote subsegment.</p>
    public let remote: Bool?

    public init (
        exceptions: [RootCauseException]? = nil,
        name: String? = nil,
        remote: Bool? = nil
    )
    {
        self.exceptions = exceptions
        self.name = name
        self.remote = remote
    }
}

extension FaultRootCauseService: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case entityPath = "EntityPath"
        case inferred = "Inferred"
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let entityPath = entityPath {
            var entityPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityPath)
            for faultrootcauseentitypath0 in entityPath {
                try entityPathContainer.encode(faultrootcauseentitypath0)
            }
        }
        if let inferred = inferred {
            try encodeContainer.encode(inferred, forKey: .inferred)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for servicenames0 in names {
                try namesContainer.encode(servicenames0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let entityPathContainer = try containerValues.decodeIfPresent([FaultRootCauseEntity?].self, forKey: .entityPath)
        var entityPathDecoded0:[FaultRootCauseEntity]? = nil
        if let entityPathContainer = entityPathContainer {
            entityPathDecoded0 = [FaultRootCauseEntity]()
            for structure0 in entityPathContainer {
                if let structure0 = structure0 {
                    entityPathDecoded0?.append(structure0)
                }
            }
        }
        entityPath = entityPathDecoded0
        let inferredDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .inferred)
        inferred = inferredDecoded
    }
}

extension FaultRootCauseService: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FaultRootCauseService(accountId: \(String(describing: accountId)), entityPath: \(String(describing: entityPath)), inferred: \(String(describing: inferred)), name: \(String(describing: name)), names: \(String(describing: names)), type: \(String(describing: type)))"}
}

/// <p>A collection of fields identifying the services in a trace summary fault.</p>
public struct FaultRootCauseService: Equatable {
    /// <p>The account ID associated to the service.</p>
    public let accountId: String?
    /// <p>The path of root cause entities found on the service. </p>
    public let entityPath: [FaultRootCauseEntity]?
    /// <p>A Boolean value indicating if the service is inferred from the trace.</p>
    public let inferred: Bool?
    /// <p>The service name.</p>
    public let name: String?
    /// <p>A collection of associated service names.</p>
    public let names: [String]?
    /// <p>The type associated to the service.</p>
    public let type: String?

    public init (
        accountId: String? = nil,
        entityPath: [FaultRootCauseEntity]? = nil,
        inferred: Bool? = nil,
        name: String? = nil,
        names: [String]? = nil,
        type: String? = nil
    )
    {
        self.accountId = accountId
        self.entityPath = entityPath
        self.inferred = inferred
        self.name = name
        self.names = names
        self.type = type
    }
}

extension FaultStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case otherCount = "OtherCount"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let otherCount = otherCount {
            try encodeContainer.encode(otherCount, forKey: .otherCount)
        }
        if let totalCount = totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let otherCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .otherCount)
        otherCount = otherCountDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension FaultStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FaultStatistics(otherCount: \(String(describing: otherCount)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Information about requests that failed with a 5xx Server Error status code.</p>
public struct FaultStatistics: Equatable {
    /// <p>The number of requests that failed with untracked 5xx Server Error status
    ///       codes.</p>
    public let otherCount: Int?
    /// <p>The total number of requests that failed with a 5xx Server Error status code.</p>
    public let totalCount: Int?

    public init (
        otherCount: Int? = nil,
        totalCount: Int? = nil
    )
    {
        self.otherCount = otherCount
        self.totalCount = totalCount
    }
}

extension ForecastStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case faultCountHigh = "FaultCountHigh"
        case faultCountLow = "FaultCountLow"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let faultCountHigh = faultCountHigh {
            try encodeContainer.encode(faultCountHigh, forKey: .faultCountHigh)
        }
        if let faultCountLow = faultCountLow {
            try encodeContainer.encode(faultCountLow, forKey: .faultCountLow)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let faultCountHighDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .faultCountHigh)
        faultCountHigh = faultCountHighDecoded
        let faultCountLowDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .faultCountLow)
        faultCountLow = faultCountLowDecoded
    }
}

extension ForecastStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForecastStatistics(faultCountHigh: \(String(describing: faultCountHigh)), faultCountLow: \(String(describing: faultCountLow)))"}
}

/// <p>The predicted high and low fault count. This is used to determine if a service has
///          become anomalous and if an insight should be created.</p>
public struct ForecastStatistics: Equatable {
    /// <p>The upper limit of fault counts for a service.</p>
    public let faultCountHigh: Int?
    /// <p>The lower limit of fault counts for a service.</p>
    public let faultCountLow: Int?

    public init (
        faultCountHigh: Int? = nil,
        faultCountLow: Int? = nil
    )
    {
        self.faultCountHigh = faultCountHigh
        self.faultCountLow = faultCountLow
    }
}

extension GetEncryptionConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEncryptionConfigInput()"}
}

extension GetEncryptionConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEncryptionConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEncryptionConfigInput>
    public typealias MOutput = OperationOutput<GetEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEncryptionConfigOutputError>
}

public struct GetEncryptionConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEncryptionConfigInput>
    public typealias MOutput = OperationOutput<GetEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEncryptionConfigOutputError>
}

public struct GetEncryptionConfigInput: Equatable {

    public init() {}
}

struct GetEncryptionConfigInputBody: Equatable {
}

extension GetEncryptionConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEncryptionConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEncryptionConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEncryptionConfigOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEncryptionConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEncryptionConfigOutputResponse(encryptionConfig: \(String(describing: encryptionConfig)))"}
}

extension GetEncryptionConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEncryptionConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.encryptionConfig = output.encryptionConfig
        } else {
            self.encryptionConfig = nil
        }
    }
}

public struct GetEncryptionConfigOutputResponse: Equatable {
    /// <p>The encryption configuration document.</p>
    public let encryptionConfig: EncryptionConfig?

    public init (
        encryptionConfig: EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

struct GetEncryptionConfigOutputResponseBody: Equatable {
    public let encryptionConfig: EncryptionConfig?
}

extension GetEncryptionConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionConfig = "EncryptionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

public struct GetGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

extension GetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupInput(groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)))"}
}

extension GetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupARN = "GroupARN"
        case groupName = "GroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }
}

public struct GetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupInput>
    public typealias MOutput = OperationOutput<GetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupOutputError>
}

public struct GetGroupInput: Equatable {
    /// <p>The ARN of the group that was generated on creation.</p>
    public let groupARN: String?
    /// <p>The case-sensitive name of the group.</p>
    public let groupName: String?

    public init (
        groupARN: String? = nil,
        groupName: String? = nil
    )
    {
        self.groupARN = groupARN
        self.groupName = groupName
    }
}

struct GetGroupInputBody: Equatable {
    public let groupName: String?
    public let groupARN: String?
}

extension GetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupARN = "GroupARN"
        case groupName = "GroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
    }
}

extension GetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupOutputResponse(group: \(String(describing: group)))"}
}

extension GetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct GetGroupOutputResponse: Equatable {
    /// <p>The group that was requested. Contains the name of the group, the ARN of the group,
    ///             the filter expression, and the insight configuration assigned to the group.</p>
    public let group: Group?

    public init (
        group: Group? = nil
    )
    {
        self.group = group
    }
}

struct GetGroupOutputResponseBody: Equatable {
    public let group: Group?
}

extension GetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
    }
}

public struct GetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "GetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupsInput>
    public typealias MOutput = OperationOutput<GetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupsOutputError>
}

extension GetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupsInput(nextToken: \(String(describing: nextToken)))"}
}

extension GetGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "GetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupsInput>
    public typealias MOutput = OperationOutput<GetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupsOutputError>
}

public struct GetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGroupsInput>
    public typealias MOutput = OperationOutput<GetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGroupsOutputError>
}

public struct GetGroupsInput: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetGroupsInputBody: Equatable {
    public let nextToken: String?
}

extension GetGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGroupsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGroupsOutputResponse(groups: \(String(describing: groups)), nextToken: \(String(describing: nextToken)))"}
}

extension GetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct GetGroupsOutputResponse: Equatable {
    /// <p>The collection of all active groups.</p>
    public let groups: [GroupSummary]?
    /// <p>Pagination token.</p>
    public let nextToken: String?

    public init (
        groups: [GroupSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct GetGroupsOutputResponseBody: Equatable {
    public let groups: [GroupSummary]?
    public let nextToken: String?
}

extension GetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([GroupSummary?].self, forKey: .groups)
        var groupsDecoded0:[GroupSummary]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GroupSummary]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetInsightEventsInputBodyMiddleware: Middleware {
    public let id: String = "GetInsightEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightEventsInput>
    public typealias MOutput = OperationOutput<GetInsightEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightEventsOutputError>
}

extension GetInsightEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightEventsInput(insightId: \(String(describing: insightId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetInsightEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightId = "InsightId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetInsightEventsInputHeadersMiddleware: Middleware {
    public let id: String = "GetInsightEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightEventsInput>
    public typealias MOutput = OperationOutput<GetInsightEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightEventsOutputError>
}

public struct GetInsightEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInsightEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightEventsInput>
    public typealias MOutput = OperationOutput<GetInsightEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightEventsOutputError>
}

public struct GetInsightEventsInput: Equatable {
    /// <p>The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.</p>
    public let insightId: String?
    /// <p>Used to retrieve at most the specified value of events.</p>
    public let maxResults: Int?
    /// <p>Specify the pagination token returned by a previous request to retrieve the next page of events. </p>
    public let nextToken: String?

    public init (
        insightId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.insightId = insightId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetInsightEventsInputBody: Equatable {
    public let insightId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetInsightEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightId = "InsightId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInsightEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInsightEventsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightEventsOutputResponse(insightEvents: \(String(describing: insightEvents)), nextToken: \(String(describing: nextToken)))"}
}

extension GetInsightEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInsightEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insightEvents = output.insightEvents
            self.nextToken = output.nextToken
        } else {
            self.insightEvents = nil
            self.nextToken = nil
        }
    }
}

public struct GetInsightEventsOutputResponse: Equatable {
    /// <p>A detailed description of the event. This includes the time of the event, client and
    ///          root cause impact statistics, and the top anomalous service at the time of the
    ///          event.</p>
    public let insightEvents: [InsightEvent]?
    /// <p>Use this token to retrieve the next page of insight events.</p>
    public let nextToken: String?

    public init (
        insightEvents: [InsightEvent]? = nil,
        nextToken: String? = nil
    )
    {
        self.insightEvents = insightEvents
        self.nextToken = nextToken
    }
}

struct GetInsightEventsOutputResponseBody: Equatable {
    public let insightEvents: [InsightEvent]?
    public let nextToken: String?
}

extension GetInsightEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightEvents = "InsightEvents"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightEventsContainer = try containerValues.decodeIfPresent([InsightEvent?].self, forKey: .insightEvents)
        var insightEventsDecoded0:[InsightEvent]? = nil
        if let insightEventsContainer = insightEventsContainer {
            insightEventsDecoded0 = [InsightEvent]()
            for structure0 in insightEventsContainer {
                if let structure0 = structure0 {
                    insightEventsDecoded0?.append(structure0)
                }
            }
        }
        insightEvents = insightEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetInsightImpactGraphInputBodyMiddleware: Middleware {
    public let id: String = "GetInsightImpactGraphInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightImpactGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightImpactGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightImpactGraphInput>
    public typealias MOutput = OperationOutput<GetInsightImpactGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightImpactGraphOutputError>
}

extension GetInsightImpactGraphInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightImpactGraphInput(endTime: \(String(describing: endTime)), insightId: \(String(describing: insightId)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

extension GetInsightImpactGraphInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case insightId = "InsightId"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GetInsightImpactGraphInputHeadersMiddleware: Middleware {
    public let id: String = "GetInsightImpactGraphInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightImpactGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightImpactGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightImpactGraphInput>
    public typealias MOutput = OperationOutput<GetInsightImpactGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightImpactGraphOutputError>
}

public struct GetInsightImpactGraphInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInsightImpactGraphInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightImpactGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightImpactGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightImpactGraphInput>
    public typealias MOutput = OperationOutput<GetInsightImpactGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightImpactGraphOutputError>
}

public struct GetInsightImpactGraphInput: Equatable {
    /// <p>The estimated end time of the insight, in Unix time seconds. The EndTime is exclusive of the value provided.
    ///          The time range between the start time and end time can't be more than six hours. </p>
    public let endTime: Date?
    /// <p>The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.</p>
    public let insightId: String?
    /// <p>Specify the pagination token returned by a previous request to retrieve the next page of results. </p>
    public let nextToken: String?
    /// <p>The estimated start time of the insight, in Unix time seconds. The StartTime is inclusive of the value
    ///          provided and can't be more than 30 days old.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        insightId: String? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.insightId = insightId
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct GetInsightImpactGraphInputBody: Equatable {
    public let insightId: String?
    public let startTime: Date?
    public let endTime: Date?
    public let nextToken: String?
}

extension GetInsightImpactGraphInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case insightId = "InsightId"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInsightImpactGraphOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightImpactGraphOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInsightImpactGraphOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightImpactGraphOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightImpactGraphOutputResponse(endTime: \(String(describing: endTime)), insightId: \(String(describing: insightId)), nextToken: \(String(describing: nextToken)), serviceGraphEndTime: \(String(describing: serviceGraphEndTime)), serviceGraphStartTime: \(String(describing: serviceGraphStartTime)), services: \(String(describing: services)), startTime: \(String(describing: startTime)))"}
}

extension GetInsightImpactGraphOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInsightImpactGraphOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endTime = output.endTime
            self.insightId = output.insightId
            self.nextToken = output.nextToken
            self.serviceGraphEndTime = output.serviceGraphEndTime
            self.serviceGraphStartTime = output.serviceGraphStartTime
            self.services = output.services
            self.startTime = output.startTime
        } else {
            self.endTime = nil
            self.insightId = nil
            self.nextToken = nil
            self.serviceGraphEndTime = nil
            self.serviceGraphStartTime = nil
            self.services = nil
            self.startTime = nil
        }
    }
}

public struct GetInsightImpactGraphOutputResponse: Equatable {
    /// <p>The provided end time. </p>
    public let endTime: Date?
    /// <p>The insight's unique identifier.</p>
    public let insightId: String?
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The time, in Unix seconds, at which the service graph ended.</p>
    public let serviceGraphEndTime: Date?
    /// <p>The time, in Unix seconds, at which the service graph started.</p>
    public let serviceGraphStartTime: Date?
    /// <p>The AWS instrumented services related to the insight.</p>
    public let services: [InsightImpactGraphService]?
    /// <p>The provided start time.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        insightId: String? = nil,
        nextToken: String? = nil,
        serviceGraphEndTime: Date? = nil,
        serviceGraphStartTime: Date? = nil,
        services: [InsightImpactGraphService]? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.insightId = insightId
        self.nextToken = nextToken
        self.serviceGraphEndTime = serviceGraphEndTime
        self.serviceGraphStartTime = serviceGraphStartTime
        self.services = services
        self.startTime = startTime
    }
}

struct GetInsightImpactGraphOutputResponseBody: Equatable {
    public let insightId: String?
    public let startTime: Date?
    public let endTime: Date?
    public let serviceGraphStartTime: Date?
    public let serviceGraphEndTime: Date?
    public let services: [InsightImpactGraphService]?
    public let nextToken: String?
}

extension GetInsightImpactGraphOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case insightId = "InsightId"
        case nextToken = "NextToken"
        case serviceGraphEndTime = "ServiceGraphEndTime"
        case serviceGraphStartTime = "ServiceGraphStartTime"
        case services = "Services"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let serviceGraphStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .serviceGraphStartTime)
        serviceGraphStartTime = serviceGraphStartTimeDecoded
        let serviceGraphEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .serviceGraphEndTime)
        serviceGraphEndTime = serviceGraphEndTimeDecoded
        let servicesContainer = try containerValues.decodeIfPresent([InsightImpactGraphService?].self, forKey: .services)
        var servicesDecoded0:[InsightImpactGraphService]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [InsightImpactGraphService]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetInsightInputBodyMiddleware: Middleware {
    public let id: String = "GetInsightInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightInput>
    public typealias MOutput = OperationOutput<GetInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightOutputError>
}

extension GetInsightInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightInput(insightId: \(String(describing: insightId)))"}
}

extension GetInsightInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightId = "InsightId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
    }
}

public struct GetInsightInputHeadersMiddleware: Middleware {
    public let id: String = "GetInsightInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightInput>
    public typealias MOutput = OperationOutput<GetInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightOutputError>
}

public struct GetInsightInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInsightInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightInput>
    public typealias MOutput = OperationOutput<GetInsightOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightOutputError>
}

public struct GetInsightInput: Equatable {
    /// <p>The insight's unique identifier. Use the GetInsightSummaries action to retrieve an InsightId.</p>
    public let insightId: String?

    public init (
        insightId: String? = nil
    )
    {
        self.insightId = insightId
    }
}

struct GetInsightInputBody: Equatable {
    public let insightId: String?
}

extension GetInsightInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightId = "InsightId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
    }
}

extension GetInsightOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInsightOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightOutputResponse(insight: \(String(describing: insight)))"}
}

extension GetInsightOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInsightOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insight = output.insight
        } else {
            self.insight = nil
        }
    }
}

public struct GetInsightOutputResponse: Equatable {
    /// <p>The summary information of an insight.</p>
    public let insight: Insight?

    public init (
        insight: Insight? = nil
    )
    {
        self.insight = insight
    }
}

struct GetInsightOutputResponseBody: Equatable {
    public let insight: Insight?
}

extension GetInsightOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insight = "Insight"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightDecoded = try containerValues.decodeIfPresent(Insight.self, forKey: .insight)
        insight = insightDecoded
    }
}

public struct GetInsightSummariesInputBodyMiddleware: Middleware {
    public let id: String = "GetInsightSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightSummariesInput>
    public typealias MOutput = OperationOutput<GetInsightSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightSummariesOutputError>
}

extension GetInsightSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightSummariesInput(endTime: \(String(describing: endTime)), groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)), states: \(String(describing: states)))"}
}

extension GetInsightSummariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
        case states = "States"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for insightstatelist0 in states {
                try statesContainer.encode(insightstatelist0.rawValue)
            }
        }
    }
}

public struct GetInsightSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "GetInsightSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightSummariesInput>
    public typealias MOutput = OperationOutput<GetInsightSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightSummariesOutputError>
}

public struct GetInsightSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInsightSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightSummariesInput>
    public typealias MOutput = OperationOutput<GetInsightSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightSummariesOutputError>
}

public struct GetInsightSummariesInput: Equatable {
    /// <p>The end of the time frame in which the insights ended. The end time can't be more than 30 days old.</p>
    public let endTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the group. Required if the GroupName isn't provided.</p>
    public let groupARN: String?
    /// <p>The name of the group. Required if the GroupARN isn't provided.</p>
    public let groupName: String?
    /// <p>The maximum number of results to display.</p>
    public let maxResults: Int?
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The beginning of the time frame in which the insights started. The start time can't be more than 30 days
    ///          old.</p>
    public let startTime: Date?
    /// <p>The list of insight states. </p>
    public let states: [InsightState]?

    public init (
        endTime: Date? = nil,
        groupARN: String? = nil,
        groupName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil,
        states: [InsightState]? = nil
    )
    {
        self.endTime = endTime
        self.groupARN = groupARN
        self.groupName = groupName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
        self.states = states
    }
}

struct GetInsightSummariesInputBody: Equatable {
    public let states: [InsightState]?
    public let groupARN: String?
    public let groupName: String?
    public let startTime: Date?
    public let endTime: Date?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetInsightSummariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
        case states = "States"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statesContainer = try containerValues.decodeIfPresent([InsightState?].self, forKey: .states)
        var statesDecoded0:[InsightState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [InsightState]()
            for string0 in statesContainer {
                if let string0 = string0 {
                    statesDecoded0?.append(string0)
                }
            }
        }
        states = statesDecoded0
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetInsightSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInsightSummariesOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightSummariesOutputResponse(insightSummaries: \(String(describing: insightSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension GetInsightSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInsightSummariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insightSummaries = output.insightSummaries
            self.nextToken = output.nextToken
        } else {
            self.insightSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct GetInsightSummariesOutputResponse: Equatable {
    /// <p>The summary of each insight within the group matching the provided filters. The summary
    ///          contains the InsightID, start and end time, the root cause service, the root cause and
    ///          client impact statistics, the top anomalous services, and the status of the insight.</p>
    public let insightSummaries: [InsightSummary]?
    /// <p>Pagination token.</p>
    public let nextToken: String?

    public init (
        insightSummaries: [InsightSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.insightSummaries = insightSummaries
        self.nextToken = nextToken
    }
}

struct GetInsightSummariesOutputResponseBody: Equatable {
    public let insightSummaries: [InsightSummary]?
    public let nextToken: String?
}

extension GetInsightSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightSummaries = "InsightSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightSummariesContainer = try containerValues.decodeIfPresent([InsightSummary?].self, forKey: .insightSummaries)
        var insightSummariesDecoded0:[InsightSummary]? = nil
        if let insightSummariesContainer = insightSummariesContainer {
            insightSummariesDecoded0 = [InsightSummary]()
            for structure0 in insightSummariesContainer {
                if let structure0 = structure0 {
                    insightSummariesDecoded0?.append(structure0)
                }
            }
        }
        insightSummaries = insightSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetSamplingRulesInputBodyMiddleware: Middleware {
    public let id: String = "GetSamplingRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingRulesInput>
    public typealias MOutput = OperationOutput<GetSamplingRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingRulesOutputError>
}

extension GetSamplingRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSamplingRulesInput(nextToken: \(String(describing: nextToken)))"}
}

extension GetSamplingRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetSamplingRulesInputHeadersMiddleware: Middleware {
    public let id: String = "GetSamplingRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingRulesInput>
    public typealias MOutput = OperationOutput<GetSamplingRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingRulesOutputError>
}

public struct GetSamplingRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSamplingRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingRulesInput>
    public typealias MOutput = OperationOutput<GetSamplingRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingRulesOutputError>
}

public struct GetSamplingRulesInput: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetSamplingRulesInputBody: Equatable {
    public let nextToken: String?
}

extension GetSamplingRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSamplingRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSamplingRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSamplingRulesOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSamplingRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSamplingRulesOutputResponse(nextToken: \(String(describing: nextToken)), samplingRuleRecords: \(String(describing: samplingRuleRecords)))"}
}

extension GetSamplingRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSamplingRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.samplingRuleRecords = output.samplingRuleRecords
        } else {
            self.nextToken = nil
            self.samplingRuleRecords = nil
        }
    }
}

public struct GetSamplingRulesOutputResponse: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>Rule definitions and metadata.</p>
    public let samplingRuleRecords: [SamplingRuleRecord]?

    public init (
        nextToken: String? = nil,
        samplingRuleRecords: [SamplingRuleRecord]? = nil
    )
    {
        self.nextToken = nextToken
        self.samplingRuleRecords = samplingRuleRecords
    }
}

struct GetSamplingRulesOutputResponseBody: Equatable {
    public let samplingRuleRecords: [SamplingRuleRecord]?
    public let nextToken: String?
}

extension GetSamplingRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case samplingRuleRecords = "SamplingRuleRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleRecordsContainer = try containerValues.decodeIfPresent([SamplingRuleRecord?].self, forKey: .samplingRuleRecords)
        var samplingRuleRecordsDecoded0:[SamplingRuleRecord]? = nil
        if let samplingRuleRecordsContainer = samplingRuleRecordsContainer {
            samplingRuleRecordsDecoded0 = [SamplingRuleRecord]()
            for structure0 in samplingRuleRecordsContainer {
                if let structure0 = structure0 {
                    samplingRuleRecordsDecoded0?.append(structure0)
                }
            }
        }
        samplingRuleRecords = samplingRuleRecordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetSamplingStatisticSummariesInputBodyMiddleware: Middleware {
    public let id: String = "GetSamplingStatisticSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingStatisticSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingStatisticSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingStatisticSummariesInput>
    public typealias MOutput = OperationOutput<GetSamplingStatisticSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingStatisticSummariesOutputError>
}

extension GetSamplingStatisticSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSamplingStatisticSummariesInput(nextToken: \(String(describing: nextToken)))"}
}

extension GetSamplingStatisticSummariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetSamplingStatisticSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "GetSamplingStatisticSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingStatisticSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingStatisticSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingStatisticSummariesInput>
    public typealias MOutput = OperationOutput<GetSamplingStatisticSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingStatisticSummariesOutputError>
}

public struct GetSamplingStatisticSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSamplingStatisticSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingStatisticSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingStatisticSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingStatisticSummariesInput>
    public typealias MOutput = OperationOutput<GetSamplingStatisticSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingStatisticSummariesOutputError>
}

public struct GetSamplingStatisticSummariesInput: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct GetSamplingStatisticSummariesInputBody: Equatable {
    public let nextToken: String?
}

extension GetSamplingStatisticSummariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSamplingStatisticSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSamplingStatisticSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSamplingStatisticSummariesOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSamplingStatisticSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSamplingStatisticSummariesOutputResponse(nextToken: \(String(describing: nextToken)), samplingStatisticSummaries: \(String(describing: samplingStatisticSummaries)))"}
}

extension GetSamplingStatisticSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSamplingStatisticSummariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.samplingStatisticSummaries = output.samplingStatisticSummaries
        } else {
            self.nextToken = nil
            self.samplingStatisticSummaries = nil
        }
    }
}

public struct GetSamplingStatisticSummariesOutputResponse: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>Information about the number of requests instrumented for each sampling
    ///          rule.</p>
    public let samplingStatisticSummaries: [SamplingStatisticSummary]?

    public init (
        nextToken: String? = nil,
        samplingStatisticSummaries: [SamplingStatisticSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.samplingStatisticSummaries = samplingStatisticSummaries
    }
}

struct GetSamplingStatisticSummariesOutputResponseBody: Equatable {
    public let samplingStatisticSummaries: [SamplingStatisticSummary]?
    public let nextToken: String?
}

extension GetSamplingStatisticSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case samplingStatisticSummaries = "SamplingStatisticSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingStatisticSummariesContainer = try containerValues.decodeIfPresent([SamplingStatisticSummary?].self, forKey: .samplingStatisticSummaries)
        var samplingStatisticSummariesDecoded0:[SamplingStatisticSummary]? = nil
        if let samplingStatisticSummariesContainer = samplingStatisticSummariesContainer {
            samplingStatisticSummariesDecoded0 = [SamplingStatisticSummary]()
            for structure0 in samplingStatisticSummariesContainer {
                if let structure0 = structure0 {
                    samplingStatisticSummariesDecoded0?.append(structure0)
                }
            }
        }
        samplingStatisticSummaries = samplingStatisticSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetSamplingTargetsInputBodyMiddleware: Middleware {
    public let id: String = "GetSamplingTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingTargetsInput>
    public typealias MOutput = OperationOutput<GetSamplingTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingTargetsOutputError>
}

extension GetSamplingTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSamplingTargetsInput(samplingStatisticsDocuments: \(String(describing: samplingStatisticsDocuments)))"}
}

extension GetSamplingTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case samplingStatisticsDocuments = "SamplingStatisticsDocuments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let samplingStatisticsDocuments = samplingStatisticsDocuments {
            var samplingStatisticsDocumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samplingStatisticsDocuments)
            for samplingstatisticsdocumentlist0 in samplingStatisticsDocuments {
                try samplingStatisticsDocumentsContainer.encode(samplingstatisticsdocumentlist0)
            }
        }
    }
}

public struct GetSamplingTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSamplingTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingTargetsInput>
    public typealias MOutput = OperationOutput<GetSamplingTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingTargetsOutputError>
}

public struct GetSamplingTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSamplingTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSamplingTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSamplingTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSamplingTargetsInput>
    public typealias MOutput = OperationOutput<GetSamplingTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSamplingTargetsOutputError>
}

public struct GetSamplingTargetsInput: Equatable {
    /// <p>Information about rules that the service is using to sample requests.</p>
    public let samplingStatisticsDocuments: [SamplingStatisticsDocument]?

    public init (
        samplingStatisticsDocuments: [SamplingStatisticsDocument]? = nil
    )
    {
        self.samplingStatisticsDocuments = samplingStatisticsDocuments
    }
}

struct GetSamplingTargetsInputBody: Equatable {
    public let samplingStatisticsDocuments: [SamplingStatisticsDocument]?
}

extension GetSamplingTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case samplingStatisticsDocuments = "SamplingStatisticsDocuments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingStatisticsDocumentsContainer = try containerValues.decodeIfPresent([SamplingStatisticsDocument?].self, forKey: .samplingStatisticsDocuments)
        var samplingStatisticsDocumentsDecoded0:[SamplingStatisticsDocument]? = nil
        if let samplingStatisticsDocumentsContainer = samplingStatisticsDocumentsContainer {
            samplingStatisticsDocumentsDecoded0 = [SamplingStatisticsDocument]()
            for structure0 in samplingStatisticsDocumentsContainer {
                if let structure0 = structure0 {
                    samplingStatisticsDocumentsDecoded0?.append(structure0)
                }
            }
        }
        samplingStatisticsDocuments = samplingStatisticsDocumentsDecoded0
    }
}

extension GetSamplingTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSamplingTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSamplingTargetsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSamplingTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSamplingTargetsOutputResponse(lastRuleModification: \(String(describing: lastRuleModification)), samplingTargetDocuments: \(String(describing: samplingTargetDocuments)), unprocessedStatistics: \(String(describing: unprocessedStatistics)))"}
}

extension GetSamplingTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSamplingTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastRuleModification = output.lastRuleModification
            self.samplingTargetDocuments = output.samplingTargetDocuments
            self.unprocessedStatistics = output.unprocessedStatistics
        } else {
            self.lastRuleModification = nil
            self.samplingTargetDocuments = nil
            self.unprocessedStatistics = nil
        }
    }
}

public struct GetSamplingTargetsOutputResponse: Equatable {
    /// <p>The last time a user changed the sampling rule configuration. If
    ///          the sampling rule configuration changed since the service last retrieved it, the service
    ///          should call <a>GetSamplingRules</a> to get the latest version.</p>
    public let lastRuleModification: Date?
    /// <p>Updated rules that the service should use to sample requests.</p>
    public let samplingTargetDocuments: [SamplingTargetDocument]?
    /// <p>Information about <a>SamplingStatisticsDocument</a> that X-Ray could not
    ///          process.</p>
    public let unprocessedStatistics: [UnprocessedStatistics]?

    public init (
        lastRuleModification: Date? = nil,
        samplingTargetDocuments: [SamplingTargetDocument]? = nil,
        unprocessedStatistics: [UnprocessedStatistics]? = nil
    )
    {
        self.lastRuleModification = lastRuleModification
        self.samplingTargetDocuments = samplingTargetDocuments
        self.unprocessedStatistics = unprocessedStatistics
    }
}

struct GetSamplingTargetsOutputResponseBody: Equatable {
    public let samplingTargetDocuments: [SamplingTargetDocument]?
    public let lastRuleModification: Date?
    public let unprocessedStatistics: [UnprocessedStatistics]?
}

extension GetSamplingTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastRuleModification = "LastRuleModification"
        case samplingTargetDocuments = "SamplingTargetDocuments"
        case unprocessedStatistics = "UnprocessedStatistics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingTargetDocumentsContainer = try containerValues.decodeIfPresent([SamplingTargetDocument?].self, forKey: .samplingTargetDocuments)
        var samplingTargetDocumentsDecoded0:[SamplingTargetDocument]? = nil
        if let samplingTargetDocumentsContainer = samplingTargetDocumentsContainer {
            samplingTargetDocumentsDecoded0 = [SamplingTargetDocument]()
            for structure0 in samplingTargetDocumentsContainer {
                if let structure0 = structure0 {
                    samplingTargetDocumentsDecoded0?.append(structure0)
                }
            }
        }
        samplingTargetDocuments = samplingTargetDocumentsDecoded0
        let lastRuleModificationDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastRuleModification)
        lastRuleModification = lastRuleModificationDecoded
        let unprocessedStatisticsContainer = try containerValues.decodeIfPresent([UnprocessedStatistics?].self, forKey: .unprocessedStatistics)
        var unprocessedStatisticsDecoded0:[UnprocessedStatistics]? = nil
        if let unprocessedStatisticsContainer = unprocessedStatisticsContainer {
            unprocessedStatisticsDecoded0 = [UnprocessedStatistics]()
            for structure0 in unprocessedStatisticsContainer {
                if let structure0 = structure0 {
                    unprocessedStatisticsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedStatistics = unprocessedStatisticsDecoded0
    }
}

public struct GetServiceGraphInputBodyMiddleware: Middleware {
    public let id: String = "GetServiceGraphInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceGraphInput>
    public typealias MOutput = OperationOutput<GetServiceGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceGraphOutputError>
}

extension GetServiceGraphInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceGraphInput(endTime: \(String(describing: endTime)), groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

extension GetServiceGraphInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GetServiceGraphInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceGraphInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceGraphInput>
    public typealias MOutput = OperationOutput<GetServiceGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceGraphOutputError>
}

public struct GetServiceGraphInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceGraphInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceGraphInput>
    public typealias MOutput = OperationOutput<GetServiceGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceGraphOutputError>
}

public struct GetServiceGraphInput: Equatable {
    /// <p>The end of the timeframe for which to generate a graph.</p>
    public let endTime: Date?
    /// <p>The Amazon Resource Name (ARN) of a group based on which you want to generate a graph.</p>
    public let groupARN: String?
    /// <p>The name of a group based on which you want to generate a graph.</p>
    public let groupName: String?
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The start of the time frame for which to generate a graph.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        groupARN: String? = nil,
        groupName: String? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.groupARN = groupARN
        self.groupName = groupName
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct GetServiceGraphInputBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let groupName: String?
    public let groupARN: String?
    public let nextToken: String?
}

extension GetServiceGraphInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetServiceGraphOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceGraphOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceGraphOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceGraphOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceGraphOutputResponse(containsOldGroupVersions: \(String(describing: containsOldGroupVersions)), endTime: \(String(describing: endTime)), nextToken: \(String(describing: nextToken)), services: \(String(describing: services)), startTime: \(String(describing: startTime)))"}
}

extension GetServiceGraphOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceGraphOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.containsOldGroupVersions = output.containsOldGroupVersions
            self.endTime = output.endTime
            self.nextToken = output.nextToken
            self.services = output.services
            self.startTime = output.startTime
        } else {
            self.containsOldGroupVersions = false
            self.endTime = nil
            self.nextToken = nil
            self.services = nil
            self.startTime = nil
        }
    }
}

public struct GetServiceGraphOutputResponse: Equatable {
    /// <p>A flag indicating whether the group's filter expression has been consistent, or
    ///       if the returned service graph may show traces from an older version of the group's filter
    ///       expression.</p>
    public let containsOldGroupVersions: Bool
    /// <p>The end of the time frame for which the graph was generated.</p>
    public let endTime: Date?
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The services that have processed a traced request during the specified time
    ///       frame.</p>
    public let services: [Service]?
    /// <p>The start of the time frame for which the graph was generated.</p>
    public let startTime: Date?

    public init (
        containsOldGroupVersions: Bool = false,
        endTime: Date? = nil,
        nextToken: String? = nil,
        services: [Service]? = nil,
        startTime: Date? = nil
    )
    {
        self.containsOldGroupVersions = containsOldGroupVersions
        self.endTime = endTime
        self.nextToken = nextToken
        self.services = services
        self.startTime = startTime
    }
}

struct GetServiceGraphOutputResponseBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let services: [Service]?
    public let containsOldGroupVersions: Bool
    public let nextToken: String?
}

extension GetServiceGraphOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containsOldGroupVersions = "ContainsOldGroupVersions"
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case services = "Services"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let servicesContainer = try containerValues.decodeIfPresent([Service?].self, forKey: .services)
        var servicesDecoded0:[Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let containsOldGroupVersionsDecoded = try containerValues.decode(Bool.self, forKey: .containsOldGroupVersions)
        containsOldGroupVersions = containsOldGroupVersionsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTimeSeriesServiceStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "GetTimeSeriesServiceStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTimeSeriesServiceStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTimeSeriesServiceStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTimeSeriesServiceStatisticsInput>
    public typealias MOutput = OperationOutput<GetTimeSeriesServiceStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTimeSeriesServiceStatisticsOutputError>
}

extension GetTimeSeriesServiceStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTimeSeriesServiceStatisticsInput(endTime: \(String(describing: endTime)), entitySelectorExpression: \(String(describing: entitySelectorExpression)), forecastStatistics: \(String(describing: forecastStatistics)), groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)), nextToken: \(String(describing: nextToken)), period: \(String(describing: period)), startTime: \(String(describing: startTime)))"}
}

extension GetTimeSeriesServiceStatisticsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case entitySelectorExpression = "EntitySelectorExpression"
        case forecastStatistics = "ForecastStatistics"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case nextToken = "NextToken"
        case period = "Period"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let entitySelectorExpression = entitySelectorExpression {
            try encodeContainer.encode(entitySelectorExpression, forKey: .entitySelectorExpression)
        }
        if let forecastStatistics = forecastStatistics {
            try encodeContainer.encode(forecastStatistics, forKey: .forecastStatistics)
        }
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let period = period {
            try encodeContainer.encode(period, forKey: .period)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct GetTimeSeriesServiceStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTimeSeriesServiceStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTimeSeriesServiceStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTimeSeriesServiceStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTimeSeriesServiceStatisticsInput>
    public typealias MOutput = OperationOutput<GetTimeSeriesServiceStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTimeSeriesServiceStatisticsOutputError>
}

public struct GetTimeSeriesServiceStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTimeSeriesServiceStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTimeSeriesServiceStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTimeSeriesServiceStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTimeSeriesServiceStatisticsInput>
    public typealias MOutput = OperationOutput<GetTimeSeriesServiceStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTimeSeriesServiceStatisticsOutputError>
}

public struct GetTimeSeriesServiceStatisticsInput: Equatable {
    /// <p>The end of the time frame for which to aggregate statistics.</p>
    public let endTime: Date?
    /// <p>A filter expression defining entities that will be aggregated for statistics.
    ///             Supports ID, service, and edge functions. If no selector expression is specified, edge
    ///             statistics are returned. </p>
    public let entitySelectorExpression: String?
    /// <p>The forecasted high and low fault count values. Forecast enabled requests require the
    ///             EntitySelectorExpression ID be provided.</p>
    public let forecastStatistics: Bool?
    /// <p>The Amazon Resource Name (ARN) of the group for which to pull statistics from.</p>
    public let groupARN: String?
    /// <p>The case-sensitive name of the group for which to pull statistics from.</p>
    public let groupName: String?
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>Aggregation period in seconds.</p>
    public let period: Int?
    /// <p>The start of the time frame for which to aggregate statistics.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        entitySelectorExpression: String? = nil,
        forecastStatistics: Bool? = nil,
        groupARN: String? = nil,
        groupName: String? = nil,
        nextToken: String? = nil,
        period: Int? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.entitySelectorExpression = entitySelectorExpression
        self.forecastStatistics = forecastStatistics
        self.groupARN = groupARN
        self.groupName = groupName
        self.nextToken = nextToken
        self.period = period
        self.startTime = startTime
    }
}

struct GetTimeSeriesServiceStatisticsInputBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let groupName: String?
    public let groupARN: String?
    public let entitySelectorExpression: String?
    public let period: Int?
    public let forecastStatistics: Bool?
    public let nextToken: String?
}

extension GetTimeSeriesServiceStatisticsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case entitySelectorExpression = "EntitySelectorExpression"
        case forecastStatistics = "ForecastStatistics"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case nextToken = "NextToken"
        case period = "Period"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let entitySelectorExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entitySelectorExpression)
        entitySelectorExpression = entitySelectorExpressionDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .period)
        period = periodDecoded
        let forecastStatisticsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forecastStatistics)
        forecastStatistics = forecastStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTimeSeriesServiceStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTimeSeriesServiceStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTimeSeriesServiceStatisticsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTimeSeriesServiceStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTimeSeriesServiceStatisticsOutputResponse(containsOldGroupVersions: \(String(describing: containsOldGroupVersions)), nextToken: \(String(describing: nextToken)), timeSeriesServiceStatistics: \(String(describing: timeSeriesServiceStatistics)))"}
}

extension GetTimeSeriesServiceStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTimeSeriesServiceStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.containsOldGroupVersions = output.containsOldGroupVersions
            self.nextToken = output.nextToken
            self.timeSeriesServiceStatistics = output.timeSeriesServiceStatistics
        } else {
            self.containsOldGroupVersions = false
            self.nextToken = nil
            self.timeSeriesServiceStatistics = nil
        }
    }
}

public struct GetTimeSeriesServiceStatisticsOutputResponse: Equatable {
    /// <p>A flag indicating whether or not a group's filter expression has been consistent, or if a returned
    ///             aggregation might show statistics from an older version of the group's filter expression.</p>
    public let containsOldGroupVersions: Bool
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The collection of statistics.</p>
    public let timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]?

    public init (
        containsOldGroupVersions: Bool = false,
        nextToken: String? = nil,
        timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]? = nil
    )
    {
        self.containsOldGroupVersions = containsOldGroupVersions
        self.nextToken = nextToken
        self.timeSeriesServiceStatistics = timeSeriesServiceStatistics
    }
}

struct GetTimeSeriesServiceStatisticsOutputResponseBody: Equatable {
    public let timeSeriesServiceStatistics: [TimeSeriesServiceStatistics]?
    public let containsOldGroupVersions: Bool
    public let nextToken: String?
}

extension GetTimeSeriesServiceStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containsOldGroupVersions = "ContainsOldGroupVersions"
        case nextToken = "NextToken"
        case timeSeriesServiceStatistics = "TimeSeriesServiceStatistics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesServiceStatisticsContainer = try containerValues.decodeIfPresent([TimeSeriesServiceStatistics?].self, forKey: .timeSeriesServiceStatistics)
        var timeSeriesServiceStatisticsDecoded0:[TimeSeriesServiceStatistics]? = nil
        if let timeSeriesServiceStatisticsContainer = timeSeriesServiceStatisticsContainer {
            timeSeriesServiceStatisticsDecoded0 = [TimeSeriesServiceStatistics]()
            for structure0 in timeSeriesServiceStatisticsContainer {
                if let structure0 = structure0 {
                    timeSeriesServiceStatisticsDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesServiceStatistics = timeSeriesServiceStatisticsDecoded0
        let containsOldGroupVersionsDecoded = try containerValues.decode(Bool.self, forKey: .containsOldGroupVersions)
        containsOldGroupVersions = containsOldGroupVersionsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTraceGraphInputBodyMiddleware: Middleware {
    public let id: String = "GetTraceGraphInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTraceGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTraceGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTraceGraphInput>
    public typealias MOutput = OperationOutput<GetTraceGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTraceGraphOutputError>
}

extension GetTraceGraphInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTraceGraphInput(nextToken: \(String(describing: nextToken)), traceIds: \(String(describing: traceIds)))"}
}

extension GetTraceGraphInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case traceIds = "TraceIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let traceIds = traceIds {
            var traceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traceIds)
            for traceidlist0 in traceIds {
                try traceIdsContainer.encode(traceidlist0)
            }
        }
    }
}

public struct GetTraceGraphInputHeadersMiddleware: Middleware {
    public let id: String = "GetTraceGraphInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTraceGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTraceGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTraceGraphInput>
    public typealias MOutput = OperationOutput<GetTraceGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTraceGraphOutputError>
}

public struct GetTraceGraphInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTraceGraphInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTraceGraphInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTraceGraphOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTraceGraphInput>
    public typealias MOutput = OperationOutput<GetTraceGraphOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTraceGraphOutputError>
}

public struct GetTraceGraphInput: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>Trace IDs of requests for which to generate a service graph.</p>
    public let traceIds: [String]?

    public init (
        nextToken: String? = nil,
        traceIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.traceIds = traceIds
    }
}

struct GetTraceGraphInputBody: Equatable {
    public let traceIds: [String]?
    public let nextToken: String?
}

extension GetTraceGraphInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case traceIds = "TraceIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .traceIds)
        var traceIdsDecoded0:[String]? = nil
        if let traceIdsContainer = traceIdsContainer {
            traceIdsDecoded0 = [String]()
            for string0 in traceIdsContainer {
                if let string0 = string0 {
                    traceIdsDecoded0?.append(string0)
                }
            }
        }
        traceIds = traceIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTraceGraphOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTraceGraphOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTraceGraphOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTraceGraphOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTraceGraphOutputResponse(nextToken: \(String(describing: nextToken)), services: \(String(describing: services)))"}
}

extension GetTraceGraphOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTraceGraphOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.services = output.services
        } else {
            self.nextToken = nil
            self.services = nil
        }
    }
}

public struct GetTraceGraphOutputResponse: Equatable {
    /// <p>Pagination token.</p>
    public let nextToken: String?
    /// <p>The services that have processed one of the specified requests.</p>
    public let services: [Service]?

    public init (
        nextToken: String? = nil,
        services: [Service]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

struct GetTraceGraphOutputResponseBody: Equatable {
    public let services: [Service]?
    public let nextToken: String?
}

extension GetTraceGraphOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case services = "Services"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([Service?].self, forKey: .services)
        var servicesDecoded0:[Service]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Service]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTraceSummariesInputBodyMiddleware: Middleware {
    public let id: String = "GetTraceSummariesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTraceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTraceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTraceSummariesInput>
    public typealias MOutput = OperationOutput<GetTraceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTraceSummariesOutputError>
}

extension GetTraceSummariesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTraceSummariesInput(endTime: \(String(describing: endTime)), filterExpression: \(String(describing: filterExpression)), nextToken: \(String(describing: nextToken)), sampling: \(String(describing: sampling)), samplingStrategy: \(String(describing: samplingStrategy)), startTime: \(String(describing: startTime)), timeRangeType: \(String(describing: timeRangeType)))"}
}

extension GetTraceSummariesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case filterExpression = "FilterExpression"
        case nextToken = "NextToken"
        case sampling = "Sampling"
        case samplingStrategy = "SamplingStrategy"
        case startTime = "StartTime"
        case timeRangeType = "TimeRangeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sampling = sampling {
            try encodeContainer.encode(sampling, forKey: .sampling)
        }
        if let samplingStrategy = samplingStrategy {
            try encodeContainer.encode(samplingStrategy, forKey: .samplingStrategy)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let timeRangeType = timeRangeType {
            try encodeContainer.encode(timeRangeType.rawValue, forKey: .timeRangeType)
        }
    }
}

public struct GetTraceSummariesInputHeadersMiddleware: Middleware {
    public let id: String = "GetTraceSummariesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTraceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTraceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTraceSummariesInput>
    public typealias MOutput = OperationOutput<GetTraceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTraceSummariesOutputError>
}

public struct GetTraceSummariesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTraceSummariesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTraceSummariesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTraceSummariesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTraceSummariesInput>
    public typealias MOutput = OperationOutput<GetTraceSummariesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTraceSummariesOutputError>
}

public struct GetTraceSummariesInput: Equatable {
    /// <p>The end of the time frame for which to retrieve traces.</p>
    public let endTime: Date?
    /// <p>Specify a filter expression to retrieve trace summaries for services or requests that
    ///       meet certain requirements.</p>
    public let filterExpression: String?
    /// <p>Specify the pagination token returned by a previous request to retrieve the next page
    ///       of results.</p>
    public let nextToken: String?
    /// <p>Set to <code>true</code> to get summaries for only a subset of available
    ///       traces.</p>
    public let sampling: Bool?
    /// <p>A parameter to indicate whether to enable sampling on trace summaries. Input parameters are Name and
    ///             Value.</p>
    public let samplingStrategy: SamplingStrategy?
    /// <p>The start of the time frame for which to retrieve traces.</p>
    public let startTime: Date?
    /// <p>A parameter to indicate whether to query trace summaries by TraceId or Event time.</p>
    public let timeRangeType: TimeRangeType?

    public init (
        endTime: Date? = nil,
        filterExpression: String? = nil,
        nextToken: String? = nil,
        sampling: Bool? = nil,
        samplingStrategy: SamplingStrategy? = nil,
        startTime: Date? = nil,
        timeRangeType: TimeRangeType? = nil
    )
    {
        self.endTime = endTime
        self.filterExpression = filterExpression
        self.nextToken = nextToken
        self.sampling = sampling
        self.samplingStrategy = samplingStrategy
        self.startTime = startTime
        self.timeRangeType = timeRangeType
    }
}

struct GetTraceSummariesInputBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let timeRangeType: TimeRangeType?
    public let sampling: Bool?
    public let samplingStrategy: SamplingStrategy?
    public let filterExpression: String?
    public let nextToken: String?
}

extension GetTraceSummariesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case filterExpression = "FilterExpression"
        case nextToken = "NextToken"
        case sampling = "Sampling"
        case samplingStrategy = "SamplingStrategy"
        case startTime = "StartTime"
        case timeRangeType = "TimeRangeType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let timeRangeTypeDecoded = try containerValues.decodeIfPresent(TimeRangeType.self, forKey: .timeRangeType)
        timeRangeType = timeRangeTypeDecoded
        let samplingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .sampling)
        sampling = samplingDecoded
        let samplingStrategyDecoded = try containerValues.decodeIfPresent(SamplingStrategy.self, forKey: .samplingStrategy)
        samplingStrategy = samplingStrategyDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTraceSummariesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTraceSummariesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTraceSummariesOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTraceSummariesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTraceSummariesOutputResponse(approximateTime: \(String(describing: approximateTime)), nextToken: \(String(describing: nextToken)), traceSummaries: \(String(describing: traceSummaries)), tracesProcessedCount: \(String(describing: tracesProcessedCount)))"}
}

extension GetTraceSummariesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTraceSummariesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.approximateTime = output.approximateTime
            self.nextToken = output.nextToken
            self.traceSummaries = output.traceSummaries
            self.tracesProcessedCount = output.tracesProcessedCount
        } else {
            self.approximateTime = nil
            self.nextToken = nil
            self.traceSummaries = nil
            self.tracesProcessedCount = nil
        }
    }
}

public struct GetTraceSummariesOutputResponse: Equatable {
    /// <p>The start time of this page of results.</p>
    public let approximateTime: Date?
    /// <p>If the requested time frame contained more than one page of results, you can use this token to retrieve the
    ///       next page. The first page contains the most recent results, closest to the end of the time frame.</p>
    public let nextToken: String?
    /// <p>Trace IDs and annotations for traces that were found in the specified time
    ///       frame.</p>
    public let traceSummaries: [TraceSummary]?
    /// <p>The total number of traces processed, including traces that did not match the specified
    ///       filter expression.</p>
    public let tracesProcessedCount: Int?

    public init (
        approximateTime: Date? = nil,
        nextToken: String? = nil,
        traceSummaries: [TraceSummary]? = nil,
        tracesProcessedCount: Int? = nil
    )
    {
        self.approximateTime = approximateTime
        self.nextToken = nextToken
        self.traceSummaries = traceSummaries
        self.tracesProcessedCount = tracesProcessedCount
    }
}

struct GetTraceSummariesOutputResponseBody: Equatable {
    public let traceSummaries: [TraceSummary]?
    public let approximateTime: Date?
    public let tracesProcessedCount: Int?
    public let nextToken: String?
}

extension GetTraceSummariesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approximateTime = "ApproximateTime"
        case nextToken = "NextToken"
        case traceSummaries = "TraceSummaries"
        case tracesProcessedCount = "TracesProcessedCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceSummariesContainer = try containerValues.decodeIfPresent([TraceSummary?].self, forKey: .traceSummaries)
        var traceSummariesDecoded0:[TraceSummary]? = nil
        if let traceSummariesContainer = traceSummariesContainer {
            traceSummariesDecoded0 = [TraceSummary]()
            for structure0 in traceSummariesContainer {
                if let structure0 = structure0 {
                    traceSummariesDecoded0?.append(structure0)
                }
            }
        }
        traceSummaries = traceSummariesDecoded0
        let approximateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .approximateTime)
        approximateTime = approximateTimeDecoded
        let tracesProcessedCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tracesProcessedCount)
        tracesProcessedCount = tracesProcessedCountDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Group: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterExpression = "FilterExpression"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightsConfiguration = insightsConfiguration {
            try encodeContainer.encode(insightsConfiguration, forKey: .insightsConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let insightsConfigurationDecoded = try containerValues.decodeIfPresent(InsightsConfiguration.self, forKey: .insightsConfiguration)
        insightsConfiguration = insightsConfigurationDecoded
    }
}

extension Group: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Group(filterExpression: \(String(describing: filterExpression)), groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)), insightsConfiguration: \(String(describing: insightsConfiguration)))"}
}

/// <p>Details and metadata for a group.</p>
public struct Group: Equatable {
    /// <p>The filter expression defining the parameters to include traces.</p>
    public let filterExpression: String?
    /// <p>The Amazon Resource Name (ARN) of the group generated based on the GroupName.</p>
    public let groupARN: String?
    /// <p>The unique case-sensitive name of the group.</p>
    public let groupName: String?
    /// <p>The structure containing configurations related to insights.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The InsightsEnabled boolean can be set to true to enable insights for the
    ///                     group or false to disable insights for the group.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The NotifcationsEnabled  boolean can be set to true to enable insights
    ///                     notifications through Amazon EventBridge for the group.</p>
    ///             </li>
    ///          </ul>
    public let insightsConfiguration: InsightsConfiguration?

    public init (
        filterExpression: String? = nil,
        groupARN: String? = nil,
        groupName: String? = nil,
        insightsConfiguration: InsightsConfiguration? = nil
    )
    {
        self.filterExpression = filterExpression
        self.groupARN = groupARN
        self.groupName = groupName
        self.insightsConfiguration = insightsConfiguration
    }
}

extension GroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterExpression = "FilterExpression"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightsConfiguration = insightsConfiguration {
            try encodeContainer.encode(insightsConfiguration, forKey: .insightsConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let insightsConfigurationDecoded = try containerValues.decodeIfPresent(InsightsConfiguration.self, forKey: .insightsConfiguration)
        insightsConfiguration = insightsConfigurationDecoded
    }
}

extension GroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupSummary(filterExpression: \(String(describing: filterExpression)), groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)), insightsConfiguration: \(String(describing: insightsConfiguration)))"}
}

/// <p>Details for a group without metadata.</p>
public struct GroupSummary: Equatable {
    /// <p>The filter expression defining the parameters to include traces.</p>
    public let filterExpression: String?
    /// <p>The ARN of the group generated based on the GroupName.</p>
    public let groupARN: String?
    /// <p>The unique case-sensitive name of the group.</p>
    public let groupName: String?
    /// <p>The structure containing configurations related to insights.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The InsightsEnabled boolean can be set to true to enable insights for the
    ///                     group or false to disable insights for the group.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The NotificationsEnabled boolean can be set to true to enable insights notifications.
    ///                     Notifications can only be enabled on a group with InsightsEnabled set to true.</p>
    ///             </li>
    ///          </ul>
    public let insightsConfiguration: InsightsConfiguration?

    public init (
        filterExpression: String? = nil,
        groupARN: String? = nil,
        groupName: String? = nil,
        insightsConfiguration: InsightsConfiguration? = nil
    )
    {
        self.filterExpression = filterExpression
        self.groupARN = groupARN
        self.groupName = groupName
        self.insightsConfiguration = insightsConfiguration
    }
}

extension HistogramEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count = "Count"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
    }
}

extension HistogramEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HistogramEntry(count: \(String(describing: count)), value: \(String(describing: value)))"}
}

/// <p>An entry in a histogram for a statistic. A histogram maps the range of observed values
///       on the X axis, and the prevalence of each value on the Y axis.</p>
public struct HistogramEntry: Equatable {
    /// <p>The prevalence of the entry.</p>
    public let count: Int
    /// <p>The value of the entry.</p>
    public let value: Double

    public init (
        count: Int = 0,
        value: Double = 0.0
    )
    {
        self.count = count
        self.value = value
    }
}

extension Http: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientIp = "ClientIp"
        case httpMethod = "HttpMethod"
        case httpStatus = "HttpStatus"
        case httpURL = "HttpURL"
        case userAgent = "UserAgent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIp = clientIp {
            try encodeContainer.encode(clientIp, forKey: .clientIp)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let httpStatus = httpStatus {
            try encodeContainer.encode(httpStatus, forKey: .httpStatus)
        }
        if let httpURL = httpURL {
            try encodeContainer.encode(httpURL, forKey: .httpURL)
        }
        if let userAgent = userAgent {
            try encodeContainer.encode(userAgent, forKey: .userAgent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpURL)
        httpURL = httpURLDecoded
        let httpStatusDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .httpStatus)
        httpStatus = httpStatusDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let userAgentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userAgent)
        userAgent = userAgentDecoded
        let clientIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientIp)
        clientIp = clientIpDecoded
    }
}

extension Http: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Http(clientIp: \(String(describing: clientIp)), httpMethod: \(String(describing: httpMethod)), httpStatus: \(String(describing: httpStatus)), httpURL: \(String(describing: httpURL)), userAgent: \(String(describing: userAgent)))"}
}

/// <p>Information about an HTTP request.</p>
public struct Http: Equatable {
    /// <p>The IP address of the requestor.</p>
    public let clientIp: String?
    /// <p>The request method.</p>
    public let httpMethod: String?
    /// <p>The response status.</p>
    public let httpStatus: Int?
    /// <p>The request URL.</p>
    public let httpURL: String?
    /// <p>The request's user agent string.</p>
    public let userAgent: String?

    public init (
        clientIp: String? = nil,
        httpMethod: String? = nil,
        httpStatus: Int? = nil,
        httpURL: String? = nil,
        userAgent: String? = nil
    )
    {
        self.clientIp = clientIp
        self.httpMethod = httpMethod
        self.httpStatus = httpStatus
        self.httpURL = httpURL
        self.userAgent = userAgent
    }
}

extension Insight: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categories = "Categories"
        case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightId = "InsightId"
        case rootCauseServiceId = "RootCauseServiceId"
        case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
        case startTime = "StartTime"
        case state = "State"
        case summary = "Summary"
        case topAnomalousServices = "TopAnomalousServices"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for insightcategorylist0 in categories {
                try categoriesContainer.encode(insightcategorylist0.rawValue)
            }
        }
        if let clientRequestImpactStatistics = clientRequestImpactStatistics {
            try encodeContainer.encode(clientRequestImpactStatistics, forKey: .clientRequestImpactStatistics)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let rootCauseServiceId = rootCauseServiceId {
            try encodeContainer.encode(rootCauseServiceId, forKey: .rootCauseServiceId)
        }
        if let rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics {
            try encodeContainer.encode(rootCauseServiceRequestImpactStatistics, forKey: .rootCauseServiceRequestImpactStatistics)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let topAnomalousServices = topAnomalousServices {
            var topAnomalousServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topAnomalousServices)
            for anomalousservicelist0 in topAnomalousServices {
                try topAnomalousServicesContainer.encode(anomalousservicelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let rootCauseServiceIdDecoded = try containerValues.decodeIfPresent(ServiceId.self, forKey: .rootCauseServiceId)
        rootCauseServiceId = rootCauseServiceIdDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([InsightCategory?].self, forKey: .categories)
        var categoriesDecoded0:[InsightCategory]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [InsightCategory]()
            for string0 in categoriesContainer {
                if let string0 = string0 {
                    categoriesDecoded0?.append(string0)
                }
            }
        }
        categories = categoriesDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(InsightState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let clientRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(RequestImpactStatistics.self, forKey: .clientRequestImpactStatistics)
        clientRequestImpactStatistics = clientRequestImpactStatisticsDecoded
        let rootCauseServiceRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(RequestImpactStatistics.self, forKey: .rootCauseServiceRequestImpactStatistics)
        rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatisticsDecoded
        let topAnomalousServicesContainer = try containerValues.decodeIfPresent([AnomalousService?].self, forKey: .topAnomalousServices)
        var topAnomalousServicesDecoded0:[AnomalousService]? = nil
        if let topAnomalousServicesContainer = topAnomalousServicesContainer {
            topAnomalousServicesDecoded0 = [AnomalousService]()
            for structure0 in topAnomalousServicesContainer {
                if let structure0 = structure0 {
                    topAnomalousServicesDecoded0?.append(structure0)
                }
            }
        }
        topAnomalousServices = topAnomalousServicesDecoded0
    }
}

extension Insight: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Insight(categories: \(String(describing: categories)), clientRequestImpactStatistics: \(String(describing: clientRequestImpactStatistics)), endTime: \(String(describing: endTime)), groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)), insightId: \(String(describing: insightId)), rootCauseServiceId: \(String(describing: rootCauseServiceId)), rootCauseServiceRequestImpactStatistics: \(String(describing: rootCauseServiceRequestImpactStatistics)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), summary: \(String(describing: summary)), topAnomalousServices: \(String(describing: topAnomalousServices)))"}
}

/// <p>When fault rates go outside of the expected range, X-Ray creates an insight. Insights
///          tracks emergent issues within your applications.</p>
public struct Insight: Equatable {
    /// <p>The categories that label and describe the type of insight.</p>
    public let categories: [InsightCategory]?
    /// <p>The impact statistics of the client side service. This includes the number of requests to the client service
    ///          and whether the requests were faults or okay.</p>
    public let clientRequestImpactStatistics: RequestImpactStatistics?
    /// <p>The time, in Unix seconds, at which the insight ended.</p>
    public let endTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the group that the insight belongs to.</p>
    public let groupARN: String?
    /// <p>The name of the group  that the insight belongs to.</p>
    public let groupName: String?
    /// <p>The insights unique identifier. </p>
    public let insightId: String?
    /// <p></p>
    public let rootCauseServiceId: ServiceId?
    /// <p>The impact statistics of the root cause service. This includes the number of requests to the client service
    ///          and whether the requests were faults or okay.</p>
    public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
    /// <p>The time, in Unix seconds, at which the insight began.</p>
    public let startTime: Date?
    /// <p>The current state of the insight.</p>
    public let state: InsightState?
    /// <p>A brief description of the insight.</p>
    public let summary: String?
    /// <p>The service within the insight that is most impacted by the incident.</p>
    public let topAnomalousServices: [AnomalousService]?

    public init (
        categories: [InsightCategory]? = nil,
        clientRequestImpactStatistics: RequestImpactStatistics? = nil,
        endTime: Date? = nil,
        groupARN: String? = nil,
        groupName: String? = nil,
        insightId: String? = nil,
        rootCauseServiceId: ServiceId? = nil,
        rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil,
        startTime: Date? = nil,
        state: InsightState? = nil,
        summary: String? = nil,
        topAnomalousServices: [AnomalousService]? = nil
    )
    {
        self.categories = categories
        self.clientRequestImpactStatistics = clientRequestImpactStatistics
        self.endTime = endTime
        self.groupARN = groupARN
        self.groupName = groupName
        self.insightId = insightId
        self.rootCauseServiceId = rootCauseServiceId
        self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
        self.startTime = startTime
        self.state = state
        self.summary = summary
        self.topAnomalousServices = topAnomalousServices
    }
}

public enum InsightCategory {
    case fault
    case sdkUnknown(String)
}

extension InsightCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InsightCategory] {
        return [
            .fault,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fault: return "FAULT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InsightCategory(rawValue: rawValue) ?? InsightCategory.sdkUnknown(rawValue)
    }
}

extension InsightEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
        case eventTime = "EventTime"
        case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
        case summary = "Summary"
        case topAnomalousServices = "TopAnomalousServices"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestImpactStatistics = clientRequestImpactStatistics {
            try encodeContainer.encode(clientRequestImpactStatistics, forKey: .clientRequestImpactStatistics)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics {
            try encodeContainer.encode(rootCauseServiceRequestImpactStatistics, forKey: .rootCauseServiceRequestImpactStatistics)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let topAnomalousServices = topAnomalousServices {
            var topAnomalousServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topAnomalousServices)
            for anomalousservicelist0 in topAnomalousServices {
                try topAnomalousServicesContainer.encode(anomalousservicelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let clientRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(RequestImpactStatistics.self, forKey: .clientRequestImpactStatistics)
        clientRequestImpactStatistics = clientRequestImpactStatisticsDecoded
        let rootCauseServiceRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(RequestImpactStatistics.self, forKey: .rootCauseServiceRequestImpactStatistics)
        rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatisticsDecoded
        let topAnomalousServicesContainer = try containerValues.decodeIfPresent([AnomalousService?].self, forKey: .topAnomalousServices)
        var topAnomalousServicesDecoded0:[AnomalousService]? = nil
        if let topAnomalousServicesContainer = topAnomalousServicesContainer {
            topAnomalousServicesDecoded0 = [AnomalousService]()
            for structure0 in topAnomalousServicesContainer {
                if let structure0 = structure0 {
                    topAnomalousServicesDecoded0?.append(structure0)
                }
            }
        }
        topAnomalousServices = topAnomalousServicesDecoded0
    }
}

extension InsightEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightEvent(clientRequestImpactStatistics: \(String(describing: clientRequestImpactStatistics)), eventTime: \(String(describing: eventTime)), rootCauseServiceRequestImpactStatistics: \(String(describing: rootCauseServiceRequestImpactStatistics)), summary: \(String(describing: summary)), topAnomalousServices: \(String(describing: topAnomalousServices)))"}
}

/// <p>X-Ray reevaluates insights periodically until they are resolved, and records each intermediate state in an
///          event. You can review incident events in the Impact Timeline on the Inspect page in the X-Ray console.</p>
public struct InsightEvent: Equatable {
    /// <p>The impact statistics of the client side service. This includes the number of requests to the client service
    ///          and whether the requests were faults or okay.</p>
    public let clientRequestImpactStatistics: RequestImpactStatistics?
    /// <p>The time, in Unix seconds, at which the event was recorded.</p>
    public let eventTime: Date?
    /// <p>The impact statistics of the root cause service. This includes the number of requests to the client service
    ///          and whether the requests were faults or okay.</p>
    public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
    /// <p>A brief description of the event.</p>
    public let summary: String?
    /// <p>The service during the event that is most impacted by the incident.</p>
    public let topAnomalousServices: [AnomalousService]?

    public init (
        clientRequestImpactStatistics: RequestImpactStatistics? = nil,
        eventTime: Date? = nil,
        rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil,
        summary: String? = nil,
        topAnomalousServices: [AnomalousService]? = nil
    )
    {
        self.clientRequestImpactStatistics = clientRequestImpactStatistics
        self.eventTime = eventTime
        self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
        self.summary = summary
        self.topAnomalousServices = topAnomalousServices
    }
}

extension InsightImpactGraphEdge: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case referenceId = "ReferenceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
    }
}

extension InsightImpactGraphEdge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightImpactGraphEdge(referenceId: \(String(describing: referenceId)))"}
}

/// <p>The connection between two service in an insight impact graph.</p>
public struct InsightImpactGraphEdge: Equatable {
    /// <p>Identifier of the edge. Unique within a service map.</p>
    public let referenceId: Int?

    public init (
        referenceId: Int? = nil
    )
    {
        self.referenceId = referenceId
    }
}

extension InsightImpactGraphService: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case edges = "Edges"
        case name = "Name"
        case names = "Names"
        case referenceId = "ReferenceId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let edges = edges {
            var edgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edges)
            for insightimpactgraphedgelist0 in edges {
                try edgesContainer.encode(insightimpactgraphedgelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for servicenames0 in names {
                try namesContainer.encode(servicenames0)
            }
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let edgesContainer = try containerValues.decodeIfPresent([InsightImpactGraphEdge?].self, forKey: .edges)
        var edgesDecoded0:[InsightImpactGraphEdge]? = nil
        if let edgesContainer = edgesContainer {
            edgesDecoded0 = [InsightImpactGraphEdge]()
            for structure0 in edgesContainer {
                if let structure0 = structure0 {
                    edgesDecoded0?.append(structure0)
                }
            }
        }
        edges = edgesDecoded0
    }
}

extension InsightImpactGraphService: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightImpactGraphService(accountId: \(String(describing: accountId)), edges: \(String(describing: edges)), name: \(String(describing: name)), names: \(String(describing: names)), referenceId: \(String(describing: referenceId)), type: \(String(describing: type)))"}
}

/// <p>Information about an application that processed requests, users that made requests, or downstream services,
///          resources, and applications that an application used. </p>
public struct InsightImpactGraphService: Equatable {
    /// <p>Identifier of the AWS account in which the service runs.</p>
    public let accountId: String?
    /// <p>Connections to downstream services.</p>
    public let edges: [InsightImpactGraphEdge]?
    /// <p>The canonical name of the service.</p>
    public let name: String?
    /// <p>A list of names for the service, including the canonical name.</p>
    public let names: [String]?
    /// <p>Identifier for the service. Unique within the service map.</p>
    public let referenceId: Int?
    /// <p>Identifier for the service. Unique within the service map.</p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS Resource - The type of an AWS resource. For example, AWS::EC2::Instance for an application running
    ///                on Amazon EC2 or AWS::DynamoDB::Table for an Amazon DynamoDB table that the application used. </p>
    ///             </li>
    ///             <li>
    ///                <p>AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon
    ///                DynamoDB that didn't target a specific table. </p>
    ///             </li>
    ///             <li>
    ///                <p>AWS Service - The type of an AWS service. For example, AWS::DynamoDB for downstream calls to Amazon
    ///                DynamoDB that didn't target a specific table. </p>
    ///             </li>
    ///             <li>
    ///                <p>remote - A downstream service of indeterminate type.</p>
    ///             </li>
    ///          </ul>
    public let type: String?

    public init (
        accountId: String? = nil,
        edges: [InsightImpactGraphEdge]? = nil,
        name: String? = nil,
        names: [String]? = nil,
        referenceId: Int? = nil,
        type: String? = nil
    )
    {
        self.accountId = accountId
        self.edges = edges
        self.name = name
        self.names = names
        self.referenceId = referenceId
        self.type = type
    }
}

public enum InsightState {
    case active
    case closed
    case sdkUnknown(String)
}

extension InsightState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InsightState] {
        return [
            .active,
            .closed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .closed: return "CLOSED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InsightState(rawValue: rawValue) ?? InsightState.sdkUnknown(rawValue)
    }
}

extension InsightSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categories = "Categories"
        case clientRequestImpactStatistics = "ClientRequestImpactStatistics"
        case endTime = "EndTime"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightId = "InsightId"
        case lastUpdateTime = "LastUpdateTime"
        case rootCauseServiceId = "RootCauseServiceId"
        case rootCauseServiceRequestImpactStatistics = "RootCauseServiceRequestImpactStatistics"
        case startTime = "StartTime"
        case state = "State"
        case summary = "Summary"
        case topAnomalousServices = "TopAnomalousServices"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categories = categories {
            var categoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categories)
            for insightcategorylist0 in categories {
                try categoriesContainer.encode(insightcategorylist0.rawValue)
            }
        }
        if let clientRequestImpactStatistics = clientRequestImpactStatistics {
            try encodeContainer.encode(clientRequestImpactStatistics, forKey: .clientRequestImpactStatistics)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightId = insightId {
            try encodeContainer.encode(insightId, forKey: .insightId)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let rootCauseServiceId = rootCauseServiceId {
            try encodeContainer.encode(rootCauseServiceId, forKey: .rootCauseServiceId)
        }
        if let rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics {
            try encodeContainer.encode(rootCauseServiceRequestImpactStatistics, forKey: .rootCauseServiceRequestImpactStatistics)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let topAnomalousServices = topAnomalousServices {
            var topAnomalousServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topAnomalousServices)
            for anomalousservicelist0 in topAnomalousServices {
                try topAnomalousServicesContainer.encode(anomalousservicelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insightId)
        insightId = insightIdDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let rootCauseServiceIdDecoded = try containerValues.decodeIfPresent(ServiceId.self, forKey: .rootCauseServiceId)
        rootCauseServiceId = rootCauseServiceIdDecoded
        let categoriesContainer = try containerValues.decodeIfPresent([InsightCategory?].self, forKey: .categories)
        var categoriesDecoded0:[InsightCategory]? = nil
        if let categoriesContainer = categoriesContainer {
            categoriesDecoded0 = [InsightCategory]()
            for string0 in categoriesContainer {
                if let string0 = string0 {
                    categoriesDecoded0?.append(string0)
                }
            }
        }
        categories = categoriesDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(InsightState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let clientRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(RequestImpactStatistics.self, forKey: .clientRequestImpactStatistics)
        clientRequestImpactStatistics = clientRequestImpactStatisticsDecoded
        let rootCauseServiceRequestImpactStatisticsDecoded = try containerValues.decodeIfPresent(RequestImpactStatistics.self, forKey: .rootCauseServiceRequestImpactStatistics)
        rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatisticsDecoded
        let topAnomalousServicesContainer = try containerValues.decodeIfPresent([AnomalousService?].self, forKey: .topAnomalousServices)
        var topAnomalousServicesDecoded0:[AnomalousService]? = nil
        if let topAnomalousServicesContainer = topAnomalousServicesContainer {
            topAnomalousServicesDecoded0 = [AnomalousService]()
            for structure0 in topAnomalousServicesContainer {
                if let structure0 = structure0 {
                    topAnomalousServicesDecoded0?.append(structure0)
                }
            }
        }
        topAnomalousServices = topAnomalousServicesDecoded0
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
    }
}

extension InsightSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightSummary(categories: \(String(describing: categories)), clientRequestImpactStatistics: \(String(describing: clientRequestImpactStatistics)), endTime: \(String(describing: endTime)), groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)), insightId: \(String(describing: insightId)), lastUpdateTime: \(String(describing: lastUpdateTime)), rootCauseServiceId: \(String(describing: rootCauseServiceId)), rootCauseServiceRequestImpactStatistics: \(String(describing: rootCauseServiceRequestImpactStatistics)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), summary: \(String(describing: summary)), topAnomalousServices: \(String(describing: topAnomalousServices)))"}
}

/// <p>Information that describes an insight.</p>
public struct InsightSummary: Equatable {
    /// <p> Categories The categories that label and describe the type of insight.</p>
    public let categories: [InsightCategory]?
    /// <p>The impact statistics of the client side service. This includes the number of requests
    ///          to the client service and whether the requests were faults or okay. </p>
    public let clientRequestImpactStatistics: RequestImpactStatistics?
    /// <p>The time, in Unix seconds, at which the insight ended.</p>
    public let endTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the group that the insight belongs to.</p>
    public let groupARN: String?
    /// <p>The name of the group  that the insight belongs to.</p>
    public let groupName: String?
    /// <p>The insights unique identifier. </p>
    public let insightId: String?
    /// <p>The time, in Unix seconds, that the insight was last updated.</p>
    public let lastUpdateTime: Date?
    /// <p></p>
    public let rootCauseServiceId: ServiceId?
    /// <p>The impact statistics of the root cause service. This includes the number of requests to
    ///          the client service and whether the requests were faults or okay. </p>
    public let rootCauseServiceRequestImpactStatistics: RequestImpactStatistics?
    /// <p>The time, in Unix seconds, at which the insight began.</p>
    public let startTime: Date?
    /// <p>The current state of the insight.</p>
    public let state: InsightState?
    /// <p>A brief description of the insight.</p>
    public let summary: String?
    /// <p>The service within the insight that is most impacted by the incident.</p>
    public let topAnomalousServices: [AnomalousService]?

    public init (
        categories: [InsightCategory]? = nil,
        clientRequestImpactStatistics: RequestImpactStatistics? = nil,
        endTime: Date? = nil,
        groupARN: String? = nil,
        groupName: String? = nil,
        insightId: String? = nil,
        lastUpdateTime: Date? = nil,
        rootCauseServiceId: ServiceId? = nil,
        rootCauseServiceRequestImpactStatistics: RequestImpactStatistics? = nil,
        startTime: Date? = nil,
        state: InsightState? = nil,
        summary: String? = nil,
        topAnomalousServices: [AnomalousService]? = nil
    )
    {
        self.categories = categories
        self.clientRequestImpactStatistics = clientRequestImpactStatistics
        self.endTime = endTime
        self.groupARN = groupARN
        self.groupName = groupName
        self.insightId = insightId
        self.lastUpdateTime = lastUpdateTime
        self.rootCauseServiceId = rootCauseServiceId
        self.rootCauseServiceRequestImpactStatistics = rootCauseServiceRequestImpactStatistics
        self.startTime = startTime
        self.state = state
        self.summary = summary
        self.topAnomalousServices = topAnomalousServices
    }
}

extension InsightsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightsEnabled = "InsightsEnabled"
        case notificationsEnabled = "NotificationsEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightsEnabled = insightsEnabled {
            try encodeContainer.encode(insightsEnabled, forKey: .insightsEnabled)
        }
        if let notificationsEnabled = notificationsEnabled {
            try encodeContainer.encode(notificationsEnabled, forKey: .notificationsEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .insightsEnabled)
        insightsEnabled = insightsEnabledDecoded
        let notificationsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .notificationsEnabled)
        notificationsEnabled = notificationsEnabledDecoded
    }
}

extension InsightsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightsConfiguration(insightsEnabled: \(String(describing: insightsEnabled)), notificationsEnabled: \(String(describing: notificationsEnabled)))"}
}

/// <p>The structure containing configurations related to insights.</p>
public struct InsightsConfiguration: Equatable {
    /// <p>Set the InsightsEnabled value to true to enable insights or false to disable
    ///             insights.</p>
    public let insightsEnabled: Bool?
    /// <p>Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be
    ///             enabled on a group with InsightsEnabled set to true.</p>
    public let notificationsEnabled: Bool?

    public init (
        insightsEnabled: Bool? = nil,
        notificationsEnabled: Bool? = nil
    )
    {
        self.insightsEnabled = insightsEnabled
        self.notificationsEnabled = notificationsEnabled
    }
}

extension InstanceIdDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension InstanceIdDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceIdDetail(id: \(String(describing: id)))"}
}

/// <p>A list of EC2 instance IDs corresponding to the segments in a trace. </p>
public struct InstanceIdDetail: Equatable {
    /// <p>The ID of a corresponding EC2 instance.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is missing required parameters or has invalid parameters.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(nextToken: \(String(describing: nextToken)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>A pagination token. If multiple pages of results are returned, use the <code>NextToken</code> value returned with
    ///     the current page of results as the value of this parameter to get the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.</p>
    public let resourceARN: String?

    public init (
        nextToken: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A pagination token. If multiple pages of results are returned, use the <code>NextToken</code> value returned with
    ///       the current page of results to get the next page of results.</p>
    public let nextToken: String?
    /// <p>A list of tags, as key and value pairs, that is associated with the specified X-Ray group or sampling rule.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct PutEncryptionConfigInputBodyMiddleware: Middleware {
    public let id: String = "PutEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEncryptionConfigInput>
    public typealias MOutput = OperationOutput<PutEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEncryptionConfigOutputError>
}

extension PutEncryptionConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEncryptionConfigInput(keyId: \(String(describing: keyId)), type: \(String(describing: type)))"}
}

extension PutEncryptionConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct PutEncryptionConfigInputHeadersMiddleware: Middleware {
    public let id: String = "PutEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEncryptionConfigInput>
    public typealias MOutput = OperationOutput<PutEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEncryptionConfigOutputError>
}

public struct PutEncryptionConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEncryptionConfigInput>
    public typealias MOutput = OperationOutput<PutEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEncryptionConfigOutputError>
}

public struct PutEncryptionConfigInput: Equatable {
    /// <p>An AWS KMS customer master key (CMK) in one of the following formats:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Alias</b> - The name of the key. For example,
    ///             <code>alias/MyKey</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Key ID</b> - The KMS key ID of the key. For example,
    ///           <code>ae4aa6d49-a4d8-9df9-a475-4ff6d7898456</code>. AWS X-Ray does not support asymmetric CMKs.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>ARN</b> - The full Amazon Resource Name of the key ID or alias.
    ///           For example,
    ///             <code>arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456</code>.
    ///           Use this format to specify a key in a different account.</p>
    ///             </li>
    ///          </ul>
    ///          <p>Omit this key if you set <code>Type</code> to <code>NONE</code>.</p>
    public let keyId: String?
    /// <p>The type of encryption. Set to <code>KMS</code> to use your own key for encryption. Set
    ///       to <code>NONE</code> for default encryption.</p>
    public let type: EncryptionType?

    public init (
        keyId: String? = nil,
        type: EncryptionType? = nil
    )
    {
        self.keyId = keyId
        self.type = type
    }
}

struct PutEncryptionConfigInputBody: Equatable {
    public let keyId: String?
    public let type: EncryptionType?
}

extension PutEncryptionConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyId = "KeyId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EncryptionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension PutEncryptionConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEncryptionConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEncryptionConfigOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEncryptionConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEncryptionConfigOutputResponse(encryptionConfig: \(String(describing: encryptionConfig)))"}
}

extension PutEncryptionConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutEncryptionConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.encryptionConfig = output.encryptionConfig
        } else {
            self.encryptionConfig = nil
        }
    }
}

public struct PutEncryptionConfigOutputResponse: Equatable {
    /// <p>The new encryption configuration.</p>
    public let encryptionConfig: EncryptionConfig?

    public init (
        encryptionConfig: EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

struct PutEncryptionConfigOutputResponseBody: Equatable {
    public let encryptionConfig: EncryptionConfig?
}

extension PutEncryptionConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case encryptionConfig = "EncryptionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

public struct PutTelemetryRecordsInputBodyMiddleware: Middleware {
    public let id: String = "PutTelemetryRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTelemetryRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTelemetryRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTelemetryRecordsInput>
    public typealias MOutput = OperationOutput<PutTelemetryRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTelemetryRecordsOutputError>
}

extension PutTelemetryRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutTelemetryRecordsInput(eC2InstanceId: \(String(describing: eC2InstanceId)), hostname: \(String(describing: hostname)), resourceARN: \(String(describing: resourceARN)), telemetryRecords: \(String(describing: telemetryRecords)))"}
}

extension PutTelemetryRecordsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eC2InstanceId = "EC2InstanceId"
        case hostname = "Hostname"
        case resourceARN = "ResourceARN"
        case telemetryRecords = "TelemetryRecords"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2InstanceId = eC2InstanceId {
            try encodeContainer.encode(eC2InstanceId, forKey: .eC2InstanceId)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let telemetryRecords = telemetryRecords {
            var telemetryRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .telemetryRecords)
            for telemetryrecordlist0 in telemetryRecords {
                try telemetryRecordsContainer.encode(telemetryrecordlist0)
            }
        }
    }
}

public struct PutTelemetryRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "PutTelemetryRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTelemetryRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTelemetryRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTelemetryRecordsInput>
    public typealias MOutput = OperationOutput<PutTelemetryRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTelemetryRecordsOutputError>
}

public struct PutTelemetryRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutTelemetryRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTelemetryRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTelemetryRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTelemetryRecordsInput>
    public typealias MOutput = OperationOutput<PutTelemetryRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTelemetryRecordsOutputError>
}

public struct PutTelemetryRecordsInput: Equatable {
    /// <p></p>
    public let eC2InstanceId: String?
    /// <p></p>
    public let hostname: String?
    /// <p></p>
    public let resourceARN: String?
    /// <p></p>
    public let telemetryRecords: [TelemetryRecord]?

    public init (
        eC2InstanceId: String? = nil,
        hostname: String? = nil,
        resourceARN: String? = nil,
        telemetryRecords: [TelemetryRecord]? = nil
    )
    {
        self.eC2InstanceId = eC2InstanceId
        self.hostname = hostname
        self.resourceARN = resourceARN
        self.telemetryRecords = telemetryRecords
    }
}

struct PutTelemetryRecordsInputBody: Equatable {
    public let telemetryRecords: [TelemetryRecord]?
    public let eC2InstanceId: String?
    public let hostname: String?
    public let resourceARN: String?
}

extension PutTelemetryRecordsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eC2InstanceId = "EC2InstanceId"
        case hostname = "Hostname"
        case resourceARN = "ResourceARN"
        case telemetryRecords = "TelemetryRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryRecordsContainer = try containerValues.decodeIfPresent([TelemetryRecord?].self, forKey: .telemetryRecords)
        var telemetryRecordsDecoded0:[TelemetryRecord]? = nil
        if let telemetryRecordsContainer = telemetryRecordsContainer {
            telemetryRecordsDecoded0 = [TelemetryRecord]()
            for structure0 in telemetryRecordsContainer {
                if let structure0 = structure0 {
                    telemetryRecordsDecoded0?.append(structure0)
                }
            }
        }
        telemetryRecords = telemetryRecordsDecoded0
        let eC2InstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eC2InstanceId)
        eC2InstanceId = eC2InstanceIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension PutTelemetryRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutTelemetryRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutTelemetryRecordsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutTelemetryRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutTelemetryRecordsOutputResponse()"}
}

extension PutTelemetryRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutTelemetryRecordsOutputResponse: Equatable {

    public init() {}
}

struct PutTelemetryRecordsOutputResponseBody: Equatable {
}

extension PutTelemetryRecordsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutTraceSegmentsInputBodyMiddleware: Middleware {
    public let id: String = "PutTraceSegmentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTraceSegmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTraceSegmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTraceSegmentsInput>
    public typealias MOutput = OperationOutput<PutTraceSegmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTraceSegmentsOutputError>
}

extension PutTraceSegmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutTraceSegmentsInput(traceSegmentDocuments: \(String(describing: traceSegmentDocuments)))"}
}

extension PutTraceSegmentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case traceSegmentDocuments = "TraceSegmentDocuments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let traceSegmentDocuments = traceSegmentDocuments {
            var traceSegmentDocumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .traceSegmentDocuments)
            for tracesegmentdocumentlist0 in traceSegmentDocuments {
                try traceSegmentDocumentsContainer.encode(tracesegmentdocumentlist0)
            }
        }
    }
}

public struct PutTraceSegmentsInputHeadersMiddleware: Middleware {
    public let id: String = "PutTraceSegmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTraceSegmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTraceSegmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTraceSegmentsInput>
    public typealias MOutput = OperationOutput<PutTraceSegmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTraceSegmentsOutputError>
}

public struct PutTraceSegmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutTraceSegmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTraceSegmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTraceSegmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTraceSegmentsInput>
    public typealias MOutput = OperationOutput<PutTraceSegmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTraceSegmentsOutputError>
}

public struct PutTraceSegmentsInput: Equatable {
    /// <p>A string containing a JSON document defining one or more segments or
    ///       subsegments.</p>
    public let traceSegmentDocuments: [String]?

    public init (
        traceSegmentDocuments: [String]? = nil
    )
    {
        self.traceSegmentDocuments = traceSegmentDocuments
    }
}

struct PutTraceSegmentsInputBody: Equatable {
    public let traceSegmentDocuments: [String]?
}

extension PutTraceSegmentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case traceSegmentDocuments = "TraceSegmentDocuments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let traceSegmentDocumentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .traceSegmentDocuments)
        var traceSegmentDocumentsDecoded0:[String]? = nil
        if let traceSegmentDocumentsContainer = traceSegmentDocumentsContainer {
            traceSegmentDocumentsDecoded0 = [String]()
            for string0 in traceSegmentDocumentsContainer {
                if let string0 = string0 {
                    traceSegmentDocumentsDecoded0?.append(string0)
                }
            }
        }
        traceSegmentDocuments = traceSegmentDocumentsDecoded0
    }
}

extension PutTraceSegmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutTraceSegmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutTraceSegmentsOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutTraceSegmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutTraceSegmentsOutputResponse(unprocessedTraceSegments: \(String(describing: unprocessedTraceSegments)))"}
}

extension PutTraceSegmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutTraceSegmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedTraceSegments = output.unprocessedTraceSegments
        } else {
            self.unprocessedTraceSegments = nil
        }
    }
}

public struct PutTraceSegmentsOutputResponse: Equatable {
    /// <p>Segments that failed processing.</p>
    public let unprocessedTraceSegments: [UnprocessedTraceSegment]?

    public init (
        unprocessedTraceSegments: [UnprocessedTraceSegment]? = nil
    )
    {
        self.unprocessedTraceSegments = unprocessedTraceSegments
    }
}

struct PutTraceSegmentsOutputResponseBody: Equatable {
    public let unprocessedTraceSegments: [UnprocessedTraceSegment]?
}

extension PutTraceSegmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedTraceSegments = "UnprocessedTraceSegments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedTraceSegmentsContainer = try containerValues.decodeIfPresent([UnprocessedTraceSegment?].self, forKey: .unprocessedTraceSegments)
        var unprocessedTraceSegmentsDecoded0:[UnprocessedTraceSegment]? = nil
        if let unprocessedTraceSegmentsContainer = unprocessedTraceSegmentsContainer {
            unprocessedTraceSegmentsDecoded0 = [UnprocessedTraceSegment]()
            for structure0 in unprocessedTraceSegmentsContainer {
                if let structure0 = structure0 {
                    unprocessedTraceSegmentsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedTraceSegments = unprocessedTraceSegmentsDecoded0
    }
}

extension RequestImpactStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case faultCount = "FaultCount"
        case okCount = "OkCount"
        case totalCount = "TotalCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let faultCount = faultCount {
            try encodeContainer.encode(faultCount, forKey: .faultCount)
        }
        if let okCount = okCount {
            try encodeContainer.encode(okCount, forKey: .okCount)
        }
        if let totalCount = totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let faultCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .faultCount)
        faultCount = faultCountDecoded
        let okCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .okCount)
        okCount = okCountDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension RequestImpactStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestImpactStatistics(faultCount: \(String(describing: faultCount)), okCount: \(String(describing: okCount)), totalCount: \(String(describing: totalCount)))"}
}

/// <p>Statistics that describe how the incident has impacted a service.</p>
public struct RequestImpactStatistics: Equatable {
    /// <p>The number of requests that have resulted in a fault,</p>
    public let faultCount: Int?
    /// <p>The number of successful requests.</p>
    public let okCount: Int?
    /// <p>The total number of requests to the service.</p>
    public let totalCount: Int?

    public init (
        faultCount: Int? = nil,
        okCount: Int? = nil,
        totalCount: Int? = nil
    )
    {
        self.faultCount = faultCount
        self.okCount = okCount
        self.totalCount = totalCount
    }
}

extension ResourceARNDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension ResourceARNDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceARNDetail(aRN: \(String(describing: aRN)))"}
}

/// <p>A list of resources ARNs corresponding to the segments in a trace.</p>
public struct ResourceARNDetail: Equatable {
    /// <p>The ARN of a corresponding resource.</p>
    public let aRN: String?

    public init (
        aRN: String? = nil
    )
    {
        self.aRN = aRN
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource was not found. Verify that the name or Amazon Resource Name (ARN) of the resource is
///       correct.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ResponseTimeRootCause: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientImpacting = "ClientImpacting"
        case services = "Services"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientImpacting = clientImpacting {
            try encodeContainer.encode(clientImpacting, forKey: .clientImpacting)
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for responsetimerootcauseservices0 in services {
                try servicesContainer.encode(responsetimerootcauseservices0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let servicesContainer = try containerValues.decodeIfPresent([ResponseTimeRootCauseService?].self, forKey: .services)
        var servicesDecoded0:[ResponseTimeRootCauseService]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [ResponseTimeRootCauseService]()
            for structure0 in servicesContainer {
                if let structure0 = structure0 {
                    servicesDecoded0?.append(structure0)
                }
            }
        }
        services = servicesDecoded0
        let clientImpactingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .clientImpacting)
        clientImpacting = clientImpactingDecoded
    }
}

extension ResponseTimeRootCause: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponseTimeRootCause(clientImpacting: \(String(describing: clientImpacting)), services: \(String(describing: services)))"}
}

/// <p>The root cause information for a response time warning.</p>
public struct ResponseTimeRootCause: Equatable {
    /// <p>A flag that denotes that the root cause impacts the trace client.</p>
    public let clientImpacting: Bool?
    /// <p>A list of corresponding services. A service identifies a segment and contains a name,
    ///       account ID, type, and inferred flag.</p>
    public let services: [ResponseTimeRootCauseService]?

    public init (
        clientImpacting: Bool? = nil,
        services: [ResponseTimeRootCauseService]? = nil
    )
    {
        self.clientImpacting = clientImpacting
        self.services = services
    }
}

extension ResponseTimeRootCauseEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case coverage = "Coverage"
        case name = "Name"
        case remote = "Remote"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverage = coverage {
            try encodeContainer.encode(coverage, forKey: .coverage)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let remote = remote {
            try encodeContainer.encode(remote, forKey: .remote)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let coverageDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .coverage)
        coverage = coverageDecoded
        let remoteDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .remote)
        remote = remoteDecoded
    }
}

extension ResponseTimeRootCauseEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponseTimeRootCauseEntity(coverage: \(String(describing: coverage)), name: \(String(describing: name)), remote: \(String(describing: remote)))"}
}

/// <p>A collection of segments and corresponding subsegments associated to a response time
///       warning.</p>
public struct ResponseTimeRootCauseEntity: Equatable {
    /// <p>The type and messages of the exceptions.</p>
    public let coverage: Double?
    /// <p>The name of the entity.</p>
    public let name: String?
    /// <p>A flag that denotes a remote subsegment.</p>
    public let remote: Bool?

    public init (
        coverage: Double? = nil,
        name: String? = nil,
        remote: Bool? = nil
    )
    {
        self.coverage = coverage
        self.name = name
        self.remote = remote
    }
}

extension ResponseTimeRootCauseService: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case entityPath = "EntityPath"
        case inferred = "Inferred"
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let entityPath = entityPath {
            var entityPathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityPath)
            for responsetimerootcauseentitypath0 in entityPath {
                try entityPathContainer.encode(responsetimerootcauseentitypath0)
            }
        }
        if let inferred = inferred {
            try encodeContainer.encode(inferred, forKey: .inferred)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for servicenames0 in names {
                try namesContainer.encode(servicenames0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let entityPathContainer = try containerValues.decodeIfPresent([ResponseTimeRootCauseEntity?].self, forKey: .entityPath)
        var entityPathDecoded0:[ResponseTimeRootCauseEntity]? = nil
        if let entityPathContainer = entityPathContainer {
            entityPathDecoded0 = [ResponseTimeRootCauseEntity]()
            for structure0 in entityPathContainer {
                if let structure0 = structure0 {
                    entityPathDecoded0?.append(structure0)
                }
            }
        }
        entityPath = entityPathDecoded0
        let inferredDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .inferred)
        inferred = inferredDecoded
    }
}

extension ResponseTimeRootCauseService: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponseTimeRootCauseService(accountId: \(String(describing: accountId)), entityPath: \(String(describing: entityPath)), inferred: \(String(describing: inferred)), name: \(String(describing: name)), names: \(String(describing: names)), type: \(String(describing: type)))"}
}

/// <p>A collection of fields identifying the service in a response time warning.</p>
public struct ResponseTimeRootCauseService: Equatable {
    /// <p>The account ID associated to the service.</p>
    public let accountId: String?
    /// <p>The path of root cause entities found on the service. </p>
    public let entityPath: [ResponseTimeRootCauseEntity]?
    /// <p>A Boolean value indicating if the service is inferred from the trace.</p>
    public let inferred: Bool?
    /// <p>The service name.</p>
    public let name: String?
    /// <p>A collection of associated service names.</p>
    public let names: [String]?
    /// <p>The type associated to the service.</p>
    public let type: String?

    public init (
        accountId: String? = nil,
        entityPath: [ResponseTimeRootCauseEntity]? = nil,
        inferred: Bool? = nil,
        name: String? = nil,
        names: [String]? = nil,
        type: String? = nil
    )
    {
        self.accountId = accountId
        self.entityPath = entityPath
        self.inferred = inferred
        self.name = name
        self.names = names
        self.type = type
    }
}

extension RootCauseException: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RootCauseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RootCauseException(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>The exception associated with a root cause.</p>
public struct RootCauseException: Equatable {
    /// <p>The message of the exception.</p>
    public let message: String?
    /// <p>The name of the exception.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

extension RuleLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleLimitExceededException(message: \(String(describing: message)))"}
}

extension RuleLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RuleLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of sampling rules.</p>
public struct RuleLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RuleLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension RuleLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SamplingRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case fixedRate = "FixedRate"
        case hTTPMethod = "HTTPMethod"
        case host = "Host"
        case priority = "Priority"
        case reservoirSize = "ReservoirSize"
        case resourceARN = "ResourceARN"
        case ruleARN = "RuleARN"
        case ruleName = "RuleName"
        case serviceName = "ServiceName"
        case serviceType = "ServiceType"
        case uRLPath = "URLPath"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributemap0) in attributes {
                try attributesContainer.encode(attributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if fixedRate != 0.0 {
            try encodeContainer.encode(fixedRate, forKey: .fixedRate)
        }
        if let hTTPMethod = hTTPMethod {
            try encodeContainer.encode(hTTPMethod, forKey: .hTTPMethod)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if reservoirSize != 0 {
            try encodeContainer.encode(reservoirSize, forKey: .reservoirSize)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let ruleARN = ruleARN {
            try encodeContainer.encode(ruleARN, forKey: .ruleARN)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType, forKey: .serviceType)
        }
        if let uRLPath = uRLPath {
            try encodeContainer.encode(uRLPath, forKey: .uRLPath)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleARN)
        ruleARN = ruleARNDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
        let fixedRateDecoded = try containerValues.decode(Double.self, forKey: .fixedRate)
        fixedRate = fixedRateDecoded
        let reservoirSizeDecoded = try containerValues.decode(Int.self, forKey: .reservoirSize)
        reservoirSize = reservoirSizeDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let hTTPMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hTTPMethod)
        hTTPMethod = hTTPMethodDecoded
        let uRLPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRLPath)
        uRLPath = uRLPathDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension SamplingRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SamplingRule(attributes: \(String(describing: attributes)), fixedRate: \(String(describing: fixedRate)), hTTPMethod: \(String(describing: hTTPMethod)), host: \(String(describing: host)), priority: \(String(describing: priority)), reservoirSize: \(String(describing: reservoirSize)), resourceARN: \(String(describing: resourceARN)), ruleARN: \(String(describing: ruleARN)), ruleName: \(String(describing: ruleName)), serviceName: \(String(describing: serviceName)), serviceType: \(String(describing: serviceType)), uRLPath: \(String(describing: uRLPath)), version: \(String(describing: version)))"}
}

/// <p>A sampling rule that services use to decide whether to instrument a request. Rule
///       fields can match properties of the service, or properties of a request. The service can ignore
///       rules that don't match its properties.</p>
public struct SamplingRule: Equatable {
    /// <p>Matches attributes derived from the request.</p>
    public let attributes: [String:String]?
    /// <p>The percentage of matching requests to instrument, after the reservoir is
    ///       exhausted.</p>
    public let fixedRate: Double
    /// <p>Matches the HTTP method of a request.</p>
    public let hTTPMethod: String?
    /// <p>Matches the hostname from a request URL.</p>
    public let host: String?
    /// <p>The priority of the sampling rule.</p>
    public let priority: Int
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the
    ///       fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    public let reservoirSize: Int
    /// <p>Matches the ARN of the AWS resource on which the service runs.</p>
    public let resourceARN: String?
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    public let ruleARN: String?
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    public let ruleName: String?
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    public let serviceName: String?
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    public let serviceType: String?
    /// <p>Matches the path from a request URL.</p>
    public let uRLPath: String?
    /// <p>The version of the sampling rule format (<code>1</code>).</p>
    public let version: Int

    public init (
        attributes: [String:String]? = nil,
        fixedRate: Double = 0.0,
        hTTPMethod: String? = nil,
        host: String? = nil,
        priority: Int = 0,
        reservoirSize: Int = 0,
        resourceARN: String? = nil,
        ruleARN: String? = nil,
        ruleName: String? = nil,
        serviceName: String? = nil,
        serviceType: String? = nil,
        uRLPath: String? = nil,
        version: Int = 0
    )
    {
        self.attributes = attributes
        self.fixedRate = fixedRate
        self.hTTPMethod = hTTPMethod
        self.host = host
        self.priority = priority
        self.reservoirSize = reservoirSize
        self.resourceARN = resourceARN
        self.ruleARN = ruleARN
        self.ruleName = ruleName
        self.serviceName = serviceName
        self.serviceType = serviceType
        self.uRLPath = uRLPath
        self.version = version
    }
}

extension SamplingRuleRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case modifiedAt = "ModifiedAt"
        case samplingRule = "SamplingRule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let modifiedAt = modifiedAt {
            try encodeContainer.encode(modifiedAt.timeIntervalSince1970, forKey: .modifiedAt)
        }
        if let samplingRule = samplingRule {
            try encodeContainer.encode(samplingRule, forKey: .samplingRule)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleDecoded = try containerValues.decodeIfPresent(SamplingRule.self, forKey: .samplingRule)
        samplingRule = samplingRuleDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension SamplingRuleRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SamplingRuleRecord(createdAt: \(String(describing: createdAt)), modifiedAt: \(String(describing: modifiedAt)), samplingRule: \(String(describing: samplingRule)))"}
}

/// <p>A <a>SamplingRule</a> and its metadata.</p>
public struct SamplingRuleRecord: Equatable {
    /// <p>When the rule was created.</p>
    public let createdAt: Date?
    /// <p>When the rule was last modified.</p>
    public let modifiedAt: Date?
    /// <p>The sampling rule.</p>
    public let samplingRule: SamplingRule?

    public init (
        createdAt: Date? = nil,
        modifiedAt: Date? = nil,
        samplingRule: SamplingRule? = nil
    )
    {
        self.createdAt = createdAt
        self.modifiedAt = modifiedAt
        self.samplingRule = samplingRule
    }
}

extension SamplingRuleUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case fixedRate = "FixedRate"
        case hTTPMethod = "HTTPMethod"
        case host = "Host"
        case priority = "Priority"
        case reservoirSize = "ReservoirSize"
        case resourceARN = "ResourceARN"
        case ruleARN = "RuleARN"
        case ruleName = "RuleName"
        case serviceName = "ServiceName"
        case serviceType = "ServiceType"
        case uRLPath = "URLPath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributemap0) in attributes {
                try attributesContainer.encode(attributemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let fixedRate = fixedRate {
            try encodeContainer.encode(fixedRate, forKey: .fixedRate)
        }
        if let hTTPMethod = hTTPMethod {
            try encodeContainer.encode(hTTPMethod, forKey: .hTTPMethod)
        }
        if let host = host {
            try encodeContainer.encode(host, forKey: .host)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let reservoirSize = reservoirSize {
            try encodeContainer.encode(reservoirSize, forKey: .reservoirSize)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let ruleARN = ruleARN {
            try encodeContainer.encode(ruleARN, forKey: .ruleARN)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceType = serviceType {
            try encodeContainer.encode(serviceType, forKey: .serviceType)
        }
        if let uRLPath = uRLPath {
            try encodeContainer.encode(uRLPath, forKey: .uRLPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let ruleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleARN)
        ruleARN = ruleARNDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let fixedRateDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .fixedRate)
        fixedRate = fixedRateDecoded
        let reservoirSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .reservoirSize)
        reservoirSize = reservoirSizeDecoded
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let hTTPMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hTTPMethod)
        hTTPMethod = hTTPMethodDecoded
        let uRLPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRLPath)
        uRLPath = uRLPathDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension SamplingRuleUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SamplingRuleUpdate(attributes: \(String(describing: attributes)), fixedRate: \(String(describing: fixedRate)), hTTPMethod: \(String(describing: hTTPMethod)), host: \(String(describing: host)), priority: \(String(describing: priority)), reservoirSize: \(String(describing: reservoirSize)), resourceARN: \(String(describing: resourceARN)), ruleARN: \(String(describing: ruleARN)), ruleName: \(String(describing: ruleName)), serviceName: \(String(describing: serviceName)), serviceType: \(String(describing: serviceType)), uRLPath: \(String(describing: uRLPath)))"}
}

/// <p>A document specifying changes to a sampling rule's configuration.</p>
public struct SamplingRuleUpdate: Equatable {
    /// <p>Matches attributes derived from the request.</p>
    public let attributes: [String:String]?
    /// <p>The percentage of matching requests to instrument, after the reservoir is
    ///       exhausted.</p>
    public let fixedRate: Double?
    /// <p>Matches the HTTP method of a request.</p>
    public let hTTPMethod: String?
    /// <p>Matches the hostname from a request URL.</p>
    public let host: String?
    /// <p>The priority of the sampling rule.</p>
    public let priority: Int?
    /// <p>A fixed number of matching requests to instrument per second, prior to applying the
    ///       fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.</p>
    public let reservoirSize: Int?
    /// <p>Matches the ARN of the AWS resource on which the service runs.</p>
    public let resourceARN: String?
    /// <p>The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    public let ruleARN: String?
    /// <p>The name of the sampling rule. Specify a rule by either name or ARN, but not both.</p>
    public let ruleName: String?
    /// <p>Matches the <code>name</code> that the service uses to identify itself in segments.</p>
    public let serviceName: String?
    /// <p>Matches the <code>origin</code> that the service uses to identify its type in segments.</p>
    public let serviceType: String?
    /// <p>Matches the path from a request URL.</p>
    public let uRLPath: String?

    public init (
        attributes: [String:String]? = nil,
        fixedRate: Double? = nil,
        hTTPMethod: String? = nil,
        host: String? = nil,
        priority: Int? = nil,
        reservoirSize: Int? = nil,
        resourceARN: String? = nil,
        ruleARN: String? = nil,
        ruleName: String? = nil,
        serviceName: String? = nil,
        serviceType: String? = nil,
        uRLPath: String? = nil
    )
    {
        self.attributes = attributes
        self.fixedRate = fixedRate
        self.hTTPMethod = hTTPMethod
        self.host = host
        self.priority = priority
        self.reservoirSize = reservoirSize
        self.resourceARN = resourceARN
        self.ruleARN = ruleARN
        self.ruleName = ruleName
        self.serviceName = serviceName
        self.serviceType = serviceType
        self.uRLPath = uRLPath
    }
}

extension SamplingStatisticSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case borrowCount = "BorrowCount"
        case requestCount = "RequestCount"
        case ruleName = "RuleName"
        case sampledCount = "SampledCount"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if borrowCount != 0 {
            try encodeContainer.encode(borrowCount, forKey: .borrowCount)
        }
        if requestCount != 0 {
            try encodeContainer.encode(requestCount, forKey: .requestCount)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if sampledCount != 0 {
            try encodeContainer.encode(sampledCount, forKey: .sampledCount)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let requestCountDecoded = try containerValues.decode(Int.self, forKey: .requestCount)
        requestCount = requestCountDecoded
        let borrowCountDecoded = try containerValues.decode(Int.self, forKey: .borrowCount)
        borrowCount = borrowCountDecoded
        let sampledCountDecoded = try containerValues.decode(Int.self, forKey: .sampledCount)
        sampledCount = sampledCountDecoded
    }
}

extension SamplingStatisticSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SamplingStatisticSummary(borrowCount: \(String(describing: borrowCount)), requestCount: \(String(describing: requestCount)), ruleName: \(String(describing: ruleName)), sampledCount: \(String(describing: sampledCount)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>Aggregated request sampling data for a sampling rule across all services for a 10-second window.</p>
public struct SamplingStatisticSummary: Equatable {
    /// <p>The number of requests recorded with borrowed reservoir quota.</p>
    public let borrowCount: Int
    /// <p>The number of requests that matched the rule.</p>
    public let requestCount: Int
    /// <p>The name of the sampling rule.</p>
    public let ruleName: String?
    /// <p>The number of requests recorded.</p>
    public let sampledCount: Int
    /// <p>The start time of the reporting window.</p>
    public let timestamp: Date?

    public init (
        borrowCount: Int = 0,
        requestCount: Int = 0,
        ruleName: String? = nil,
        sampledCount: Int = 0,
        timestamp: Date? = nil
    )
    {
        self.borrowCount = borrowCount
        self.requestCount = requestCount
        self.ruleName = ruleName
        self.sampledCount = sampledCount
        self.timestamp = timestamp
    }
}

extension SamplingStatisticsDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case borrowCount = "BorrowCount"
        case clientID = "ClientID"
        case requestCount = "RequestCount"
        case ruleName = "RuleName"
        case sampledCount = "SampledCount"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if borrowCount != 0 {
            try encodeContainer.encode(borrowCount, forKey: .borrowCount)
        }
        if let clientID = clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
        if requestCount != 0 {
            try encodeContainer.encode(requestCount, forKey: .requestCount)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if sampledCount != 0 {
            try encodeContainer.encode(sampledCount, forKey: .sampledCount)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let clientIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientID)
        clientID = clientIDDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let requestCountDecoded = try containerValues.decode(Int.self, forKey: .requestCount)
        requestCount = requestCountDecoded
        let sampledCountDecoded = try containerValues.decode(Int.self, forKey: .sampledCount)
        sampledCount = sampledCountDecoded
        let borrowCountDecoded = try containerValues.decode(Int.self, forKey: .borrowCount)
        borrowCount = borrowCountDecoded
    }
}

extension SamplingStatisticsDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SamplingStatisticsDocument(borrowCount: \(String(describing: borrowCount)), clientID: \(String(describing: clientID)), requestCount: \(String(describing: requestCount)), ruleName: \(String(describing: ruleName)), sampledCount: \(String(describing: sampledCount)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>Request sampling results for a single rule from a service. Results are for the last 10
///       seconds unless the service has been assigned a longer reporting interval after a previous call
///       to <a>GetSamplingTargets</a>.</p>
public struct SamplingStatisticsDocument: Equatable {
    /// <p>The number of requests recorded with borrowed reservoir quota.</p>
    public let borrowCount: Int
    /// <p>A unique identifier for the service in hexadecimal.</p>
    public let clientID: String?
    /// <p>The number of requests that matched the rule.</p>
    public let requestCount: Int
    /// <p>The name of the sampling rule.</p>
    public let ruleName: String?
    /// <p>The number of requests recorded.</p>
    public let sampledCount: Int
    /// <p>The current time.</p>
    public let timestamp: Date?

    public init (
        borrowCount: Int = 0,
        clientID: String? = nil,
        requestCount: Int = 0,
        ruleName: String? = nil,
        sampledCount: Int = 0,
        timestamp: Date? = nil
    )
    {
        self.borrowCount = borrowCount
        self.clientID = clientID
        self.requestCount = requestCount
        self.ruleName = ruleName
        self.sampledCount = sampledCount
        self.timestamp = timestamp
    }
}

extension SamplingStrategy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SamplingStrategyName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension SamplingStrategy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SamplingStrategy(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>The name and value of a sampling rule to apply to a trace summary.</p>
public struct SamplingStrategy: Equatable {
    /// <p>The name of a sampling rule.</p>
    public let name: SamplingStrategyName?
    /// <p>The value of a sampling rule.</p>
    public let value: Double?

    public init (
        name: SamplingStrategyName? = nil,
        value: Double? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public enum SamplingStrategyName {
    case fixedrate
    case partialscan
    case sdkUnknown(String)
}

extension SamplingStrategyName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SamplingStrategyName] {
        return [
            .fixedrate,
            .partialscan,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fixedrate: return "FixedRate"
        case .partialscan: return "PartialScan"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SamplingStrategyName(rawValue: rawValue) ?? SamplingStrategyName.sdkUnknown(rawValue)
    }
}

extension SamplingTargetDocument: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fixedRate = "FixedRate"
        case interval = "Interval"
        case reservoirQuota = "ReservoirQuota"
        case reservoirQuotaTTL = "ReservoirQuotaTTL"
        case ruleName = "RuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fixedRate != 0.0 {
            try encodeContainer.encode(fixedRate, forKey: .fixedRate)
        }
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let reservoirQuota = reservoirQuota {
            try encodeContainer.encode(reservoirQuota, forKey: .reservoirQuota)
        }
        if let reservoirQuotaTTL = reservoirQuotaTTL {
            try encodeContainer.encode(reservoirQuotaTTL.timeIntervalSince1970, forKey: .reservoirQuotaTTL)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let fixedRateDecoded = try containerValues.decode(Double.self, forKey: .fixedRate)
        fixedRate = fixedRateDecoded
        let reservoirQuotaDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .reservoirQuota)
        reservoirQuota = reservoirQuotaDecoded
        let reservoirQuotaTTLDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .reservoirQuotaTTL)
        reservoirQuotaTTL = reservoirQuotaTTLDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .interval)
        interval = intervalDecoded
    }
}

extension SamplingTargetDocument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SamplingTargetDocument(fixedRate: \(String(describing: fixedRate)), interval: \(String(describing: interval)), reservoirQuota: \(String(describing: reservoirQuota)), reservoirQuotaTTL: \(String(describing: reservoirQuotaTTL)), ruleName: \(String(describing: ruleName)))"}
}

/// <p>Temporary changes to a sampling rule configuration. To meet the global sampling target for a rule, X-Ray
///       calculates a new reservoir for each service based on the recent sampling results of all services that called <a>GetSamplingTargets</a>.</p>
public struct SamplingTargetDocument: Equatable {
    /// <p>The percentage of matching requests to instrument, after the reservoir is
    ///       exhausted.</p>
    public let fixedRate: Double
    /// <p>The number of seconds for the service to wait before getting sampling targets
    ///       again.</p>
    public let interval: Int?
    /// <p>The number of requests per second that X-Ray allocated for this service.</p>
    public let reservoirQuota: Int?
    /// <p>When the reservoir quota expires.</p>
    public let reservoirQuotaTTL: Date?
    /// <p>The name of the sampling rule.</p>
    public let ruleName: String?

    public init (
        fixedRate: Double = 0.0,
        interval: Int? = nil,
        reservoirQuota: Int? = nil,
        reservoirQuotaTTL: Date? = nil,
        ruleName: String? = nil
    )
    {
        self.fixedRate = fixedRate
        self.interval = interval
        self.reservoirQuota = reservoirQuota
        self.reservoirQuotaTTL = reservoirQuotaTTL
        self.ruleName = ruleName
    }
}

extension Segment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case document = "Document"
        case id = "Id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let documentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .document)
        document = documentDecoded
    }
}

extension Segment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Segment(document: \(String(describing: document)), id: \(String(describing: id)))"}
}

/// <p>A segment from a trace that has been ingested by the X-Ray service. The segment can be
///       compiled from documents uploaded with <a>PutTraceSegments</a>, or an
///         <code>inferred</code> segment for a downstream service, generated from a subsegment sent by
///       the service that called it.</p>
///          <p>For the full segment document schema, see <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html">AWS X-Ray Segment
///         Documents</a> in the <i>AWS X-Ray Developer Guide</i>.</p>
public struct Segment: Equatable {
    /// <p>The segment document.</p>
    public let document: String?
    /// <p>The segment's ID.</p>
    public let id: String?

    public init (
        document: String? = nil,
        id: String? = nil
    )
    {
        self.document = document
        self.id = id
    }
}

extension Service: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case durationHistogram = "DurationHistogram"
        case edges = "Edges"
        case endTime = "EndTime"
        case name = "Name"
        case names = "Names"
        case referenceId = "ReferenceId"
        case responseTimeHistogram = "ResponseTimeHistogram"
        case root = "Root"
        case startTime = "StartTime"
        case state = "State"
        case summaryStatistics = "SummaryStatistics"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let durationHistogram = durationHistogram {
            var durationHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .durationHistogram)
            for histogram0 in durationHistogram {
                try durationHistogramContainer.encode(histogram0)
            }
        }
        if let edges = edges {
            var edgesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .edges)
            for edgelist0 in edges {
                try edgesContainer.encode(edgelist0)
            }
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for servicenames0 in names {
                try namesContainer.encode(servicenames0)
            }
        }
        if let referenceId = referenceId {
            try encodeContainer.encode(referenceId, forKey: .referenceId)
        }
        if let responseTimeHistogram = responseTimeHistogram {
            var responseTimeHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeHistogram)
            for histogram0 in responseTimeHistogram {
                try responseTimeHistogramContainer.encode(histogram0)
            }
        }
        if let root = root {
            try encodeContainer.encode(root, forKey: .root)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let summaryStatistics = summaryStatistics {
            try encodeContainer.encode(summaryStatistics, forKey: .summaryStatistics)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceIdDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .referenceId)
        referenceId = referenceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let rootDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .root)
        root = rootDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let edgesContainer = try containerValues.decodeIfPresent([Edge?].self, forKey: .edges)
        var edgesDecoded0:[Edge]? = nil
        if let edgesContainer = edgesContainer {
            edgesDecoded0 = [Edge]()
            for structure0 in edgesContainer {
                if let structure0 = structure0 {
                    edgesDecoded0?.append(structure0)
                }
            }
        }
        edges = edgesDecoded0
        let summaryStatisticsDecoded = try containerValues.decodeIfPresent(ServiceStatistics.self, forKey: .summaryStatistics)
        summaryStatistics = summaryStatisticsDecoded
        let durationHistogramContainer = try containerValues.decodeIfPresent([HistogramEntry?].self, forKey: .durationHistogram)
        var durationHistogramDecoded0:[HistogramEntry]? = nil
        if let durationHistogramContainer = durationHistogramContainer {
            durationHistogramDecoded0 = [HistogramEntry]()
            for structure0 in durationHistogramContainer {
                if let structure0 = structure0 {
                    durationHistogramDecoded0?.append(structure0)
                }
            }
        }
        durationHistogram = durationHistogramDecoded0
        let responseTimeHistogramContainer = try containerValues.decodeIfPresent([HistogramEntry?].self, forKey: .responseTimeHistogram)
        var responseTimeHistogramDecoded0:[HistogramEntry]? = nil
        if let responseTimeHistogramContainer = responseTimeHistogramContainer {
            responseTimeHistogramDecoded0 = [HistogramEntry]()
            for structure0 in responseTimeHistogramContainer {
                if let structure0 = structure0 {
                    responseTimeHistogramDecoded0?.append(structure0)
                }
            }
        }
        responseTimeHistogram = responseTimeHistogramDecoded0
    }
}

extension Service: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Service(accountId: \(String(describing: accountId)), durationHistogram: \(String(describing: durationHistogram)), edges: \(String(describing: edges)), endTime: \(String(describing: endTime)), name: \(String(describing: name)), names: \(String(describing: names)), referenceId: \(String(describing: referenceId)), responseTimeHistogram: \(String(describing: responseTimeHistogram)), root: \(String(describing: root)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), summaryStatistics: \(String(describing: summaryStatistics)), type: \(String(describing: type)))"}
}

/// <p>Information about an application that processed requests, users that made requests, or downstream services,
///       resources, and applications that an application used.</p>
public struct Service: Equatable {
    /// <p>Identifier of the AWS account in which the service runs.</p>
    public let accountId: String?
    /// <p>A histogram that maps the spread of service durations.</p>
    public let durationHistogram: [HistogramEntry]?
    /// <p>Connections to downstream services.</p>
    public let edges: [Edge]?
    /// <p>The end time of the last segment that the service generated.</p>
    public let endTime: Date?
    /// <p>The canonical name of the service.</p>
    public let name: String?
    /// <p>A list of names for the service, including the canonical name.</p>
    public let names: [String]?
    /// <p>Identifier for the service. Unique within the service map.</p>
    public let referenceId: Int?
    /// <p>A histogram that maps the spread of service response times.</p>
    public let responseTimeHistogram: [HistogramEntry]?
    /// <p>Indicates that the service was the first service to process a request.</p>
    public let root: Bool?
    /// <p>The start time of the first segment that the service generated.</p>
    public let startTime: Date?
    /// <p>The service's state.</p>
    public let state: String?
    /// <p>Aggregated statistics for the service.</p>
    public let summaryStatistics: ServiceStatistics?
    /// <p>The type of service.</p>
    ///          <ul>
    ///             <li>
    ///                <p>AWS Resource - The type of an AWS resource. For example, <code>AWS::EC2::Instance</code> for an
    ///           application running on Amazon EC2 or <code>AWS::DynamoDB::Table</code> for an Amazon DynamoDB table that the
    ///           application used.</p>
    ///             </li>
    ///             <li>
    ///                <p>AWS Service - The type of an AWS service. For example, <code>AWS::DynamoDB</code>
    ///           for downstream calls to Amazon DynamoDB that didn't target a specific table.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>client</code> - Represents the clients that sent requests to a root
    ///           service.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>remote</code> - A downstream service of indeterminate type.</p>
    ///             </li>
    ///          </ul>
    public let type: String?

    public init (
        accountId: String? = nil,
        durationHistogram: [HistogramEntry]? = nil,
        edges: [Edge]? = nil,
        endTime: Date? = nil,
        name: String? = nil,
        names: [String]? = nil,
        referenceId: Int? = nil,
        responseTimeHistogram: [HistogramEntry]? = nil,
        root: Bool? = nil,
        startTime: Date? = nil,
        state: String? = nil,
        summaryStatistics: ServiceStatistics? = nil,
        type: String? = nil
    )
    {
        self.accountId = accountId
        self.durationHistogram = durationHistogram
        self.edges = edges
        self.endTime = endTime
        self.name = name
        self.names = names
        self.referenceId = referenceId
        self.responseTimeHistogram = responseTimeHistogram
        self.root = root
        self.startTime = startTime
        self.state = state
        self.summaryStatistics = summaryStatistics
        self.type = type
    }
}

extension ServiceId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case name = "Name"
        case names = "Names"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for servicenames0 in names {
                try namesContainer.encode(servicenames0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let namesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .names)
        var namesDecoded0:[String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ServiceId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceId(accountId: \(String(describing: accountId)), name: \(String(describing: name)), names: \(String(describing: names)), type: \(String(describing: type)))"}
}

/// <p></p>
public struct ServiceId: Equatable {
    /// <p></p>
    public let accountId: String?
    /// <p></p>
    public let name: String?
    /// <p></p>
    public let names: [String]?
    /// <p></p>
    public let type: String?

    public init (
        accountId: String? = nil,
        name: String? = nil,
        names: [String]? = nil,
        type: String? = nil
    )
    {
        self.accountId = accountId
        self.name = name
        self.names = names
        self.type = type
    }
}

extension ServiceStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorStatistics = "ErrorStatistics"
        case faultStatistics = "FaultStatistics"
        case okCount = "OkCount"
        case totalCount = "TotalCount"
        case totalResponseTime = "TotalResponseTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorStatistics = errorStatistics {
            try encodeContainer.encode(errorStatistics, forKey: .errorStatistics)
        }
        if let faultStatistics = faultStatistics {
            try encodeContainer.encode(faultStatistics, forKey: .faultStatistics)
        }
        if let okCount = okCount {
            try encodeContainer.encode(okCount, forKey: .okCount)
        }
        if let totalCount = totalCount {
            try encodeContainer.encode(totalCount, forKey: .totalCount)
        }
        if let totalResponseTime = totalResponseTime {
            try encodeContainer.encode(totalResponseTime, forKey: .totalResponseTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let okCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .okCount)
        okCount = okCountDecoded
        let errorStatisticsDecoded = try containerValues.decodeIfPresent(ErrorStatistics.self, forKey: .errorStatistics)
        errorStatistics = errorStatisticsDecoded
        let faultStatisticsDecoded = try containerValues.decodeIfPresent(FaultStatistics.self, forKey: .faultStatistics)
        faultStatistics = faultStatisticsDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
        let totalResponseTimeDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .totalResponseTime)
        totalResponseTime = totalResponseTimeDecoded
    }
}

extension ServiceStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceStatistics(errorStatistics: \(String(describing: errorStatistics)), faultStatistics: \(String(describing: faultStatistics)), okCount: \(String(describing: okCount)), totalCount: \(String(describing: totalCount)), totalResponseTime: \(String(describing: totalResponseTime)))"}
}

/// <p>Response statistics for a service.</p>
public struct ServiceStatistics: Equatable {
    /// <p>Information about requests that failed with a 4xx Client Error status code.</p>
    public let errorStatistics: ErrorStatistics?
    /// <p>Information about requests that failed with a 5xx Server Error status code.</p>
    public let faultStatistics: FaultStatistics?
    /// <p>The number of requests that completed with a 2xx Success status code.</p>
    public let okCount: Int?
    /// <p>The total number of completed requests.</p>
    public let totalCount: Int?
    /// <p>The aggregate response time of completed requests.</p>
    public let totalResponseTime: Double?

    public init (
        errorStatistics: ErrorStatistics? = nil,
        faultStatistics: FaultStatistics? = nil,
        okCount: Int? = nil,
        totalCount: Int? = nil,
        totalResponseTime: Double? = nil
    )
    {
        self.errorStatistics = errorStatistics
        self.faultStatistics = faultStatistics
        self.okCount = okCount
        self.totalCount = totalCount
        self.totalResponseTime = totalResponseTime
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A map that contains tag keys and tag values to attach to an AWS X-Ray group or sampling
///       rule. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS resources</a>
///       in the <i>AWS General Reference</i>.</p>
///          <p>The following restrictions apply to tags:</p>
///          <ul>
///             <li>
///                <p>Maximum number of user-applied tags per resource: 50</p>
///             </li>
///             <li>
///                <p>Tag keys and values are case sensitive.</p>
///             </li>
///             <li>
///                <p>Don't use <code>aws:</code> as a prefix for keys; it's reserved for AWS use. You
///           cannot edit or delete system tags.</p>
///             </li>
///          </ul>
public struct Tag: Equatable {
    /// <p>A tag key, such as <code>Stage</code> or <code>Name</code>. A tag key cannot be empty. The
    ///       key can be a maximum of 128 characters, and can contain only Unicode letters, numbers, or separators,
    ///       or the following special characters: <code>+ - = . _ : /</code>
    ///          </p>
    public let key: String?
    /// <p>An optional tag value, such as <code>Production</code> or <code>test-only</code>. The value can be
    ///       a maximum of 255 characters, and contain only Unicode letters, numbers, or separators, or the following
    ///       special characters: <code>+ - = . _ : /</code>
    ///          </p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.</p>
    public let resourceARN: String?
    /// <p>A map that contains one or more tag keys and tag values to attach to an X-Ray group or
    ///       sampling rule. For more information about ways to use tags, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS resources</a>
    ///       in the <i>AWS General Reference</i>.</p>
    ///          <p>The following restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of user-applied tags per resource: 50</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum tag key length: 128 Unicode characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum tag value length: 256 Unicode characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Valid values for key and value: a-z, A-Z, 0-9, space, and the following characters: _ . :
    ///           / = + - and @</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Don't use <code>aws:</code> as a prefix for keys; it's reserved for AWS use. You
    ///           cannot edit or delete system tags.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TelemetryRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendConnectionErrors = "BackendConnectionErrors"
        case segmentsReceivedCount = "SegmentsReceivedCount"
        case segmentsRejectedCount = "SegmentsRejectedCount"
        case segmentsSentCount = "SegmentsSentCount"
        case segmentsSpilloverCount = "SegmentsSpilloverCount"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendConnectionErrors = backendConnectionErrors {
            try encodeContainer.encode(backendConnectionErrors, forKey: .backendConnectionErrors)
        }
        if let segmentsReceivedCount = segmentsReceivedCount {
            try encodeContainer.encode(segmentsReceivedCount, forKey: .segmentsReceivedCount)
        }
        if let segmentsRejectedCount = segmentsRejectedCount {
            try encodeContainer.encode(segmentsRejectedCount, forKey: .segmentsRejectedCount)
        }
        if let segmentsSentCount = segmentsSentCount {
            try encodeContainer.encode(segmentsSentCount, forKey: .segmentsSentCount)
        }
        if let segmentsSpilloverCount = segmentsSpilloverCount {
            try encodeContainer.encode(segmentsSpilloverCount, forKey: .segmentsSpilloverCount)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let segmentsReceivedCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .segmentsReceivedCount)
        segmentsReceivedCount = segmentsReceivedCountDecoded
        let segmentsSentCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .segmentsSentCount)
        segmentsSentCount = segmentsSentCountDecoded
        let segmentsSpilloverCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .segmentsSpilloverCount)
        segmentsSpilloverCount = segmentsSpilloverCountDecoded
        let segmentsRejectedCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .segmentsRejectedCount)
        segmentsRejectedCount = segmentsRejectedCountDecoded
        let backendConnectionErrorsDecoded = try containerValues.decodeIfPresent(BackendConnectionErrors.self, forKey: .backendConnectionErrors)
        backendConnectionErrors = backendConnectionErrorsDecoded
    }
}

extension TelemetryRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TelemetryRecord(backendConnectionErrors: \(String(describing: backendConnectionErrors)), segmentsReceivedCount: \(String(describing: segmentsReceivedCount)), segmentsRejectedCount: \(String(describing: segmentsRejectedCount)), segmentsSentCount: \(String(describing: segmentsSentCount)), segmentsSpilloverCount: \(String(describing: segmentsSpilloverCount)), timestamp: \(String(describing: timestamp)))"}
}

/// <p></p>
public struct TelemetryRecord: Equatable {
    /// <p></p>
    public let backendConnectionErrors: BackendConnectionErrors?
    /// <p></p>
    public let segmentsReceivedCount: Int?
    /// <p></p>
    public let segmentsRejectedCount: Int?
    /// <p></p>
    public let segmentsSentCount: Int?
    /// <p></p>
    public let segmentsSpilloverCount: Int?
    /// <p></p>
    public let timestamp: Date?

    public init (
        backendConnectionErrors: BackendConnectionErrors? = nil,
        segmentsReceivedCount: Int? = nil,
        segmentsRejectedCount: Int? = nil,
        segmentsSentCount: Int? = nil,
        segmentsSpilloverCount: Int? = nil,
        timestamp: Date? = nil
    )
    {
        self.backendConnectionErrors = backendConnectionErrors
        self.segmentsReceivedCount = segmentsReceivedCount
        self.segmentsRejectedCount = segmentsRejectedCount
        self.segmentsSentCount = segmentsSentCount
        self.segmentsSpilloverCount = segmentsSpilloverCount
        self.timestamp = timestamp
    }
}

extension ThrottledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottledException(message: \(String(describing: message)))"}
}

extension ThrottledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request exceeds the maximum number of requests per second.</p>
public struct ThrottledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottledExceptionBody: Equatable {
    public let message: String?
}

extension ThrottledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum TimeRangeType {
    case event
    case traceid
    case sdkUnknown(String)
}

extension TimeRangeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TimeRangeType] {
        return [
            .event,
            .traceid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .event: return "Event"
        case .traceid: return "TraceId"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TimeRangeType(rawValue: rawValue) ?? TimeRangeType.sdkUnknown(rawValue)
    }
}

extension TimeSeriesServiceStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case edgeSummaryStatistics = "EdgeSummaryStatistics"
        case responseTimeHistogram = "ResponseTimeHistogram"
        case serviceForecastStatistics = "ServiceForecastStatistics"
        case serviceSummaryStatistics = "ServiceSummaryStatistics"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edgeSummaryStatistics = edgeSummaryStatistics {
            try encodeContainer.encode(edgeSummaryStatistics, forKey: .edgeSummaryStatistics)
        }
        if let responseTimeHistogram = responseTimeHistogram {
            var responseTimeHistogramContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeHistogram)
            for histogram0 in responseTimeHistogram {
                try responseTimeHistogramContainer.encode(histogram0)
            }
        }
        if let serviceForecastStatistics = serviceForecastStatistics {
            try encodeContainer.encode(serviceForecastStatistics, forKey: .serviceForecastStatistics)
        }
        if let serviceSummaryStatistics = serviceSummaryStatistics {
            try encodeContainer.encode(serviceSummaryStatistics, forKey: .serviceSummaryStatistics)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let edgeSummaryStatisticsDecoded = try containerValues.decodeIfPresent(EdgeStatistics.self, forKey: .edgeSummaryStatistics)
        edgeSummaryStatistics = edgeSummaryStatisticsDecoded
        let serviceSummaryStatisticsDecoded = try containerValues.decodeIfPresent(ServiceStatistics.self, forKey: .serviceSummaryStatistics)
        serviceSummaryStatistics = serviceSummaryStatisticsDecoded
        let serviceForecastStatisticsDecoded = try containerValues.decodeIfPresent(ForecastStatistics.self, forKey: .serviceForecastStatistics)
        serviceForecastStatistics = serviceForecastStatisticsDecoded
        let responseTimeHistogramContainer = try containerValues.decodeIfPresent([HistogramEntry?].self, forKey: .responseTimeHistogram)
        var responseTimeHistogramDecoded0:[HistogramEntry]? = nil
        if let responseTimeHistogramContainer = responseTimeHistogramContainer {
            responseTimeHistogramDecoded0 = [HistogramEntry]()
            for structure0 in responseTimeHistogramContainer {
                if let structure0 = structure0 {
                    responseTimeHistogramDecoded0?.append(structure0)
                }
            }
        }
        responseTimeHistogram = responseTimeHistogramDecoded0
    }
}

extension TimeSeriesServiceStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeSeriesServiceStatistics(edgeSummaryStatistics: \(String(describing: edgeSummaryStatistics)), responseTimeHistogram: \(String(describing: responseTimeHistogram)), serviceForecastStatistics: \(String(describing: serviceForecastStatistics)), serviceSummaryStatistics: \(String(describing: serviceSummaryStatistics)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>A list of TimeSeriesStatistic structures.</p>
public struct TimeSeriesServiceStatistics: Equatable {
    /// <p>Response statistics for an edge.</p>
    public let edgeSummaryStatistics: EdgeStatistics?
    /// <p>The response time histogram for the selected entities.</p>
    public let responseTimeHistogram: [HistogramEntry]?
    /// <p>The forecasted high and low fault count values.</p>
    public let serviceForecastStatistics: ForecastStatistics?
    /// <p>Response statistics for a service.</p>
    public let serviceSummaryStatistics: ServiceStatistics?
    /// <p>Timestamp of the window for which statistics are aggregated.</p>
    public let timestamp: Date?

    public init (
        edgeSummaryStatistics: EdgeStatistics? = nil,
        responseTimeHistogram: [HistogramEntry]? = nil,
        serviceForecastStatistics: ForecastStatistics? = nil,
        serviceSummaryStatistics: ServiceStatistics? = nil,
        timestamp: Date? = nil
    )
    {
        self.edgeSummaryStatistics = edgeSummaryStatistics
        self.responseTimeHistogram = responseTimeHistogram
        self.serviceForecastStatistics = serviceForecastStatistics
        self.serviceSummaryStatistics = serviceSummaryStatistics
        self.timestamp = timestamp
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of tags you can apply to this resource.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension Trace: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case id = "Id"
        case limitExceeded = "LimitExceeded"
        case segments = "Segments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let limitExceeded = limitExceeded {
            try encodeContainer.encode(limitExceeded, forKey: .limitExceeded)
        }
        if let segments = segments {
            var segmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .segments)
            for segmentlist0 in segments {
                try segmentsContainer.encode(segmentlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .duration)
        duration = durationDecoded
        let limitExceededDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .limitExceeded)
        limitExceeded = limitExceededDecoded
        let segmentsContainer = try containerValues.decodeIfPresent([Segment?].self, forKey: .segments)
        var segmentsDecoded0:[Segment]? = nil
        if let segmentsContainer = segmentsContainer {
            segmentsDecoded0 = [Segment]()
            for structure0 in segmentsContainer {
                if let structure0 = structure0 {
                    segmentsDecoded0?.append(structure0)
                }
            }
        }
        segments = segmentsDecoded0
    }
}

extension Trace: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Trace(duration: \(String(describing: duration)), id: \(String(describing: id)), limitExceeded: \(String(describing: limitExceeded)), segments: \(String(describing: segments)))"}
}

/// <p>A collection of segment documents with matching trace IDs.</p>
public struct Trace: Equatable {
    /// <p>The length of time in seconds between the start time of the root segment and the end
    ///       time of the last segment that completed.</p>
    public let duration: Double?
    /// <p>The unique identifier for the request that generated the trace's segments and
    ///       subsegments.</p>
    public let id: String?
    /// <p>LimitExceeded is set to true when the trace has exceeded one of the defined quotas. For
    ///       more information about quotas, see <a href="https://docs.aws.amazon.com/general/latest/gr/xray.html">AWS X-Ray endpoints and quotas</a>.</p>
    public let limitExceeded: Bool?
    /// <p>Segment documents for the segments and subsegments that comprise the trace.</p>
    public let segments: [Segment]?

    public init (
        duration: Double? = nil,
        id: String? = nil,
        limitExceeded: Bool? = nil,
        segments: [Segment]? = nil
    )
    {
        self.duration = duration
        self.id = id
        self.limitExceeded = limitExceeded
        self.segments = segments
    }
}

extension TraceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotations = "Annotations"
        case availabilityZones = "AvailabilityZones"
        case duration = "Duration"
        case entryPoint = "EntryPoint"
        case errorRootCauses = "ErrorRootCauses"
        case faultRootCauses = "FaultRootCauses"
        case hasError = "HasError"
        case hasFault = "HasFault"
        case hasThrottle = "HasThrottle"
        case http = "Http"
        case id = "Id"
        case instanceIds = "InstanceIds"
        case isPartial = "IsPartial"
        case matchedEventTime = "MatchedEventTime"
        case resourceARNs = "ResourceARNs"
        case responseTime = "ResponseTime"
        case responseTimeRootCauses = "ResponseTimeRootCauses"
        case revision = "Revision"
        case serviceIds = "ServiceIds"
        case users = "Users"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotations = annotations {
            var annotationsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .annotations)
            for (dictKey0, annotations0) in annotations {
                try annotationsContainer.encode(annotations0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for traceavailabilityzones0 in availabilityZones {
                try availabilityZonesContainer.encode(traceavailabilityzones0)
            }
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let entryPoint = entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let errorRootCauses = errorRootCauses {
            var errorRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorRootCauses)
            for errorrootcauses0 in errorRootCauses {
                try errorRootCausesContainer.encode(errorrootcauses0)
            }
        }
        if let faultRootCauses = faultRootCauses {
            var faultRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .faultRootCauses)
            for faultrootcauses0 in faultRootCauses {
                try faultRootCausesContainer.encode(faultrootcauses0)
            }
        }
        if let hasError = hasError {
            try encodeContainer.encode(hasError, forKey: .hasError)
        }
        if let hasFault = hasFault {
            try encodeContainer.encode(hasFault, forKey: .hasFault)
        }
        if let hasThrottle = hasThrottle {
            try encodeContainer.encode(hasThrottle, forKey: .hasThrottle)
        }
        if let http = http {
            try encodeContainer.encode(http, forKey: .http)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for traceinstanceids0 in instanceIds {
                try instanceIdsContainer.encode(traceinstanceids0)
            }
        }
        if let isPartial = isPartial {
            try encodeContainer.encode(isPartial, forKey: .isPartial)
        }
        if let matchedEventTime = matchedEventTime {
            try encodeContainer.encode(matchedEventTime.timeIntervalSince1970, forKey: .matchedEventTime)
        }
        if let resourceARNs = resourceARNs {
            var resourceARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceARNs)
            for traceresourcearns0 in resourceARNs {
                try resourceARNsContainer.encode(traceresourcearns0)
            }
        }
        if let responseTime = responseTime {
            try encodeContainer.encode(responseTime, forKey: .responseTime)
        }
        if let responseTimeRootCauses = responseTimeRootCauses {
            var responseTimeRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeRootCauses)
            for responsetimerootcauses0 in responseTimeRootCauses {
                try responseTimeRootCausesContainer.encode(responsetimerootcauses0)
            }
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let serviceIds = serviceIds {
            var serviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceIds)
            for serviceids0 in serviceIds {
                try serviceIdsContainer.encode(serviceids0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for traceusers0 in users {
                try usersContainer.encode(traceusers0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .duration)
        duration = durationDecoded
        let responseTimeDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .responseTime)
        responseTime = responseTimeDecoded
        let hasFaultDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasFault)
        hasFault = hasFaultDecoded
        let hasErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasError)
        hasError = hasErrorDecoded
        let hasThrottleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasThrottle)
        hasThrottle = hasThrottleDecoded
        let isPartialDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isPartial)
        isPartial = isPartialDecoded
        let httpDecoded = try containerValues.decodeIfPresent(Http.self, forKey: .http)
        http = httpDecoded
        let annotationsContainer = try containerValues.decodeIfPresent([String: [ValueWithServiceIds?]?].self, forKey: .annotations)
        var annotationsDecoded0: [String:[ValueWithServiceIds]]? = nil
        if let annotationsContainer = annotationsContainer {
            annotationsDecoded0 = [String:[ValueWithServiceIds]]()
            for (key0, valueswithserviceids0) in annotationsContainer {
                var valueswithserviceids0Decoded0: [ValueWithServiceIds]? = nil
                if let valueswithserviceids0 = valueswithserviceids0 {
                    valueswithserviceids0Decoded0 = [ValueWithServiceIds]()
                    for structure1 in valueswithserviceids0 {
                        if let structure1 = structure1 {
                            valueswithserviceids0Decoded0?.append(structure1)
                        }
                    }
                }
                annotationsDecoded0?[key0] = valueswithserviceids0Decoded0
            }
        }
        annotations = annotationsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([TraceUser?].self, forKey: .users)
        var usersDecoded0:[TraceUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [TraceUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let serviceIdsContainer = try containerValues.decodeIfPresent([ServiceId?].self, forKey: .serviceIds)
        var serviceIdsDecoded0:[ServiceId]? = nil
        if let serviceIdsContainer = serviceIdsContainer {
            serviceIdsDecoded0 = [ServiceId]()
            for structure0 in serviceIdsContainer {
                if let structure0 = structure0 {
                    serviceIdsDecoded0?.append(structure0)
                }
            }
        }
        serviceIds = serviceIdsDecoded0
        let resourceARNsContainer = try containerValues.decodeIfPresent([ResourceARNDetail?].self, forKey: .resourceARNs)
        var resourceARNsDecoded0:[ResourceARNDetail]? = nil
        if let resourceARNsContainer = resourceARNsContainer {
            resourceARNsDecoded0 = [ResourceARNDetail]()
            for structure0 in resourceARNsContainer {
                if let structure0 = structure0 {
                    resourceARNsDecoded0?.append(structure0)
                }
            }
        }
        resourceARNs = resourceARNsDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([InstanceIdDetail?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[InstanceIdDetail]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [InstanceIdDetail]()
            for structure0 in instanceIdsContainer {
                if let structure0 = structure0 {
                    instanceIdsDecoded0?.append(structure0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
        let availabilityZonesContainer = try containerValues.decodeIfPresent([AvailabilityZoneDetail?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[AvailabilityZoneDetail]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [AvailabilityZoneDetail]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let entryPointDecoded = try containerValues.decodeIfPresent(ServiceId.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let faultRootCausesContainer = try containerValues.decodeIfPresent([FaultRootCause?].self, forKey: .faultRootCauses)
        var faultRootCausesDecoded0:[FaultRootCause]? = nil
        if let faultRootCausesContainer = faultRootCausesContainer {
            faultRootCausesDecoded0 = [FaultRootCause]()
            for structure0 in faultRootCausesContainer {
                if let structure0 = structure0 {
                    faultRootCausesDecoded0?.append(structure0)
                }
            }
        }
        faultRootCauses = faultRootCausesDecoded0
        let errorRootCausesContainer = try containerValues.decodeIfPresent([ErrorRootCause?].self, forKey: .errorRootCauses)
        var errorRootCausesDecoded0:[ErrorRootCause]? = nil
        if let errorRootCausesContainer = errorRootCausesContainer {
            errorRootCausesDecoded0 = [ErrorRootCause]()
            for structure0 in errorRootCausesContainer {
                if let structure0 = structure0 {
                    errorRootCausesDecoded0?.append(structure0)
                }
            }
        }
        errorRootCauses = errorRootCausesDecoded0
        let responseTimeRootCausesContainer = try containerValues.decodeIfPresent([ResponseTimeRootCause?].self, forKey: .responseTimeRootCauses)
        var responseTimeRootCausesDecoded0:[ResponseTimeRootCause]? = nil
        if let responseTimeRootCausesContainer = responseTimeRootCausesContainer {
            responseTimeRootCausesDecoded0 = [ResponseTimeRootCause]()
            for structure0 in responseTimeRootCausesContainer {
                if let structure0 = structure0 {
                    responseTimeRootCausesDecoded0?.append(structure0)
                }
            }
        }
        responseTimeRootCauses = responseTimeRootCausesDecoded0
        let revisionDecoded = try containerValues.decode(Int.self, forKey: .revision)
        revision = revisionDecoded
        let matchedEventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .matchedEventTime)
        matchedEventTime = matchedEventTimeDecoded
    }
}

extension TraceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TraceSummary(annotations: \(String(describing: annotations)), availabilityZones: \(String(describing: availabilityZones)), duration: \(String(describing: duration)), entryPoint: \(String(describing: entryPoint)), errorRootCauses: \(String(describing: errorRootCauses)), faultRootCauses: \(String(describing: faultRootCauses)), hasError: \(String(describing: hasError)), hasFault: \(String(describing: hasFault)), hasThrottle: \(String(describing: hasThrottle)), http: \(String(describing: http)), id: \(String(describing: id)), instanceIds: \(String(describing: instanceIds)), isPartial: \(String(describing: isPartial)), matchedEventTime: \(String(describing: matchedEventTime)), resourceARNs: \(String(describing: resourceARNs)), responseTime: \(String(describing: responseTime)), responseTimeRootCauses: \(String(describing: responseTimeRootCauses)), revision: \(String(describing: revision)), serviceIds: \(String(describing: serviceIds)), users: \(String(describing: users)))"}
}

/// <p>Metadata generated from the segment documents in a trace.</p>
public struct TraceSummary: Equatable {
    /// <p>Annotations from the trace's segment documents.</p>
    public let annotations: [String:[ValueWithServiceIds]]?
    /// <p>A list of Availability Zones for any zone corresponding to the trace segments.</p>
    public let availabilityZones: [AvailabilityZoneDetail]?
    /// <p>The length of time in seconds between the start time of the root segment and the end
    ///       time of the last segment that completed.</p>
    public let duration: Double?
    /// <p>The root of a trace.</p>
    public let entryPoint: ServiceId?
    /// <p>A collection of ErrorRootCause structures corresponding to the trace
    ///       segments.</p>
    public let errorRootCauses: [ErrorRootCause]?
    /// <p>A collection of FaultRootCause structures corresponding to the trace segments.</p>
    public let faultRootCauses: [FaultRootCause]?
    /// <p>The root segment document has a 400 series error.</p>
    public let hasError: Bool?
    /// <p>The root segment document has a 500 series error.</p>
    public let hasFault: Bool?
    /// <p>One or more of the segment documents has a 429 throttling error.</p>
    public let hasThrottle: Bool?
    /// <p>Information about the HTTP request served by the trace.</p>
    public let http: Http?
    /// <p>The unique identifier for the request that generated the trace's segments and
    ///       subsegments.</p>
    public let id: String?
    /// <p>A list of EC2 instance IDs for any instance corresponding to the trace
    ///       segments.</p>
    public let instanceIds: [InstanceIdDetail]?
    /// <p>One or more of the segment documents is in progress.</p>
    public let isPartial: Bool?
    /// <p>The matched time stamp of a defined event.</p>
    public let matchedEventTime: Date?
    /// <p>A list of resource ARNs for any resource corresponding to the trace segments.</p>
    public let resourceARNs: [ResourceARNDetail]?
    /// <p>The length of time in seconds between the start and end times of the root segment. If
    ///       the service performs work asynchronously, the response time measures the time before the
    ///       response is sent to the user, while the duration measures the amount of time before the last
    ///       traced activity completes.</p>
    public let responseTime: Double?
    /// <p>A collection of ResponseTimeRootCause structures corresponding to the trace
    ///       segments.</p>
    public let responseTimeRootCauses: [ResponseTimeRootCause]?
    /// <p>The revision number of a trace.</p>
    public let revision: Int
    /// <p>Service IDs from the trace's segment documents.</p>
    public let serviceIds: [ServiceId]?
    /// <p>Users from the trace's segment documents.</p>
    public let users: [TraceUser]?

    public init (
        annotations: [String:[ValueWithServiceIds]]? = nil,
        availabilityZones: [AvailabilityZoneDetail]? = nil,
        duration: Double? = nil,
        entryPoint: ServiceId? = nil,
        errorRootCauses: [ErrorRootCause]? = nil,
        faultRootCauses: [FaultRootCause]? = nil,
        hasError: Bool? = nil,
        hasFault: Bool? = nil,
        hasThrottle: Bool? = nil,
        http: Http? = nil,
        id: String? = nil,
        instanceIds: [InstanceIdDetail]? = nil,
        isPartial: Bool? = nil,
        matchedEventTime: Date? = nil,
        resourceARNs: [ResourceARNDetail]? = nil,
        responseTime: Double? = nil,
        responseTimeRootCauses: [ResponseTimeRootCause]? = nil,
        revision: Int = 0,
        serviceIds: [ServiceId]? = nil,
        users: [TraceUser]? = nil
    )
    {
        self.annotations = annotations
        self.availabilityZones = availabilityZones
        self.duration = duration
        self.entryPoint = entryPoint
        self.errorRootCauses = errorRootCauses
        self.faultRootCauses = faultRootCauses
        self.hasError = hasError
        self.hasFault = hasFault
        self.hasThrottle = hasThrottle
        self.http = http
        self.id = id
        self.instanceIds = instanceIds
        self.isPartial = isPartial
        self.matchedEventTime = matchedEventTime
        self.resourceARNs = resourceARNs
        self.responseTime = responseTime
        self.responseTimeRootCauses = responseTimeRootCauses
        self.revision = revision
        self.serviceIds = serviceIds
        self.users = users
    }
}

extension TraceUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceIds = "ServiceIds"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceIds = serviceIds {
            var serviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceIds)
            for serviceids0 in serviceIds {
                try serviceIdsContainer.encode(serviceids0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let serviceIdsContainer = try containerValues.decodeIfPresent([ServiceId?].self, forKey: .serviceIds)
        var serviceIdsDecoded0:[ServiceId]? = nil
        if let serviceIdsContainer = serviceIdsContainer {
            serviceIdsDecoded0 = [ServiceId]()
            for structure0 in serviceIdsContainer {
                if let structure0 = structure0 {
                    serviceIdsDecoded0?.append(structure0)
                }
            }
        }
        serviceIds = serviceIdsDecoded0
    }
}

extension TraceUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TraceUser(serviceIds: \(String(describing: serviceIds)), userName: \(String(describing: userName)))"}
}

/// <p>Information about a user recorded in segment documents.</p>
public struct TraceUser: Equatable {
    /// <p>Services that the user's request hit.</p>
    public let serviceIds: [ServiceId]?
    /// <p>The user's name.</p>
    public let userName: String?

    public init (
        serviceIds: [ServiceId]? = nil,
        userName: String? = nil
    )
    {
        self.serviceIds = serviceIds
        self.userName = userName
    }
}

extension UnprocessedStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
        case ruleName = "RuleName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessedStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedStatistics(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)), ruleName: \(String(describing: ruleName)))"}
}

/// <p>Sampling statistics from a call to <a>GetSamplingTargets</a> that X-Ray
///       could not process.</p>
public struct UnprocessedStatistics: Equatable {
    /// <p>The error code.</p>
    public let errorCode: String?
    /// <p>The error message.</p>
    public let message: String?
    /// <p>The name of the sampling rule.</p>
    public let ruleName: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil,
        ruleName: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
        self.ruleName = ruleName
    }
}

extension UnprocessedTraceSegment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case id = "Id"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessedTraceSegment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedTraceSegment(errorCode: \(String(describing: errorCode)), id: \(String(describing: id)), message: \(String(describing: message)))"}
}

/// <p>Information about a segment that failed processing.</p>
public struct UnprocessedTraceSegment: Equatable {
    /// <p>The error that caused processing to fail.</p>
    public let errorCode: String?
    /// <p>The segment's ID.</p>
    public let id: String?
    /// <p>The error message.</p>
    public let message: String?

    public init (
        errorCode: String? = nil,
        id: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.id = id
        self.message = message
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of an X-Ray group or sampling rule.</p>
    public let resourceARN: String?
    /// <p>Keys for one or more tags that you want to remove from an X-Ray group or sampling rule.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

extension UpdateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupInput(filterExpression: \(String(describing: filterExpression)), groupARN: \(String(describing: groupARN)), groupName: \(String(describing: groupName)), insightsConfiguration: \(String(describing: insightsConfiguration)))"}
}

extension UpdateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterExpression = "FilterExpression"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterExpression = filterExpression {
            try encodeContainer.encode(filterExpression, forKey: .filterExpression)
        }
        if let groupARN = groupARN {
            try encodeContainer.encode(groupARN, forKey: .groupARN)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let insightsConfiguration = insightsConfiguration {
            try encodeContainer.encode(insightsConfiguration, forKey: .insightsConfiguration)
        }
    }
}

public struct UpdateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGroupInput>
    public typealias MOutput = OperationOutput<UpdateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGroupOutputError>
}

public struct UpdateGroupInput: Equatable {
    /// <p>The updated filter expression defining criteria by which to group traces.</p>
    public let filterExpression: String?
    /// <p>The ARN that was generated upon creation.</p>
    public let groupARN: String?
    /// <p>The case-sensitive name of the group.</p>
    public let groupName: String?
    /// <p>The structure containing configurations related to insights.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>The InsightsEnabled boolean can be set to true to enable insights for the
    ///                     group or false to disable insights for the group.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The NotifcationsEnabled boolean can be set to true to enable insights notifications for the group.
    ///                     Notifications can only be enabled on a group with InsightsEnabled set to true.</p>
    ///             </li>
    ///          </ul>
    public let insightsConfiguration: InsightsConfiguration?

    public init (
        filterExpression: String? = nil,
        groupARN: String? = nil,
        groupName: String? = nil,
        insightsConfiguration: InsightsConfiguration? = nil
    )
    {
        self.filterExpression = filterExpression
        self.groupARN = groupARN
        self.groupName = groupName
        self.insightsConfiguration = insightsConfiguration
    }
}

struct UpdateGroupInputBody: Equatable {
    public let groupName: String?
    public let groupARN: String?
    public let filterExpression: String?
    public let insightsConfiguration: InsightsConfiguration?
}

extension UpdateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterExpression = "FilterExpression"
        case groupARN = "GroupARN"
        case groupName = "GroupName"
        case insightsConfiguration = "InsightsConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupARN)
        groupARN = groupARNDecoded
        let filterExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterExpression)
        filterExpression = filterExpressionDecoded
        let insightsConfigurationDecoded = try containerValues.decodeIfPresent(InsightsConfiguration.self, forKey: .insightsConfiguration)
        insightsConfiguration = insightsConfigurationDecoded
    }
}

extension UpdateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGroupOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGroupOutputResponse(group: \(String(describing: group)))"}
}

extension UpdateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.group = output.group
        } else {
            self.group = nil
        }
    }
}

public struct UpdateGroupOutputResponse: Equatable {
    /// <p>The group that was updated. Contains the name of the group that was updated, the
    ///             ARN of the group that was updated, the updated filter expression, and the updated insight
    ///             configuration assigned to the group.</p>
    public let group: Group?

    public init (
        group: Group? = nil
    )
    {
        self.group = group
    }
}

struct UpdateGroupOutputResponseBody: Equatable {
    public let group: Group?
}

extension UpdateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Group.self, forKey: .group)
        group = groupDecoded
    }
}

public struct UpdateSamplingRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSamplingRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSamplingRuleInput>
    public typealias MOutput = OperationOutput<UpdateSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSamplingRuleOutputError>
}

extension UpdateSamplingRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSamplingRuleInput(samplingRuleUpdate: \(String(describing: samplingRuleUpdate)))"}
}

extension UpdateSamplingRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case samplingRuleUpdate = "SamplingRuleUpdate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let samplingRuleUpdate = samplingRuleUpdate {
            try encodeContainer.encode(samplingRuleUpdate, forKey: .samplingRuleUpdate)
        }
    }
}

public struct UpdateSamplingRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSamplingRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSamplingRuleInput>
    public typealias MOutput = OperationOutput<UpdateSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSamplingRuleOutputError>
}

public struct UpdateSamplingRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSamplingRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSamplingRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSamplingRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSamplingRuleInput>
    public typealias MOutput = OperationOutput<UpdateSamplingRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSamplingRuleOutputError>
}

public struct UpdateSamplingRuleInput: Equatable {
    /// <p>The rule and fields to change.</p>
    public let samplingRuleUpdate: SamplingRuleUpdate?

    public init (
        samplingRuleUpdate: SamplingRuleUpdate? = nil
    )
    {
        self.samplingRuleUpdate = samplingRuleUpdate
    }
}

struct UpdateSamplingRuleInputBody: Equatable {
    public let samplingRuleUpdate: SamplingRuleUpdate?
}

extension UpdateSamplingRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case samplingRuleUpdate = "SamplingRuleUpdate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleUpdateDecoded = try containerValues.decodeIfPresent(SamplingRuleUpdate.self, forKey: .samplingRuleUpdate)
        samplingRuleUpdate = samplingRuleUpdateDecoded
    }
}

extension UpdateSamplingRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSamplingRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottledException" : self = .throttledException(try ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSamplingRuleOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case throttledException(ThrottledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSamplingRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSamplingRuleOutputResponse(samplingRuleRecord: \(String(describing: samplingRuleRecord)))"}
}

extension UpdateSamplingRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSamplingRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.samplingRuleRecord = output.samplingRuleRecord
        } else {
            self.samplingRuleRecord = nil
        }
    }
}

public struct UpdateSamplingRuleOutputResponse: Equatable {
    /// <p>The updated rule definition and metadata.</p>
    public let samplingRuleRecord: SamplingRuleRecord?

    public init (
        samplingRuleRecord: SamplingRuleRecord? = nil
    )
    {
        self.samplingRuleRecord = samplingRuleRecord
    }
}

struct UpdateSamplingRuleOutputResponseBody: Equatable {
    public let samplingRuleRecord: SamplingRuleRecord?
}

extension UpdateSamplingRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case samplingRuleRecord = "SamplingRuleRecord"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let samplingRuleRecordDecoded = try containerValues.decodeIfPresent(SamplingRuleRecord.self, forKey: .samplingRuleRecord)
        samplingRuleRecord = samplingRuleRecordDecoded
    }
}

extension ValueWithServiceIds: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotationValue = "AnnotationValue"
        case serviceIds = "ServiceIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationValue = annotationValue {
            try encodeContainer.encode(annotationValue, forKey: .annotationValue)
        }
        if let serviceIds = serviceIds {
            var serviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceIds)
            for serviceids0 in serviceIds {
                try serviceIdsContainer.encode(serviceids0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationValueDecoded = try containerValues.decodeIfPresent(AnnotationValue.self, forKey: .annotationValue)
        annotationValue = annotationValueDecoded
        let serviceIdsContainer = try containerValues.decodeIfPresent([ServiceId?].self, forKey: .serviceIds)
        var serviceIdsDecoded0:[ServiceId]? = nil
        if let serviceIdsContainer = serviceIdsContainer {
            serviceIdsDecoded0 = [ServiceId]()
            for structure0 in serviceIdsContainer {
                if let structure0 = structure0 {
                    serviceIdsDecoded0?.append(structure0)
                }
            }
        }
        serviceIds = serviceIdsDecoded0
    }
}

extension ValueWithServiceIds: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValueWithServiceIds(annotationValue: \(String(describing: annotationValue)), serviceIds: \(String(describing: serviceIds)))"}
}

/// <p>Information about a segment annotation.</p>
public struct ValueWithServiceIds: Equatable {
    /// <p>Values of the annotation.</p>
    public let annotationValue: AnnotationValue?
    /// <p>Services to which the annotation applies.</p>
    public let serviceIds: [ServiceId]?

    public init (
        annotationValue: AnnotationValue? = nil,
        serviceIds: [ServiceId]? = nil
    )
    {
        self.annotationValue = annotationValue
        self.serviceIds = serviceIds
    }
}
