// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TraceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotations = "Annotations"
        case availabilityZones = "AvailabilityZones"
        case duration = "Duration"
        case entryPoint = "EntryPoint"
        case errorRootCauses = "ErrorRootCauses"
        case faultRootCauses = "FaultRootCauses"
        case hasError = "HasError"
        case hasFault = "HasFault"
        case hasThrottle = "HasThrottle"
        case http = "Http"
        case id = "Id"
        case instanceIds = "InstanceIds"
        case isPartial = "IsPartial"
        case matchedEventTime = "MatchedEventTime"
        case resourceARNs = "ResourceARNs"
        case responseTime = "ResponseTime"
        case responseTimeRootCauses = "ResponseTimeRootCauses"
        case revision = "Revision"
        case serviceIds = "ServiceIds"
        case users = "Users"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotations = annotations {
            var annotationsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .annotations)
            for (dictKey0, annotations0) in annotations {
                try annotationsContainer.encode(annotations0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for traceavailabilityzones0 in availabilityZones {
                try availabilityZonesContainer.encode(traceavailabilityzones0)
            }
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let entryPoint = entryPoint {
            try encodeContainer.encode(entryPoint, forKey: .entryPoint)
        }
        if let errorRootCauses = errorRootCauses {
            var errorRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorRootCauses)
            for errorrootcauses0 in errorRootCauses {
                try errorRootCausesContainer.encode(errorrootcauses0)
            }
        }
        if let faultRootCauses = faultRootCauses {
            var faultRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .faultRootCauses)
            for faultrootcauses0 in faultRootCauses {
                try faultRootCausesContainer.encode(faultrootcauses0)
            }
        }
        if let hasError = hasError {
            try encodeContainer.encode(hasError, forKey: .hasError)
        }
        if let hasFault = hasFault {
            try encodeContainer.encode(hasFault, forKey: .hasFault)
        }
        if let hasThrottle = hasThrottle {
            try encodeContainer.encode(hasThrottle, forKey: .hasThrottle)
        }
        if let http = http {
            try encodeContainer.encode(http, forKey: .http)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for traceinstanceids0 in instanceIds {
                try instanceIdsContainer.encode(traceinstanceids0)
            }
        }
        if let isPartial = isPartial {
            try encodeContainer.encode(isPartial, forKey: .isPartial)
        }
        if let matchedEventTime = matchedEventTime {
            try encodeContainer.encode(matchedEventTime.timeIntervalSince1970, forKey: .matchedEventTime)
        }
        if let resourceARNs = resourceARNs {
            var resourceARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceARNs)
            for traceresourcearns0 in resourceARNs {
                try resourceARNsContainer.encode(traceresourcearns0)
            }
        }
        if let responseTime = responseTime {
            try encodeContainer.encode(responseTime, forKey: .responseTime)
        }
        if let responseTimeRootCauses = responseTimeRootCauses {
            var responseTimeRootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .responseTimeRootCauses)
            for responsetimerootcauses0 in responseTimeRootCauses {
                try responseTimeRootCausesContainer.encode(responsetimerootcauses0)
            }
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let serviceIds = serviceIds {
            var serviceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceIds)
            for serviceids0 in serviceIds {
                try serviceIdsContainer.encode(serviceids0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for traceusers0 in users {
                try usersContainer.encode(traceusers0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .duration)
        duration = durationDecoded
        let responseTimeDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .responseTime)
        responseTime = responseTimeDecoded
        let hasFaultDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasFault)
        hasFault = hasFaultDecoded
        let hasErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasError)
        hasError = hasErrorDecoded
        let hasThrottleDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasThrottle)
        hasThrottle = hasThrottleDecoded
        let isPartialDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isPartial)
        isPartial = isPartialDecoded
        let httpDecoded = try containerValues.decodeIfPresent(Http.self, forKey: .http)
        http = httpDecoded
        let annotationsContainer = try containerValues.decodeIfPresent([String:[ValueWithServiceIds]?].self, forKey: .annotations)
        var annotationsDecoded0: [String:[ValueWithServiceIds]?]? = nil
        if let annotationsContainer = annotationsContainer {
            annotationsDecoded0 = [String:[ValueWithServiceIds]?]()
            for (key0, valueswithserviceids0) in annotationsContainer {
                var valueswithserviceids0Decoded0 = [ValueWithServiceIds]()
                if let valueswithserviceids0 = valueswithserviceids0 {
                    for structure1 in valueswithserviceids0 {
                        valueswithserviceids0Decoded0.append(structure1)
                    }
                }
                annotationsDecoded0?[key0] = valueswithserviceids0Decoded0
            }
        }
        annotations = annotationsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([TraceUser].self, forKey: .users)
        var usersDecoded0:[TraceUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [TraceUser]()
            for structure0 in usersContainer {
                usersDecoded0?.append(structure0)
            }
        }
        users = usersDecoded0
        let serviceIdsContainer = try containerValues.decodeIfPresent([ServiceId].self, forKey: .serviceIds)
        var serviceIdsDecoded0:[ServiceId]? = nil
        if let serviceIdsContainer = serviceIdsContainer {
            serviceIdsDecoded0 = [ServiceId]()
            for structure0 in serviceIdsContainer {
                serviceIdsDecoded0?.append(structure0)
            }
        }
        serviceIds = serviceIdsDecoded0
        let resourceARNsContainer = try containerValues.decodeIfPresent([ResourceARNDetail].self, forKey: .resourceARNs)
        var resourceARNsDecoded0:[ResourceARNDetail]? = nil
        if let resourceARNsContainer = resourceARNsContainer {
            resourceARNsDecoded0 = [ResourceARNDetail]()
            for structure0 in resourceARNsContainer {
                resourceARNsDecoded0?.append(structure0)
            }
        }
        resourceARNs = resourceARNsDecoded0
        let instanceIdsContainer = try containerValues.decodeIfPresent([InstanceIdDetail].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[InstanceIdDetail]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [InstanceIdDetail]()
            for structure0 in instanceIdsContainer {
                instanceIdsDecoded0?.append(structure0)
            }
        }
        instanceIds = instanceIdsDecoded0
        let availabilityZonesContainer = try containerValues.decodeIfPresent([AvailabilityZoneDetail].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[AvailabilityZoneDetail]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [AvailabilityZoneDetail]()
            for structure0 in availabilityZonesContainer {
                availabilityZonesDecoded0?.append(structure0)
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let entryPointDecoded = try containerValues.decodeIfPresent(ServiceId.self, forKey: .entryPoint)
        entryPoint = entryPointDecoded
        let faultRootCausesContainer = try containerValues.decodeIfPresent([FaultRootCause].self, forKey: .faultRootCauses)
        var faultRootCausesDecoded0:[FaultRootCause]? = nil
        if let faultRootCausesContainer = faultRootCausesContainer {
            faultRootCausesDecoded0 = [FaultRootCause]()
            for structure0 in faultRootCausesContainer {
                faultRootCausesDecoded0?.append(structure0)
            }
        }
        faultRootCauses = faultRootCausesDecoded0
        let errorRootCausesContainer = try containerValues.decodeIfPresent([ErrorRootCause].self, forKey: .errorRootCauses)
        var errorRootCausesDecoded0:[ErrorRootCause]? = nil
        if let errorRootCausesContainer = errorRootCausesContainer {
            errorRootCausesDecoded0 = [ErrorRootCause]()
            for structure0 in errorRootCausesContainer {
                errorRootCausesDecoded0?.append(structure0)
            }
        }
        errorRootCauses = errorRootCausesDecoded0
        let responseTimeRootCausesContainer = try containerValues.decodeIfPresent([ResponseTimeRootCause].self, forKey: .responseTimeRootCauses)
        var responseTimeRootCausesDecoded0:[ResponseTimeRootCause]? = nil
        if let responseTimeRootCausesContainer = responseTimeRootCausesContainer {
            responseTimeRootCausesDecoded0 = [ResponseTimeRootCause]()
            for structure0 in responseTimeRootCausesContainer {
                responseTimeRootCausesDecoded0?.append(structure0)
            }
        }
        responseTimeRootCauses = responseTimeRootCausesDecoded0
        let revisionDecoded = try containerValues.decode(Int.self, forKey: .revision)
        revision = revisionDecoded
        let matchedEventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .matchedEventTime)
        matchedEventTime = matchedEventTimeDecoded
    }
}
