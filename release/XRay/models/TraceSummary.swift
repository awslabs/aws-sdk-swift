// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

/// <p>Metadata generated from the segment documents in a trace.</p>
public struct TraceSummary: Equatable {
    /// <p>Annotations from the trace's segment documents.</p>
    public let annotations: [String:[ValueWithServiceIds]]?
    /// <p>A list of Availability Zones for any zone corresponding to the trace segments.</p>
    public let availabilityZones: [AvailabilityZoneDetail]?
    /// <p>The length of time in seconds between the start time of the root segment and the end
    ///       time of the last segment that completed.</p>
    public let duration: Double?
    /// <p>The root of a trace.</p>
    public let entryPoint: ServiceId?
    /// <p>A collection of ErrorRootCause structures corresponding to the trace
    ///       segments.</p>
    public let errorRootCauses: [ErrorRootCause]?
    /// <p>A collection of FaultRootCause structures corresponding to the trace segments.</p>
    public let faultRootCauses: [FaultRootCause]?
    /// <p>The root segment document has a 400 series error.</p>
    public let hasError: Bool?
    /// <p>The root segment document has a 500 series error.</p>
    public let hasFault: Bool?
    /// <p>One or more of the segment documents has a 429 throttling error.</p>
    public let hasThrottle: Bool?
    /// <p>Information about the HTTP request served by the trace.</p>
    public let http: Http?
    /// <p>The unique identifier for the request that generated the trace's segments and
    ///       subsegments.</p>
    public let id: String?
    /// <p>A list of EC2 instance IDs for any instance corresponding to the trace
    ///       segments.</p>
    public let instanceIds: [InstanceIdDetail]?
    /// <p>One or more of the segment documents is in progress.</p>
    public let isPartial: Bool?
    /// <p>The matched time stamp of a defined event.</p>
    public let matchedEventTime: Date?
    /// <p>A list of resource ARNs for any resource corresponding to the trace segments.</p>
    public let resourceARNs: [ResourceARNDetail]?
    /// <p>The length of time in seconds between the start and end times of the root segment. If
    ///       the service performs work asynchronously, the response time measures the time before the
    ///       response is sent to the user, while the duration measures the amount of time before the last
    ///       traced activity completes.</p>
    public let responseTime: Double?
    /// <p>A collection of ResponseTimeRootCause structures corresponding to the trace
    ///       segments.</p>
    public let responseTimeRootCauses: [ResponseTimeRootCause]?
    /// <p>The revision number of a trace.</p>
    public let revision: Int
    /// <p>Service IDs from the trace's segment documents.</p>
    public let serviceIds: [ServiceId]?
    /// <p>Users from the trace's segment documents.</p>
    public let users: [TraceUser]?

    public init (
        annotations: [String:[ValueWithServiceIds]]? = nil,
        availabilityZones: [AvailabilityZoneDetail]? = nil,
        duration: Double? = nil,
        entryPoint: ServiceId? = nil,
        errorRootCauses: [ErrorRootCause]? = nil,
        faultRootCauses: [FaultRootCause]? = nil,
        hasError: Bool? = nil,
        hasFault: Bool? = nil,
        hasThrottle: Bool? = nil,
        http: Http? = nil,
        id: String? = nil,
        instanceIds: [InstanceIdDetail]? = nil,
        isPartial: Bool? = nil,
        matchedEventTime: Date? = nil,
        resourceARNs: [ResourceARNDetail]? = nil,
        responseTime: Double? = nil,
        responseTimeRootCauses: [ResponseTimeRootCause]? = nil,
        revision: Int = 0,
        serviceIds: [ServiceId]? = nil,
        users: [TraceUser]? = nil
    )
    {
        self.annotations = annotations
        self.availabilityZones = availabilityZones
        self.duration = duration
        self.entryPoint = entryPoint
        self.errorRootCauses = errorRootCauses
        self.faultRootCauses = faultRootCauses
        self.hasError = hasError
        self.hasFault = hasFault
        self.hasThrottle = hasThrottle
        self.http = http
        self.id = id
        self.instanceIds = instanceIds
        self.isPartial = isPartial
        self.matchedEventTime = matchedEventTime
        self.resourceARNs = resourceARNs
        self.responseTime = responseTime
        self.responseTimeRootCauses = responseTimeRootCauses
        self.revision = revision
        self.serviceIds = serviceIds
        self.users = users
    }
}

extension TraceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TraceSummary(annotations: \(String(describing: annotations)), availabilityZones: \(String(describing: availabilityZones)), duration: \(String(describing: duration)), entryPoint: \(String(describing: entryPoint)), errorRootCauses: \(String(describing: errorRootCauses)), faultRootCauses: \(String(describing: faultRootCauses)), hasError: \(String(describing: hasError)), hasFault: \(String(describing: hasFault)), hasThrottle: \(String(describing: hasThrottle)), http: \(String(describing: http)), id: \(String(describing: id)), instanceIds: \(String(describing: instanceIds)), isPartial: \(String(describing: isPartial)), matchedEventTime: \(String(describing: matchedEventTime)), resourceARNs: \(String(describing: resourceARNs)), responseTime: \(String(describing: responseTime)), responseTimeRootCauses: \(String(describing: responseTimeRootCauses)), revision: \(String(describing: revision)), serviceIds: \(String(describing: serviceIds)), users: \(String(describing: users)))"}
}
