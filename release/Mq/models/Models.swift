// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

/// The authentication strategy used to secure the broker.
public enum AuthenticationStrategy {
    case ldap
    case simple
    case sdkUnknown(String)
}

extension AuthenticationStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthenticationStrategy] {
        return [
            .ldap,
            .simple,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ldap: return "LDAP"
        case .simple: return "SIMPLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthenticationStrategy(rawValue: rawValue) ?? AuthenticationStrategy.sdkUnknown(rawValue)
    }
}

extension AvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZone(name: \(String(describing: name)))"}
}

/// Name of the availability zone.
public struct AvailabilityZone: Equatable {
    /// Id for the availability zone.
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(errorAttribute: \(String(describing: errorAttribute)), message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: String?
    /// The explanation of the error.
    public var message: String?

    public init (
        errorAttribute: String? = nil,
        message: String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let errorAttribute: String?
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BrokerEngineType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engineType = "engineType"
        case engineVersions = "engineVersions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersions = engineVersions {
            var engineVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineVersions)
            for __listofengineversion0 in engineVersions {
                try engineVersionsContainer.encode(__listofengineversion0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineTypeDecoded = try containerValues.decodeIfPresent(EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionsContainer = try containerValues.decodeIfPresent([EngineVersion?].self, forKey: .engineVersions)
        var engineVersionsDecoded0:[EngineVersion]? = nil
        if let engineVersionsContainer = engineVersionsContainer {
            engineVersionsDecoded0 = [EngineVersion]()
            for structure0 in engineVersionsContainer {
                if let structure0 = structure0 {
                    engineVersionsDecoded0?.append(structure0)
                }
            }
        }
        engineVersions = engineVersionsDecoded0
    }
}

extension BrokerEngineType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerEngineType(engineType: \(String(describing: engineType)), engineVersions: \(String(describing: engineVersions)))"}
}

/// Types of broker engines.
public struct BrokerEngineType: Equatable {
    /// The type of broker engine.
    public let engineType: EngineType?
    /// The list of engine versions.
    public let engineVersions: [EngineVersion]?

    public init (
        engineType: EngineType? = nil,
        engineVersions: [EngineVersion]? = nil
    )
    {
        self.engineType = engineType
        self.engineVersions = engineVersions
    }
}

extension BrokerInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consoleURL = "consoleURL"
        case endpoints = "endpoints"
        case ipAddress = "ipAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleURL = consoleURL {
            try encodeContainer.encode(consoleURL, forKey: .consoleURL)
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpoints)
            for __listof__string0 in endpoints {
                try endpointsContainer.encode(__listof__string0)
            }
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleURLDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consoleURL)
        consoleURL = consoleURLDecoded
        let endpointsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .endpoints)
        var endpointsDecoded0:[String]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [String]()
            for string0 in endpointsContainer {
                if let string0 = string0 {
                    endpointsDecoded0?.append(string0)
                }
            }
        }
        endpoints = endpointsDecoded0
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
    }
}

extension BrokerInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerInstance(consoleURL: \(String(describing: consoleURL)), endpoints: \(String(describing: endpoints)), ipAddress: \(String(describing: ipAddress)))"}
}

/// Returns information about all brokers.
public struct BrokerInstance: Equatable {
    /// The URL of the broker's Web Console.
    public let consoleURL: String?
    /// The broker's wire-level protocol endpoints.
    public let endpoints: [String]?
    /// The IP address of the Elastic Network Interface (ENI) attached to the broker. Does not apply to RabbitMQ brokers
    public let ipAddress: String?

    public init (
        consoleURL: String? = nil,
        endpoints: [String]? = nil,
        ipAddress: String? = nil
    )
    {
        self.consoleURL = consoleURL
        self.endpoints = endpoints
        self.ipAddress = ipAddress
    }
}

extension BrokerInstanceOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "availabilityZones"
        case engineType = "engineType"
        case hostInstanceType = "hostInstanceType"
        case storageType = "storageType"
        case supportedDeploymentModes = "supportedDeploymentModes"
        case supportedEngineVersions = "supportedEngineVersions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for __listofavailabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(__listofavailabilityzone0)
            }
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let supportedDeploymentModes = supportedDeploymentModes {
            var supportedDeploymentModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDeploymentModes)
            for __listofdeploymentmode0 in supportedDeploymentModes {
                try supportedDeploymentModesContainer.encode(__listofdeploymentmode0.rawValue)
            }
        }
        if let supportedEngineVersions = supportedEngineVersions {
            var supportedEngineVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedEngineVersions)
            for __listof__string0 in supportedEngineVersions {
                try supportedEngineVersionsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZonesContainer = try containerValues.decodeIfPresent([AvailabilityZone?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[AvailabilityZone]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [AvailabilityZone]()
            for structure0 in availabilityZonesContainer {
                if let structure0 = structure0 {
                    availabilityZonesDecoded0?.append(structure0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let engineTypeDecoded = try containerValues.decodeIfPresent(EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let supportedDeploymentModesContainer = try containerValues.decodeIfPresent([DeploymentMode?].self, forKey: .supportedDeploymentModes)
        var supportedDeploymentModesDecoded0:[DeploymentMode]? = nil
        if let supportedDeploymentModesContainer = supportedDeploymentModesContainer {
            supportedDeploymentModesDecoded0 = [DeploymentMode]()
            for string0 in supportedDeploymentModesContainer {
                if let string0 = string0 {
                    supportedDeploymentModesDecoded0?.append(string0)
                }
            }
        }
        supportedDeploymentModes = supportedDeploymentModesDecoded0
        let supportedEngineVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedEngineVersions)
        var supportedEngineVersionsDecoded0:[String]? = nil
        if let supportedEngineVersionsContainer = supportedEngineVersionsContainer {
            supportedEngineVersionsDecoded0 = [String]()
            for string0 in supportedEngineVersionsContainer {
                if let string0 = string0 {
                    supportedEngineVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedEngineVersions = supportedEngineVersionsDecoded0
    }
}

extension BrokerInstanceOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerInstanceOption(availabilityZones: \(String(describing: availabilityZones)), engineType: \(String(describing: engineType)), hostInstanceType: \(String(describing: hostInstanceType)), storageType: \(String(describing: storageType)), supportedDeploymentModes: \(String(describing: supportedDeploymentModes)), supportedEngineVersions: \(String(describing: supportedEngineVersions)))"}
}

/// Option for host instance type.
public struct BrokerInstanceOption: Equatable {
    /// The list of available az.
    public let availabilityZones: [AvailabilityZone]?
    /// The type of broker engine.
    public let engineType: EngineType?
    /// The type of broker instance.
    public let hostInstanceType: String?
    /// The broker's storage type.
    public let storageType: BrokerStorageType?
    /// The list of supported deployment modes.
    public let supportedDeploymentModes: [DeploymentMode]?
    /// The list of supported engine versions.
    public let supportedEngineVersions: [String]?

    public init (
        availabilityZones: [AvailabilityZone]? = nil,
        engineType: EngineType? = nil,
        hostInstanceType: String? = nil,
        storageType: BrokerStorageType? = nil,
        supportedDeploymentModes: [DeploymentMode]? = nil,
        supportedEngineVersions: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.engineType = engineType
        self.hostInstanceType = hostInstanceType
        self.storageType = storageType
        self.supportedDeploymentModes = supportedDeploymentModes
        self.supportedEngineVersions = supportedEngineVersions
    }
}

/// The status of the broker.
public enum BrokerState {
    case creationFailed
    case creationInProgress
    case deletionInProgress
    case rebootInProgress
    case running
    case sdkUnknown(String)
}

extension BrokerState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BrokerState] {
        return [
            .creationFailed,
            .creationInProgress,
            .deletionInProgress,
            .rebootInProgress,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creationFailed: return "CREATION_FAILED"
        case .creationInProgress: return "CREATION_IN_PROGRESS"
        case .deletionInProgress: return "DELETION_IN_PROGRESS"
        case .rebootInProgress: return "REBOOT_IN_PROGRESS"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BrokerState(rawValue: rawValue) ?? BrokerState.sdkUnknown(rawValue)
    }
}

/// The broker's storage type. <important>EFS is currently not Supported for RabbitMQ engine type.</important>
public enum BrokerStorageType {
    case ebs
    case efs
    case sdkUnknown(String)
}

extension BrokerStorageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BrokerStorageType] {
        return [
            .ebs,
            .efs,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ebs: return "EBS"
        case .efs: return "EFS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BrokerStorageType(rawValue: rawValue) ?? BrokerStorageType.sdkUnknown(rawValue)
    }
}

extension BrokerSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
        case brokerName = "brokerName"
        case brokerState = "brokerState"
        case created = "created"
        case deploymentMode = "deploymentMode"
        case engineType = "engineType"
        case hostInstanceType = "hostInstanceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let brokerArn = brokerArn {
            try encodeContainer.encode(brokerArn, forKey: .brokerArn)
        }
        if let brokerId = brokerId {
            try encodeContainer.encode(brokerId, forKey: .brokerId)
        }
        if let brokerName = brokerName {
            try encodeContainer.encode(brokerName, forKey: .brokerName)
        }
        if let brokerState = brokerState {
            try encodeContainer.encode(brokerState.rawValue, forKey: .brokerState)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let deploymentMode = deploymentMode {
            try encodeContainer.encode(deploymentMode.rawValue, forKey: .deploymentMode)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let brokerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let brokerStateDecoded = try containerValues.decodeIfPresent(BrokerState.self, forKey: .brokerState)
        brokerState = brokerStateDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
    }
}

extension BrokerSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BrokerSummary(brokerArn: \(String(describing: brokerArn)), brokerId: \(String(describing: brokerId)), brokerName: \(String(describing: brokerName)), brokerState: \(String(describing: brokerState)), created: \(String(describing: created)), deploymentMode: \(String(describing: deploymentMode)), engineType: \(String(describing: engineType)), hostInstanceType: \(String(describing: hostInstanceType)))"}
}

/// The Amazon Resource Name (ARN) of the broker.
public struct BrokerSummary: Equatable {
    /// The Amazon Resource Name (ARN) of the broker.
    public let brokerArn: String?
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// The name of the broker. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain whitespaces, brackets, wildcard characters, or special characters.
    public let brokerName: String?
    /// The status of the broker.
    public let brokerState: BrokerState?
    /// The time when the broker was created.
    public let created: Date?
    /// Required. The deployment mode of the broker.
    public let deploymentMode: DeploymentMode?
    /// Required. The type of broker engine.
    public let engineType: EngineType?
    /// The broker's instance type.
    public let hostInstanceType: String?

    public init (
        brokerArn: String? = nil,
        brokerId: String? = nil,
        brokerName: String? = nil,
        brokerState: BrokerState? = nil,
        created: Date? = nil,
        deploymentMode: DeploymentMode? = nil,
        engineType: EngineType? = nil,
        hostInstanceType: String? = nil
    )
    {
        self.brokerArn = brokerArn
        self.brokerId = brokerId
        self.brokerName = brokerName
        self.brokerState = brokerState
        self.created = created
        self.deploymentMode = deploymentMode
        self.engineType = engineType
        self.hostInstanceType = hostInstanceType
    }
}

/// The type of change pending for the ActiveMQ user.
public enum ChangeType {
    case create
    case delete
    case update
    case sdkUnknown(String)
}

extension ChangeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeType] {
        return [
            .create,
            .delete,
            .update,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .create: return "CREATE"
        case .delete: return "DELETE"
        case .update: return "UPDATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
    }
}

extension Configuration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case description = "description"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let latestRevision = latestRevision {
            try encodeContainer.encode(latestRevision, forKey: .latestRevision)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Configuration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Configuration(arn: \(String(describing: arn)), authenticationStrategy: \(String(describing: authenticationStrategy)), created: \(String(describing: created)), description: \(String(describing: description)), engineType: \(String(describing: engineType)), engineVersion: \(String(describing: engineVersion)), id: \(String(describing: id)), latestRevision: \(String(describing: latestRevision)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// Returns information about all configurations.
public struct Configuration: Equatable {
    /// Required. The ARN of the configuration.
    public let arn: String?
    /// The authentication strategy associated with the configuration.
    public let authenticationStrategy: AuthenticationStrategy?
    /// Required. The date and time of the configuration revision.
    public let created: Date?
    /// Required. The description of the configuration.
    public let description: String?
    /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public let engineType: EngineType?
    /// Required. The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    public let engineVersion: String?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public let id: String?
    /// Required. The latest revision of the configuration.
    public let latestRevision: ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public let name: String?
    /// The list of all tags associated with this configuration.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        authenticationStrategy: AuthenticationStrategy? = nil,
        created: Date? = nil,
        description: String? = nil,
        engineType: EngineType? = nil,
        engineVersion: String? = nil,
        id: String? = nil,
        latestRevision: ConfigurationRevision? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.tags = tags
    }
}

extension ConfigurationId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "id"
        case revision = "revision"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let revisionDecoded = try containerValues.decode(Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension ConfigurationId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationId(id: \(String(describing: id)), revision: \(String(describing: revision)))"}
}

/// A list of information about the configuration. <important>Does not apply to RabbitMQ brokers.</important>
public struct ConfigurationId: Equatable {
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public let id: String?
    /// The revision number of the configuration.
    public let revision: Int

    public init (
        id: String? = nil,
        revision: Int = 0
    )
    {
        self.id = id
        self.revision = revision
    }
}

extension ConfigurationRevision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case created = "created"
        case description = "description"
        case revision = "revision"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if revision != 0 {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let revisionDecoded = try containerValues.decode(Int.self, forKey: .revision)
        revision = revisionDecoded
    }
}

extension ConfigurationRevision: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationRevision(created: \(String(describing: created)), description: \(String(describing: description)), revision: \(String(describing: revision)))"}
}

/// Returns information about the specified configuration revision.
public struct ConfigurationRevision: Equatable {
    /// Required. The date and time of the configuration revision.
    public let created: Date?
    /// The description of the configuration revision.
    public let description: String?
    /// Required. The revision number of the configuration.
    public let revision: Int

    public init (
        created: Date? = nil,
        description: String? = nil,
        revision: Int = 0
    )
    {
        self.created = created
        self.description = description
        self.revision = revision
    }
}

extension Configurations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case current = "current"
        case history = "history"
        case pending = "pending"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let current = current {
            try encodeContainer.encode(current, forKey: .current)
        }
        if let history = history {
            var historyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .history)
            for __listofconfigurationid0 in history {
                try historyContainer.encode(__listofconfigurationid0)
            }
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentDecoded = try containerValues.decodeIfPresent(ConfigurationId.self, forKey: .current)
        current = currentDecoded
        let historyContainer = try containerValues.decodeIfPresent([ConfigurationId?].self, forKey: .history)
        var historyDecoded0:[ConfigurationId]? = nil
        if let historyContainer = historyContainer {
            historyDecoded0 = [ConfigurationId]()
            for structure0 in historyContainer {
                if let structure0 = structure0 {
                    historyDecoded0?.append(structure0)
                }
            }
        }
        history = historyDecoded0
        let pendingDecoded = try containerValues.decodeIfPresent(ConfigurationId.self, forKey: .pending)
        pending = pendingDecoded
    }
}

extension Configurations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Configurations(current: \(String(describing: current)), history: \(String(describing: history)), pending: \(String(describing: pending)))"}
}

/// Broker configuration information
public struct Configurations: Equatable {
    /// The current configuration of the broker.
    public let current: ConfigurationId?
    /// The history of configurations applied to the broker.
    public let history: [ConfigurationId]?
    /// The pending configuration of the broker.
    public let pending: ConfigurationId?

    public init (
        current: ConfigurationId? = nil,
        history: [ConfigurationId]? = nil,
        pending: ConfigurationId? = nil
    )
    {
        self.current = current
        self.history = history
        self.pending = pending
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(errorAttribute: \(String(describing: errorAttribute)), message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: String?
    /// The explanation of the error.
    public var message: String?

    public init (
        errorAttribute: String? = nil,
        message: String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let errorAttribute: String?
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateBrokerInputBodyMiddleware: Middleware {
    public let id: String = "CreateBrokerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBrokerInput>
    public typealias MOutput = OperationOutput<CreateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBrokerOutputError>
}

extension CreateBrokerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBrokerInput(authenticationStrategy: \(String(describing: authenticationStrategy)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), brokerName: \(String(describing: brokerName)), configuration: \(String(describing: configuration)), creatorRequestId: \(String(describing: creatorRequestId)), deploymentMode: \(String(describing: deploymentMode)), encryptionOptions: \(String(describing: encryptionOptions)), engineType: \(String(describing: engineType)), engineVersion: \(String(describing: engineVersion)), hostInstanceType: \(String(describing: hostInstanceType)), ldapServerMetadata: \(String(describing: ldapServerMetadata)), logs: \(String(describing: logs)), maintenanceWindowStartTime: \(String(describing: maintenanceWindowStartTime)), publiclyAccessible: \(String(describing: publiclyAccessible)), securityGroups: \(String(describing: securityGroups)), storageType: \(String(describing: storageType)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), users: \(String(describing: users)))"}
}

extension CreateBrokerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerName = "brokerName"
        case configuration = "configuration"
        case creatorRequestId = "creatorRequestId"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if autoMinorVersionUpgrade != false {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let brokerName = brokerName {
            try encodeContainer.encode(brokerName, forKey: .brokerName)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let creatorRequestId = creatorRequestId {
            try encodeContainer.encode(creatorRequestId, forKey: .creatorRequestId)
        }
        if let deploymentMode = deploymentMode {
            try encodeContainer.encode(deploymentMode.rawValue, forKey: .deploymentMode)
        }
        if let encryptionOptions = encryptionOptions {
            try encodeContainer.encode(encryptionOptions, forKey: .encryptionOptions)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let ldapServerMetadata = ldapServerMetadata {
            try encodeContainer.encode(ldapServerMetadata, forKey: .ldapServerMetadata)
        }
        if let logs = logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let maintenanceWindowStartTime = maintenanceWindowStartTime {
            try encodeContainer.encode(maintenanceWindowStartTime, forKey: .maintenanceWindowStartTime)
        }
        if publiclyAccessible != false {
            try encodeContainer.encode(publiclyAccessible, forKey: .publiclyAccessible)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for __listof__string0 in subnetIds {
                try subnetIdsContainer.encode(__listof__string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for __listofuser0 in users {
                try usersContainer.encode(__listofuser0)
            }
        }
    }
}

public struct CreateBrokerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBrokerInput>
    public typealias MOutput = OperationOutput<CreateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBrokerOutputError>
}

public struct CreateBrokerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBrokerInput>
    public typealias MOutput = OperationOutput<CreateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBrokerOutputError>
}

/// Creates a broker using the specified properties.
public struct CreateBrokerInput: Equatable {
    /// The authentication strategy used to secure the broker.
    public let authenticationStrategy: AuthenticationStrategy?
    /// Required. Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. The automatic upgrades occur during the maintenance window of the broker or after a manual broker reboot.
    public let autoMinorVersionUpgrade: Bool
    /// Required. The name of the broker. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain whitespaces, brackets, wildcard characters, or special characters.
    public let brokerName: String?
    /// A list of information about the configuration.
    public let configuration: ConfigurationId?
    /// The unique ID that the requester receives for the created broker. Amazon MQ passes your ID with the API action. Note: We recommend using a Universally Unique Identifier (UUID) for the creatorRequestId. You may omit the creatorRequestId if your application doesn't require idempotency.
    public var creatorRequestId: String?
    /// Required. The deployment mode of the broker.
    public let deploymentMode: DeploymentMode?
    /// Encryption options for the broker.
    public let encryptionOptions: EncryptionOptions?
    /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public let engineType: EngineType?
    /// Required. The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    public let engineVersion: String?
    /// Required. The broker's instance type.
    public let hostInstanceType: String?
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public let ldapServerMetadata: LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public let logs: Logs?
    /// The parameters that determine the WeeklyStartTime.
    public let maintenanceWindowStartTime: WeeklyStartTime?
    /// Required. Enables connections from applications outside of the VPC that hosts the broker's subnets.
    public let publiclyAccessible: Bool
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public let securityGroups: [String]?
    /// The broker's storage type.
    public let storageType: BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ deployment (ACTIVEMQ) requires two subnets. A CLUSTER_MULTI_AZ deployment (RABBITMQ) has no subnet requirements when deployed with public accessibility, deployment without public accessibility requires at least one subnet.
    public let subnetIds: [String]?
    /// Create tags when creating the broker.
    public let tags: [String:String]?
    /// Required. The list of broker users (persons or applications) who can access queues and topics. For RabbitMQ brokers, one and only one administrative user is accepted and created when a broker is first provisioned. All subsequent broker users are created by making RabbitMQ API calls directly to brokers or via the RabbitMQ Web Console. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let users: [User]?

    public init (
        authenticationStrategy: AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Bool = false,
        brokerName: String? = nil,
        configuration: ConfigurationId? = nil,
        creatorRequestId: String? = nil,
        deploymentMode: DeploymentMode? = nil,
        encryptionOptions: EncryptionOptions? = nil,
        engineType: EngineType? = nil,
        engineVersion: String? = nil,
        hostInstanceType: String? = nil,
        ldapServerMetadata: LdapServerMetadataInput? = nil,
        logs: Logs? = nil,
        maintenanceWindowStartTime: WeeklyStartTime? = nil,
        publiclyAccessible: Bool = false,
        securityGroups: [String]? = nil,
        storageType: BrokerStorageType? = nil,
        subnetIds: [String]? = nil,
        tags: [String:String]? = nil,
        users: [User]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerName = brokerName
        self.configuration = configuration
        self.creatorRequestId = creatorRequestId
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

struct CreateBrokerInputBody: Equatable {
    public let authenticationStrategy: AuthenticationStrategy?
    public let autoMinorVersionUpgrade: Bool
    public let brokerName: String?
    public let configuration: ConfigurationId?
    public let creatorRequestId: String?
    public let deploymentMode: DeploymentMode?
    public let encryptionOptions: EncryptionOptions?
    public let engineType: EngineType?
    public let engineVersion: String?
    public let hostInstanceType: String?
    public let ldapServerMetadata: LdapServerMetadataInput?
    public let logs: Logs?
    public let maintenanceWindowStartTime: WeeklyStartTime?
    public let publiclyAccessible: Bool
    public let securityGroups: [String]?
    public let storageType: BrokerStorageType?
    public let subnetIds: [String]?
    public let tags: [String:String]?
    public let users: [User]?
}

extension CreateBrokerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerName = "brokerName"
        case configuration = "configuration"
        case creatorRequestId = "creatorRequestId"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let creatorRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creatorRequestId)
        creatorRequestId = creatorRequestIdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let encryptionOptionsDecoded = try containerValues.decodeIfPresent(EncryptionOptions.self, forKey: .encryptionOptions)
        encryptionOptions = encryptionOptionsDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(LdapServerMetadataInput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(Logs.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([User?].self, forKey: .users)
        var usersDecoded0:[User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension CreateBrokerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBrokerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBrokerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBrokerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBrokerOutputResponse(brokerArn: \(String(describing: brokerArn)), brokerId: \(String(describing: brokerId)))"}
}

extension CreateBrokerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBrokerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.brokerArn = output.brokerArn
            self.brokerId = output.brokerId
        } else {
            self.brokerArn = nil
            self.brokerId = nil
        }
    }
}

public struct CreateBrokerOutputResponse: Equatable {
    /// The Amazon Resource Name (ARN) of the broker.
    public let brokerArn: String?
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?

    public init (
        brokerArn: String? = nil,
        brokerId: String? = nil
    )
    {
        self.brokerArn = brokerArn
        self.brokerId = brokerId
    }
}

struct CreateBrokerOutputResponseBody: Equatable {
    public let brokerArn: String?
    public let brokerId: String?
}

extension CreateBrokerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

public struct CreateConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationOutputError>
}

extension CreateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationInput(authenticationStrategy: \(String(describing: authenticationStrategy)), engineType: \(String(describing: engineType)), engineVersion: \(String(describing: engineVersion)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if let engineType = engineType {
            try encodeContainer.encode(engineType.rawValue, forKey: .engineType)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationOutputError>
}

public struct CreateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationOutputError>
}

/// Creates a new configuration for the specified configuration name. Amazon MQ uses the default configuration (the engine type and version).
public struct CreateConfigurationInput: Equatable {
    /// The authentication strategy associated with the configuration.
    public let authenticationStrategy: AuthenticationStrategy?
    /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public let engineType: EngineType?
    /// Required. The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    public let engineVersion: String?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public let name: String?
    /// Create tags when creating the configuration.
    public let tags: [String:String]?

    public init (
        authenticationStrategy: AuthenticationStrategy? = nil,
        engineType: EngineType? = nil,
        engineVersion: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateConfigurationInputBody: Equatable {
    public let authenticationStrategy: AuthenticationStrategy?
    public let engineType: EngineType?
    public let engineVersion: String?
    public let name: String?
    public let tags: [String:String]?
}

extension CreateConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationOutputResponse(arn: \(String(describing: arn)), authenticationStrategy: \(String(describing: authenticationStrategy)), created: \(String(describing: created)), id: \(String(describing: id)), latestRevision: \(String(describing: latestRevision)), name: \(String(describing: name)))"}
}

extension CreateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authenticationStrategy = output.authenticationStrategy
            self.created = output.created
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
        } else {
            self.arn = nil
            self.authenticationStrategy = nil
            self.created = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
        }
    }
}

public struct CreateConfigurationOutputResponse: Equatable {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    public let arn: String?
    /// The authentication strategy associated with the configuration.
    public let authenticationStrategy: AuthenticationStrategy?
    /// Required. The date and time of the configuration.
    public let created: Date?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public let id: String?
    /// The latest revision of the configuration.
    public let latestRevision: ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public let name: String?

    public init (
        arn: String? = nil,
        authenticationStrategy: AuthenticationStrategy? = nil,
        created: Date? = nil,
        id: String? = nil,
        latestRevision: ConfigurationRevision? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
    }
}

struct CreateConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let authenticationStrategy: AuthenticationStrategy?
    public let created: Date?
    public let id: String?
    public let latestRevision: ConfigurationRevision?
    public let name: String?
}

extension CreateConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateTagsInputBodyMiddleware: Middleware {
    public let id: String = "CreateTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

extension CreateTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension CreateTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateTagsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

public struct CreateTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTagsInput>
    public typealias MOutput = OperationOutput<CreateTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTagsOutputError>
}

/// A map of the key-value pairs for the resource tag.
public struct CreateTagsInput: Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    public let resourceArn: String?
    /// The key-value pair for the resource tag.
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateTagsInputBody: Equatable {
    public let tags: [String:String]?
}

extension CreateTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTagsOutputResponse()"}
}

extension CreateTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateTagsOutputResponse: Equatable {

    public init() {}
}

struct CreateTagsOutputResponseBody: Equatable {
}

extension CreateTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateUserInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(brokerId: \(String(describing: brokerId)), consoleAccess: \(String(describing: consoleAccess)), groups: \(String(describing: groups)), password: \(String(describing: password)), username: \(String(describing: username)))"}
}

extension CreateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if consoleAccess != false {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

/// Creates a new ActiveMQ user.
public struct CreateUserInput: Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public let consoleAccess: Bool
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let groups: [String]?
    /// Required. The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas.
    public let password: String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let username: String?

    public init (
        brokerId: String? = nil,
        consoleAccess: Bool = false,
        groups: [String]? = nil,
        password: String? = nil,
        username: String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.username = username
    }
}

struct CreateUserInputBody: Equatable {
    public let consoleAccess: Bool
    public let groups: [String]?
    public let password: String?
}

extension CreateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decode(Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groups)
        var groupsDecoded0:[String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserOutputResponse()"}
}

extension CreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateUserOutputResponse: Equatable {

    public init() {}
}

struct CreateUserOutputResponseBody: Equatable {
}

extension CreateUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum DayOfWeek {
    case friday
    case monday
    case saturday
    case sunday
    case thursday
    case tuesday
    case wednesday
    case sdkUnknown(String)
}

extension DayOfWeek : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DayOfWeek] {
        return [
            .friday,
            .monday,
            .saturday,
            .sunday,
            .thursday,
            .tuesday,
            .wednesday,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .friday: return "FRIDAY"
        case .monday: return "MONDAY"
        case .saturday: return "SATURDAY"
        case .sunday: return "SUNDAY"
        case .thursday: return "THURSDAY"
        case .tuesday: return "TUESDAY"
        case .wednesday: return "WEDNESDAY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
    }
}

extension DeleteBrokerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBrokerInput(brokerId: \(String(describing: brokerId)))"}
}

extension DeleteBrokerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBrokerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBrokerInput>
    public typealias MOutput = OperationOutput<DeleteBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBrokerOutputError>
}

public struct DeleteBrokerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBrokerInput>
    public typealias MOutput = OperationOutput<DeleteBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBrokerOutputError>
}

public struct DeleteBrokerInput: Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?

    public init (
        brokerId: String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DeleteBrokerInputBody: Equatable {
}

extension DeleteBrokerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBrokerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBrokerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBrokerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBrokerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBrokerOutputResponse(brokerId: \(String(describing: brokerId)))"}
}

extension DeleteBrokerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteBrokerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.brokerId = output.brokerId
        } else {
            self.brokerId = nil
        }
    }
}

public struct DeleteBrokerOutputResponse: Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?

    public init (
        brokerId: String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DeleteBrokerOutputResponseBody: Equatable {
    public let brokerId: String?
}

extension DeleteBrokerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerId = "brokerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
    }
}

extension DeleteTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension DeleteTagsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTagsInput>
    public typealias MOutput = OperationOutput<DeleteTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTagsOutputError>
}

public struct DeleteTagsInput: Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    public let resourceArn: String?
    /// An array of tag keys to delete
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Equatable {
}

extension DeleteTagsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTagsOutputResponse()"}
}

extension DeleteTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagsOutputResponse: Equatable {

    public init() {}
}

struct DeleteTagsOutputResponseBody: Equatable {
}

extension DeleteTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(brokerId: \(String(describing: brokerId)), username: \(String(describing: username)))"}
}

extension DeleteUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let username: String?

    public init (
        brokerId: String? = nil,
        username: String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

struct DeleteUserInputBody: Equatable {
}

extension DeleteUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// The deployment mode of the broker.
public enum DeploymentMode {
    case activeStandbyMultiAz
    case clusterMultiAz
    case singleInstance
    case sdkUnknown(String)
}

extension DeploymentMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeploymentMode] {
        return [
            .activeStandbyMultiAz,
            .clusterMultiAz,
            .singleInstance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activeStandbyMultiAz: return "ACTIVE_STANDBY_MULTI_AZ"
        case .clusterMultiAz: return "CLUSTER_MULTI_AZ"
        case .singleInstance: return "SINGLE_INSTANCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeploymentMode(rawValue: rawValue) ?? DeploymentMode.sdkUnknown(rawValue)
    }
}

extension DescribeBrokerEngineTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBrokerEngineTypesInput(engineType: \(String(describing: engineType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBrokerEngineTypesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBrokerEngineTypesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBrokerEngineTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBrokerEngineTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBrokerEngineTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBrokerEngineTypesInput>
    public typealias MOutput = OperationOutput<DescribeBrokerEngineTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBrokerEngineTypesOutputError>
}

public struct DescribeBrokerEngineTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBrokerEngineTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBrokerEngineTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBrokerEngineTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let engineType = input.operationInput.engineType {
            let engineTypeQueryItem = URLQueryItem(name: "engineType".urlPercentEncoding(), value: String(engineType).urlPercentEncoding())
            input.builder.withQueryItem(engineTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBrokerEngineTypesInput>
    public typealias MOutput = OperationOutput<DescribeBrokerEngineTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBrokerEngineTypesOutputError>
}

public struct DescribeBrokerEngineTypesInput: Equatable {
    /// Filter response by engine type.
    public let engineType: String?
    /// The maximum number of engine types that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        engineType: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.engineType = engineType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerEngineTypesInputBody: Equatable {
}

extension DescribeBrokerEngineTypesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBrokerEngineTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerEngineTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerEngineTypesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerEngineTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBrokerEngineTypesOutputResponse(brokerEngineTypes: \(String(describing: brokerEngineTypes)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBrokerEngineTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBrokerEngineTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.brokerEngineTypes = output.brokerEngineTypes
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.brokerEngineTypes = nil
            self.maxResults = 0
            self.nextToken = nil
        }
    }
}

public struct DescribeBrokerEngineTypesOutputResponse: Equatable {
    /// List of available engine types and versions.
    public let brokerEngineTypes: [BrokerEngineType]?
    /// Required. The maximum number of engine types that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        brokerEngineTypes: [BrokerEngineType]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.brokerEngineTypes = brokerEngineTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerEngineTypesOutputResponseBody: Equatable {
    public let brokerEngineTypes: [BrokerEngineType]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeBrokerEngineTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerEngineTypes = "brokerEngineTypes"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerEngineTypesContainer = try containerValues.decodeIfPresent([BrokerEngineType?].self, forKey: .brokerEngineTypes)
        var brokerEngineTypesDecoded0:[BrokerEngineType]? = nil
        if let brokerEngineTypesContainer = brokerEngineTypesContainer {
            brokerEngineTypesDecoded0 = [BrokerEngineType]()
            for structure0 in brokerEngineTypesContainer {
                if let structure0 = structure0 {
                    brokerEngineTypesDecoded0?.append(structure0)
                }
            }
        }
        brokerEngineTypes = brokerEngineTypesDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBrokerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBrokerInput(brokerId: \(String(describing: brokerId)))"}
}

extension DescribeBrokerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBrokerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBrokerInput>
    public typealias MOutput = OperationOutput<DescribeBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBrokerOutputError>
}

public struct DescribeBrokerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBrokerInput>
    public typealias MOutput = OperationOutput<DescribeBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBrokerOutputError>
}

public struct DescribeBrokerInput: Equatable {
    /// The name of the broker. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain whitespaces, brackets, wildcard characters, or special characters.
    public let brokerId: String?

    public init (
        brokerId: String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct DescribeBrokerInputBody: Equatable {
}

extension DescribeBrokerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBrokerInstanceOptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBrokerInstanceOptionsInput(engineType: \(String(describing: engineType)), hostInstanceType: \(String(describing: hostInstanceType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), storageType: \(String(describing: storageType)))"}
}

extension DescribeBrokerInstanceOptionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeBrokerInstanceOptionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBrokerInstanceOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBrokerInstanceOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBrokerInstanceOptionsInput>
    public typealias MOutput = OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBrokerInstanceOptionsOutputError>
}

public struct DescribeBrokerInstanceOptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBrokerInstanceOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBrokerInstanceOptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let storageType = input.operationInput.storageType {
            let storageTypeQueryItem = URLQueryItem(name: "storageType".urlPercentEncoding(), value: String(storageType).urlPercentEncoding())
            input.builder.withQueryItem(storageTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let engineType = input.operationInput.engineType {
            let engineTypeQueryItem = URLQueryItem(name: "engineType".urlPercentEncoding(), value: String(engineType).urlPercentEncoding())
            input.builder.withQueryItem(engineTypeQueryItem)
        }
        if let hostInstanceType = input.operationInput.hostInstanceType {
            let hostInstanceTypeQueryItem = URLQueryItem(name: "hostInstanceType".urlPercentEncoding(), value: String(hostInstanceType).urlPercentEncoding())
            input.builder.withQueryItem(hostInstanceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBrokerInstanceOptionsInput>
    public typealias MOutput = OperationOutput<DescribeBrokerInstanceOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBrokerInstanceOptionsOutputError>
}

public struct DescribeBrokerInstanceOptionsInput: Equatable {
    /// Filter response by engine type.
    public let engineType: String?
    /// Filter response by host instance type.
    public let hostInstanceType: String?
    /// The maximum number of instance options that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?
    /// Filter response by storage type.
    public let storageType: String?

    public init (
        engineType: String? = nil,
        hostInstanceType: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        storageType: String? = nil
    )
    {
        self.engineType = engineType
        self.hostInstanceType = hostInstanceType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.storageType = storageType
    }
}

struct DescribeBrokerInstanceOptionsInputBody: Equatable {
}

extension DescribeBrokerInstanceOptionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeBrokerInstanceOptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerInstanceOptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerInstanceOptionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerInstanceOptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBrokerInstanceOptionsOutputResponse(brokerInstanceOptions: \(String(describing: brokerInstanceOptions)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBrokerInstanceOptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBrokerInstanceOptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.brokerInstanceOptions = output.brokerInstanceOptions
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.brokerInstanceOptions = nil
            self.maxResults = 0
            self.nextToken = nil
        }
    }
}

public struct DescribeBrokerInstanceOptionsOutputResponse: Equatable {
    /// List of available broker instance options.
    public let brokerInstanceOptions: [BrokerInstanceOption]?
    /// Required. The maximum number of instance options that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        brokerInstanceOptions: [BrokerInstanceOption]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.brokerInstanceOptions = brokerInstanceOptions
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBrokerInstanceOptionsOutputResponseBody: Equatable {
    public let brokerInstanceOptions: [BrokerInstanceOption]?
    public let maxResults: Int
    public let nextToken: String?
}

extension DescribeBrokerInstanceOptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerInstanceOptions = "brokerInstanceOptions"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerInstanceOptionsContainer = try containerValues.decodeIfPresent([BrokerInstanceOption?].self, forKey: .brokerInstanceOptions)
        var brokerInstanceOptionsDecoded0:[BrokerInstanceOption]? = nil
        if let brokerInstanceOptionsContainer = brokerInstanceOptionsContainer {
            brokerInstanceOptionsDecoded0 = [BrokerInstanceOption]()
            for structure0 in brokerInstanceOptionsContainer {
                if let structure0 = structure0 {
                    brokerInstanceOptionsDecoded0?.append(structure0)
                }
            }
        }
        brokerInstanceOptions = brokerInstanceOptionsDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBrokerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBrokerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBrokerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBrokerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBrokerOutputResponse(authenticationStrategy: \(String(describing: authenticationStrategy)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), brokerArn: \(String(describing: brokerArn)), brokerId: \(String(describing: brokerId)), brokerInstances: \(String(describing: brokerInstances)), brokerName: \(String(describing: brokerName)), brokerState: \(String(describing: brokerState)), configurations: \(String(describing: configurations)), created: \(String(describing: created)), deploymentMode: \(String(describing: deploymentMode)), encryptionOptions: \(String(describing: encryptionOptions)), engineType: \(String(describing: engineType)), engineVersion: \(String(describing: engineVersion)), hostInstanceType: \(String(describing: hostInstanceType)), ldapServerMetadata: \(String(describing: ldapServerMetadata)), logs: \(String(describing: logs)), maintenanceWindowStartTime: \(String(describing: maintenanceWindowStartTime)), pendingAuthenticationStrategy: \(String(describing: pendingAuthenticationStrategy)), pendingEngineVersion: \(String(describing: pendingEngineVersion)), pendingHostInstanceType: \(String(describing: pendingHostInstanceType)), pendingLdapServerMetadata: \(String(describing: pendingLdapServerMetadata)), pendingSecurityGroups: \(String(describing: pendingSecurityGroups)), publiclyAccessible: \(String(describing: publiclyAccessible)), securityGroups: \(String(describing: securityGroups)), storageType: \(String(describing: storageType)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)), users: \(String(describing: users)))"}
}

extension DescribeBrokerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBrokerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authenticationStrategy = output.authenticationStrategy
            self.autoMinorVersionUpgrade = output.autoMinorVersionUpgrade
            self.brokerArn = output.brokerArn
            self.brokerId = output.brokerId
            self.brokerInstances = output.brokerInstances
            self.brokerName = output.brokerName
            self.brokerState = output.brokerState
            self.configurations = output.configurations
            self.created = output.created
            self.deploymentMode = output.deploymentMode
            self.encryptionOptions = output.encryptionOptions
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.hostInstanceType = output.hostInstanceType
            self.ldapServerMetadata = output.ldapServerMetadata
            self.logs = output.logs
            self.maintenanceWindowStartTime = output.maintenanceWindowStartTime
            self.pendingAuthenticationStrategy = output.pendingAuthenticationStrategy
            self.pendingEngineVersion = output.pendingEngineVersion
            self.pendingHostInstanceType = output.pendingHostInstanceType
            self.pendingLdapServerMetadata = output.pendingLdapServerMetadata
            self.pendingSecurityGroups = output.pendingSecurityGroups
            self.publiclyAccessible = output.publiclyAccessible
            self.securityGroups = output.securityGroups
            self.storageType = output.storageType
            self.subnetIds = output.subnetIds
            self.tags = output.tags
            self.users = output.users
        } else {
            self.authenticationStrategy = nil
            self.autoMinorVersionUpgrade = false
            self.brokerArn = nil
            self.brokerId = nil
            self.brokerInstances = nil
            self.brokerName = nil
            self.brokerState = nil
            self.configurations = nil
            self.created = nil
            self.deploymentMode = nil
            self.encryptionOptions = nil
            self.engineType = nil
            self.engineVersion = nil
            self.hostInstanceType = nil
            self.ldapServerMetadata = nil
            self.logs = nil
            self.maintenanceWindowStartTime = nil
            self.pendingAuthenticationStrategy = nil
            self.pendingEngineVersion = nil
            self.pendingHostInstanceType = nil
            self.pendingLdapServerMetadata = nil
            self.pendingSecurityGroups = nil
            self.publiclyAccessible = false
            self.securityGroups = nil
            self.storageType = nil
            self.subnetIds = nil
            self.tags = nil
            self.users = nil
        }
    }
}

public struct DescribeBrokerOutputResponse: Equatable {
    /// The authentication strategy used to secure the broker.
    public let authenticationStrategy: AuthenticationStrategy?
    /// Required. Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. The automatic upgrades occur during the maintenance window of the broker or after a manual broker reboot.
    public let autoMinorVersionUpgrade: Bool
    /// The Amazon Resource Name (ARN) of the broker.
    public let brokerArn: String?
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// A list of information about allocated brokers.
    public let brokerInstances: [BrokerInstance]?
    /// The name of the broker. This value must be unique in your AWS account, 1-50 characters long, must contain only letters, numbers, dashes, and underscores, and must not contain whitespaces, brackets, wildcard characters, or special characters.
    public let brokerName: String?
    /// The status of the broker.
    public let brokerState: BrokerState?
    /// The list of all revisions for the specified configuration.
    public let configurations: Configurations?
    /// The time when the broker was created.
    public let created: Date?
    /// Required. The deployment mode of the broker.
    public let deploymentMode: DeploymentMode?
    /// Encryption options for the broker.
    public let encryptionOptions: EncryptionOptions?
    /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public let engineType: EngineType?
    /// The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    public let engineVersion: String?
    /// The broker's instance type.
    public let hostInstanceType: String?
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public let ldapServerMetadata: LdapServerMetadataOutput?
    /// The list of information about logs currently enabled and pending to be deployed for the specified broker.
    public let logs: LogsSummary?
    /// The parameters that determine the WeeklyStartTime.
    public let maintenanceWindowStartTime: WeeklyStartTime?
    /// The authentication strategy that will be applied when the broker is rebooted.
    public let pendingAuthenticationStrategy: AuthenticationStrategy?
    /// The version of the broker engine to upgrade to. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    public let pendingEngineVersion: String?
    /// The host instance type of the broker to upgrade to. For a list of supported instance types, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide//broker.html#broker-instance-types
    public let pendingHostInstanceType: String?
    /// The metadata of the LDAP server that will be used to authenticate and authorize connections to the broker once it is rebooted.
    public let pendingLdapServerMetadata: LdapServerMetadataOutput?
    /// The list of pending security groups to authorize connections to brokers.
    public let pendingSecurityGroups: [String]?
    /// Required. Enables connections from applications outside of the VPC that hosts the broker's subnets.
    public let publiclyAccessible: Bool
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public let securityGroups: [String]?
    /// The broker's storage type.
    public let storageType: BrokerStorageType?
    /// The list of groups that define which subnets and IP ranges the broker can use from different Availability Zones. A SINGLE_INSTANCE deployment requires one subnet (for example, the default subnet). An ACTIVE_STANDBY_MULTI_AZ deployment (ACTIVEMQ) requires two subnets. A CLUSTER_MULTI_AZ deployment (RABBITMQ) has no subnet requirements when deployed with public accessibility, deployment without public accessibility requires at least one subnet.
    public let subnetIds: [String]?
    /// The list of all tags associated with this broker.
    public let tags: [String:String]?
    /// The list of all broker usernames for the specified broker.
    public let users: [UserSummary]?

    public init (
        authenticationStrategy: AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Bool = false,
        brokerArn: String? = nil,
        brokerId: String? = nil,
        brokerInstances: [BrokerInstance]? = nil,
        brokerName: String? = nil,
        brokerState: BrokerState? = nil,
        configurations: Configurations? = nil,
        created: Date? = nil,
        deploymentMode: DeploymentMode? = nil,
        encryptionOptions: EncryptionOptions? = nil,
        engineType: EngineType? = nil,
        engineVersion: String? = nil,
        hostInstanceType: String? = nil,
        ldapServerMetadata: LdapServerMetadataOutput? = nil,
        logs: LogsSummary? = nil,
        maintenanceWindowStartTime: WeeklyStartTime? = nil,
        pendingAuthenticationStrategy: AuthenticationStrategy? = nil,
        pendingEngineVersion: String? = nil,
        pendingHostInstanceType: String? = nil,
        pendingLdapServerMetadata: LdapServerMetadataOutput? = nil,
        pendingSecurityGroups: [String]? = nil,
        publiclyAccessible: Bool = false,
        securityGroups: [String]? = nil,
        storageType: BrokerStorageType? = nil,
        subnetIds: [String]? = nil,
        tags: [String:String]? = nil,
        users: [UserSummary]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerArn = brokerArn
        self.brokerId = brokerId
        self.brokerInstances = brokerInstances
        self.brokerName = brokerName
        self.brokerState = brokerState
        self.configurations = configurations
        self.created = created
        self.deploymentMode = deploymentMode
        self.encryptionOptions = encryptionOptions
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.maintenanceWindowStartTime = maintenanceWindowStartTime
        self.pendingAuthenticationStrategy = pendingAuthenticationStrategy
        self.pendingEngineVersion = pendingEngineVersion
        self.pendingHostInstanceType = pendingHostInstanceType
        self.pendingLdapServerMetadata = pendingLdapServerMetadata
        self.pendingSecurityGroups = pendingSecurityGroups
        self.publiclyAccessible = publiclyAccessible
        self.securityGroups = securityGroups
        self.storageType = storageType
        self.subnetIds = subnetIds
        self.tags = tags
        self.users = users
    }
}

struct DescribeBrokerOutputResponseBody: Equatable {
    public let authenticationStrategy: AuthenticationStrategy?
    public let autoMinorVersionUpgrade: Bool
    public let brokerArn: String?
    public let brokerId: String?
    public let brokerInstances: [BrokerInstance]?
    public let brokerName: String?
    public let brokerState: BrokerState?
    public let configurations: Configurations?
    public let created: Date?
    public let deploymentMode: DeploymentMode?
    public let encryptionOptions: EncryptionOptions?
    public let engineType: EngineType?
    public let engineVersion: String?
    public let hostInstanceType: String?
    public let ldapServerMetadata: LdapServerMetadataOutput?
    public let logs: LogsSummary?
    public let maintenanceWindowStartTime: WeeklyStartTime?
    public let pendingAuthenticationStrategy: AuthenticationStrategy?
    public let pendingEngineVersion: String?
    public let pendingHostInstanceType: String?
    public let pendingLdapServerMetadata: LdapServerMetadataOutput?
    public let pendingSecurityGroups: [String]?
    public let publiclyAccessible: Bool
    public let securityGroups: [String]?
    public let storageType: BrokerStorageType?
    public let subnetIds: [String]?
    public let tags: [String:String]?
    public let users: [UserSummary]?
}

extension DescribeBrokerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerArn = "brokerArn"
        case brokerId = "brokerId"
        case brokerInstances = "brokerInstances"
        case brokerName = "brokerName"
        case brokerState = "brokerState"
        case configurations = "configurations"
        case created = "created"
        case deploymentMode = "deploymentMode"
        case encryptionOptions = "encryptionOptions"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case maintenanceWindowStartTime = "maintenanceWindowStartTime"
        case pendingAuthenticationStrategy = "pendingAuthenticationStrategy"
        case pendingEngineVersion = "pendingEngineVersion"
        case pendingHostInstanceType = "pendingHostInstanceType"
        case pendingLdapServerMetadata = "pendingLdapServerMetadata"
        case pendingSecurityGroups = "pendingSecurityGroups"
        case publiclyAccessible = "publiclyAccessible"
        case securityGroups = "securityGroups"
        case storageType = "storageType"
        case subnetIds = "subnetIds"
        case tags = "tags"
        case users = "users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerArn)
        brokerArn = brokerArnDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let brokerInstancesContainer = try containerValues.decodeIfPresent([BrokerInstance?].self, forKey: .brokerInstances)
        var brokerInstancesDecoded0:[BrokerInstance]? = nil
        if let brokerInstancesContainer = brokerInstancesContainer {
            brokerInstancesDecoded0 = [BrokerInstance]()
            for structure0 in brokerInstancesContainer {
                if let structure0 = structure0 {
                    brokerInstancesDecoded0?.append(structure0)
                }
            }
        }
        brokerInstances = brokerInstancesDecoded0
        let brokerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerName)
        brokerName = brokerNameDecoded
        let brokerStateDecoded = try containerValues.decodeIfPresent(BrokerState.self, forKey: .brokerState)
        brokerState = brokerStateDecoded
        let configurationsDecoded = try containerValues.decodeIfPresent(Configurations.self, forKey: .configurations)
        configurations = configurationsDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let deploymentModeDecoded = try containerValues.decodeIfPresent(DeploymentMode.self, forKey: .deploymentMode)
        deploymentMode = deploymentModeDecoded
        let encryptionOptionsDecoded = try containerValues.decodeIfPresent(EncryptionOptions.self, forKey: .encryptionOptions)
        encryptionOptions = encryptionOptionsDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(LdapServerMetadataOutput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(LogsSummary.self, forKey: .logs)
        logs = logsDecoded
        let maintenanceWindowStartTimeDecoded = try containerValues.decodeIfPresent(WeeklyStartTime.self, forKey: .maintenanceWindowStartTime)
        maintenanceWindowStartTime = maintenanceWindowStartTimeDecoded
        let pendingAuthenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .pendingAuthenticationStrategy)
        pendingAuthenticationStrategy = pendingAuthenticationStrategyDecoded
        let pendingEngineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pendingEngineVersion)
        pendingEngineVersion = pendingEngineVersionDecoded
        let pendingHostInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pendingHostInstanceType)
        pendingHostInstanceType = pendingHostInstanceTypeDecoded
        let pendingLdapServerMetadataDecoded = try containerValues.decodeIfPresent(LdapServerMetadataOutput.self, forKey: .pendingLdapServerMetadata)
        pendingLdapServerMetadata = pendingLdapServerMetadataDecoded
        let pendingSecurityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pendingSecurityGroups)
        var pendingSecurityGroupsDecoded0:[String]? = nil
        if let pendingSecurityGroupsContainer = pendingSecurityGroupsContainer {
            pendingSecurityGroupsDecoded0 = [String]()
            for string0 in pendingSecurityGroupsContainer {
                if let string0 = string0 {
                    pendingSecurityGroupsDecoded0?.append(string0)
                }
            }
        }
        pendingSecurityGroups = pendingSecurityGroupsDecoded0
        let publiclyAccessibleDecoded = try containerValues.decode(Bool.self, forKey: .publiclyAccessible)
        publiclyAccessible = publiclyAccessibleDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let storageTypeDecoded = try containerValues.decodeIfPresent(BrokerStorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([UserSummary?].self, forKey: .users)
        var usersDecoded0:[UserSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [UserSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension DescribeConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationInput(configurationId: \(String(describing: configurationId)))"}
}

extension DescribeConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationOutputError>
}

public struct DescribeConfigurationInput: Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    public let configurationId: String?

    public init (
        configurationId: String? = nil
    )
    {
        self.configurationId = configurationId
    }
}

struct DescribeConfigurationInputBody: Equatable {
}

extension DescribeConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationOutputResponse(arn: \(String(describing: arn)), authenticationStrategy: \(String(describing: authenticationStrategy)), created: \(String(describing: created)), description: \(String(describing: description)), engineType: \(String(describing: engineType)), engineVersion: \(String(describing: engineVersion)), id: \(String(describing: id)), latestRevision: \(String(describing: latestRevision)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension DescribeConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authenticationStrategy = output.authenticationStrategy
            self.created = output.created
            self.description = output.description
            self.engineType = output.engineType
            self.engineVersion = output.engineVersion
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authenticationStrategy = nil
            self.created = nil
            self.description = nil
            self.engineType = nil
            self.engineVersion = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct DescribeConfigurationOutputResponse: Equatable {
    /// Required. The ARN of the configuration.
    public let arn: String?
    /// The authentication strategy associated with the configuration.
    public let authenticationStrategy: AuthenticationStrategy?
    /// Required. The date and time of the configuration revision.
    public let created: Date?
    /// Required. The description of the configuration.
    public let description: String?
    /// Required. The type of broker engine. Note: Currently, Amazon MQ supports ACTIVEMQ and RABBITMQ.
    public let engineType: EngineType?
    /// Required. The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    public let engineVersion: String?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public let id: String?
    /// Required. The latest revision of the configuration.
    public let latestRevision: ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public let name: String?
    /// The list of all tags associated with this configuration.
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        authenticationStrategy: AuthenticationStrategy? = nil,
        created: Date? = nil,
        description: String? = nil,
        engineType: EngineType? = nil,
        engineVersion: String? = nil,
        id: String? = nil,
        latestRevision: ConfigurationRevision? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.authenticationStrategy = authenticationStrategy
        self.created = created
        self.description = description
        self.engineType = engineType
        self.engineVersion = engineVersion
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.tags = tags
    }
}

struct DescribeConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let authenticationStrategy: AuthenticationStrategy?
    public let created: Date?
    public let description: String?
    public let engineType: EngineType?
    public let engineVersion: String?
    public let id: String?
    public let latestRevision: ConfigurationRevision?
    public let name: String?
    public let tags: [String:String]?
}

extension DescribeConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authenticationStrategy = "authenticationStrategy"
        case created = "created"
        case description = "description"
        case engineType = "engineType"
        case engineVersion = "engineVersion"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let engineTypeDecoded = try containerValues.decodeIfPresent(EngineType.self, forKey: .engineType)
        engineType = engineTypeDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribeConfigurationRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationRevisionInput(configurationId: \(String(describing: configurationId)), configurationRevision: \(String(describing: configurationRevision)))"}
}

extension DescribeConfigurationRevisionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeConfigurationRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRevisionInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConfigurationRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConfigurationRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConfigurationRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConfigurationRevisionInput>
    public typealias MOutput = OperationOutput<DescribeConfigurationRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConfigurationRevisionOutputError>
}

public struct DescribeConfigurationRevisionInput: Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    public let configurationId: String?
    /// The revision of the configuration.
    public let configurationRevision: String?

    public init (
        configurationId: String? = nil,
        configurationRevision: String? = nil
    )
    {
        self.configurationId = configurationId
        self.configurationRevision = configurationRevision
    }
}

struct DescribeConfigurationRevisionInputBody: Equatable {
}

extension DescribeConfigurationRevisionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeConfigurationRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConfigurationRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConfigurationRevisionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConfigurationRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConfigurationRevisionOutputResponse(configurationId: \(String(describing: configurationId)), created: \(String(describing: created)), data: \(String(describing: data)), description: \(String(describing: description)))"}
}

extension DescribeConfigurationRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConfigurationRevisionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationId = output.configurationId
            self.created = output.created
            self.data = output.data
            self.description = output.description
        } else {
            self.configurationId = nil
            self.created = nil
            self.data = nil
            self.description = nil
        }
    }
}

public struct DescribeConfigurationRevisionOutputResponse: Equatable {
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public let configurationId: String?
    /// Required. The date and time of the configuration.
    public let created: Date?
    /// Required. The base64-encoded XML configuration.
    public let data: String?
    /// The description of the configuration.
    public let description: String?

    public init (
        configurationId: String? = nil,
        created: Date? = nil,
        data: String? = nil,
        description: String? = nil
    )
    {
        self.configurationId = configurationId
        self.created = created
        self.data = data
        self.description = description
    }
}

struct DescribeConfigurationRevisionOutputResponseBody: Equatable {
    public let configurationId: String?
    public let created: Date?
    public let data: String?
    public let description: String?
}

extension DescribeConfigurationRevisionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationId = "configurationId"
        case created = "created"
        case data = "data"
        case description = "description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension DescribeUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserInput(brokerId: \(String(describing: brokerId)), username: \(String(describing: username)))"}
}

extension DescribeUserInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeUserInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let username: String?

    public init (
        brokerId: String? = nil,
        username: String? = nil
    )
    {
        self.brokerId = brokerId
        self.username = username
    }
}

struct DescribeUserInputBody: Equatable {
}

extension DescribeUserInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserOutputResponse(brokerId: \(String(describing: brokerId)), consoleAccess: \(String(describing: consoleAccess)), groups: \(String(describing: groups)), pending: \(String(describing: pending)), username: \(String(describing: username)))"}
}

extension DescribeUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.brokerId = output.brokerId
            self.consoleAccess = output.consoleAccess
            self.groups = output.groups
            self.pending = output.pending
            self.username = output.username
        } else {
            self.brokerId = nil
            self.consoleAccess = false
            self.groups = nil
            self.pending = nil
            self.username = nil
        }
    }
}

public struct DescribeUserOutputResponse: Equatable {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public let consoleAccess: Bool
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let groups: [String]?
    /// The status of the changes pending for the ActiveMQ user.
    public let pending: UserPendingChanges?
    /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let username: String?

    public init (
        brokerId: String? = nil,
        consoleAccess: Bool = false,
        groups: [String]? = nil,
        pending: UserPendingChanges? = nil,
        username: String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.pending = pending
        self.username = username
    }
}

struct DescribeUserOutputResponseBody: Equatable {
    public let brokerId: String?
    public let consoleAccess: Bool
    public let groups: [String]?
    public let pending: UserPendingChanges?
    public let username: String?
}

extension DescribeUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerId = "brokerId"
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case pending = "pending"
        case username = "username"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let consoleAccessDecoded = try containerValues.decode(Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groups)
        var groupsDecoded0:[String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let pendingDecoded = try containerValues.decodeIfPresent(UserPendingChanges.self, forKey: .pending)
        pending = pendingDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension EncryptionOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId = "kmsKeyId"
        case useAwsOwnedKey = "useAwsOwnedKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if useAwsOwnedKey != false {
            try encodeContainer.encode(useAwsOwnedKey, forKey: .useAwsOwnedKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let useAwsOwnedKeyDecoded = try containerValues.decode(Bool.self, forKey: .useAwsOwnedKey)
        useAwsOwnedKey = useAwsOwnedKeyDecoded
    }
}

extension EncryptionOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionOptions(kmsKeyId: \(String(describing: kmsKeyId)), useAwsOwnedKey: \(String(describing: useAwsOwnedKey)))"}
}

/// Encryption options for the broker.
public struct EncryptionOptions: Equatable {
    /// The symmetric customer master key (CMK) to use for the AWS Key Management Service (KMS). This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
    public let kmsKeyId: String?
    /// Enables the use of an AWS owned CMK using AWS Key Management Service (KMS).
    public let useAwsOwnedKey: Bool

    public init (
        kmsKeyId: String? = nil,
        useAwsOwnedKey: Bool = false
    )
    {
        self.kmsKeyId = kmsKeyId
        self.useAwsOwnedKey = useAwsOwnedKey
    }
}

/// The type of broker engine. Note: Currently, Amazon MQ supports ActiveMQ and RabbitMQ.
public enum EngineType {
    case activemq
    case rabbitmq
    case sdkUnknown(String)
}

extension EngineType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EngineType] {
        return [
            .activemq,
            .rabbitmq,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activemq: return "ACTIVEMQ"
        case .rabbitmq: return "RABBITMQ"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EngineType(rawValue: rawValue) ?? EngineType.sdkUnknown(rawValue)
    }
}

extension EngineVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension EngineVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EngineVersion(name: \(String(describing: name)))"}
}

/// Id of the engine version.
public struct EngineVersion: Equatable {
    /// Id for the version.
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(errorAttribute: \(String(describing: errorAttribute)), message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: String?
    /// The explanation of the error.
    public var message: String?

    public init (
        errorAttribute: String? = nil,
        message: String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let errorAttribute: String?
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(errorAttribute: \(String(describing: errorAttribute)), message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// The attribute which caused the error.
    public var errorAttribute: String?
    /// The explanation of the error.
    public var message: String?

    public init (
        errorAttribute: String? = nil,
        message: String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let errorAttribute: String?
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LdapServerMetadataInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hosts = "hosts"
        case roleBase = "roleBase"
        case roleName = "roleName"
        case roleSearchMatching = "roleSearchMatching"
        case roleSearchSubtree = "roleSearchSubtree"
        case serviceAccountPassword = "serviceAccountPassword"
        case serviceAccountUsername = "serviceAccountUsername"
        case userBase = "userBase"
        case userRoleName = "userRoleName"
        case userSearchMatching = "userSearchMatching"
        case userSearchSubtree = "userSearchSubtree"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for __listof__string0 in hosts {
                try hostsContainer.encode(__listof__string0)
            }
        }
        if let roleBase = roleBase {
            try encodeContainer.encode(roleBase, forKey: .roleBase)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let roleSearchMatching = roleSearchMatching {
            try encodeContainer.encode(roleSearchMatching, forKey: .roleSearchMatching)
        }
        if roleSearchSubtree != false {
            try encodeContainer.encode(roleSearchSubtree, forKey: .roleSearchSubtree)
        }
        if let serviceAccountPassword = serviceAccountPassword {
            try encodeContainer.encode(serviceAccountPassword, forKey: .serviceAccountPassword)
        }
        if let serviceAccountUsername = serviceAccountUsername {
            try encodeContainer.encode(serviceAccountUsername, forKey: .serviceAccountUsername)
        }
        if let userBase = userBase {
            try encodeContainer.encode(userBase, forKey: .userBase)
        }
        if let userRoleName = userRoleName {
            try encodeContainer.encode(userRoleName, forKey: .userRoleName)
        }
        if let userSearchMatching = userSearchMatching {
            try encodeContainer.encode(userSearchMatching, forKey: .userSearchMatching)
        }
        if userSearchSubtree != false {
            try encodeContainer.encode(userSearchSubtree, forKey: .userSearchSubtree)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hosts)
        var hostsDecoded0:[String]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [String]()
            for string0 in hostsContainer {
                if let string0 = string0 {
                    hostsDecoded0?.append(string0)
                }
            }
        }
        hosts = hostsDecoded0
        let roleBaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleBase)
        roleBase = roleBaseDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleSearchMatchingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleSearchMatching)
        roleSearchMatching = roleSearchMatchingDecoded
        let roleSearchSubtreeDecoded = try containerValues.decode(Bool.self, forKey: .roleSearchSubtree)
        roleSearchSubtree = roleSearchSubtreeDecoded
        let serviceAccountPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccountPassword)
        serviceAccountPassword = serviceAccountPasswordDecoded
        let serviceAccountUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccountUsername)
        serviceAccountUsername = serviceAccountUsernameDecoded
        let userBaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userBase)
        userBase = userBaseDecoded
        let userRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userRoleName)
        userRoleName = userRoleNameDecoded
        let userSearchMatchingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userSearchMatching)
        userSearchMatching = userSearchMatchingDecoded
        let userSearchSubtreeDecoded = try containerValues.decode(Bool.self, forKey: .userSearchSubtree)
        userSearchSubtree = userSearchSubtreeDecoded
    }
}

extension LdapServerMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LdapServerMetadataInput(hosts: \(String(describing: hosts)), roleBase: \(String(describing: roleBase)), roleName: \(String(describing: roleName)), roleSearchMatching: \(String(describing: roleSearchMatching)), roleSearchSubtree: \(String(describing: roleSearchSubtree)), serviceAccountPassword: \(String(describing: serviceAccountPassword)), serviceAccountUsername: \(String(describing: serviceAccountUsername)), userBase: \(String(describing: userBase)), userRoleName: \(String(describing: userRoleName)), userSearchMatching: \(String(describing: userSearchMatching)), userSearchSubtree: \(String(describing: userSearchSubtree)))"}
}

/// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
public struct LdapServerMetadataInput: Equatable {
    /// Fully qualified domain name of the LDAP server. Optional failover server.
    public let hosts: [String]?
    /// Fully qualified name of the directory to search for a user’s groups.
    public let roleBase: String?
    /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
    public let roleName: String?
    /// The search criteria for groups.
    public let roleSearchMatching: String?
    /// The directory search scope for the role. If set to true, scope is to search the entire sub-tree.
    public let roleSearchSubtree: Bool
    /// Service account password.
    public let serviceAccountPassword: String?
    /// Service account username.
    public let serviceAccountUsername: String?
    /// Fully qualified name of the directory where you want to search for users.
    public let userBase: String?
    /// Specifies the name of the LDAP attribute for the user group membership.
    public let userRoleName: String?
    /// The search criteria for users.
    public let userSearchMatching: String?
    /// The directory search scope for the user. If set to true, scope is to search the entire sub-tree.
    public let userSearchSubtree: Bool

    public init (
        hosts: [String]? = nil,
        roleBase: String? = nil,
        roleName: String? = nil,
        roleSearchMatching: String? = nil,
        roleSearchSubtree: Bool = false,
        serviceAccountPassword: String? = nil,
        serviceAccountUsername: String? = nil,
        userBase: String? = nil,
        userRoleName: String? = nil,
        userSearchMatching: String? = nil,
        userSearchSubtree: Bool = false
    )
    {
        self.hosts = hosts
        self.roleBase = roleBase
        self.roleName = roleName
        self.roleSearchMatching = roleSearchMatching
        self.roleSearchSubtree = roleSearchSubtree
        self.serviceAccountPassword = serviceAccountPassword
        self.serviceAccountUsername = serviceAccountUsername
        self.userBase = userBase
        self.userRoleName = userRoleName
        self.userSearchMatching = userSearchMatching
        self.userSearchSubtree = userSearchSubtree
    }
}

extension LdapServerMetadataOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hosts = "hosts"
        case roleBase = "roleBase"
        case roleName = "roleName"
        case roleSearchMatching = "roleSearchMatching"
        case roleSearchSubtree = "roleSearchSubtree"
        case serviceAccountUsername = "serviceAccountUsername"
        case userBase = "userBase"
        case userRoleName = "userRoleName"
        case userSearchMatching = "userSearchMatching"
        case userSearchSubtree = "userSearchSubtree"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hosts = hosts {
            var hostsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hosts)
            for __listof__string0 in hosts {
                try hostsContainer.encode(__listof__string0)
            }
        }
        if let roleBase = roleBase {
            try encodeContainer.encode(roleBase, forKey: .roleBase)
        }
        if let roleName = roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let roleSearchMatching = roleSearchMatching {
            try encodeContainer.encode(roleSearchMatching, forKey: .roleSearchMatching)
        }
        if roleSearchSubtree != false {
            try encodeContainer.encode(roleSearchSubtree, forKey: .roleSearchSubtree)
        }
        if let serviceAccountUsername = serviceAccountUsername {
            try encodeContainer.encode(serviceAccountUsername, forKey: .serviceAccountUsername)
        }
        if let userBase = userBase {
            try encodeContainer.encode(userBase, forKey: .userBase)
        }
        if let userRoleName = userRoleName {
            try encodeContainer.encode(userRoleName, forKey: .userRoleName)
        }
        if let userSearchMatching = userSearchMatching {
            try encodeContainer.encode(userSearchMatching, forKey: .userSearchMatching)
        }
        if userSearchSubtree != false {
            try encodeContainer.encode(userSearchSubtree, forKey: .userSearchSubtree)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .hosts)
        var hostsDecoded0:[String]? = nil
        if let hostsContainer = hostsContainer {
            hostsDecoded0 = [String]()
            for string0 in hostsContainer {
                if let string0 = string0 {
                    hostsDecoded0?.append(string0)
                }
            }
        }
        hosts = hostsDecoded0
        let roleBaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleBase)
        roleBase = roleBaseDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let roleSearchMatchingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleSearchMatching)
        roleSearchMatching = roleSearchMatchingDecoded
        let roleSearchSubtreeDecoded = try containerValues.decode(Bool.self, forKey: .roleSearchSubtree)
        roleSearchSubtree = roleSearchSubtreeDecoded
        let serviceAccountUsernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceAccountUsername)
        serviceAccountUsername = serviceAccountUsernameDecoded
        let userBaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userBase)
        userBase = userBaseDecoded
        let userRoleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userRoleName)
        userRoleName = userRoleNameDecoded
        let userSearchMatchingDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userSearchMatching)
        userSearchMatching = userSearchMatchingDecoded
        let userSearchSubtreeDecoded = try containerValues.decode(Bool.self, forKey: .userSearchSubtree)
        userSearchSubtree = userSearchSubtreeDecoded
    }
}

extension LdapServerMetadataOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LdapServerMetadataOutput(hosts: \(String(describing: hosts)), roleBase: \(String(describing: roleBase)), roleName: \(String(describing: roleName)), roleSearchMatching: \(String(describing: roleSearchMatching)), roleSearchSubtree: \(String(describing: roleSearchSubtree)), serviceAccountUsername: \(String(describing: serviceAccountUsername)), userBase: \(String(describing: userBase)), userRoleName: \(String(describing: userRoleName)), userSearchMatching: \(String(describing: userSearchMatching)), userSearchSubtree: \(String(describing: userSearchSubtree)))"}
}

/// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
public struct LdapServerMetadataOutput: Equatable {
    /// Fully qualified domain name of the LDAP server. Optional failover server.
    public let hosts: [String]?
    /// Fully qualified name of the directory to search for a user’s groups.
    public let roleBase: String?
    /// Specifies the LDAP attribute that identifies the group name attribute in the object returned from the group membership query.
    public let roleName: String?
    /// The search criteria for groups.
    public let roleSearchMatching: String?
    /// The directory search scope for the role. If set to true, scope is to search the entire sub-tree.
    public let roleSearchSubtree: Bool
    /// Service account username.
    public let serviceAccountUsername: String?
    /// Fully qualified name of the directory where you want to search for users.
    public let userBase: String?
    /// Specifies the name of the LDAP attribute for the user group membership.
    public let userRoleName: String?
    /// The search criteria for users.
    public let userSearchMatching: String?
    /// The directory search scope for the user. If set to true, scope is to search the entire sub-tree.
    public let userSearchSubtree: Bool

    public init (
        hosts: [String]? = nil,
        roleBase: String? = nil,
        roleName: String? = nil,
        roleSearchMatching: String? = nil,
        roleSearchSubtree: Bool = false,
        serviceAccountUsername: String? = nil,
        userBase: String? = nil,
        userRoleName: String? = nil,
        userSearchMatching: String? = nil,
        userSearchSubtree: Bool = false
    )
    {
        self.hosts = hosts
        self.roleBase = roleBase
        self.roleName = roleName
        self.roleSearchMatching = roleSearchMatching
        self.roleSearchSubtree = roleSearchSubtree
        self.serviceAccountUsername = serviceAccountUsername
        self.userBase = userBase
        self.userRoleName = userRoleName
        self.userSearchMatching = userSearchMatching
        self.userSearchSubtree = userSearchSubtree
    }
}

extension ListBrokersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBrokersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBrokersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListBrokersInputHeadersMiddleware: Middleware {
    public let id: String = "ListBrokersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBrokersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBrokersInput>
    public typealias MOutput = OperationOutput<ListBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBrokersOutputError>
}

public struct ListBrokersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListBrokersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListBrokersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListBrokersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListBrokersInput>
    public typealias MOutput = OperationOutput<ListBrokersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListBrokersOutputError>
}

public struct ListBrokersInput: Equatable {
    /// The maximum number of brokers that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBrokersInputBody: Equatable {
}

extension ListBrokersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListBrokersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBrokersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBrokersOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBrokersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListBrokersOutputResponse(brokerSummaries: \(String(describing: brokerSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListBrokersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListBrokersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.brokerSummaries = output.brokerSummaries
            self.nextToken = output.nextToken
        } else {
            self.brokerSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBrokersOutputResponse: Equatable {
    /// A list of information about all brokers.
    public let brokerSummaries: [BrokerSummary]?
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        brokerSummaries: [BrokerSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.brokerSummaries = brokerSummaries
        self.nextToken = nextToken
    }
}

struct ListBrokersOutputResponseBody: Equatable {
    public let brokerSummaries: [BrokerSummary]?
    public let nextToken: String?
}

extension ListBrokersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerSummaries = "brokerSummaries"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerSummariesContainer = try containerValues.decodeIfPresent([BrokerSummary?].self, forKey: .brokerSummaries)
        var brokerSummariesDecoded0:[BrokerSummary]? = nil
        if let brokerSummariesContainer = brokerSummariesContainer {
            brokerSummariesDecoded0 = [BrokerSummary]()
            for structure0 in brokerSummariesContainer {
                if let structure0 = structure0 {
                    brokerSummariesDecoded0?.append(structure0)
                }
            }
        }
        brokerSummaries = brokerSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationRevisionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationRevisionsInput(configurationId: \(String(describing: configurationId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationRevisionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigurationRevisionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationRevisionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationRevisionsInput>
    public typealias MOutput = OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationRevisionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationRevisionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationRevisionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationRevisionsInput>
    public typealias MOutput = OperationOutput<ListConfigurationRevisionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationRevisionsOutputError>
}

public struct ListConfigurationRevisionsInput: Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    public let configurationId: String?
    /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        configurationId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationRevisionsInputBody: Equatable {
}

extension ListConfigurationRevisionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigurationRevisionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationRevisionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationRevisionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationRevisionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationRevisionsOutputResponse(configurationId: \(String(describing: configurationId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), revisions: \(String(describing: revisions)))"}
}

extension ListConfigurationRevisionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationRevisionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationId = output.configurationId
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.revisions = output.revisions
        } else {
            self.configurationId = nil
            self.maxResults = 0
            self.nextToken = nil
            self.revisions = nil
        }
    }
}

public struct ListConfigurationRevisionsOutputResponse: Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    public let configurationId: String?
    /// The maximum number of configuration revisions that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?
    /// The list of all revisions for the specified configuration.
    public let revisions: [ConfigurationRevision]?

    public init (
        configurationId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        revisions: [ConfigurationRevision]? = nil
    )
    {
        self.configurationId = configurationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.revisions = revisions
    }
}

struct ListConfigurationRevisionsOutputResponseBody: Equatable {
    public let configurationId: String?
    public let maxResults: Int
    public let nextToken: String?
    public let revisions: [ConfigurationRevision]?
}

extension ListConfigurationRevisionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationId = "configurationId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case revisions = "revisions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationId)
        configurationId = configurationIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let revisionsContainer = try containerValues.decodeIfPresent([ConfigurationRevision?].self, forKey: .revisions)
        var revisionsDecoded0:[ConfigurationRevision]? = nil
        if let revisionsContainer = revisionsContainer {
            revisionsDecoded0 = [ConfigurationRevision]()
            for structure0 in revisionsContainer {
                if let structure0 = structure0 {
                    revisionsDecoded0?.append(structure0)
                }
            }
        }
        revisions = revisionsDecoded0
    }
}

extension ListConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationsInput>
    public typealias MOutput = OperationOutput<ListConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationsOutputError>
}

public struct ListConfigurationsInput: Equatable {
    /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsInputBody: Equatable {
}

extension ListConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationsOutputResponse(configurations: \(String(describing: configurations)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurations = output.configurations
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
        } else {
            self.configurations = nil
            self.maxResults = 0
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationsOutputResponse: Equatable {
    /// The list of all revisions for the specified configuration.
    public let configurations: [Configuration]?
    /// The maximum number of configurations that Amazon MQ can return per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        configurations: [Configuration]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.configurations = configurations
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfigurationsOutputResponseBody: Equatable {
    public let configurations: [Configuration]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurations = "configurations"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationsContainer = try containerValues.decodeIfPresent([Configuration?].self, forKey: .configurations)
        var configurationsDecoded0:[Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Configuration]()
            for structure0 in configurationsContainer {
                if let structure0 = structure0 {
                    configurationsDecoded0?.append(structure0)
                }
            }
        }
        configurations = configurationsDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Equatable {
    /// The Amazon Resource Name (ARN) of the resource tag.
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsInputBody: Equatable {
}

extension ListTagsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Equatable {
    /// The key-value pair for the resource tag.
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInput(brokerId: \(String(describing: brokerId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListUsersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListUsersInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?

    public init (
        brokerId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Equatable {
}

extension ListUsersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersOutputResponse(brokerId: \(String(describing: brokerId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), users: \(String(describing: users)))"}
}

extension ListUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.brokerId = output.brokerId
            self.maxResults = output.maxResults
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.brokerId = nil
            self.maxResults = 0
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Equatable {
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// Required. The maximum number of ActiveMQ users that can be returned per page (20 by default). This value must be an integer from 5 to 100.
    public let maxResults: Int
    /// The token that specifies the next page of results Amazon MQ should return. To request the first page, leave nextToken empty.
    public let nextToken: String?
    /// Required. The list of all ActiveMQ usernames for the specified broker.
    public let users: [UserSummary]?

    public init (
        brokerId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        users: [UserSummary]? = nil
    )
    {
        self.brokerId = brokerId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Equatable {
    public let brokerId: String?
    public let maxResults: Int
    public let nextToken: String?
    public let users: [UserSummary]?
}

extension ListUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case brokerId = "brokerId"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case users = "users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let brokerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let usersContainer = try containerValues.decodeIfPresent([UserSummary?].self, forKey: .users)
        var usersDecoded0:[UserSummary]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [UserSummary]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension Logs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audit = "audit"
        case general = "general"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if audit != false {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if general != false {
            try encodeContainer.encode(general, forKey: .general)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decode(Bool.self, forKey: .audit)
        audit = auditDecoded
        let generalDecoded = try containerValues.decode(Bool.self, forKey: .general)
        general = generalDecoded
    }
}

extension Logs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Logs(audit: \(String(describing: audit)), general: \(String(describing: general)))"}
}

/// The list of information about logs to be enabled for the specified broker.
public struct Logs: Equatable {
    /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
    public let audit: Bool
    /// Enables general logging.
    public let general: Bool

    public init (
        audit: Bool = false,
        general: Bool = false
    )
    {
        self.audit = audit
        self.general = general
    }
}

extension LogsSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audit = "audit"
        case auditLogGroup = "auditLogGroup"
        case general = "general"
        case generalLogGroup = "generalLogGroup"
        case pending = "pending"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if audit != false {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if let auditLogGroup = auditLogGroup {
            try encodeContainer.encode(auditLogGroup, forKey: .auditLogGroup)
        }
        if general != false {
            try encodeContainer.encode(general, forKey: .general)
        }
        if let generalLogGroup = generalLogGroup {
            try encodeContainer.encode(generalLogGroup, forKey: .generalLogGroup)
        }
        if let pending = pending {
            try encodeContainer.encode(pending, forKey: .pending)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decode(Bool.self, forKey: .audit)
        audit = auditDecoded
        let auditLogGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .auditLogGroup)
        auditLogGroup = auditLogGroupDecoded
        let generalDecoded = try containerValues.decode(Bool.self, forKey: .general)
        general = generalDecoded
        let generalLogGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generalLogGroup)
        generalLogGroup = generalLogGroupDecoded
        let pendingDecoded = try containerValues.decodeIfPresent(PendingLogs.self, forKey: .pending)
        pending = pendingDecoded
    }
}

extension LogsSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogsSummary(audit: \(String(describing: audit)), auditLogGroup: \(String(describing: auditLogGroup)), general: \(String(describing: general)), generalLogGroup: \(String(describing: generalLogGroup)), pending: \(String(describing: pending)))"}
}

/// The list of information about logs currently enabled and pending to be deployed for the specified broker.
public struct LogsSummary: Equatable {
    /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
    public let audit: Bool
    /// The location of the CloudWatch Logs log group where audit logs are sent.
    public let auditLogGroup: String?
    /// Enables general logging.
    public let general: Bool
    /// The location of the CloudWatch Logs log group where general logs are sent.
    public let generalLogGroup: String?
    /// The list of information about logs pending to be deployed for the specified broker.
    public let pending: PendingLogs?

    public init (
        audit: Bool = false,
        auditLogGroup: String? = nil,
        general: Bool = false,
        generalLogGroup: String? = nil,
        pending: PendingLogs? = nil
    )
    {
        self.audit = audit
        self.auditLogGroup = auditLogGroup
        self.general = general
        self.generalLogGroup = generalLogGroup
        self.pending = pending
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(errorAttribute: \(String(describing: errorAttribute)), message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: String?
    /// The explanation of the error.
    public var message: String?

    public init (
        errorAttribute: String? = nil,
        message: String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let errorAttribute: String?
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PendingLogs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case audit = "audit"
        case general = "general"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if audit != false {
            try encodeContainer.encode(audit, forKey: .audit)
        }
        if general != false {
            try encodeContainer.encode(general, forKey: .general)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditDecoded = try containerValues.decode(Bool.self, forKey: .audit)
        audit = auditDecoded
        let generalDecoded = try containerValues.decode(Bool.self, forKey: .general)
        general = generalDecoded
    }
}

extension PendingLogs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingLogs(audit: \(String(describing: audit)), general: \(String(describing: general)))"}
}

/// The list of information about logs to be enabled for the specified broker.
public struct PendingLogs: Equatable {
    /// Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged.
    public let audit: Bool
    /// Enables general logging.
    public let general: Bool

    public init (
        audit: Bool = false,
        general: Bool = false
    )
    {
        self.audit = audit
        self.general = general
    }
}

extension RebootBrokerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootBrokerInput(brokerId: \(String(describing: brokerId)))"}
}

extension RebootBrokerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RebootBrokerInputHeadersMiddleware: Middleware {
    public let id: String = "RebootBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootBrokerInput>
    public typealias MOutput = OperationOutput<RebootBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootBrokerOutputError>
}

public struct RebootBrokerInput: Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?

    public init (
        brokerId: String? = nil
    )
    {
        self.brokerId = brokerId
    }
}

struct RebootBrokerInputBody: Equatable {
}

extension RebootBrokerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RebootBrokerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootBrokerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootBrokerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootBrokerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootBrokerOutputResponse()"}
}

extension RebootBrokerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RebootBrokerOutputResponse: Equatable {

    public init() {}
}

struct RebootBrokerOutputResponseBody: Equatable {
}

extension RebootBrokerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SanitizationWarning: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "attributeName"
        case elementName = "elementName"
        case reason = "reason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let elementName = elementName {
            try encodeContainer.encode(elementName, forKey: .elementName)
        }
        if let reason = reason {
            try encodeContainer.encode(reason.rawValue, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let elementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .elementName)
        elementName = elementNameDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(SanitizationWarningReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension SanitizationWarning: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SanitizationWarning(attributeName: \(String(describing: attributeName)), elementName: \(String(describing: elementName)), reason: \(String(describing: reason)))"}
}

/// Returns information about the XML element or attribute that was sanitized in the configuration.
public struct SanitizationWarning: Equatable {
    /// The name of the XML attribute that has been sanitized.
    public let attributeName: String?
    /// The name of the XML element that has been sanitized.
    public let elementName: String?
    /// Required. The reason for which the XML elements or attributes were sanitized.
    public let reason: SanitizationWarningReason?

    public init (
        attributeName: String? = nil,
        elementName: String? = nil,
        reason: SanitizationWarningReason? = nil
    )
    {
        self.attributeName = attributeName
        self.elementName = elementName
        self.reason = reason
    }
}

/// The reason for which the XML elements or attributes were sanitized.
public enum SanitizationWarningReason {
    case disallowedAttributeRemoved
    case disallowedElementRemoved
    case invalidAttributeValueRemoved
    case sdkUnknown(String)
}

extension SanitizationWarningReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SanitizationWarningReason] {
        return [
            .disallowedAttributeRemoved,
            .disallowedElementRemoved,
            .invalidAttributeValueRemoved,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disallowedAttributeRemoved: return "DISALLOWED_ATTRIBUTE_REMOVED"
        case .disallowedElementRemoved: return "DISALLOWED_ELEMENT_REMOVED"
        case .invalidAttributeValueRemoved: return "INVALID_ATTRIBUTE_VALUE_REMOVED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SanitizationWarningReason(rawValue: rawValue) ?? SanitizationWarningReason.sdkUnknown(rawValue)
    }
}

extension UnauthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnauthorizedException(errorAttribute: \(String(describing: errorAttribute)), message: \(String(describing: message)))"}
}

extension UnauthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errorAttribute = output.errorAttribute
            self.message = output.message
        } else {
            self.errorAttribute = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Returns information about an error.
public struct UnauthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The attribute which caused the error.
    public var errorAttribute: String?
    /// The explanation of the error.
    public var message: String?

    public init (
        errorAttribute: String? = nil,
        message: String? = nil
    )
    {
        self.errorAttribute = errorAttribute
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Equatable {
    public let errorAttribute: String?
    public let message: String?
}

extension UnauthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errorAttribute = "errorAttribute"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorAttribute)
        errorAttribute = errorAttributeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateBrokerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBrokerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerInput>
    public typealias MOutput = OperationOutput<UpdateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerOutputError>
}

extension UpdateBrokerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBrokerInput(authenticationStrategy: \(String(describing: authenticationStrategy)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), brokerId: \(String(describing: brokerId)), configuration: \(String(describing: configuration)), engineVersion: \(String(describing: engineVersion)), hostInstanceType: \(String(describing: hostInstanceType)), ldapServerMetadata: \(String(describing: ldapServerMetadata)), logs: \(String(describing: logs)), securityGroups: \(String(describing: securityGroups)))"}
}

extension UpdateBrokerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case securityGroups = "securityGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationStrategy = authenticationStrategy {
            try encodeContainer.encode(authenticationStrategy.rawValue, forKey: .authenticationStrategy)
        }
        if autoMinorVersionUpgrade != false {
            try encodeContainer.encode(autoMinorVersionUpgrade, forKey: .autoMinorVersionUpgrade)
        }
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let hostInstanceType = hostInstanceType {
            try encodeContainer.encode(hostInstanceType, forKey: .hostInstanceType)
        }
        if let ldapServerMetadata = ldapServerMetadata {
            try encodeContainer.encode(ldapServerMetadata, forKey: .ldapServerMetadata)
        }
        if let logs = logs {
            try encodeContainer.encode(logs, forKey: .logs)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for __listof__string0 in securityGroups {
                try securityGroupsContainer.encode(__listof__string0)
            }
        }
    }
}

public struct UpdateBrokerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBrokerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerInput>
    public typealias MOutput = OperationOutput<UpdateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerOutputError>
}

public struct UpdateBrokerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBrokerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBrokerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBrokerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBrokerInput>
    public typealias MOutput = OperationOutput<UpdateBrokerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBrokerOutputError>
}

/// Updates the broker using the specified properties.
public struct UpdateBrokerInput: Equatable {
    /// The authentication strategy used to secure the broker.
    public let authenticationStrategy: AuthenticationStrategy?
    /// Enables automatic upgrades to new minor versions for brokers, as Apache releases the versions. The automatic upgrades occur during the maintenance window of the broker or after a manual broker reboot.
    public let autoMinorVersionUpgrade: Bool
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// A list of information about the configuration.
    public let configuration: ConfigurationId?
    /// The version of the broker engine. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    public let engineVersion: String?
    /// The host instance type of the broker to upgrade to. For a list of supported instance types, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide//broker.html#broker-instance-types
    public let hostInstanceType: String?
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public let ldapServerMetadata: LdapServerMetadataInput?
    /// Enables Amazon CloudWatch logging for brokers.
    public let logs: Logs?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public let securityGroups: [String]?

    public init (
        authenticationStrategy: AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Bool = false,
        brokerId: String? = nil,
        configuration: ConfigurationId? = nil,
        engineVersion: String? = nil,
        hostInstanceType: String? = nil,
        ldapServerMetadata: LdapServerMetadataInput? = nil,
        logs: Logs? = nil,
        securityGroups: [String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.securityGroups = securityGroups
    }
}

struct UpdateBrokerInputBody: Equatable {
    public let authenticationStrategy: AuthenticationStrategy?
    public let autoMinorVersionUpgrade: Bool
    public let configuration: ConfigurationId?
    public let engineVersion: String?
    public let hostInstanceType: String?
    public let ldapServerMetadata: LdapServerMetadataInput?
    public let logs: Logs?
    public let securityGroups: [String]?
}

extension UpdateBrokerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case securityGroups = "securityGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(LdapServerMetadataInput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(Logs.self, forKey: .logs)
        logs = logsDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension UpdateBrokerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBrokerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBrokerOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBrokerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBrokerOutputResponse(authenticationStrategy: \(String(describing: authenticationStrategy)), autoMinorVersionUpgrade: \(String(describing: autoMinorVersionUpgrade)), brokerId: \(String(describing: brokerId)), configuration: \(String(describing: configuration)), engineVersion: \(String(describing: engineVersion)), hostInstanceType: \(String(describing: hostInstanceType)), ldapServerMetadata: \(String(describing: ldapServerMetadata)), logs: \(String(describing: logs)), securityGroups: \(String(describing: securityGroups)))"}
}

extension UpdateBrokerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateBrokerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authenticationStrategy = output.authenticationStrategy
            self.autoMinorVersionUpgrade = output.autoMinorVersionUpgrade
            self.brokerId = output.brokerId
            self.configuration = output.configuration
            self.engineVersion = output.engineVersion
            self.hostInstanceType = output.hostInstanceType
            self.ldapServerMetadata = output.ldapServerMetadata
            self.logs = output.logs
            self.securityGroups = output.securityGroups
        } else {
            self.authenticationStrategy = nil
            self.autoMinorVersionUpgrade = false
            self.brokerId = nil
            self.configuration = nil
            self.engineVersion = nil
            self.hostInstanceType = nil
            self.ldapServerMetadata = nil
            self.logs = nil
            self.securityGroups = nil
        }
    }
}

public struct UpdateBrokerOutputResponse: Equatable {
    /// The authentication strategy used to secure the broker.
    public let authenticationStrategy: AuthenticationStrategy?
    /// The new value of automatic upgrades to new minor version for brokers.
    public let autoMinorVersionUpgrade: Bool
    /// Required. The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// The ID of the updated configuration.
    public let configuration: ConfigurationId?
    /// The version of the broker engine to upgrade to. For a list of supported engine versions, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide/broker-engine.html
    public let engineVersion: String?
    /// The host instance type of the broker to upgrade to. For a list of supported instance types, see https://docs.aws.amazon.com/amazon-mq/latest/developer-guide//broker.html#broker-instance-types
    public let hostInstanceType: String?
    /// The metadata of the LDAP server used to authenticate and authorize connections to the broker.
    public let ldapServerMetadata: LdapServerMetadataOutput?
    /// The list of information about logs to be enabled for the specified broker.
    public let logs: Logs?
    /// The list of security groups (1 minimum, 5 maximum) that authorizes connections to brokers.
    public let securityGroups: [String]?

    public init (
        authenticationStrategy: AuthenticationStrategy? = nil,
        autoMinorVersionUpgrade: Bool = false,
        brokerId: String? = nil,
        configuration: ConfigurationId? = nil,
        engineVersion: String? = nil,
        hostInstanceType: String? = nil,
        ldapServerMetadata: LdapServerMetadataOutput? = nil,
        logs: Logs? = nil,
        securityGroups: [String]? = nil
    )
    {
        self.authenticationStrategy = authenticationStrategy
        self.autoMinorVersionUpgrade = autoMinorVersionUpgrade
        self.brokerId = brokerId
        self.configuration = configuration
        self.engineVersion = engineVersion
        self.hostInstanceType = hostInstanceType
        self.ldapServerMetadata = ldapServerMetadata
        self.logs = logs
        self.securityGroups = securityGroups
    }
}

struct UpdateBrokerOutputResponseBody: Equatable {
    public let authenticationStrategy: AuthenticationStrategy?
    public let autoMinorVersionUpgrade: Bool
    public let brokerId: String?
    public let configuration: ConfigurationId?
    public let engineVersion: String?
    public let hostInstanceType: String?
    public let ldapServerMetadata: LdapServerMetadataOutput?
    public let logs: Logs?
    public let securityGroups: [String]?
}

extension UpdateBrokerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authenticationStrategy = "authenticationStrategy"
        case autoMinorVersionUpgrade = "autoMinorVersionUpgrade"
        case brokerId = "brokerId"
        case configuration = "configuration"
        case engineVersion = "engineVersion"
        case hostInstanceType = "hostInstanceType"
        case ldapServerMetadata = "ldapServerMetadata"
        case logs = "logs"
        case securityGroups = "securityGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationStrategyDecoded = try containerValues.decodeIfPresent(AuthenticationStrategy.self, forKey: .authenticationStrategy)
        authenticationStrategy = authenticationStrategyDecoded
        let autoMinorVersionUpgradeDecoded = try containerValues.decode(Bool.self, forKey: .autoMinorVersionUpgrade)
        autoMinorVersionUpgrade = autoMinorVersionUpgradeDecoded
        let brokerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .brokerId)
        brokerId = brokerIdDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ConfigurationId.self, forKey: .configuration)
        configuration = configurationDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let hostInstanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostInstanceType)
        hostInstanceType = hostInstanceTypeDecoded
        let ldapServerMetadataDecoded = try containerValues.decodeIfPresent(LdapServerMetadataOutput.self, forKey: .ldapServerMetadata)
        ldapServerMetadata = ldapServerMetadataDecoded
        let logsDecoded = try containerValues.decodeIfPresent(Logs.self, forKey: .logs)
        logs = logsDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

public struct UpdateConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationOutputError>
}

extension UpdateConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationInput(configurationId: \(String(describing: configurationId)), data: \(String(describing: data)), description: \(String(describing: description)))"}
}

extension UpdateConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "data"
        case description = "description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationOutputError>
}

public struct UpdateConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationOutputError>
}

/// Updates the specified configuration.
public struct UpdateConfigurationInput: Equatable {
    /// The unique ID that Amazon MQ generates for the configuration.
    public let configurationId: String?
    /// Required. The base64-encoded XML configuration.
    public let data: String?
    /// The description of the configuration.
    public let description: String?

    public init (
        configurationId: String? = nil,
        data: String? = nil,
        description: String? = nil
    )
    {
        self.configurationId = configurationId
        self.data = data
        self.description = description
    }
}

struct UpdateConfigurationInputBody: Equatable {
    public let data: String?
    public let description: String?
}

extension UpdateConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case data = "data"
        case description = "description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationOutputResponse(arn: \(String(describing: arn)), created: \(String(describing: created)), id: \(String(describing: id)), latestRevision: \(String(describing: latestRevision)), name: \(String(describing: name)), warnings: \(String(describing: warnings)))"}
}

extension UpdateConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.created = output.created
            self.id = output.id
            self.latestRevision = output.latestRevision
            self.name = output.name
            self.warnings = output.warnings
        } else {
            self.arn = nil
            self.created = nil
            self.id = nil
            self.latestRevision = nil
            self.name = nil
            self.warnings = nil
        }
    }
}

public struct UpdateConfigurationOutputResponse: Equatable {
    /// Required. The Amazon Resource Name (ARN) of the configuration.
    public let arn: String?
    /// Required. The date and time of the configuration.
    public let created: Date?
    /// Required. The unique ID that Amazon MQ generates for the configuration.
    public let id: String?
    /// The latest revision of the configuration.
    public let latestRevision: ConfigurationRevision?
    /// Required. The name of the configuration. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 1-150 characters long.
    public let name: String?
    /// The list of the first 20 warnings about the configuration XML elements or attributes that were sanitized.
    public let warnings: [SanitizationWarning]?

    public init (
        arn: String? = nil,
        created: Date? = nil,
        id: String? = nil,
        latestRevision: ConfigurationRevision? = nil,
        name: String? = nil,
        warnings: [SanitizationWarning]? = nil
    )
    {
        self.arn = arn
        self.created = created
        self.id = id
        self.latestRevision = latestRevision
        self.name = name
        self.warnings = warnings
    }
}

struct UpdateConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let created: Date?
    public let id: String?
    public let latestRevision: ConfigurationRevision?
    public let name: String?
    public let warnings: [SanitizationWarning]?
}

extension UpdateConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case created = "created"
        case id = "id"
        case latestRevision = "latestRevision"
        case name = "name"
        case warnings = "warnings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let latestRevisionDecoded = try containerValues.decodeIfPresent(ConfigurationRevision.self, forKey: .latestRevision)
        latestRevision = latestRevisionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let warningsContainer = try containerValues.decodeIfPresent([SanitizationWarning?].self, forKey: .warnings)
        var warningsDecoded0:[SanitizationWarning]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [SanitizationWarning]()
            for structure0 in warningsContainer {
                if let structure0 = structure0 {
                    warningsDecoded0?.append(structure0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct UpdateUserInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

extension UpdateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserInput(brokerId: \(String(describing: brokerId)), consoleAccess: \(String(describing: consoleAccess)), groups: \(String(describing: groups)), password: \(String(describing: password)), username: \(String(describing: username)))"}
}

extension UpdateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if consoleAccess != false {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct UpdateUserInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

/// Updates the information for an ActiveMQ user.
public struct UpdateUserInput: Equatable {
    /// The unique ID that Amazon MQ generates for the broker.
    public let brokerId: String?
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public let consoleAccess: Bool
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let groups: [String]?
    /// The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas.
    public let password: String?
    /// Required. The username of the ActiveMQ user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let username: String?

    public init (
        brokerId: String? = nil,
        consoleAccess: Bool = false,
        groups: [String]? = nil,
        password: String? = nil,
        username: String? = nil
    )
    {
        self.brokerId = brokerId
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.username = username
    }
}

struct UpdateUserInputBody: Equatable {
    public let consoleAccess: Bool
    public let groups: [String]?
    public let password: String?
}

extension UpdateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decode(Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groups)
        var groupsDecoded0:[String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension UpdateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserOutputResponse()"}
}

extension UpdateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateUserOutputResponse: Equatable {

    public init() {}
}

struct UpdateUserOutputResponseBody: Equatable {
}

extension UpdateUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension User: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case password = "password"
        case username = "username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if consoleAccess != false {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decode(Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groups)
        var groupsDecoded0:[String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension User: CustomDebugStringConvertible {
    public var debugDescription: String {
        "User(consoleAccess: \(String(describing: consoleAccess)), groups: \(String(describing: groups)), password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// A user associated with the broker.
public struct User: Equatable {
    /// Enables access to the ActiveMQ Web Console for the ActiveMQ user (Does not apply to RabbitMQ brokers).
    public let consoleAccess: Bool
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let groups: [String]?
    /// Required. The password of the broker user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas.
    public let password: String?
    /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let username: String?

    public init (
        consoleAccess: Bool = false,
        groups: [String]? = nil,
        password: String? = nil,
        username: String? = nil
    )
    {
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.password = password
        self.username = username
    }
}

extension UserPendingChanges: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case consoleAccess = "consoleAccess"
        case groups = "groups"
        case pendingChange = "pendingChange"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if consoleAccess != false {
            try encodeContainer.encode(consoleAccess, forKey: .consoleAccess)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for __listof__string0 in groups {
                try groupsContainer.encode(__listof__string0)
            }
        }
        if let pendingChange = pendingChange {
            try encodeContainer.encode(pendingChange.rawValue, forKey: .pendingChange)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let consoleAccessDecoded = try containerValues.decode(Bool.self, forKey: .consoleAccess)
        consoleAccess = consoleAccessDecoded
        let groupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .groups)
        var groupsDecoded0:[String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let pendingChangeDecoded = try containerValues.decodeIfPresent(ChangeType.self, forKey: .pendingChange)
        pendingChange = pendingChangeDecoded
    }
}

extension UserPendingChanges: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserPendingChanges(consoleAccess: \(String(describing: consoleAccess)), groups: \(String(describing: groups)), pendingChange: \(String(describing: pendingChange)))"}
}

/// Returns information about the status of the changes pending for the ActiveMQ user.
public struct UserPendingChanges: Equatable {
    /// Enables access to the the ActiveMQ Web Console for the ActiveMQ user.
    public let consoleAccess: Bool
    /// The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let groups: [String]?
    /// Required. The type of change pending for the ActiveMQ user.
    public let pendingChange: ChangeType?

    public init (
        consoleAccess: Bool = false,
        groups: [String]? = nil,
        pendingChange: ChangeType? = nil
    )
    {
        self.consoleAccess = consoleAccess
        self.groups = groups
        self.pendingChange = pendingChange
    }
}

extension UserSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pendingChange = "pendingChange"
        case username = "username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pendingChange = pendingChange {
            try encodeContainer.encode(pendingChange.rawValue, forKey: .pendingChange)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pendingChangeDecoded = try containerValues.decodeIfPresent(ChangeType.self, forKey: .pendingChange)
        pendingChange = pendingChangeDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension UserSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserSummary(pendingChange: \(String(describing: pendingChange)), username: \(String(describing: username)))"}
}

/// Returns a list of all broker users.
public struct UserSummary: Equatable {
    /// The type of change pending for the broker user.
    public let pendingChange: ChangeType?
    /// Required. The username of the broker user. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long.
    public let username: String?

    public init (
        pendingChange: ChangeType? = nil,
        username: String? = nil
    )
    {
        self.pendingChange = pendingChange
        self.username = username
    }
}

extension WeeklyStartTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dayOfWeek = "dayOfWeek"
        case timeOfDay = "timeOfDay"
        case timeZone = "timeZone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfWeek = dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let timeOfDay = timeOfDay {
            try encodeContainer.encode(timeOfDay, forKey: .timeOfDay)
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let timeOfDayDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeOfDay)
        timeOfDay = timeOfDayDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
    }
}

extension WeeklyStartTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WeeklyStartTime(dayOfWeek: \(String(describing: dayOfWeek)), timeOfDay: \(String(describing: timeOfDay)), timeZone: \(String(describing: timeZone)))"}
}

/// The scheduled time period relative to UTC during which Amazon MQ begins to apply pending updates or patches to the broker.
public struct WeeklyStartTime: Equatable {
    /// Required. The day of the week.
    public let dayOfWeek: DayOfWeek?
    /// Required. The time, in 24-hour format.
    public let timeOfDay: String?
    /// The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
    public let timeZone: String?

    public init (
        dayOfWeek: DayOfWeek? = nil,
        timeOfDay: String? = nil,
        timeZone: String? = nil
    )
    {
        self.dayOfWeek = dayOfWeek
        self.timeOfDay = timeOfDay
        self.timeZone = timeZone
    }
}
