// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Ami: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case description
        case image
        case name
        case region
        case state
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let imageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .image)
        image = imageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImageState.self, forKey: .state)
        state = stateDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension Ami: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Ami(accountId: \(String(describing: accountId)), description: \(String(describing: description)), image: \(String(describing: image)), name: \(String(describing: name)), region: \(String(describing: region)), state: \(String(describing: state)))"}
}

/// <p> Details of an EC2 AMI.</p>
public struct Ami: Equatable {
    /// <p>The account ID of the owner of the AMI.</p>
    public let accountId: String?
    /// <p>The description of the EC2 AMI. Minimum and maximum length are in characters.</p>
    public let description: String?
    /// <p>The AMI ID of the EC2 AMI.</p>
    public let image: String?
    /// <p>The name of the EC2 AMI.</p>
    public let name: String?
    /// <p>The AWS Region of the EC2 AMI.</p>
    public let region: String?
    /// <p> Image state shows the image status and the reason for that status.</p>
    public let state: ImageState?

    public init (
        accountId: String? = nil,
        description: String? = nil,
        image: String? = nil,
        name: String? = nil,
        region: String? = nil,
        state: ImageState? = nil
    )
    {
        self.accountId = accountId
        self.description = description
        self.image = image
        self.name = name
        self.region = region
        self.state = state
    }
}

extension AmiDistributionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiTags
        case description
        case kmsKeyId
        case launchPermission
        case name
        case targetAccountIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiTags = amiTags {
            var amiTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .amiTags)
            for (dictKey0, tagmap0) in amiTags {
                try amiTagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let launchPermission = launchPermission {
            try encodeContainer.encode(launchPermission, forKey: .launchPermission)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetAccountIds = targetAccountIds {
            var targetAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetAccountIds)
            for accountlist0 in targetAccountIds {
                try targetAccountIdsContainer.encode(accountlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let targetAccountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targetAccountIds)
        var targetAccountIdsDecoded0:[String]? = nil
        if let targetAccountIdsContainer = targetAccountIdsContainer {
            targetAccountIdsDecoded0 = [String]()
            for string0 in targetAccountIdsContainer {
                if let string0 = string0 {
                    targetAccountIdsDecoded0?.append(string0)
                }
            }
        }
        targetAccountIds = targetAccountIdsDecoded0
        let amiTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .amiTags)
        var amiTagsDecoded0: [String:String]? = nil
        if let amiTagsContainer = amiTagsContainer {
            amiTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in amiTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    amiTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        amiTags = amiTagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let launchPermissionDecoded = try containerValues.decodeIfPresent(LaunchPermissionConfiguration.self, forKey: .launchPermission)
        launchPermission = launchPermissionDecoded
    }
}

extension AmiDistributionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AmiDistributionConfiguration(amiTags: \(String(describing: amiTags)), description: \(String(describing: description)), kmsKeyId: \(String(describing: kmsKeyId)), launchPermission: \(String(describing: launchPermission)), name: \(String(describing: name)), targetAccountIds: \(String(describing: targetAccountIds)))"}
}

/// <p> Define and configure the output AMIs of the pipeline.</p>
public struct AmiDistributionConfiguration: Equatable {
    /// <p>The tags to apply to AMIs distributed to this Region.</p>
    public let amiTags: [String:String]?
    /// <p>The description of the distribution configuration. Minimum and maximum length are in characters.</p>
    public let description: String?
    /// <p>The KMS key identifier used to encrypt the distributed image.</p>
    public let kmsKeyId: String?
    /// <p> Launch permissions can be used to configure which AWS accounts can use the AMI to launch
    ///       instances.</p>
    public let launchPermission: LaunchPermissionConfiguration?
    /// <p>The name of the distribution configuration.</p>
    public let name: String?
    /// <p>The ID of an account to which you want to distribute an image.</p>
    public let targetAccountIds: [String]?

    public init (
        amiTags: [String:String]? = nil,
        description: String? = nil,
        kmsKeyId: String? = nil,
        launchPermission: LaunchPermissionConfiguration? = nil,
        name: String? = nil,
        targetAccountIds: [String]? = nil
    )
    {
        self.amiTags = amiTags
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.launchPermission = launchPermission
        self.name = name
        self.targetAccountIds = targetAccountIds
    }
}

extension CallRateLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CallRateLimitExceededException(message: \(String(describing: message)))"}
}

extension CallRateLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CallRateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the permitted request rate for the specific operation.</p>
public struct CallRateLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CallRateLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension CallRateLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelImageCreationInputBodyMiddleware: Middleware {
    public let id: String = "CancelImageCreationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelImageCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelImageCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelImageCreationInput>
    public typealias MOutput = OperationOutput<CancelImageCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelImageCreationOutputError>
}

extension CancelImageCreationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelImageCreationInput(clientToken: \(String(describing: clientToken)), imageBuildVersionArn: \(String(describing: imageBuildVersionArn)))"}
}

extension CancelImageCreationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imageBuildVersionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imageBuildVersionArn = imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
    }
}

public struct CancelImageCreationInputHeadersMiddleware: Middleware {
    public let id: String = "CancelImageCreationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelImageCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelImageCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelImageCreationInput>
    public typealias MOutput = OperationOutput<CancelImageCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelImageCreationOutputError>
}

public struct CancelImageCreationInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelImageCreationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelImageCreationInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelImageCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelImageCreationInput>
    public typealias MOutput = OperationOutput<CancelImageCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelImageCreationOutputError>
}

public struct CancelImageCreationInput: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the image whose creation you want to cancel.</p>
    public let imageBuildVersionArn: String?

    public init (
        clientToken: String? = nil,
        imageBuildVersionArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct CancelImageCreationInputBody: Equatable {
    public let imageBuildVersionArn: String?
    public let clientToken: String?
}

extension CancelImageCreationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imageBuildVersionArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CancelImageCreationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelImageCreationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelImageCreationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelImageCreationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelImageCreationOutputResponse(clientToken: \(String(describing: clientToken)), imageBuildVersionArn: \(String(describing: imageBuildVersionArn)), requestId: \(String(describing: requestId)))"}
}

extension CancelImageCreationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelImageCreationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CancelImageCreationOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the image whose creation has been cancelled.</p>
    public let imageBuildVersionArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        imageBuildVersionArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct CancelImageCreationOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let imageBuildVersionArn: String?
}

extension CancelImageCreationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension ClientException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientException(message: \(String(describing: message)))"}
}

extension ClientException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClientExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>These errors are usually caused by a client action, such as using an action or resource on
///       behalf of a user that doesn't have permissions to use the action or resource, or specifying an
///       invalid resource identifier.</p>
public struct ClientException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClientExceptionBody: Equatable {
    public let message: String?
}

extension ClientExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Component: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case changeDescription
        case data
        case dateCreated
        case description
        case encrypted
        case kmsKeyId
        case name
        case owner
        case platform
        case supportedOsVersions
        case tags
        case type
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let changeDescription = changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversionlist0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComponentType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Component: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Component(arn: \(String(describing: arn)), changeDescription: \(String(describing: changeDescription)), data: \(String(describing: data)), dateCreated: \(String(describing: dateCreated)), description: \(String(describing: description)), encrypted: \(String(describing: encrypted)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), owner: \(String(describing: owner)), platform: \(String(describing: platform)), supportedOsVersions: \(String(describing: supportedOsVersions)), tags: \(String(describing: tags)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>A detailed view of a component.</p>
public struct Component: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component.</p>
    public let arn: String?
    /// <p>The change description of the component.</p>
    public let changeDescription: String?
    /// <p>The data of the component.</p>
    public let data: String?
    /// <p>The date that the component was created.</p>
    public let dateCreated: String?
    /// <p>The description of the component.</p>
    public let description: String?
    /// <p>The encryption status of the component.</p>
    public let encrypted: Bool?
    /// <p>The KMS key identifier used to encrypt the component.</p>
    public let kmsKeyId: String?
    /// <p>The name of the component.</p>
    public let name: String?
    /// <p>The owner of the component.</p>
    public let owner: String?
    /// <p>The platform of the component.</p>
    public let platform: Platform?
    /// <p>The operating system (OS) version supported by the component. If the OS information is
    ///       available, a prefix match is performed against the parent image OS version during image recipe
    ///       creation.</p>
    public let supportedOsVersions: [String]?
    /// <p>The tags associated with the component.</p>
    public let tags: [String:String]?
    /// <p>The type of the component denotes whether the component is used to build the image or only
    ///       to test it.</p>
    public let type: ComponentType?
    /// <p>The version of the component.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        changeDescription: String? = nil,
        data: String? = nil,
        dateCreated: String? = nil,
        description: String? = nil,
        encrypted: Bool? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        platform: Platform? = nil,
        supportedOsVersions: [String]? = nil,
        tags: [String:String]? = nil,
        type: ComponentType? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.changeDescription = changeDescription
        self.data = data
        self.dateCreated = dateCreated
        self.description = description
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.owner = owner
        self.platform = platform
        self.supportedOsVersions = supportedOsVersions
        self.tags = tags
        self.type = type
        self.version = version
    }
}

extension ComponentConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentArn = componentArn {
            try encodeContainer.encode(componentArn, forKey: .componentArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
    }
}

extension ComponentConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentConfiguration(componentArn: \(String(describing: componentArn)))"}
}

/// <p> Configuration details of the component.</p>
public struct ComponentConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component.</p>
    public let componentArn: String?

    public init (
        componentArn: String? = nil
    )
    {
        self.componentArn = componentArn
    }
}

public enum ComponentFormat {
    case shell
    case sdkUnknown(String)
}

extension ComponentFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComponentFormat] {
        return [
            .shell,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .shell: return "SHELL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComponentFormat(rawValue: rawValue) ?? ComponentFormat.sdkUnknown(rawValue)
    }
}

extension ComponentSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case changeDescription
        case dateCreated
        case description
        case name
        case owner
        case platform
        case supportedOsVersions
        case tags
        case type
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let changeDescription = changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversionlist0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ComponentType.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ComponentSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentSummary(arn: \(String(describing: arn)), changeDescription: \(String(describing: changeDescription)), dateCreated: \(String(describing: dateCreated)), description: \(String(describing: description)), name: \(String(describing: name)), owner: \(String(describing: owner)), platform: \(String(describing: platform)), supportedOsVersions: \(String(describing: supportedOsVersions)), tags: \(String(describing: tags)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>A high-level summary of a component.</p>
public struct ComponentSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component.</p>
    public let arn: String?
    /// <p>The change description of the component.</p>
    public let changeDescription: String?
    /// <p>The date that the component was created.</p>
    public let dateCreated: String?
    /// <p>The description of the component.</p>
    public let description: String?
    /// <p>The name of the component.</p>
    public let name: String?
    /// <p>The owner of the component.</p>
    public let owner: String?
    /// <p>The platform of the component.</p>
    public let platform: Platform?
    /// <p>The operating system (OS) version supported by the component. If the OS information is
    ///       available, a prefix match is performed against the parent image OS version during image recipe
    ///       creation.</p>
    public let supportedOsVersions: [String]?
    /// <p>The tags associated with the component.</p>
    public let tags: [String:String]?
    /// <p>The type of the component denotes whether the component is used to build the image or only
    ///       to test it.</p>
    public let type: ComponentType?
    /// <p>The version of the component.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        changeDescription: String? = nil,
        dateCreated: String? = nil,
        description: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        platform: Platform? = nil,
        supportedOsVersions: [String]? = nil,
        tags: [String:String]? = nil,
        type: ComponentType? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.changeDescription = changeDescription
        self.dateCreated = dateCreated
        self.description = description
        self.name = name
        self.owner = owner
        self.platform = platform
        self.supportedOsVersions = supportedOsVersions
        self.tags = tags
        self.type = type
        self.version = version
    }
}

public enum ComponentType {
    case build
    case test
    case sdkUnknown(String)
}

extension ComponentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComponentType] {
        return [
            .build,
            .test,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .build: return "BUILD"
        case .test: return "TEST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComponentType(rawValue: rawValue) ?? ComponentType.sdkUnknown(rawValue)
    }
}

extension ComponentVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dateCreated
        case description
        case name
        case owner
        case platform
        case supportedOsVersions
        case type
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversionlist0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversionlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ComponentType.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
    }
}

extension ComponentVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ComponentVersion(arn: \(String(describing: arn)), dateCreated: \(String(describing: dateCreated)), description: \(String(describing: description)), name: \(String(describing: name)), owner: \(String(describing: owner)), platform: \(String(describing: platform)), supportedOsVersions: \(String(describing: supportedOsVersions)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>A high-level overview of a component semantic version.</p>
public struct ComponentVersion: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component.</p>
    public let arn: String?
    /// <p>The date that the component was created.</p>
    public let dateCreated: String?
    /// <p>The description of the component.</p>
    public let description: String?
    /// <p>The name of the component.</p>
    public let name: String?
    /// <p>The owner of the component.</p>
    public let owner: String?
    /// <p>The platform of the component.</p>
    public let platform: Platform?
    /// <p>he operating system (OS) version supported by the component. If the OS information is
    ///       available, a prefix match is performed against the parent image OS version during image recipe
    ///       creation.</p>
    public let supportedOsVersions: [String]?
    /// <p>The type of the component denotes whether the component is used to build the image or only
    ///       to test it.</p>
    public let type: ComponentType?
    /// <p>The semantic version of the component.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        dateCreated: String? = nil,
        description: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        platform: Platform? = nil,
        supportedOsVersions: [String]? = nil,
        type: ComponentType? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.dateCreated = dateCreated
        self.description = description
        self.name = name
        self.owner = owner
        self.platform = platform
        self.supportedOsVersions = supportedOsVersions
        self.type = type
        self.version = version
    }
}

extension Container: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageUris
        case region
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUris = imageUris {
            var imageUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageUris)
            for stringlist0 in imageUris {
                try imageUrisContainer.encode(stringlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let imageUrisContainer = try containerValues.decodeIfPresent([String?].self, forKey: .imageUris)
        var imageUrisDecoded0:[String]? = nil
        if let imageUrisContainer = imageUrisContainer {
            imageUrisDecoded0 = [String]()
            for string0 in imageUrisContainer {
                if let string0 = string0 {
                    imageUrisDecoded0?.append(string0)
                }
            }
        }
        imageUris = imageUrisDecoded0
    }
}

extension Container: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Container(imageUris: \(String(describing: imageUris)), region: \(String(describing: region)))"}
}

/// <p>A container encapsulates the runtime environment for an application.</p>
public struct Container: Equatable {
    /// <p>A list of URIs for containers created in the context Region.</p>
    public let imageUris: [String]?
    /// <p>Containers and container images are Region-specific. This is the Region context for the container.</p>
    public let region: String?

    public init (
        imageUris: [String]? = nil,
        region: String? = nil
    )
    {
        self.imageUris = imageUris
        self.region = region
    }
}

extension ContainerDistributionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerTags
        case description
        case targetRepository
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerTags = containerTags {
            var containerTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containerTags)
            for stringlist0 in containerTags {
                try containerTagsContainer.encode(stringlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let targetRepository = targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let containerTagsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .containerTags)
        var containerTagsDecoded0:[String]? = nil
        if let containerTagsContainer = containerTagsContainer {
            containerTagsDecoded0 = [String]()
            for string0 in containerTagsContainer {
                if let string0 = string0 {
                    containerTagsDecoded0?.append(string0)
                }
            }
        }
        containerTags = containerTagsDecoded0
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
    }
}

extension ContainerDistributionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerDistributionConfiguration(containerTags: \(String(describing: containerTags)), description: \(String(describing: description)), targetRepository: \(String(describing: targetRepository)))"}
}

/// <p>Container distribution settings for encryption, licensing, and sharing in a specific Region.</p>
public struct ContainerDistributionConfiguration: Equatable {
    /// <p>Tags that are attached to the container distribution configuration.</p>
    public let containerTags: [String]?
    /// <p>The description of the container distribution configuration.</p>
    public let description: String?
    /// <p>The destination repository for the container distribution configuration.</p>
    public let targetRepository: TargetContainerRepository?

    public init (
        containerTags: [String]? = nil,
        description: String? = nil,
        targetRepository: TargetContainerRepository? = nil
    )
    {
        self.containerTags = containerTags
        self.description = description
        self.targetRepository = targetRepository
    }
}

extension ContainerRecipe: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case components
        case containerType
        case dateCreated
        case description
        case dockerfileTemplateData
        case encrypted
        case instanceConfiguration
        case kmsKeyId
        case name
        case owner
        case parentImage
        case platform
        case tags
        case targetRepository
        case version
        case workingDirectory
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let containerType = containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let dockerfileTemplateDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dockerfileTemplateData)
        dockerfileTemplateData = dockerfileTemplateDataDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
    }
}

extension ContainerRecipe: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerRecipe(arn: \(String(describing: arn)), components: \(String(describing: components)), containerType: \(String(describing: containerType)), dateCreated: \(String(describing: dateCreated)), description: \(String(describing: description)), dockerfileTemplateData: \(String(describing: dockerfileTemplateData)), encrypted: \(String(describing: encrypted)), instanceConfiguration: \(String(describing: instanceConfiguration)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), owner: \(String(describing: owner)), parentImage: \(String(describing: parentImage)), platform: \(String(describing: platform)), tags: \(String(describing: tags)), targetRepository: \(String(describing: targetRepository)), version: \(String(describing: version)), workingDirectory: \(String(describing: workingDirectory)))"}
}

/// <p>A container recipe.</p>
public struct ContainerRecipe: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container recipe.</p>
    public let arn: String?
    /// <p>Components for build and test that are included in the container recipe.</p>
    public let components: [ComponentConfiguration]?
    /// <p>Specifies the type of container, such as Docker.</p>
    public let containerType: ContainerType?
    /// <p>The date when this container recipe was created.</p>
    public let dateCreated: String?
    /// <p>The description of the container recipe.</p>
    public let description: String?
    /// <p>Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.</p>
    public let dockerfileTemplateData: String?
    /// <p>A flag that indicates if the target container is encrypted.</p>
    public let encrypted: Bool?
    /// <p>A group of options that can be used to configure an instance for building and testing container images.</p>
    public let instanceConfiguration: InstanceConfiguration?
    /// <p>Identifies which KMS key is used to encrypt the container image for distribution to the target Region.</p>
    public let kmsKeyId: String?
    /// <p>The name of the container recipe.</p>
    public let name: String?
    /// <p>The owner of the container recipe.</p>
    public let owner: String?
    /// <p>The source image for the container recipe.</p>
    public let parentImage: String?
    /// <p>The system platform for the container, such as Windows or Linux.</p>
    public let platform: Platform?
    /// <p>Tags that are attached to the container recipe.</p>
    public let tags: [String:String]?
    /// <p>The destination repository for the container image.</p>
    public let targetRepository: TargetContainerRepository?
    /// <p>The semantic version of the container recipe (<major>.<minor>.<patch>).</p>
    public let version: String?
    /// <p>The working directory for use during build and test workflows.</p>
    public let workingDirectory: String?

    public init (
        arn: String? = nil,
        components: [ComponentConfiguration]? = nil,
        containerType: ContainerType? = nil,
        dateCreated: String? = nil,
        description: String? = nil,
        dockerfileTemplateData: String? = nil,
        encrypted: Bool? = nil,
        instanceConfiguration: InstanceConfiguration? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        parentImage: String? = nil,
        platform: Platform? = nil,
        tags: [String:String]? = nil,
        targetRepository: TargetContainerRepository? = nil,
        version: String? = nil,
        workingDirectory: String? = nil
    )
    {
        self.arn = arn
        self.components = components
        self.containerType = containerType
        self.dateCreated = dateCreated
        self.description = description
        self.dockerfileTemplateData = dockerfileTemplateData
        self.encrypted = encrypted
        self.instanceConfiguration = instanceConfiguration
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.owner = owner
        self.parentImage = parentImage
        self.platform = platform
        self.tags = tags
        self.targetRepository = targetRepository
        self.version = version
        self.workingDirectory = workingDirectory
    }
}

extension ContainerRecipeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case containerType
        case dateCreated
        case name
        case owner
        case parentImage
        case platform
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerType = containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ContainerRecipeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContainerRecipeSummary(arn: \(String(describing: arn)), containerType: \(String(describing: containerType)), dateCreated: \(String(describing: dateCreated)), name: \(String(describing: name)), owner: \(String(describing: owner)), parentImage: \(String(describing: parentImage)), platform: \(String(describing: platform)), tags: \(String(describing: tags)))"}
}

/// <p>A summary of a container recipe</p>
public struct ContainerRecipeSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container recipe.</p>
    public let arn: String?
    /// <p>Specifies the type of container, such as "Docker".</p>
    public let containerType: ContainerType?
    /// <p>The date when this container recipe was created.</p>
    public let dateCreated: String?
    /// <p>The name of the container recipe.</p>
    public let name: String?
    /// <p>The owner of the container recipe.</p>
    public let owner: String?
    /// <p>The source image for the container recipe.</p>
    public let parentImage: String?
    /// <p>The system platform for the container, such as Windows or Linux.</p>
    public let platform: Platform?
    /// <p>Tags that are attached to the container recipe.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        containerType: ContainerType? = nil,
        dateCreated: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        parentImage: String? = nil,
        platform: Platform? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.containerType = containerType
        self.dateCreated = dateCreated
        self.name = name
        self.owner = owner
        self.parentImage = parentImage
        self.platform = platform
        self.tags = tags
    }
}

public enum ContainerRepositoryService {
    case ecr
    case sdkUnknown(String)
}

extension ContainerRepositoryService : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContainerRepositoryService] {
        return [
            .ecr,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ecr: return "ECR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContainerRepositoryService(rawValue: rawValue) ?? ContainerRepositoryService.sdkUnknown(rawValue)
    }
}

public enum ContainerType {
    case docker
    case sdkUnknown(String)
}

extension ContainerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ContainerType] {
        return [
            .docker,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .docker: return "DOCKER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ContainerType(rawValue: rawValue) ?? ContainerType.sdkUnknown(rawValue)
    }
}

public struct CreateComponentInputBodyMiddleware: Middleware {
    public let id: String = "CreateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentInput>
    public typealias MOutput = OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentOutputError>
}

extension CreateComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateComponentInput(changeDescription: \(String(describing: changeDescription)), clientToken: \(String(describing: clientToken)), data: \(String(describing: data)), description: \(String(describing: description)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), platform: \(String(describing: platform)), semanticVersion: \(String(describing: semanticVersion)), supportedOsVersions: \(String(describing: supportedOsVersions)), tags: \(String(describing: tags)), uri: \(String(describing: uri)))"}
}

extension CreateComponentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case supportedOsVersions
        case tags
        case uri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDescription = changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversionlist0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct CreateComponentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentInput>
    public typealias MOutput = OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentOutputError>
}

public struct CreateComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentInput>
    public typealias MOutput = OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentOutputError>
}

public struct CreateComponentInput: Equatable {
    /// <p>The change description of the component. Describes what change has been made in this
    ///       version, or what makes this version different from other versions of this component.</p>
    public let changeDescription: String?
    /// <p>The idempotency token of the component.</p>
    public var clientToken: String?
    /// <p>The data of the component. Used to specify the data inline. Either <code>data</code> or
    ///       <code>uri</code> can be used to specify the data within the component.</p>
    public let data: String?
    /// <p>The description of the component. Describes the contents of the component.</p>
    public let description: String?
    /// <p>The ID of the KMS key that should be used to encrypt this component.</p>
    public let kmsKeyId: String?
    /// <p>The name of the component.</p>
    public let name: String?
    /// <p>The platform of the component.</p>
    public let platform: Platform?
    /// <p>The semantic version of the component. This version follows the semantic version syntax.
    ///       For example, major.minor.patch. This could be versioned like software (2.0.1) or like a date
    ///       (2019.12.01).</p>
    public let semanticVersion: String?
    /// <p> The operating system (OS) version supported by the component. If the OS information is
    ///       available, a prefix match is performed against the parent image OS version during image recipe
    ///       creation.</p>
    public let supportedOsVersions: [String]?
    /// <p>The tags of the component.</p>
    public let tags: [String:String]?
    /// <p>The uri of the component. Must be an S3 URL and the requester must have permission to
    ///       access the S3 bucket. If you use S3, you can specify component content up to your service
    ///       quota. Either <code>data</code> or <code>uri</code> can be used to specify the data within the
    ///       component.</p>
    public let uri: String?

    public init (
        changeDescription: String? = nil,
        clientToken: String? = nil,
        data: String? = nil,
        description: String? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        platform: Platform? = nil,
        semanticVersion: String? = nil,
        supportedOsVersions: [String]? = nil,
        tags: [String:String]? = nil,
        uri: String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.supportedOsVersions = supportedOsVersions
        self.tags = tags
        self.uri = uri
    }
}

struct CreateComponentInputBody: Equatable {
    public let name: String?
    public let semanticVersion: String?
    public let description: String?
    public let changeDescription: String?
    public let platform: Platform?
    public let supportedOsVersions: [String]?
    public let data: String?
    public let uri: String?
    public let kmsKeyId: String?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension CreateComponentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case supportedOsVersions
        case tags
        case uri
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateComponentOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateComponentOutputResponse(clientToken: \(String(describing: clientToken)), componentBuildVersionArn: \(String(describing: componentBuildVersionArn)), requestId: \(String(describing: requestId)))"}
}

extension CreateComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateComponentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateComponentOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the component that was created by this request.</p>
    public let componentBuildVersionArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        componentBuildVersionArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct CreateComponentOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let componentBuildVersionArn: String?
}

extension CreateComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

public struct CreateContainerRecipeInputBodyMiddleware: Middleware {
    public let id: String = "CreateContainerRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerRecipeOutputError>
}

extension CreateContainerRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContainerRecipeInput(clientToken: \(String(describing: clientToken)), components: \(String(describing: components)), containerType: \(String(describing: containerType)), description: \(String(describing: description)), dockerfileTemplateData: \(String(describing: dockerfileTemplateData)), dockerfileTemplateUri: \(String(describing: dockerfileTemplateUri)), imageOsVersionOverride: \(String(describing: imageOsVersionOverride)), instanceConfiguration: \(String(describing: instanceConfiguration)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), parentImage: \(String(describing: parentImage)), platformOverride: \(String(describing: platformOverride)), semanticVersion: \(String(describing: semanticVersion)), tags: \(String(describing: tags)), targetRepository: \(String(describing: targetRepository)), workingDirectory: \(String(describing: workingDirectory)))"}
}

extension CreateContainerRecipeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let containerType = containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let dockerfileTemplateUri = dockerfileTemplateUri {
            try encodeContainer.encode(dockerfileTemplateUri, forKey: .dockerfileTemplateUri)
        }
        if let imageOsVersionOverride = imageOsVersionOverride {
            try encodeContainer.encode(imageOsVersionOverride, forKey: .imageOsVersionOverride)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platformOverride = platformOverride {
            try encodeContainer.encode(platformOverride.rawValue, forKey: .platformOverride)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

public struct CreateContainerRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateContainerRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerRecipeOutputError>
}

public struct CreateContainerRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateContainerRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateContainerRecipeOutputError>
}

public struct CreateContainerRecipeInput: Equatable {
    /// <p>The client token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>Components for build and test that are included in the container recipe.</p>
    public let components: [ComponentConfiguration]?
    /// <p>The type of container to create.</p>
    public let containerType: ContainerType?
    /// <p>The description of the container recipe.</p>
    public let description: String?
    /// <p>The Dockerfile template used to build your image as an inline data blob.</p>
    public let dockerfileTemplateData: String?
    /// <p>The S3 URI for the Dockerfile that will be used to build your container image.</p>
    public let dockerfileTemplateUri: String?
    /// <p>Specifies the operating system version for the source image.</p>
    public let imageOsVersionOverride: String?
    /// <p>A group of options that can be used to configure an instance for building and testing container images.</p>
    public let instanceConfiguration: InstanceConfiguration?
    /// <p>Identifies which KMS key is used to encrypt the container image.</p>
    public let kmsKeyId: String?
    /// <p>The name of the container recipe.</p>
    public let name: String?
    /// <p>The source image for the container recipe.</p>
    public let parentImage: String?
    /// <p>Specifies the operating system platform when you use a custom source image.</p>
    public let platformOverride: Platform?
    /// <p>The semantic version of the container recipe (<major>.<minor>.<patch>).</p>
    public let semanticVersion: String?
    /// <p>Tags that are attached to the container recipe.</p>
    public let tags: [String:String]?
    /// <p>The destination repository for the container image.</p>
    public let targetRepository: TargetContainerRepository?
    /// <p>The working directory for use during build and test workflows.</p>
    public let workingDirectory: String?

    public init (
        clientToken: String? = nil,
        components: [ComponentConfiguration]? = nil,
        containerType: ContainerType? = nil,
        description: String? = nil,
        dockerfileTemplateData: String? = nil,
        dockerfileTemplateUri: String? = nil,
        imageOsVersionOverride: String? = nil,
        instanceConfiguration: InstanceConfiguration? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        parentImage: String? = nil,
        platformOverride: Platform? = nil,
        semanticVersion: String? = nil,
        tags: [String:String]? = nil,
        targetRepository: TargetContainerRepository? = nil,
        workingDirectory: String? = nil
    )
    {
        self.clientToken = clientToken
        self.components = components
        self.containerType = containerType
        self.description = description
        self.dockerfileTemplateData = dockerfileTemplateData
        self.dockerfileTemplateUri = dockerfileTemplateUri
        self.imageOsVersionOverride = imageOsVersionOverride
        self.instanceConfiguration = instanceConfiguration
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.parentImage = parentImage
        self.platformOverride = platformOverride
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.targetRepository = targetRepository
        self.workingDirectory = workingDirectory
    }
}

struct CreateContainerRecipeInputBody: Equatable {
    public let containerType: ContainerType?
    public let name: String?
    public let description: String?
    public let semanticVersion: String?
    public let components: [ComponentConfiguration]?
    public let instanceConfiguration: InstanceConfiguration?
    public let dockerfileTemplateData: String?
    public let dockerfileTemplateUri: String?
    public let platformOverride: Platform?
    public let imageOsVersionOverride: String?
    public let parentImage: String?
    public let tags: [String:String]?
    public let workingDirectory: String?
    public let targetRepository: TargetContainerRepository?
    public let kmsKeyId: String?
    public let clientToken: String?
}

extension CreateContainerRecipeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerTypeDecoded = try containerValues.decodeIfPresent(ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let dockerfileTemplateDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dockerfileTemplateData)
        dockerfileTemplateData = dockerfileTemplateDataDecoded
        let dockerfileTemplateUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dockerfileTemplateUri)
        dockerfileTemplateUri = dockerfileTemplateUriDecoded
        let platformOverrideDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platformOverride)
        platformOverride = platformOverrideDecoded
        let imageOsVersionOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageOsVersionOverride)
        imageOsVersionOverride = imageOsVersionOverrideDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateContainerRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContainerRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContainerRecipeOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContainerRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateContainerRecipeOutputResponse(clientToken: \(String(describing: clientToken)), containerRecipeArn: \(String(describing: containerRecipeArn)), requestId: \(String(describing: requestId)))"}
}

extension CreateContainerRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateContainerRecipeOutputResponse: Equatable {
    /// <p>The client token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>Returns the Amazon Resource Name (ARN) of the container recipe that the request created.</p>
    public let containerRecipeArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        containerRecipeArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct CreateContainerRecipeOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let containerRecipeArn: String?
}

extension CreateContainerRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

public struct CreateDistributionConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateDistributionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<CreateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionConfigurationOutputError>
}

extension CreateDistributionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDistributionConfigurationInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), distributions: \(String(describing: distributions)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateDistributionConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case distributions
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distributionlist0 in distributions {
                try distributionsContainer.encode(distributionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDistributionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDistributionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<CreateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionConfigurationOutputError>
}

public struct CreateDistributionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDistributionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<CreateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionConfigurationOutputError>
}

public struct CreateDistributionConfigurationInput: Equatable {
    /// <p> The idempotency token of the distribution configuration.</p>
    public var clientToken: String?
    /// <p> The description of the distribution configuration.</p>
    public let description: String?
    /// <p> The distributions of the distribution configuration.</p>
    public let distributions: [Distribution]?
    /// <p> The name of the distribution configuration.</p>
    public let name: String?
    /// <p> The tags of the distribution configuration.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        distributions: [Distribution]? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributions = distributions
        self.name = name
        self.tags = tags
    }
}

struct CreateDistributionConfigurationInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let distributions: [Distribution]?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension CreateDistributionConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case distributions
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDistributionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDistributionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionConfigurationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDistributionConfigurationOutputResponse(clientToken: \(String(describing: clientToken)), distributionConfigurationArn: \(String(describing: distributionConfigurationArn)), requestId: \(String(describing: requestId)))"}
}

extension CreateDistributionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateDistributionConfigurationOutputResponse: Equatable {
    /// <p> The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p> The Amazon Resource Name (ARN) of the distribution configuration that was created by this
    ///       request.</p>
    public let distributionConfigurationArn: String?
    /// <p> The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        distributionConfigurationArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct CreateDistributionConfigurationOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let distributionConfigurationArn: String?
}

extension CreateDistributionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

public struct CreateImageInputBodyMiddleware: Middleware {
    public let id: String = "CreateImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageInput>
    public typealias MOutput = OperationOutput<CreateImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageOutputError>
}

extension CreateImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImageInput(clientToken: \(String(describing: clientToken)), containerRecipeArn: \(String(describing: containerRecipeArn)), distributionConfigurationArn: \(String(describing: distributionConfigurationArn)), enhancedImageMetadataEnabled: \(String(describing: enhancedImageMetadataEnabled)), imageRecipeArn: \(String(describing: imageRecipeArn)), imageTestsConfiguration: \(String(describing: imageTestsConfiguration)), infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)), tags: \(String(describing: tags)))"}
}

extension CreateImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerRecipeArn
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateImageInputHeadersMiddleware: Middleware {
    public let id: String = "CreateImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageInput>
    public typealias MOutput = OperationOutput<CreateImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageOutputError>
}

public struct CreateImageInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageInput>
    public typealias MOutput = OperationOutput<CreateImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageOutputError>
}

public struct CreateImageInput: Equatable {
    /// <p> The idempotency token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.</p>
    public let containerRecipeArn: String?
    /// <p> The Amazon Resource Name (ARN) of the distribution configuration that defines and
    ///       configures the outputs of your pipeline.</p>
    public let distributionConfigurationArn: String?
    /// <p> Collects additional information about the image being created, including the operating
    ///       system (OS) version and package list. This information is used to enhance the overall
    ///       experience of using EC2 Image Builder. Enabled by default.</p>
    public let enhancedImageMetadataEnabled: Bool?
    /// <p> The Amazon Resource Name (ARN) of the image recipe that defines how images are
    ///       configured, tested, and assessed.</p>
    public let imageRecipeArn: String?
    /// <p> The image tests configuration of the image.</p>
    public let imageTestsConfiguration: ImageTestsConfiguration?
    /// <p> The Amazon Resource Name (ARN) of the infrastructure configuration that defines the
    ///       environment in which your image will be built and tested.</p>
    public let infrastructureConfigurationArn: String?
    /// <p> The tags of the image.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        containerRecipeArn: String? = nil,
        distributionConfigurationArn: String? = nil,
        enhancedImageMetadataEnabled: Bool? = nil,
        imageRecipeArn: String? = nil,
        imageTestsConfiguration: ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.tags = tags
    }
}

struct CreateImageInputBody: Equatable {
    public let imageRecipeArn: String?
    public let containerRecipeArn: String?
    public let distributionConfigurationArn: String?
    public let infrastructureConfigurationArn: String?
    public let imageTestsConfiguration: ImageTestsConfiguration?
    public let enhancedImageMetadataEnabled: Bool?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension CreateImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerRecipeArn
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImageOutputResponse(clientToken: \(String(describing: clientToken)), imageBuildVersionArn: \(String(describing: imageBuildVersionArn)), requestId: \(String(describing: requestId)))"}
}

extension CreateImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImageOutputResponse: Equatable {
    /// <p> The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p> The Amazon Resource Name (ARN) of the image that was created by this request.</p>
    public let imageBuildVersionArn: String?
    /// <p> The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        imageBuildVersionArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct CreateImageOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let imageBuildVersionArn: String?
}

extension CreateImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

public struct CreateImagePipelineInputBodyMiddleware: Middleware {
    public let id: String = "CreateImagePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImagePipelineInput>
    public typealias MOutput = OperationOutput<CreateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImagePipelineOutputError>
}

extension CreateImagePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImagePipelineInput(clientToken: \(String(describing: clientToken)), containerRecipeArn: \(String(describing: containerRecipeArn)), description: \(String(describing: description)), distributionConfigurationArn: \(String(describing: distributionConfigurationArn)), enhancedImageMetadataEnabled: \(String(describing: enhancedImageMetadataEnabled)), imageRecipeArn: \(String(describing: imageRecipeArn)), imageTestsConfiguration: \(String(describing: imageTestsConfiguration)), infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)), name: \(String(describing: name)), schedule: \(String(describing: schedule)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension CreateImagePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case schedule
        case status
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateImagePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "CreateImagePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImagePipelineInput>
    public typealias MOutput = OperationOutput<CreateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImagePipelineOutputError>
}

public struct CreateImagePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateImagePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImagePipelineInput>
    public typealias MOutput = OperationOutput<CreateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImagePipelineOutputError>
}

public struct CreateImagePipelineInput: Equatable {
    /// <p> The idempotency token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the container recipe that is used to configure images created by this container pipeline.</p>
    public let containerRecipeArn: String?
    /// <p> The description of the image pipeline.</p>
    public let description: String?
    /// <p> The Amazon Resource Name (ARN) of the distribution configuration that will be used to
    ///       configure and distribute images created by this image pipeline.</p>
    public let distributionConfigurationArn: String?
    /// <p> Collects additional information about the image being created, including the operating
    ///       system (OS) version and package list. This information is used to enhance the overall
    ///       experience of using EC2 Image Builder. Enabled by default.</p>
    public let enhancedImageMetadataEnabled: Bool?
    /// <p> The Amazon Resource Name (ARN) of the image recipe that will be used to configure images
    ///       created by this image pipeline.</p>
    public let imageRecipeArn: String?
    /// <p> The image test configuration of the image pipeline.</p>
    public let imageTestsConfiguration: ImageTestsConfiguration?
    /// <p> The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to
    ///       build images created by this image pipeline.</p>
    public let infrastructureConfigurationArn: String?
    /// <p> The name of the image pipeline.</p>
    public let name: String?
    /// <p> The schedule of the image pipeline.</p>
    public let schedule: Schedule?
    /// <p> The status of the image pipeline.</p>
    public let status: PipelineStatus?
    /// <p> The tags of the image pipeline.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        containerRecipeArn: String? = nil,
        description: String? = nil,
        distributionConfigurationArn: String? = nil,
        enhancedImageMetadataEnabled: Bool? = nil,
        imageRecipeArn: String? = nil,
        imageTestsConfiguration: ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: String? = nil,
        name: String? = nil,
        schedule: Schedule? = nil,
        status: PipelineStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.name = name
        self.schedule = schedule
        self.status = status
        self.tags = tags
    }
}

struct CreateImagePipelineInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let imageRecipeArn: String?
    public let containerRecipeArn: String?
    public let infrastructureConfigurationArn: String?
    public let distributionConfigurationArn: String?
    public let imageTestsConfiguration: ImageTestsConfiguration?
    public let enhancedImageMetadataEnabled: Bool?
    public let schedule: Schedule?
    public let status: PipelineStatus?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension CreateImagePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case schedule
        case status
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImagePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImagePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImagePipelineOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImagePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImagePipelineOutputResponse(clientToken: \(String(describing: clientToken)), imagePipelineArn: \(String(describing: imagePipelineArn)), requestId: \(String(describing: requestId)))"}
}

extension CreateImagePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImagePipelineOutputResponse: Equatable {
    /// <p> The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p> The Amazon Resource Name (ARN) of the image pipeline that was created by this request.</p>
    public let imagePipelineArn: String?
    /// <p> The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        imagePipelineArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct CreateImagePipelineOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let imagePipelineArn: String?
}

extension CreateImagePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

public struct CreateImageRecipeInputBodyMiddleware: Middleware {
    public let id: String = "CreateImageRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageRecipeInput>
    public typealias MOutput = OperationOutput<CreateImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageRecipeOutputError>
}

extension CreateImageRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImageRecipeInput(blockDeviceMappings: \(String(describing: blockDeviceMappings)), clientToken: \(String(describing: clientToken)), components: \(String(describing: components)), description: \(String(describing: description)), name: \(String(describing: name)), parentImage: \(String(describing: parentImage)), semanticVersion: \(String(describing: semanticVersion)), tags: \(String(describing: tags)), workingDirectory: \(String(describing: workingDirectory)))"}
}

extension CreateImageRecipeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings
        case clientToken
        case components
        case description
        case name
        case parentImage
        case semanticVersion
        case tags
        case workingDirectory
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemappings0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

public struct CreateImageRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateImageRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageRecipeInput>
    public typealias MOutput = OperationOutput<CreateImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageRecipeOutputError>
}

public struct CreateImageRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateImageRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImageRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImageRecipeInput>
    public typealias MOutput = OperationOutput<CreateImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImageRecipeOutputError>
}

public struct CreateImageRecipeInput: Equatable {
    /// <p>The block device mappings of the image recipe.</p>
    public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
    /// <p>The idempotency token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>The components of the image recipe.</p>
    public let components: [ComponentConfiguration]?
    /// <p> The description of the image recipe.</p>
    public let description: String?
    /// <p> The name of the image recipe.</p>
    public let name: String?
    /// <p>The parent image of the image recipe. The value of the string can be the ARN of the parent
    ///       image or an AMI ID. The format for the ARN follows this example:
    ///         <code>arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x</code>.
    ///       You can provide the specific version that you want to use, or you can use a wildcard in all of
    ///       the fields. If you enter an AMI ID for the string value, you must have access to the AMI, and
    ///       the AMI must be in the same Region in which you are using Image Builder.</p>
    public let parentImage: String?
    /// <p>The semantic version of the image recipe.</p>
    public let semanticVersion: String?
    /// <p> The tags of the image recipe.</p>
    public let tags: [String:String]?
    /// <p>The working directory to be used during build and test workflows.</p>
    public let workingDirectory: String?

    public init (
        blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil,
        clientToken: String? = nil,
        components: [ComponentConfiguration]? = nil,
        description: String? = nil,
        name: String? = nil,
        parentImage: String? = nil,
        semanticVersion: String? = nil,
        tags: [String:String]? = nil,
        workingDirectory: String? = nil
    )
    {
        self.blockDeviceMappings = blockDeviceMappings
        self.clientToken = clientToken
        self.components = components
        self.description = description
        self.name = name
        self.parentImage = parentImage
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.workingDirectory = workingDirectory
    }
}

struct CreateImageRecipeInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let semanticVersion: String?
    public let components: [ComponentConfiguration]?
    public let parentImage: String?
    public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
    public let tags: [String:String]?
    public let workingDirectory: String?
    public let clientToken: String?
}

extension CreateImageRecipeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings
        case clientToken
        case components
        case description
        case name
        case parentImage
        case semanticVersion
        case tags
        case workingDirectory
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let parentImageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImageRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageRecipeOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImageRecipeOutputResponse(clientToken: \(String(describing: clientToken)), imageRecipeArn: \(String(describing: imageRecipeArn)), requestId: \(String(describing: requestId)))"}
}

extension CreateImageRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImageRecipeOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the image recipe that was created by this request.</p>
    public let imageRecipeArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        imageRecipeArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct CreateImageRecipeOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let imageRecipeArn: String?
}

extension CreateImageRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

public struct CreateInfrastructureConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateInfrastructureConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<CreateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInfrastructureConfigurationOutputError>
}

extension CreateInfrastructureConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInfrastructureConfigurationInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), instanceProfileName: \(String(describing: instanceProfileName)), instanceTypes: \(String(describing: instanceTypes)), keyPair: \(String(describing: keyPair)), logging: \(String(describing: logging)), name: \(String(describing: name)), resourceTags: \(String(describing: resourceTags)), securityGroupIds: \(String(describing: securityGroupIds)), snsTopicArn: \(String(describing: snsTopicArn)), subnetId: \(String(describing: subnetId)), tags: \(String(describing: tags)), terminateInstanceOnFailure: \(String(describing: terminateInstanceOnFailure)))"}
}

extension CreateInfrastructureConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetypelist0 in instanceTypes {
                try instanceTypesContainer.encode(instancetypelist0)
            }
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTags)
            for (dictKey0, resourcetagmap0) in resourceTags {
                try resourceTagsContainer.encode(resourcetagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let terminateInstanceOnFailure = terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }
}

public struct CreateInfrastructureConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInfrastructureConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<CreateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInfrastructureConfigurationOutputError>
}

public struct CreateInfrastructureConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInfrastructureConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<CreateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInfrastructureConfigurationOutputError>
}

public struct CreateInfrastructureConfigurationInput: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>The description of the infrastructure configuration.</p>
    public let description: String?
    /// <p>The instance profile to associate with the instance used to customize your EC2 AMI.</p>
    public let instanceProfileName: String?
    /// <p>The instance types of the infrastructure configuration. You can specify one or more
    ///       instance types to use for this build. The service will pick one of these instance types based
    ///       on availability.</p>
    public let instanceTypes: [String]?
    /// <p>The key pair of the infrastructure configuration. This can be used to log on to and debug
    ///       the instance used to create your image.</p>
    public let keyPair: String?
    /// <p>The logging configuration of the infrastructure configuration.</p>
    public let logging: Logging?
    /// <p>The name of the infrastructure configuration.</p>
    public let name: String?
    /// <p>The tags attached to the resource created by Image Builder.</p>
    public let resourceTags: [String:String]?
    /// <p>The security group IDs to associate with the instance used to customize your EC2 AMI.</p>
    public let securityGroupIds: [String]?
    /// <p>The SNS topic on which to send image build events.</p>
    public let snsTopicArn: String?
    /// <p>The subnet ID in which to place the instance used to customize your EC2 AMI.</p>
    public let subnetId: String?
    /// <p>The tags of the infrastructure configuration.</p>
    public let tags: [String:String]?
    /// <p>The terminate instance on failure setting of the infrastructure configuration. Set to
    ///       false if you want Image Builder to retain the instance used to configure your AMI if the build
    ///       or test phase of your workflow fails.</p>
    public let terminateInstanceOnFailure: Bool?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        instanceProfileName: String? = nil,
        instanceTypes: [String]? = nil,
        keyPair: String? = nil,
        logging: Logging? = nil,
        name: String? = nil,
        resourceTags: [String:String]? = nil,
        securityGroupIds: [String]? = nil,
        snsTopicArn: String? = nil,
        subnetId: String? = nil,
        tags: [String:String]? = nil,
        terminateInstanceOnFailure: Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.name = name
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.tags = tags
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

struct CreateInfrastructureConfigurationInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let instanceTypes: [String]?
    public let instanceProfileName: String?
    public let securityGroupIds: [String]?
    public let subnetId: String?
    public let logging: Logging?
    public let keyPair: String?
    public let terminateInstanceOnFailure: Bool?
    public let snsTopicArn: String?
    public let resourceTags: [String:String]?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension CreateInfrastructureConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [String:String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateInfrastructureConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInfrastructureConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInfrastructureConfigurationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInfrastructureConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInfrastructureConfigurationOutputResponse(clientToken: \(String(describing: clientToken)), infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)), requestId: \(String(describing: requestId)))"}
}

extension CreateInfrastructureConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateInfrastructureConfigurationOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that was created by
    ///       this request.</p>
    public let infrastructureConfigurationArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        infrastructureConfigurationArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct CreateInfrastructureConfigurationOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let infrastructureConfigurationArn: String?
}

extension CreateInfrastructureConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

extension DeleteComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteComponentInput(componentBuildVersionArn: \(String(describing: componentBuildVersionArn)))"}
}

extension DeleteComponentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteComponentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let componentBuildVersionArn = input.operationInput.componentBuildVersionArn {
            let componentBuildVersionArnQueryItem = URLQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: String(componentBuildVersionArn).urlPercentEncoding())
            input.builder.withQueryItem(componentBuildVersionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component build version to delete.</p>
    public let componentBuildVersionArn: String?

    public init (
        componentBuildVersionArn: String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

struct DeleteComponentInputBody: Equatable {
}

extension DeleteComponentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteComponentOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteComponentOutputResponse(componentBuildVersionArn: \(String(describing: componentBuildVersionArn)), requestId: \(String(describing: requestId)))"}
}

extension DeleteComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteComponentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteComponentOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component build version that was deleted.</p>
    public let componentBuildVersionArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        componentBuildVersionArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct DeleteComponentOutputResponseBody: Equatable {
    public let requestId: String?
    public let componentBuildVersionArn: String?
}

extension DeleteComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

extension DeleteContainerRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContainerRecipeInput(containerRecipeArn: \(String(describing: containerRecipeArn)))"}
}

extension DeleteContainerRecipeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteContainerRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteContainerRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContainerRecipeInput>
    public typealias MOutput = OperationOutput<DeleteContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContainerRecipeOutputError>
}

public struct DeleteContainerRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteContainerRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let containerRecipeArn = input.operationInput.containerRecipeArn {
            let containerRecipeArnQueryItem = URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: String(containerRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(containerRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteContainerRecipeInput>
    public typealias MOutput = OperationOutput<DeleteContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteContainerRecipeOutputError>
}

public struct DeleteContainerRecipeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container recipe to delete.</p>
    public let containerRecipeArn: String?

    public init (
        containerRecipeArn: String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct DeleteContainerRecipeInputBody: Equatable {
}

extension DeleteContainerRecipeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteContainerRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContainerRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContainerRecipeOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContainerRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteContainerRecipeOutputResponse(containerRecipeArn: \(String(describing: containerRecipeArn)), requestId: \(String(describing: requestId)))"}
}

extension DeleteContainerRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteContainerRecipeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container recipe that was deleted.</p>
    public let containerRecipeArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        containerRecipeArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct DeleteContainerRecipeOutputResponseBody: Equatable {
    public let requestId: String?
    public let containerRecipeArn: String?
}

extension DeleteContainerRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

extension DeleteDistributionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDistributionConfigurationInput(distributionConfigurationArn: \(String(describing: distributionConfigurationArn)))"}
}

extension DeleteDistributionConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDistributionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDistributionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDistributionConfigurationOutputError>
}

public struct DeleteDistributionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDistributionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfigurationArn = input.operationInput.distributionConfigurationArn {
            let distributionConfigurationArnQueryItem = URLQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: String(distributionConfigurationArn).urlPercentEncoding())
            input.builder.withQueryItem(distributionConfigurationArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDistributionConfigurationOutputError>
}

public struct DeleteDistributionConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration to delete.</p>
    public let distributionConfigurationArn: String?

    public init (
        distributionConfigurationArn: String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

struct DeleteDistributionConfigurationInputBody: Equatable {
}

extension DeleteDistributionConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDistributionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDistributionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDistributionConfigurationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDistributionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDistributionConfigurationOutputResponse(distributionConfigurationArn: \(String(describing: distributionConfigurationArn)), requestId: \(String(describing: requestId)))"}
}

extension DeleteDistributionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteDistributionConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration that was deleted.</p>
    public let distributionConfigurationArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        distributionConfigurationArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct DeleteDistributionConfigurationOutputResponseBody: Equatable {
    public let requestId: String?
    public let distributionConfigurationArn: String?
}

extension DeleteDistributionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

extension DeleteImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImageInput(imageBuildVersionArn: \(String(describing: imageBuildVersionArn)))"}
}

extension DeleteImageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteImageInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageInput>
    public typealias MOutput = OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageOutputError>
}

public struct DeleteImageInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageBuildVersionArn = input.operationInput.imageBuildVersionArn {
            let imageBuildVersionArnQueryItem = URLQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: String(imageBuildVersionArn).urlPercentEncoding())
            input.builder.withQueryItem(imageBuildVersionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageInput>
    public typealias MOutput = OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageOutputError>
}

public struct DeleteImageInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image to delete.</p>
    public let imageBuildVersionArn: String?

    public init (
        imageBuildVersionArn: String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct DeleteImageInputBody: Equatable {
}

extension DeleteImageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImageOutputResponse(imageBuildVersionArn: \(String(describing: imageBuildVersionArn)), requestId: \(String(describing: requestId)))"}
}

extension DeleteImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImageOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image that was deleted.</p>
    public let imageBuildVersionArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageBuildVersionArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct DeleteImageOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageBuildVersionArn: String?
}

extension DeleteImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension DeleteImagePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImagePipelineInput(imagePipelineArn: \(String(describing: imagePipelineArn)))"}
}

extension DeleteImagePipelineInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteImagePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteImagePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImagePipelineInput>
    public typealias MOutput = OperationOutput<DeleteImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImagePipelineOutputError>
}

public struct DeleteImagePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteImagePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imagePipelineArn = input.operationInput.imagePipelineArn {
            let imagePipelineArnQueryItem = URLQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: String(imagePipelineArn).urlPercentEncoding())
            input.builder.withQueryItem(imagePipelineArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImagePipelineInput>
    public typealias MOutput = OperationOutput<DeleteImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImagePipelineOutputError>
}

public struct DeleteImagePipelineInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image pipeline to delete.</p>
    public let imagePipelineArn: String?

    public init (
        imagePipelineArn: String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

struct DeleteImagePipelineInputBody: Equatable {
}

extension DeleteImagePipelineInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteImagePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImagePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImagePipelineOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImagePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImagePipelineOutputResponse(imagePipelineArn: \(String(describing: imagePipelineArn)), requestId: \(String(describing: requestId)))"}
}

extension DeleteImagePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImagePipelineOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that was deleted.</p>
    public let imagePipelineArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imagePipelineArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct DeleteImagePipelineOutputResponseBody: Equatable {
    public let requestId: String?
    public let imagePipelineArn: String?
}

extension DeleteImagePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

extension DeleteImageRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImageRecipeInput(imageRecipeArn: \(String(describing: imageRecipeArn)))"}
}

extension DeleteImageRecipeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteImageRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteImageRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageRecipeInput>
    public typealias MOutput = OperationOutput<DeleteImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageRecipeOutputError>
}

public struct DeleteImageRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteImageRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteImageRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageRecipeArn = input.operationInput.imageRecipeArn {
            let imageRecipeArnQueryItem = URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: String(imageRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(imageRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteImageRecipeInput>
    public typealias MOutput = OperationOutput<DeleteImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteImageRecipeOutputError>
}

public struct DeleteImageRecipeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image recipe to delete.</p>
    public let imageRecipeArn: String?

    public init (
        imageRecipeArn: String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct DeleteImageRecipeInputBody: Equatable {
}

extension DeleteImageRecipeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteImageRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageRecipeOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteImageRecipeOutputResponse(imageRecipeArn: \(String(describing: imageRecipeArn)), requestId: \(String(describing: requestId)))"}
}

extension DeleteImageRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImageRecipeOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image recipe that was deleted.</p>
    public let imageRecipeArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageRecipeArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct DeleteImageRecipeOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageRecipeArn: String?
}

extension DeleteImageRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

extension DeleteInfrastructureConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInfrastructureConfigurationInput(infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)))"}
}

extension DeleteInfrastructureConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteInfrastructureConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInfrastructureConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInfrastructureConfigurationOutputError>
}

public struct DeleteInfrastructureConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInfrastructureConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let infrastructureConfigurationArn = input.operationInput.infrastructureConfigurationArn {
            let infrastructureConfigurationArnQueryItem = URLQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: String(infrastructureConfigurationArn).urlPercentEncoding())
            input.builder.withQueryItem(infrastructureConfigurationArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInfrastructureConfigurationOutputError>
}

public struct DeleteInfrastructureConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration to delete.</p>
    public let infrastructureConfigurationArn: String?

    public init (
        infrastructureConfigurationArn: String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

struct DeleteInfrastructureConfigurationInputBody: Equatable {
}

extension DeleteInfrastructureConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteInfrastructureConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInfrastructureConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInfrastructureConfigurationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInfrastructureConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInfrastructureConfigurationOutputResponse(infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)), requestId: \(String(describing: requestId)))"}
}

extension DeleteInfrastructureConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteInfrastructureConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that was deleted.</p>
    public let infrastructureConfigurationArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        infrastructureConfigurationArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct DeleteInfrastructureConfigurationOutputResponseBody: Equatable {
    public let requestId: String?
    public let infrastructureConfigurationArn: String?
}

extension DeleteInfrastructureConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

extension Distribution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiDistributionConfiguration
        case containerDistributionConfiguration
        case launchTemplateConfigurations
        case licenseConfigurationArns
        case region
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiDistributionConfiguration = amiDistributionConfiguration {
            try encodeContainer.encode(amiDistributionConfiguration, forKey: .amiDistributionConfiguration)
        }
        if let containerDistributionConfiguration = containerDistributionConfiguration {
            try encodeContainer.encode(containerDistributionConfiguration, forKey: .containerDistributionConfiguration)
        }
        if let launchTemplateConfigurations = launchTemplateConfigurations {
            var launchTemplateConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchTemplateConfigurations)
            for launchtemplateconfigurationlist0 in launchTemplateConfigurations {
                try launchTemplateConfigurationsContainer.encode(launchtemplateconfigurationlist0)
            }
        }
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for licenseconfigurationarnlist0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(licenseconfigurationarnlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let amiDistributionConfigurationDecoded = try containerValues.decodeIfPresent(AmiDistributionConfiguration.self, forKey: .amiDistributionConfiguration)
        amiDistributionConfiguration = amiDistributionConfigurationDecoded
        let containerDistributionConfigurationDecoded = try containerValues.decodeIfPresent(ContainerDistributionConfiguration.self, forKey: .containerDistributionConfiguration)
        containerDistributionConfiguration = containerDistributionConfigurationDecoded
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
        let launchTemplateConfigurationsContainer = try containerValues.decodeIfPresent([LaunchTemplateConfiguration?].self, forKey: .launchTemplateConfigurations)
        var launchTemplateConfigurationsDecoded0:[LaunchTemplateConfiguration]? = nil
        if let launchTemplateConfigurationsContainer = launchTemplateConfigurationsContainer {
            launchTemplateConfigurationsDecoded0 = [LaunchTemplateConfiguration]()
            for structure0 in launchTemplateConfigurationsContainer {
                if let structure0 = structure0 {
                    launchTemplateConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        launchTemplateConfigurations = launchTemplateConfigurationsDecoded0
    }
}

extension Distribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Distribution(amiDistributionConfiguration: \(String(describing: amiDistributionConfiguration)), containerDistributionConfiguration: \(String(describing: containerDistributionConfiguration)), launchTemplateConfigurations: \(String(describing: launchTemplateConfigurations)), licenseConfigurationArns: \(String(describing: licenseConfigurationArns)), region: \(String(describing: region)))"}
}

/// <p> Defines the settings for a specific Region.</p>
public struct Distribution: Equatable {
    /// <p>The specific AMI settings; for example, launch permissions or AMI tags.</p>
    public let amiDistributionConfiguration: AmiDistributionConfiguration?
    /// <p>Container distribution settings for encryption, licensing, and sharing
    ///       in a specific Region.</p>
    public let containerDistributionConfiguration: ContainerDistributionConfiguration?
    /// <p>A group of launchTemplateConfiguration settings that apply to image distribution
    ///       for specified accounts.</p>
    public let launchTemplateConfigurations: [LaunchTemplateConfiguration]?
    /// <p>The License Manager Configuration to associate with the AMI in the specified
    ///       Region.</p>
    public let licenseConfigurationArns: [String]?
    /// <p>The target Region.</p>
    public let region: String?

    public init (
        amiDistributionConfiguration: AmiDistributionConfiguration? = nil,
        containerDistributionConfiguration: ContainerDistributionConfiguration? = nil,
        launchTemplateConfigurations: [LaunchTemplateConfiguration]? = nil,
        licenseConfigurationArns: [String]? = nil,
        region: String? = nil
    )
    {
        self.amiDistributionConfiguration = amiDistributionConfiguration
        self.containerDistributionConfiguration = containerDistributionConfiguration
        self.launchTemplateConfigurations = launchTemplateConfigurations
        self.licenseConfigurationArns = licenseConfigurationArns
        self.region = region
    }
}

extension DistributionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case distributions
        case name
        case tags
        case timeoutMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distributionlist0 in distributions {
                try distributionsContainer.encode(distributionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeoutMinutes = timeoutMinutes {
            try encodeContainer.encode(timeoutMinutes, forKey: .timeoutMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let timeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutMinutes)
        timeoutMinutes = timeoutMinutesDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DistributionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionConfiguration(arn: \(String(describing: arn)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), distributions: \(String(describing: distributions)), name: \(String(describing: name)), tags: \(String(describing: tags)), timeoutMinutes: \(String(describing: timeoutMinutes)))"}
}

/// <p>A distribution configuration.</p>
public struct DistributionConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration.</p>
    public let arn: String?
    /// <p>The date on which this distribution configuration was created.</p>
    public let dateCreated: String?
    /// <p>The date on which this distribution configuration was last updated.</p>
    public let dateUpdated: String?
    /// <p>The description of the distribution configuration.</p>
    public let description: String?
    /// <p>The distribution objects that apply Region-specific
    ///       settings for the deployment of the image to targeted Regions.</p>
    public let distributions: [Distribution]?
    /// <p>The name of the distribution configuration.</p>
    public let name: String?
    /// <p>The tags of the distribution configuration.</p>
    public let tags: [String:String]?
    /// <p>The maximum duration in minutes for this distribution configuration.</p>
    public let timeoutMinutes: Int?

    public init (
        arn: String? = nil,
        dateCreated: String? = nil,
        dateUpdated: String? = nil,
        description: String? = nil,
        distributions: [Distribution]? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        timeoutMinutes: Int? = nil
    )
    {
        self.arn = arn
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.distributions = distributions
        self.name = name
        self.tags = tags
        self.timeoutMinutes = timeoutMinutes
    }
}

extension DistributionConfigurationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case name
        case regions
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regionlist0 in regions {
                try regionsContainer.encode(regionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .regions)
        var regionsDecoded0:[String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension DistributionConfigurationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionConfigurationSummary(arn: \(String(describing: arn)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), name: \(String(describing: name)), regions: \(String(describing: regions)), tags: \(String(describing: tags)))"}
}

/// <p>A high-level overview of a distribution configuration.</p>
public struct DistributionConfigurationSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration.</p>
    public let arn: String?
    /// <p>The date on which the distribution configuration was created.</p>
    public let dateCreated: String?
    /// <p>The date on which the distribution configuration was updated.</p>
    public let dateUpdated: String?
    /// <p>The description of the distribution configuration.</p>
    public let description: String?
    /// <p>The name of the distribution configuration.</p>
    public let name: String?
    /// <p>A list of Regions where the container image is distributed to.</p>
    public let regions: [String]?
    /// <p>The tags associated with the distribution configuration.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dateCreated: String? = nil,
        dateUpdated: String? = nil,
        description: String? = nil,
        name: String? = nil,
        regions: [String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.name = name
        self.regions = regions
        self.tags = tags
    }
}

extension EbsInstanceBlockDeviceSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteOnTermination
        case encrypted
        case iops
        case kmsKeyId
        case snapshotId
        case volumeSize
        case volumeType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteOnTermination = deleteOnTermination {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let volumeSize = volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .iops)
        iops = iopsDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(EbsVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
    }
}

extension EbsInstanceBlockDeviceSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EbsInstanceBlockDeviceSpecification(deleteOnTermination: \(String(describing: deleteOnTermination)), encrypted: \(String(describing: encrypted)), iops: \(String(describing: iops)), kmsKeyId: \(String(describing: kmsKeyId)), snapshotId: \(String(describing: snapshotId)), volumeSize: \(String(describing: volumeSize)), volumeType: \(String(describing: volumeType)))"}
}

/// <p>Amazon EBS-specific block device mapping specifications.</p>
public struct EbsInstanceBlockDeviceSpecification: Equatable {
    /// <p>Use to configure delete on termination of the associated device.</p>
    public let deleteOnTermination: Bool?
    /// <p>Use to configure device encryption.</p>
    public let encrypted: Bool?
    /// <p>Use to configure device IOPS.</p>
    public let iops: Int?
    /// <p>Use to configure the KMS key to use when encrypting the device.</p>
    public let kmsKeyId: String?
    /// <p>The snapshot that defines the device contents.</p>
    public let snapshotId: String?
    /// <p>Use to override the device's volume size.</p>
    public let volumeSize: Int?
    /// <p>Use to override the device's volume type.</p>
    public let volumeType: EbsVolumeType?

    public init (
        deleteOnTermination: Bool? = nil,
        encrypted: Bool? = nil,
        iops: Int? = nil,
        kmsKeyId: String? = nil,
        snapshotId: String? = nil,
        volumeSize: Int? = nil,
        volumeType: EbsVolumeType? = nil
    )
    {
        self.deleteOnTermination = deleteOnTermination
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.snapshotId = snapshotId
        self.volumeSize = volumeSize
        self.volumeType = volumeType
    }
}

public enum EbsVolumeType {
    case gp2
    case gp3
    case io1
    case io2
    case sc1
    case st1
    case standard
    case sdkUnknown(String)
}

extension EbsVolumeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EbsVolumeType] {
        return [
            .gp2,
            .gp3,
            .io1,
            .io2,
            .sc1,
            .st1,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gp2: return "gp2"
        case .gp3: return "gp3"
        case .io1: return "io1"
        case .io2: return "io2"
        case .sc1: return "sc1"
        case .st1: return "st1"
        case .standard: return "standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EbsVolumeType(rawValue: rawValue) ?? EbsVolumeType.sdkUnknown(rawValue)
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>A filter name and value pair that is used to return a more specific list of results from a
///       list operation. Filters can be used to match a set of resources by specific criteria, such as
///       tags, attributes, or IDs.</p>
public struct Filter: Equatable {
    /// <p>The name of the filter. Filter names are case-sensitive.</p>
    public let name: String?
    /// <p>The filter values. Filter values are case-sensitive.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to perform the requested operation.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComponentInput(componentBuildVersionArn: \(String(describing: componentBuildVersionArn)))"}
}

extension GetComponentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetComponentInputHeadersMiddleware: Middleware {
    public let id: String = "GetComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComponentInput>
    public typealias MOutput = OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComponentOutputError>
}

public struct GetComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let componentBuildVersionArn = input.operationInput.componentBuildVersionArn {
            let componentBuildVersionArnQueryItem = URLQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: String(componentBuildVersionArn).urlPercentEncoding())
            input.builder.withQueryItem(componentBuildVersionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComponentInput>
    public typealias MOutput = OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComponentOutputError>
}

public struct GetComponentInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component that you want to retrieve. Regex requires
    ///       "/\d+$" suffix.</p>
    public let componentBuildVersionArn: String?

    public init (
        componentBuildVersionArn: String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

struct GetComponentInputBody: Equatable {
}

extension GetComponentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComponentOutputResponse(component: \(String(describing: component)), requestId: \(String(describing: requestId)))"}
}

extension GetComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetComponentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.component = output.component
            self.requestId = output.requestId
        } else {
            self.component = nil
            self.requestId = nil
        }
    }
}

public struct GetComponentOutputResponse: Equatable {
    /// <p>The component object associated with the specified ARN.</p>
    public let component: Component?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        component: Component? = nil,
        requestId: String? = nil
    )
    {
        self.component = component
        self.requestId = requestId
    }
}

struct GetComponentOutputResponseBody: Equatable {
    public let requestId: String?
    public let component: Component?
}

extension GetComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case component
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentDecoded = try containerValues.decodeIfPresent(Component.self, forKey: .component)
        component = componentDecoded
    }
}

extension GetComponentPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComponentPolicyInput(componentArn: \(String(describing: componentArn)))"}
}

extension GetComponentPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetComponentPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetComponentPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComponentPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComponentPolicyInput>
    public typealias MOutput = OperationOutput<GetComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComponentPolicyOutputError>
}

public struct GetComponentPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetComponentPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetComponentPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let componentArn = input.operationInput.componentArn {
            let componentArnQueryItem = URLQueryItem(name: "componentArn".urlPercentEncoding(), value: String(componentArn).urlPercentEncoding())
            input.builder.withQueryItem(componentArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetComponentPolicyInput>
    public typealias MOutput = OperationOutput<GetComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetComponentPolicyOutputError>
}

public struct GetComponentPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component whose policy you want to retrieve.</p>
    public let componentArn: String?

    public init (
        componentArn: String? = nil
    )
    {
        self.componentArn = componentArn
    }
}

struct GetComponentPolicyInputBody: Equatable {
}

extension GetComponentPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetComponentPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentPolicyOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetComponentPolicyOutputResponse(policy: \(String(describing: policy)), requestId: \(String(describing: requestId)))"}
}

extension GetComponentPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetComponentPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetComponentPolicyOutputResponse: Equatable {
    /// <p>The component policy.</p>
    public let policy: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        policy: String? = nil,
        requestId: String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetComponentPolicyOutputResponseBody: Equatable {
    public let requestId: String?
    public let policy: String?
}

extension GetComponentPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetContainerRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContainerRecipeInput(containerRecipeArn: \(String(describing: containerRecipeArn)))"}
}

extension GetContainerRecipeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetContainerRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "GetContainerRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContainerRecipeInput>
    public typealias MOutput = OperationOutput<GetContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContainerRecipeOutputError>
}

public struct GetContainerRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContainerRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContainerRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let containerRecipeArn = input.operationInput.containerRecipeArn {
            let containerRecipeArnQueryItem = URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: String(containerRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(containerRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContainerRecipeInput>
    public typealias MOutput = OperationOutput<GetContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContainerRecipeOutputError>
}

public struct GetContainerRecipeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container recipe to retrieve.</p>
    public let containerRecipeArn: String?

    public init (
        containerRecipeArn: String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct GetContainerRecipeInputBody: Equatable {
}

extension GetContainerRecipeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetContainerRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContainerRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContainerRecipeOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContainerRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContainerRecipeOutputResponse(containerRecipe: \(String(describing: containerRecipe)), requestId: \(String(describing: requestId)))"}
}

extension GetContainerRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.containerRecipe = output.containerRecipe
            self.requestId = output.requestId
        } else {
            self.containerRecipe = nil
            self.requestId = nil
        }
    }
}

public struct GetContainerRecipeOutputResponse: Equatable {
    /// <p>The container recipe object that is returned.</p>
    public let containerRecipe: ContainerRecipe?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        containerRecipe: ContainerRecipe? = nil,
        requestId: String? = nil
    )
    {
        self.containerRecipe = containerRecipe
        self.requestId = requestId
    }
}

struct GetContainerRecipeOutputResponseBody: Equatable {
    public let requestId: String?
    public let containerRecipe: ContainerRecipe?
}

extension GetContainerRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerRecipe
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeDecoded = try containerValues.decodeIfPresent(ContainerRecipe.self, forKey: .containerRecipe)
        containerRecipe = containerRecipeDecoded
    }
}

extension GetContainerRecipePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContainerRecipePolicyInput(containerRecipeArn: \(String(describing: containerRecipeArn)))"}
}

extension GetContainerRecipePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetContainerRecipePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetContainerRecipePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContainerRecipePolicyInput>
    public typealias MOutput = OperationOutput<GetContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContainerRecipePolicyOutputError>
}

public struct GetContainerRecipePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetContainerRecipePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let containerRecipeArn = input.operationInput.containerRecipeArn {
            let containerRecipeArnQueryItem = URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: String(containerRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(containerRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetContainerRecipePolicyInput>
    public typealias MOutput = OperationOutput<GetContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetContainerRecipePolicyOutputError>
}

public struct GetContainerRecipePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container recipe for the policy being requested.</p>
    public let containerRecipeArn: String?

    public init (
        containerRecipeArn: String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct GetContainerRecipePolicyInputBody: Equatable {
}

extension GetContainerRecipePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetContainerRecipePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContainerRecipePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContainerRecipePolicyOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContainerRecipePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetContainerRecipePolicyOutputResponse(policy: \(String(describing: policy)), requestId: \(String(describing: requestId)))"}
}

extension GetContainerRecipePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetContainerRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetContainerRecipePolicyOutputResponse: Equatable {
    /// <p>The container recipe policy object that is returned.</p>
    public let policy: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        policy: String? = nil,
        requestId: String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetContainerRecipePolicyOutputResponseBody: Equatable {
    public let requestId: String?
    public let policy: String?
}

extension GetContainerRecipePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetDistributionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDistributionConfigurationInput(distributionConfigurationArn: \(String(describing: distributionConfigurationArn)))"}
}

extension GetDistributionConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDistributionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetDistributionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<GetDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDistributionConfigurationOutputError>
}

public struct GetDistributionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDistributionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfigurationArn = input.operationInput.distributionConfigurationArn {
            let distributionConfigurationArnQueryItem = URLQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: String(distributionConfigurationArn).urlPercentEncoding())
            input.builder.withQueryItem(distributionConfigurationArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<GetDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDistributionConfigurationOutputError>
}

public struct GetDistributionConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration that you want to
    ///       retrieve.</p>
    public let distributionConfigurationArn: String?

    public init (
        distributionConfigurationArn: String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

struct GetDistributionConfigurationInputBody: Equatable {
}

extension GetDistributionConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDistributionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDistributionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionConfigurationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDistributionConfigurationOutputResponse(distributionConfiguration: \(String(describing: distributionConfiguration)), requestId: \(String(describing: requestId)))"}
}

extension GetDistributionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.distributionConfiguration = output.distributionConfiguration
            self.requestId = output.requestId
        } else {
            self.distributionConfiguration = nil
            self.requestId = nil
        }
    }
}

public struct GetDistributionConfigurationOutputResponse: Equatable {
    /// <p>The distribution configuration object.</p>
    public let distributionConfiguration: DistributionConfiguration?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        distributionConfiguration: DistributionConfiguration? = nil,
        requestId: String? = nil
    )
    {
        self.distributionConfiguration = distributionConfiguration
        self.requestId = requestId
    }
}

struct GetDistributionConfigurationOutputResponseBody: Equatable {
    public let requestId: String?
    public let distributionConfiguration: DistributionConfiguration?
}

extension GetDistributionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionConfiguration
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationDecoded = try containerValues.decodeIfPresent(DistributionConfiguration.self, forKey: .distributionConfiguration)
        distributionConfiguration = distributionConfigurationDecoded
    }
}

extension GetImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImageInput(imageBuildVersionArn: \(String(describing: imageBuildVersionArn)))"}
}

extension GetImageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetImageInputHeadersMiddleware: Middleware {
    public let id: String = "GetImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImageInput>
    public typealias MOutput = OperationOutput<GetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImageOutputError>
}

public struct GetImageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageBuildVersionArn = input.operationInput.imageBuildVersionArn {
            let imageBuildVersionArnQueryItem = URLQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: String(imageBuildVersionArn).urlPercentEncoding())
            input.builder.withQueryItem(imageBuildVersionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImageInput>
    public typealias MOutput = OperationOutput<GetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImageOutputError>
}

public struct GetImageInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image that you want to retrieve.</p>
    public let imageBuildVersionArn: String?

    public init (
        imageBuildVersionArn: String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct GetImageInputBody: Equatable {
}

extension GetImageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImageOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImageOutputResponse(image: \(String(describing: image)), requestId: \(String(describing: requestId)))"}
}

extension GetImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.image = output.image
            self.requestId = output.requestId
        } else {
            self.image = nil
            self.requestId = nil
        }
    }
}

public struct GetImageOutputResponse: Equatable {
    /// <p>The image object.</p>
    public let image: Image?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        image: Image? = nil,
        requestId: String? = nil
    )
    {
        self.image = image
        self.requestId = requestId
    }
}

struct GetImageOutputResponseBody: Equatable {
    public let requestId: String?
    public let image: Image?
}

extension GetImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case image
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Image.self, forKey: .image)
        image = imageDecoded
    }
}

extension GetImagePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImagePipelineInput(imagePipelineArn: \(String(describing: imagePipelineArn)))"}
}

extension GetImagePipelineInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetImagePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "GetImagePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImagePipelineInput>
    public typealias MOutput = OperationOutput<GetImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImagePipelineOutputError>
}

public struct GetImagePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "GetImagePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imagePipelineArn = input.operationInput.imagePipelineArn {
            let imagePipelineArnQueryItem = URLQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: String(imagePipelineArn).urlPercentEncoding())
            input.builder.withQueryItem(imagePipelineArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImagePipelineInput>
    public typealias MOutput = OperationOutput<GetImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImagePipelineOutputError>
}

public struct GetImagePipelineInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.</p>
    public let imagePipelineArn: String?

    public init (
        imagePipelineArn: String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

struct GetImagePipelineInputBody: Equatable {
}

extension GetImagePipelineInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetImagePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImagePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImagePipelineOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImagePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImagePipelineOutputResponse(imagePipeline: \(String(describing: imagePipeline)), requestId: \(String(describing: requestId)))"}
}

extension GetImagePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imagePipeline = output.imagePipeline
            self.requestId = output.requestId
        } else {
            self.imagePipeline = nil
            self.requestId = nil
        }
    }
}

public struct GetImagePipelineOutputResponse: Equatable {
    /// <p>The image pipeline object.</p>
    public let imagePipeline: ImagePipeline?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imagePipeline: ImagePipeline? = nil,
        requestId: String? = nil
    )
    {
        self.imagePipeline = imagePipeline
        self.requestId = requestId
    }
}

struct GetImagePipelineOutputResponseBody: Equatable {
    public let requestId: String?
    public let imagePipeline: ImagePipeline?
}

extension GetImagePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imagePipeline
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineDecoded = try containerValues.decodeIfPresent(ImagePipeline.self, forKey: .imagePipeline)
        imagePipeline = imagePipelineDecoded
    }
}

extension GetImagePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImagePolicyInput(imageArn: \(String(describing: imageArn)))"}
}

extension GetImagePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetImagePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetImagePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImagePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImagePolicyInput>
    public typealias MOutput = OperationOutput<GetImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImagePolicyOutputError>
}

public struct GetImagePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetImagePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImagePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageArn = input.operationInput.imageArn {
            let imageArnQueryItem = URLQueryItem(name: "imageArn".urlPercentEncoding(), value: String(imageArn).urlPercentEncoding())
            input.builder.withQueryItem(imageArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImagePolicyInput>
    public typealias MOutput = OperationOutput<GetImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImagePolicyOutputError>
}

public struct GetImagePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.</p>
    public let imageArn: String?

    public init (
        imageArn: String? = nil
    )
    {
        self.imageArn = imageArn
    }
}

struct GetImagePolicyInputBody: Equatable {
}

extension GetImagePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetImagePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImagePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImagePolicyOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImagePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImagePolicyOutputResponse(policy: \(String(describing: policy)), requestId: \(String(describing: requestId)))"}
}

extension GetImagePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetImagePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetImagePolicyOutputResponse: Equatable {
    /// <p>The image policy object.</p>
    public let policy: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        policy: String? = nil,
        requestId: String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetImagePolicyOutputResponseBody: Equatable {
    public let requestId: String?
    public let policy: String?
}

extension GetImagePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetImageRecipeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImageRecipeInput(imageRecipeArn: \(String(describing: imageRecipeArn)))"}
}

extension GetImageRecipeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetImageRecipeInputHeadersMiddleware: Middleware {
    public let id: String = "GetImageRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImageRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImageRecipeInput>
    public typealias MOutput = OperationOutput<GetImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImageRecipeOutputError>
}

public struct GetImageRecipeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetImageRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImageRecipeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageRecipeArn = input.operationInput.imageRecipeArn {
            let imageRecipeArnQueryItem = URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: String(imageRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(imageRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImageRecipeInput>
    public typealias MOutput = OperationOutput<GetImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImageRecipeOutputError>
}

public struct GetImageRecipeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.</p>
    public let imageRecipeArn: String?

    public init (
        imageRecipeArn: String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct GetImageRecipeInputBody: Equatable {
}

extension GetImageRecipeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetImageRecipeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageRecipeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImageRecipeOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageRecipeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImageRecipeOutputResponse(imageRecipe: \(String(describing: imageRecipe)), requestId: \(String(describing: requestId)))"}
}

extension GetImageRecipeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageRecipe = output.imageRecipe
            self.requestId = output.requestId
        } else {
            self.imageRecipe = nil
            self.requestId = nil
        }
    }
}

public struct GetImageRecipeOutputResponse: Equatable {
    /// <p>The image recipe object.</p>
    public let imageRecipe: ImageRecipe?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageRecipe: ImageRecipe? = nil,
        requestId: String? = nil
    )
    {
        self.imageRecipe = imageRecipe
        self.requestId = requestId
    }
}

struct GetImageRecipeOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageRecipe: ImageRecipe?
}

extension GetImageRecipeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageRecipe
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeDecoded = try containerValues.decodeIfPresent(ImageRecipe.self, forKey: .imageRecipe)
        imageRecipe = imageRecipeDecoded
    }
}

extension GetImageRecipePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImageRecipePolicyInput(imageRecipeArn: \(String(describing: imageRecipeArn)))"}
}

extension GetImageRecipePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetImageRecipePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetImageRecipePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImageRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImageRecipePolicyInput>
    public typealias MOutput = OperationOutput<GetImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImageRecipePolicyOutputError>
}

public struct GetImageRecipePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetImageRecipePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImageRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageRecipeArn = input.operationInput.imageRecipeArn {
            let imageRecipeArnQueryItem = URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: String(imageRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(imageRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImageRecipePolicyInput>
    public typealias MOutput = OperationOutput<GetImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImageRecipePolicyOutputError>
}

public struct GetImageRecipePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve.</p>
    public let imageRecipeArn: String?

    public init (
        imageRecipeArn: String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct GetImageRecipePolicyInputBody: Equatable {
}

extension GetImageRecipePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetImageRecipePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageRecipePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImageRecipePolicyOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageRecipePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImageRecipePolicyOutputResponse(policy: \(String(describing: policy)), requestId: \(String(describing: requestId)))"}
}

extension GetImageRecipePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetImageRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetImageRecipePolicyOutputResponse: Equatable {
    /// <p>The image recipe policy object.</p>
    public let policy: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        policy: String? = nil,
        requestId: String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetImageRecipePolicyOutputResponseBody: Equatable {
    public let requestId: String?
    public let policy: String?
}

extension GetImageRecipePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetInfrastructureConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInfrastructureConfigurationInput(infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)))"}
}

extension GetInfrastructureConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetInfrastructureConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetInfrastructureConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<GetInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInfrastructureConfigurationOutputError>
}

public struct GetInfrastructureConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInfrastructureConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let infrastructureConfigurationArn = input.operationInput.infrastructureConfigurationArn {
            let infrastructureConfigurationArnQueryItem = URLQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: String(infrastructureConfigurationArn).urlPercentEncoding())
            input.builder.withQueryItem(infrastructureConfigurationArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<GetInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInfrastructureConfigurationOutputError>
}

/// <p> GetInfrastructureConfiguration request object.</p>
public struct GetInfrastructureConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
    ///       retrieve.</p>
    public let infrastructureConfigurationArn: String?

    public init (
        infrastructureConfigurationArn: String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

struct GetInfrastructureConfigurationInputBody: Equatable {
}

extension GetInfrastructureConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetInfrastructureConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInfrastructureConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInfrastructureConfigurationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInfrastructureConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInfrastructureConfigurationOutputResponse(infrastructureConfiguration: \(String(describing: infrastructureConfiguration)), requestId: \(String(describing: requestId)))"}
}

extension GetInfrastructureConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.infrastructureConfiguration = output.infrastructureConfiguration
            self.requestId = output.requestId
        } else {
            self.infrastructureConfiguration = nil
            self.requestId = nil
        }
    }
}

/// <p>GetInfrastructureConfiguration response object.</p>
public struct GetInfrastructureConfigurationOutputResponse: Equatable {
    /// <p>The infrastructure configuration object.</p>
    public let infrastructureConfiguration: InfrastructureConfiguration?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        infrastructureConfiguration: InfrastructureConfiguration? = nil,
        requestId: String? = nil
    )
    {
        self.infrastructureConfiguration = infrastructureConfiguration
        self.requestId = requestId
    }
}

struct GetInfrastructureConfigurationOutputResponseBody: Equatable {
    public let requestId: String?
    public let infrastructureConfiguration: InfrastructureConfiguration?
}

extension GetInfrastructureConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case infrastructureConfiguration
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationDecoded = try containerValues.decodeIfPresent(InfrastructureConfiguration.self, forKey: .infrastructureConfiguration)
        infrastructureConfiguration = infrastructureConfigurationDecoded
    }
}

extension IdempotentParameterMismatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdempotentParameterMismatchException(message: \(String(describing: message)))"}
}

extension IdempotentParameterMismatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified a client token for an operation using parameter values that differ from
///       a previous request that used the same client token.</p>
public struct IdempotentParameterMismatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Equatable {
    public let message: String?
}

extension IdempotentParameterMismatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Image: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case containerRecipe
        case dateCreated
        case distributionConfiguration
        case enhancedImageMetadataEnabled
        case imageRecipe
        case imageTestsConfiguration
        case infrastructureConfiguration
        case name
        case osVersion
        case outputResources
        case platform
        case sourcePipelineArn
        case sourcePipelineName
        case state
        case tags
        case type
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerRecipe = containerRecipe {
            try encodeContainer.encode(containerRecipe, forKey: .containerRecipe)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let distributionConfiguration = distributionConfiguration {
            try encodeContainer.encode(distributionConfiguration, forKey: .distributionConfiguration)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipe = imageRecipe {
            try encodeContainer.encode(imageRecipe, forKey: .imageRecipe)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfiguration = infrastructureConfiguration {
            try encodeContainer.encode(infrastructureConfiguration, forKey: .infrastructureConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let outputResources = outputResources {
            try encodeContainer.encode(outputResources, forKey: .outputResources)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let sourcePipelineArn = sourcePipelineArn {
            try encodeContainer.encode(sourcePipelineArn, forKey: .sourcePipelineArn)
        }
        if let sourcePipelineName = sourcePipelineName {
            try encodeContainer.encode(sourcePipelineName, forKey: .sourcePipelineName)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImageType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImageState.self, forKey: .state)
        state = stateDecoded
        let imageRecipeDecoded = try containerValues.decodeIfPresent(ImageRecipe.self, forKey: .imageRecipe)
        imageRecipe = imageRecipeDecoded
        let containerRecipeDecoded = try containerValues.decodeIfPresent(ContainerRecipe.self, forKey: .containerRecipe)
        containerRecipe = containerRecipeDecoded
        let sourcePipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePipelineName)
        sourcePipelineName = sourcePipelineNameDecoded
        let sourcePipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePipelineArn)
        sourcePipelineArn = sourcePipelineArnDecoded
        let infrastructureConfigurationDecoded = try containerValues.decodeIfPresent(InfrastructureConfiguration.self, forKey: .infrastructureConfiguration)
        infrastructureConfiguration = infrastructureConfigurationDecoded
        let distributionConfigurationDecoded = try containerValues.decodeIfPresent(DistributionConfiguration.self, forKey: .distributionConfiguration)
        distributionConfiguration = distributionConfigurationDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let outputResourcesDecoded = try containerValues.decodeIfPresent(OutputResources.self, forKey: .outputResources)
        outputResources = outputResourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Image: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Image(arn: \(String(describing: arn)), containerRecipe: \(String(describing: containerRecipe)), dateCreated: \(String(describing: dateCreated)), distributionConfiguration: \(String(describing: distributionConfiguration)), enhancedImageMetadataEnabled: \(String(describing: enhancedImageMetadataEnabled)), imageRecipe: \(String(describing: imageRecipe)), imageTestsConfiguration: \(String(describing: imageTestsConfiguration)), infrastructureConfiguration: \(String(describing: infrastructureConfiguration)), name: \(String(describing: name)), osVersion: \(String(describing: osVersion)), outputResources: \(String(describing: outputResources)), platform: \(String(describing: platform)), sourcePipelineArn: \(String(describing: sourcePipelineArn)), sourcePipelineName: \(String(describing: sourcePipelineName)), state: \(String(describing: state)), tags: \(String(describing: tags)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>An image build version.</p>
public struct Image: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image.</p>
    public let arn: String?
    /// <p>The container recipe used to create the container image type.</p>
    public let containerRecipe: ContainerRecipe?
    /// <p>The date on which this image was created.</p>
    public let dateCreated: String?
    /// <p>The distribution configuration used when creating this image.</p>
    public let distributionConfiguration: DistributionConfiguration?
    /// <p> Collects additional information about the image being created, including the operating
    ///       system (OS) version and package list. This information is used to enhance the overall
    ///       experience of using EC2 Image Builder. Enabled by default.</p>
    public let enhancedImageMetadataEnabled: Bool?
    /// <p>The image recipe used when creating the image.</p>
    public let imageRecipe: ImageRecipe?
    /// <p>The image tests configuration used when creating this image.</p>
    public let imageTestsConfiguration: ImageTestsConfiguration?
    /// <p>The infrastructure used when creating this image.</p>
    public let infrastructureConfiguration: InfrastructureConfiguration?
    /// <p>The name of the image.</p>
    public let name: String?
    /// <p>The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or
    ///       Microsoft Windows Server 2019.</p>
    public let osVersion: String?
    /// <p>The output resources produced when creating this image.</p>
    public let outputResources: OutputResources?
    /// <p>The platform of the image.</p>
    public let platform: Platform?
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that created this image.</p>
    public let sourcePipelineArn: String?
    /// <p>The name of the image pipeline that created this image.</p>
    public let sourcePipelineName: String?
    /// <p>The state of the image.</p>
    public let state: ImageState?
    /// <p>The tags of the image.</p>
    public let tags: [String:String]?
    /// <p>Specifies whether this is an AMI or container image.</p>
    public let type: ImageType?
    /// <p>The semantic version of the image.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        containerRecipe: ContainerRecipe? = nil,
        dateCreated: String? = nil,
        distributionConfiguration: DistributionConfiguration? = nil,
        enhancedImageMetadataEnabled: Bool? = nil,
        imageRecipe: ImageRecipe? = nil,
        imageTestsConfiguration: ImageTestsConfiguration? = nil,
        infrastructureConfiguration: InfrastructureConfiguration? = nil,
        name: String? = nil,
        osVersion: String? = nil,
        outputResources: OutputResources? = nil,
        platform: Platform? = nil,
        sourcePipelineArn: String? = nil,
        sourcePipelineName: String? = nil,
        state: ImageState? = nil,
        tags: [String:String]? = nil,
        type: ImageType? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.containerRecipe = containerRecipe
        self.dateCreated = dateCreated
        self.distributionConfiguration = distributionConfiguration
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipe = imageRecipe
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfiguration = infrastructureConfiguration
        self.name = name
        self.osVersion = osVersion
        self.outputResources = outputResources
        self.platform = platform
        self.sourcePipelineArn = sourcePipelineArn
        self.sourcePipelineName = sourcePipelineName
        self.state = state
        self.tags = tags
        self.type = type
        self.version = version
    }
}

extension ImagePackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case packageName
        case packageVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageVersion = packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
    }
}

extension ImagePackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImagePackage(packageName: \(String(describing: packageName)), packageVersion: \(String(describing: packageVersion)))"}
}

/// <p>Represents a package installed on an Image Builder image.</p>
public struct ImagePackage: Equatable {
    /// <p>The name of the package as reported to the operating system package manager.</p>
    public let packageName: String?
    /// <p>The version of the package as reported to the operating system package manager.</p>
    public let packageVersion: String?

    public init (
        packageName: String? = nil,
        packageVersion: String? = nil
    )
    {
        self.packageName = packageName
        self.packageVersion = packageVersion
    }
}

extension ImagePipeline: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case containerRecipeArn
        case dateCreated
        case dateLastRun
        case dateNextRun
        case dateUpdated
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case platform
        case schedule
        case status
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateLastRun = dateLastRun {
            try encodeContainer.encode(dateLastRun, forKey: .dateLastRun)
        }
        if let dateNextRun = dateNextRun {
            try encodeContainer.encode(dateNextRun, forKey: .dateNextRun)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let dateLastRunDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateLastRun)
        dateLastRun = dateLastRunDecoded
        let dateNextRunDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateNextRun)
        dateNextRun = dateNextRunDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagePipeline: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImagePipeline(arn: \(String(describing: arn)), containerRecipeArn: \(String(describing: containerRecipeArn)), dateCreated: \(String(describing: dateCreated)), dateLastRun: \(String(describing: dateLastRun)), dateNextRun: \(String(describing: dateNextRun)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), distributionConfigurationArn: \(String(describing: distributionConfigurationArn)), enhancedImageMetadataEnabled: \(String(describing: enhancedImageMetadataEnabled)), imageRecipeArn: \(String(describing: imageRecipeArn)), imageTestsConfiguration: \(String(describing: imageTestsConfiguration)), infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)), name: \(String(describing: name)), platform: \(String(describing: platform)), schedule: \(String(describing: schedule)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

/// <p>Details of an image pipeline.</p>
public struct ImagePipeline: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image pipeline.</p>
    public let arn: String?
    /// <p>The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.</p>
    public let containerRecipeArn: String?
    /// <p>The date on which this image pipeline was created.</p>
    public let dateCreated: String?
    /// <p>The date on which this image pipeline was last run.</p>
    public let dateLastRun: String?
    /// <p>The date on which this image pipeline will next be run.</p>
    public let dateNextRun: String?
    /// <p>The date on which this image pipeline was last updated.</p>
    public let dateUpdated: String?
    /// <p>The description of the image pipeline.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration associated with this
    ///       image pipeline.</p>
    public let distributionConfigurationArn: String?
    /// <p> Collects additional information about the image being created, including the operating
    ///       system (OS) version and package list. This information is used to enhance the overall
    ///       experience of using EC2 Image Builder. Enabled by default.</p>
    public let enhancedImageMetadataEnabled: Bool?
    /// <p>The Amazon Resource Name (ARN) of the image recipe associated with this image
    ///       pipeline.</p>
    public let imageRecipeArn: String?
    /// <p>The image tests configuration of the image pipeline.</p>
    public let imageTestsConfiguration: ImageTestsConfiguration?
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration associated with this
    ///       image pipeline.</p>
    public let infrastructureConfigurationArn: String?
    /// <p>The name of the image pipeline.</p>
    public let name: String?
    /// <p>The platform of the image pipeline.</p>
    public let platform: Platform?
    /// <p>The schedule of the image pipeline.</p>
    public let schedule: Schedule?
    /// <p>The status of the image pipeline.</p>
    public let status: PipelineStatus?
    /// <p>The tags of this image pipeline.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        containerRecipeArn: String? = nil,
        dateCreated: String? = nil,
        dateLastRun: String? = nil,
        dateNextRun: String? = nil,
        dateUpdated: String? = nil,
        description: String? = nil,
        distributionConfigurationArn: String? = nil,
        enhancedImageMetadataEnabled: Bool? = nil,
        imageRecipeArn: String? = nil,
        imageTestsConfiguration: ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: String? = nil,
        name: String? = nil,
        platform: Platform? = nil,
        schedule: Schedule? = nil,
        status: PipelineStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.containerRecipeArn = containerRecipeArn
        self.dateCreated = dateCreated
        self.dateLastRun = dateLastRun
        self.dateNextRun = dateNextRun
        self.dateUpdated = dateUpdated
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.name = name
        self.platform = platform
        self.schedule = schedule
        self.status = status
        self.tags = tags
    }
}

extension ImageRecipe: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case blockDeviceMappings
        case components
        case dateCreated
        case description
        case name
        case owner
        case parentImage
        case platform
        case tags
        case type
        case version
        case workingDirectory
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemappings0)
            }
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImageType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let parentImageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
    }
}

extension ImageRecipe: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageRecipe(arn: \(String(describing: arn)), blockDeviceMappings: \(String(describing: blockDeviceMappings)), components: \(String(describing: components)), dateCreated: \(String(describing: dateCreated)), description: \(String(describing: description)), name: \(String(describing: name)), owner: \(String(describing: owner)), parentImage: \(String(describing: parentImage)), platform: \(String(describing: platform)), tags: \(String(describing: tags)), type: \(String(describing: type)), version: \(String(describing: version)), workingDirectory: \(String(describing: workingDirectory)))"}
}

/// <p>An image recipe.</p>
public struct ImageRecipe: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image recipe.</p>
    public let arn: String?
    /// <p>The block device mappings to apply when creating images from this recipe.</p>
    public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
    /// <p>The components of the image recipe.</p>
    public let components: [ComponentConfiguration]?
    /// <p>The date on which this image recipe was created.</p>
    public let dateCreated: String?
    /// <p>The description of the image recipe.</p>
    public let description: String?
    /// <p>The name of the image recipe.</p>
    public let name: String?
    /// <p>The owner of the image recipe.</p>
    public let owner: String?
    /// <p>The parent image of the image recipe.</p>
    public let parentImage: String?
    /// <p>The platform of the image recipe.</p>
    public let platform: Platform?
    /// <p>The tags of the image recipe.</p>
    public let tags: [String:String]?
    /// <p>Specifies which type of image is created by the recipe - an AMI or a container image.</p>
    public let type: ImageType?
    /// <p>The version of the image recipe.</p>
    public let version: String?
    /// <p>The working directory to be used during build and test workflows.</p>
    public let workingDirectory: String?

    public init (
        arn: String? = nil,
        blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil,
        components: [ComponentConfiguration]? = nil,
        dateCreated: String? = nil,
        description: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        parentImage: String? = nil,
        platform: Platform? = nil,
        tags: [String:String]? = nil,
        type: ImageType? = nil,
        version: String? = nil,
        workingDirectory: String? = nil
    )
    {
        self.arn = arn
        self.blockDeviceMappings = blockDeviceMappings
        self.components = components
        self.dateCreated = dateCreated
        self.description = description
        self.name = name
        self.owner = owner
        self.parentImage = parentImage
        self.platform = platform
        self.tags = tags
        self.type = type
        self.version = version
        self.workingDirectory = workingDirectory
    }
}

extension ImageRecipeSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dateCreated
        case name
        case owner
        case parentImage
        case platform
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImageRecipeSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageRecipeSummary(arn: \(String(describing: arn)), dateCreated: \(String(describing: dateCreated)), name: \(String(describing: name)), owner: \(String(describing: owner)), parentImage: \(String(describing: parentImage)), platform: \(String(describing: platform)), tags: \(String(describing: tags)))"}
}

/// <p>A summary of an image recipe.</p>
public struct ImageRecipeSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image recipe.</p>
    public let arn: String?
    /// <p>The date on which this image recipe was created.</p>
    public let dateCreated: String?
    /// <p>The name of the image recipe.</p>
    public let name: String?
    /// <p>The owner of the image recipe.</p>
    public let owner: String?
    /// <p>The parent image of the image recipe.</p>
    public let parentImage: String?
    /// <p>The platform of the image recipe.</p>
    public let platform: Platform?
    /// <p>The tags of the image recipe.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dateCreated: String? = nil,
        name: String? = nil,
        owner: String? = nil,
        parentImage: String? = nil,
        platform: Platform? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dateCreated = dateCreated
        self.name = name
        self.owner = owner
        self.parentImage = parentImage
        self.platform = platform
        self.tags = tags
    }
}

extension ImageState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImageStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImageState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageState(reason: \(String(describing: reason)), status: \(String(describing: status)))"}
}

/// <p> Image state shows the image status and the reason for that status.</p>
public struct ImageState: Equatable {
    /// <p>The reason for the image's status.</p>
    public let reason: String?
    /// <p>The status of the image.</p>
    public let status: ImageStatus?

    public init (
        reason: String? = nil,
        status: ImageStatus? = nil
    )
    {
        self.reason = reason
        self.status = status
    }
}

public enum ImageStatus {
    case available
    case building
    case cancelled
    case creating
    case deleted
    case deprecated
    case distributing
    case failed
    case integrating
    case pending
    case testing
    case sdkUnknown(String)
}

extension ImageStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageStatus] {
        return [
            .available,
            .building,
            .cancelled,
            .creating,
            .deleted,
            .deprecated,
            .distributing,
            .failed,
            .integrating,
            .pending,
            .testing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .building: return "BUILDING"
        case .cancelled: return "CANCELLED"
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .deprecated: return "DEPRECATED"
        case .distributing: return "DISTRIBUTING"
        case .failed: return "FAILED"
        case .integrating: return "INTEGRATING"
        case .pending: return "PENDING"
        case .testing: return "TESTING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageStatus(rawValue: rawValue) ?? ImageStatus.sdkUnknown(rawValue)
    }
}

extension ImageSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dateCreated
        case name
        case osVersion
        case outputResources
        case owner
        case platform
        case state
        case tags
        case type
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let outputResources = outputResources {
            try encodeContainer.encode(outputResources, forKey: .outputResources)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImageType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImageState.self, forKey: .state)
        state = stateDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let outputResourcesDecoded = try containerValues.decodeIfPresent(OutputResources.self, forKey: .outputResources)
        outputResources = outputResourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImageSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageSummary(arn: \(String(describing: arn)), dateCreated: \(String(describing: dateCreated)), name: \(String(describing: name)), osVersion: \(String(describing: osVersion)), outputResources: \(String(describing: outputResources)), owner: \(String(describing: owner)), platform: \(String(describing: platform)), state: \(String(describing: state)), tags: \(String(describing: tags)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>An image summary.</p>
public struct ImageSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image.</p>
    public let arn: String?
    /// <p>The date on which this image was created.</p>
    public let dateCreated: String?
    /// <p>The name of the image.</p>
    public let name: String?
    /// <p>The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or
    ///       Microsoft Windows Server 2019.</p>
    public let osVersion: String?
    /// <p>The output resources produced when creating this image.</p>
    public let outputResources: OutputResources?
    /// <p>The owner of the image.</p>
    public let owner: String?
    /// <p>The platform of the image.</p>
    public let platform: Platform?
    /// <p>The state of the image.</p>
    public let state: ImageState?
    /// <p>The tags of the image.</p>
    public let tags: [String:String]?
    /// <p>Specifies whether this is an AMI or container image.</p>
    public let type: ImageType?
    /// <p>The version of the image.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        dateCreated: String? = nil,
        name: String? = nil,
        osVersion: String? = nil,
        outputResources: OutputResources? = nil,
        owner: String? = nil,
        platform: Platform? = nil,
        state: ImageState? = nil,
        tags: [String:String]? = nil,
        type: ImageType? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.dateCreated = dateCreated
        self.name = name
        self.osVersion = osVersion
        self.outputResources = outputResources
        self.owner = owner
        self.platform = platform
        self.state = state
        self.tags = tags
        self.type = type
        self.version = version
    }
}

extension ImageTestsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageTestsEnabled
        case timeoutMinutes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageTestsEnabled = imageTestsEnabled {
            try encodeContainer.encode(imageTestsEnabled, forKey: .imageTestsEnabled)
        }
        if let timeoutMinutes = timeoutMinutes {
            try encodeContainer.encode(timeoutMinutes, forKey: .timeoutMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTestsEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .imageTestsEnabled)
        imageTestsEnabled = imageTestsEnabledDecoded
        let timeoutMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutMinutes)
        timeoutMinutes = timeoutMinutesDecoded
    }
}

extension ImageTestsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageTestsConfiguration(imageTestsEnabled: \(String(describing: imageTestsEnabled)), timeoutMinutes: \(String(describing: timeoutMinutes)))"}
}

/// <p>Image tests configuration.</p>
public struct ImageTestsConfiguration: Equatable {
    /// <p>Defines if tests should be executed when building this image.</p>
    public let imageTestsEnabled: Bool?
    /// <p>The maximum time in minutes that tests are permitted to run.</p>
    public let timeoutMinutes: Int?

    public init (
        imageTestsEnabled: Bool? = nil,
        timeoutMinutes: Int? = nil
    )
    {
        self.imageTestsEnabled = imageTestsEnabled
        self.timeoutMinutes = timeoutMinutes
    }
}

public enum ImageType {
    case ami
    case docker
    case sdkUnknown(String)
}

extension ImageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageType] {
        return [
            .ami,
            .docker,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ami: return "AMI"
        case .docker: return "DOCKER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageType(rawValue: rawValue) ?? ImageType.sdkUnknown(rawValue)
    }
}

extension ImageVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dateCreated
        case name
        case osVersion
        case owner
        case platform
        case type
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImageType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
    }
}

extension ImageVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageVersion(arn: \(String(describing: arn)), dateCreated: \(String(describing: dateCreated)), name: \(String(describing: name)), osVersion: \(String(describing: osVersion)), owner: \(String(describing: owner)), platform: \(String(describing: platform)), type: \(String(describing: type)), version: \(String(describing: version)))"}
}

/// <p>An image semantic version.</p>
public struct ImageVersion: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image semantic version.</p>
    public let arn: String?
    /// <p>The date at which this image semantic version was created.</p>
    public let dateCreated: String?
    /// <p>The name of the image semantic version.</p>
    public let name: String?
    /// <p>The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or
    ///       Microsoft Windows Server 2019.</p>
    public let osVersion: String?
    /// <p>The owner of the image semantic version.</p>
    public let owner: String?
    /// <p>The platform of the image semantic version.</p>
    public let platform: Platform?
    /// <p>Specifies whether this is an AMI or container image.</p>
    public let type: ImageType?
    /// <p>The semantic version of the image semantic version.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        dateCreated: String? = nil,
        name: String? = nil,
        osVersion: String? = nil,
        owner: String? = nil,
        platform: Platform? = nil,
        type: ImageType? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.dateCreated = dateCreated
        self.name = name
        self.osVersion = osVersion
        self.owner = owner
        self.platform = platform
        self.type = type
        self.version = version
    }
}

public struct ImportComponentInputBodyMiddleware: Middleware {
    public let id: String = "ImportComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportComponentInput>
    public typealias MOutput = OperationOutput<ImportComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportComponentOutputError>
}

extension ImportComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportComponentInput(changeDescription: \(String(describing: changeDescription)), clientToken: \(String(describing: clientToken)), data: \(String(describing: data)), description: \(String(describing: description)), format: \(String(describing: format)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), platform: \(String(describing: platform)), semanticVersion: \(String(describing: semanticVersion)), tags: \(String(describing: tags)), type: \(String(describing: type)), uri: \(String(describing: uri)))"}
}

extension ImportComponentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case format
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case tags
        case type
        case uri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDescription = changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct ImportComponentInputHeadersMiddleware: Middleware {
    public let id: String = "ImportComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportComponentInput>
    public typealias MOutput = OperationOutput<ImportComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportComponentOutputError>
}

public struct ImportComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportComponentInput>
    public typealias MOutput = OperationOutput<ImportComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportComponentOutputError>
}

public struct ImportComponentInput: Equatable {
    /// <p>The change description of the component. Describes what change has been made in this
    ///       version, or what makes this version different from other versions of this component.</p>
    public let changeDescription: String?
    /// <p>The idempotency token of the component.</p>
    public var clientToken: String?
    /// <p>The data of the component. Used to specify the data inline. Either <code>data</code> or
    ///         <code>uri</code> can be used to specify the data within the component.</p>
    public let data: String?
    /// <p>The description of the component. Describes the contents of the component.</p>
    public let description: String?
    /// <p>The format of the resource that you want to import as a component.</p>
    public let format: ComponentFormat?
    /// <p>The ID of the KMS key that should be used to encrypt this component.</p>
    public let kmsKeyId: String?
    /// <p> The name of the component.</p>
    public let name: String?
    /// <p>The platform of the component.</p>
    public let platform: Platform?
    /// <p>The semantic version of the component. This version follows the semantic version syntax.
    ///       For example, major.minor.patch. This could be versioned like software (2.0.1) or like a date
    ///       (2019.12.01).</p>
    public let semanticVersion: String?
    /// <p>The tags of the component.</p>
    public let tags: [String:String]?
    /// <p>The type of the component denotes whether the component is used to build the image or only
    ///       to test it.</p>
    public let type: ComponentType?
    /// <p>The uri of the component. Must be an S3 URL and the requester must have permission to
    ///       access the S3 bucket. If you use S3, you can specify component content up to your service
    ///       quota. Either <code>data</code> or <code>uri</code> can be used to specify the data within the
    ///       component.</p>
    public let uri: String?

    public init (
        changeDescription: String? = nil,
        clientToken: String? = nil,
        data: String? = nil,
        description: String? = nil,
        format: ComponentFormat? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        platform: Platform? = nil,
        semanticVersion: String? = nil,
        tags: [String:String]? = nil,
        type: ComponentType? = nil,
        uri: String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.format = format
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.type = type
        self.uri = uri
    }
}

struct ImportComponentInputBody: Equatable {
    public let name: String?
    public let semanticVersion: String?
    public let description: String?
    public let changeDescription: String?
    public let type: ComponentType?
    public let format: ComponentFormat?
    public let platform: Platform?
    public let data: String?
    public let uri: String?
    public let kmsKeyId: String?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension ImportComponentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case format
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case tags
        case type
        case uri
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ComponentType.self, forKey: .type)
        type = typeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ComponentFormat.self, forKey: .format)
        format = formatDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Platform.self, forKey: .platform)
        platform = platformDecoded
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ImportComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportComponentOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportComponentOutputResponse(clientToken: \(String(describing: clientToken)), componentBuildVersionArn: \(String(describing: componentBuildVersionArn)), requestId: \(String(describing: requestId)))"}
}

extension ImportComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportComponentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct ImportComponentOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the imported component.</p>
    public let componentBuildVersionArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        componentBuildVersionArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct ImportComponentOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let componentBuildVersionArn: String?
}

extension ImportComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

extension InfrastructureConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetypelist0 in instanceTypes {
                try instanceTypesContainer.encode(instancetypelist0)
            }
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTags)
            for (dictKey0, resourcetagmap0) in resourceTags {
                try resourceTagsContainer.encode(resourcetagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let terminateInstanceOnFailure = terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [String:String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InfrastructureConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InfrastructureConfiguration(arn: \(String(describing: arn)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), instanceProfileName: \(String(describing: instanceProfileName)), instanceTypes: \(String(describing: instanceTypes)), keyPair: \(String(describing: keyPair)), logging: \(String(describing: logging)), name: \(String(describing: name)), resourceTags: \(String(describing: resourceTags)), securityGroupIds: \(String(describing: securityGroupIds)), snsTopicArn: \(String(describing: snsTopicArn)), subnetId: \(String(describing: subnetId)), tags: \(String(describing: tags)), terminateInstanceOnFailure: \(String(describing: terminateInstanceOnFailure)))"}
}

/// <p>Details of the infrastructure configuration.</p>
public struct InfrastructureConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration.</p>
    public let arn: String?
    /// <p>The date on which the infrastructure configuration was created.</p>
    public let dateCreated: String?
    /// <p>The date on which the infrastructure configuration was last updated.</p>
    public let dateUpdated: String?
    /// <p>The description of the infrastructure configuration.</p>
    public let description: String?
    /// <p>The instance profile of the infrastructure configuration.</p>
    public let instanceProfileName: String?
    /// <p>The instance types of the infrastructure configuration.</p>
    public let instanceTypes: [String]?
    /// <p>The EC2 key pair of the infrastructure configuration.</p>
    public let keyPair: String?
    /// <p>The logging configuration of the infrastructure configuration.</p>
    public let logging: Logging?
    /// <p>The name of the infrastructure configuration.</p>
    public let name: String?
    /// <p>The tags attached to the resource created by Image Builder.</p>
    public let resourceTags: [String:String]?
    /// <p>The security group IDs of the infrastructure configuration.</p>
    public let securityGroupIds: [String]?
    /// <p>The SNS topic Amazon Resource Name (ARN) of the infrastructure configuration.</p>
    public let snsTopicArn: String?
    /// <p>The subnet ID of the infrastructure configuration.</p>
    public let subnetId: String?
    /// <p>The tags of the infrastructure configuration.</p>
    public let tags: [String:String]?
    /// <p>The terminate instance on failure configuration of the infrastructure
    ///       configuration.</p>
    public let terminateInstanceOnFailure: Bool?

    public init (
        arn: String? = nil,
        dateCreated: String? = nil,
        dateUpdated: String? = nil,
        description: String? = nil,
        instanceProfileName: String? = nil,
        instanceTypes: [String]? = nil,
        keyPair: String? = nil,
        logging: Logging? = nil,
        name: String? = nil,
        resourceTags: [String:String]? = nil,
        securityGroupIds: [String]? = nil,
        snsTopicArn: String? = nil,
        subnetId: String? = nil,
        tags: [String:String]? = nil,
        terminateInstanceOnFailure: Bool? = nil
    )
    {
        self.arn = arn
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.name = name
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.tags = tags
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

extension InfrastructureConfigurationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case instanceProfileName
        case instanceTypes
        case name
        case resourceTags
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetypelist0 in instanceTypes {
                try instanceTypesContainer.encode(instancetypelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTags)
            for (dictKey0, resourcetagmap0) in resourceTags {
                try resourceTagsContainer.encode(resourcetagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [String:String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let instanceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
    }
}

extension InfrastructureConfigurationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InfrastructureConfigurationSummary(arn: \(String(describing: arn)), dateCreated: \(String(describing: dateCreated)), dateUpdated: \(String(describing: dateUpdated)), description: \(String(describing: description)), instanceProfileName: \(String(describing: instanceProfileName)), instanceTypes: \(String(describing: instanceTypes)), name: \(String(describing: name)), resourceTags: \(String(describing: resourceTags)), tags: \(String(describing: tags)))"}
}

/// <p>The infrastructure used when building EC2 AMIs.</p>
public struct InfrastructureConfigurationSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration.</p>
    public let arn: String?
    /// <p>The date on which the infrastructure configuration was created.</p>
    public let dateCreated: String?
    /// <p>The date on which the infrastructure configuration was last updated.</p>
    public let dateUpdated: String?
    /// <p>The description of the infrastructure configuration.</p>
    public let description: String?
    /// <p>The instance profile of the infrastructure configuration.</p>
    public let instanceProfileName: String?
    /// <p>The instance types of the infrastructure configuration.</p>
    public let instanceTypes: [String]?
    /// <p>The name of the infrastructure configuration.</p>
    public let name: String?
    /// <p>The tags attached to the image created by Image Builder.</p>
    public let resourceTags: [String:String]?
    /// <p>The tags of the infrastructure configuration.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        dateCreated: String? = nil,
        dateUpdated: String? = nil,
        description: String? = nil,
        instanceProfileName: String? = nil,
        instanceTypes: [String]? = nil,
        name: String? = nil,
        resourceTags: [String:String]? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.dateCreated = dateCreated
        self.dateUpdated = dateUpdated
        self.description = description
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.name = name
        self.resourceTags = resourceTags
        self.tags = tags
    }
}

extension InstanceBlockDeviceMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if let noDevice = noDevice {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(EbsInstanceBlockDeviceSpecification.self, forKey: .ebs)
        ebs = ebsDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .noDevice)
        noDevice = noDeviceDecoded
    }
}

extension InstanceBlockDeviceMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceBlockDeviceMapping(deviceName: \(String(describing: deviceName)), ebs: \(String(describing: ebs)), noDevice: \(String(describing: noDevice)), virtualName: \(String(describing: virtualName)))"}
}

/// <p>Defines block device mappings for the instance used to configure your image.</p>
public struct InstanceBlockDeviceMapping: Equatable {
    /// <p>The device to which these mappings apply.</p>
    public let deviceName: String?
    /// <p>Use to manage Amazon EBS-specific configuration for this mapping.</p>
    public let ebs: EbsInstanceBlockDeviceSpecification?
    /// <p>Use to remove a mapping from the parent image.</p>
    public let noDevice: String?
    /// <p>Use to manage instance ephemeral devices.</p>
    public let virtualName: String?

    public init (
        deviceName: String? = nil,
        ebs: EbsInstanceBlockDeviceSpecification? = nil,
        noDevice: String? = nil,
        virtualName: String? = nil
    )
    {
        self.deviceName = deviceName
        self.ebs = ebs
        self.noDevice = noDevice
        self.virtualName = virtualName
    }
}

extension InstanceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockDeviceMappings
        case image
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemappings0)
            }
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .image)
        image = imageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
    }
}

extension InstanceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceConfiguration(blockDeviceMappings: \(String(describing: blockDeviceMappings)), image: \(String(describing: image)))"}
}

/// <p>Defines a custom source AMI and block device mapping configurations of an instance
///       used for building and testing container images.</p>
public struct InstanceConfiguration: Equatable {
    /// <p>Defines the block devices to attach for building an instance from this Image Builder AMI.</p>
    public let blockDeviceMappings: [InstanceBlockDeviceMapping]?
    /// <p>The AMI ID to use as the base image for a container build and test instance. If not specified,
    ///       Image Builder will use the appropriate ECS-optimized AMI as a base image.</p>
    public let image: String?

    public init (
        blockDeviceMappings: [InstanceBlockDeviceMapping]? = nil,
        image: String? = nil
    )
    {
        self.blockDeviceMappings = blockDeviceMappings
        self.image = image
    }
}

extension InvalidPaginationTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPaginationTokenException(message: \(String(describing: message)))"}
}

extension InvalidPaginationTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have provided an invalid pagination token in your request.</p>
public struct InvalidPaginationTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPaginationTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterCombinationException(message: \(String(describing: message)))"}
}

extension InvalidParameterCombinationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have specified two or more mutually exclusive parameters. Review the error message for
///       details.</p>
public struct InvalidParameterCombinationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterCombinationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified parameter is invalid. Review the available parameters for the API
///       request.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value that you provided for the specified parameter is invalid.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have made a request for an action that is not supported by the service.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVersionNumberException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidVersionNumberException(message: \(String(describing: message)))"}
}

extension InvalidVersionNumberException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidVersionNumberExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your version number is out of bounds or does not follow the required syntax.</p>
public struct InvalidVersionNumberException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVersionNumberExceptionBody: Equatable {
    public let message: String?
}

extension InvalidVersionNumberExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LaunchPermissionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userGroups
        case userIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userGroups = userGroups {
            var userGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userGroups)
            for stringlist0 in userGroups {
                try userGroupsContainer.encode(stringlist0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for accountlist0 in userIds {
                try userIdsContainer.encode(accountlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userIds)
        var userIdsDecoded0:[String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let userGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userGroups)
        var userGroupsDecoded0:[String]? = nil
        if let userGroupsContainer = userGroupsContainer {
            userGroupsDecoded0 = [String]()
            for string0 in userGroupsContainer {
                if let string0 = string0 {
                    userGroupsDecoded0?.append(string0)
                }
            }
        }
        userGroups = userGroupsDecoded0
    }
}

extension LaunchPermissionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchPermissionConfiguration(userGroups: \(String(describing: userGroups)), userIds: \(String(describing: userIds)))"}
}

/// <p>Describes the configuration for a launch permission. The launch permission modification request is sent to the
///       <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html">EC2 ModifyImageAttribute</a>
///       API on behalf of the user for each Region they have selected to distribute the AMI. To make an AMI public,
///       set the launch permission authorized accounts to <code>all</code>. See the examples for making an AMI public at
///       <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html">EC2 ModifyImageAttribute</a>.</p>
public struct LaunchPermissionConfiguration: Equatable {
    /// <p>The name of the group.</p>
    public let userGroups: [String]?
    /// <p>The AWS account ID.</p>
    public let userIds: [String]?

    public init (
        userGroups: [String]? = nil,
        userIds: [String]? = nil
    )
    {
        self.userGroups = userGroups
        self.userIds = userIds
    }
}

extension LaunchTemplateConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case launchTemplateId
        case setDefaultVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let launchTemplateId = launchTemplateId {
            try encodeContainer.encode(launchTemplateId, forKey: .launchTemplateId)
        }
        if setDefaultVersion != false {
            try encodeContainer.encode(setDefaultVersion, forKey: .setDefaultVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchTemplateId)
        launchTemplateId = launchTemplateIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let setDefaultVersionDecoded = try containerValues.decode(Bool.self, forKey: .setDefaultVersion)
        setDefaultVersion = setDefaultVersionDecoded
    }
}

extension LaunchTemplateConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LaunchTemplateConfiguration(accountId: \(String(describing: accountId)), launchTemplateId: \(String(describing: launchTemplateId)), setDefaultVersion: \(String(describing: setDefaultVersion)))"}
}

/// <p>Identifies an EC2 launch template to use for a specific account.</p>
public struct LaunchTemplateConfiguration: Equatable {
    /// <p>The account ID that this configuration applies to.</p>
    public let accountId: String?
    /// <p>Identifies the EC2 launch template to use.</p>
    public let launchTemplateId: String?
    /// <p>Set the specified EC2 launch template as the default launch template for the specified account.</p>
    public let setDefaultVersion: Bool

    public init (
        accountId: String? = nil,
        launchTemplateId: String? = nil,
        setDefaultVersion: Bool = false
    )
    {
        self.accountId = accountId
        self.launchTemplateId = launchTemplateId
        self.setDefaultVersion = setDefaultVersion
    }
}

public struct ListComponentBuildVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListComponentBuildVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentBuildVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentBuildVersionsInput>
    public typealias MOutput = OperationOutput<ListComponentBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentBuildVersionsOutputError>
}

extension ListComponentBuildVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentBuildVersionsInput(componentVersionArn: \(String(describing: componentVersionArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListComponentBuildVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentVersionArn = componentVersionArn {
            try encodeContainer.encode(componentVersionArn, forKey: .componentVersionArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListComponentBuildVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListComponentBuildVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentBuildVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentBuildVersionsInput>
    public typealias MOutput = OperationOutput<ListComponentBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentBuildVersionsOutputError>
}

public struct ListComponentBuildVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListComponentBuildVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentBuildVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentBuildVersionsInput>
    public typealias MOutput = OperationOutput<ListComponentBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentBuildVersionsOutputError>
}

public struct ListComponentBuildVersionsInput: Equatable {
    /// <p>The component version Amazon Resource Name (ARN) whose versions you want to list.</p>
    public let componentVersionArn: String?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?

    public init (
        componentVersionArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.componentVersionArn = componentVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentBuildVersionsInputBody: Equatable {
    public let componentVersionArn: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListComponentBuildVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentVersionArn)
        componentVersionArn = componentVersionArnDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentBuildVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentBuildVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentBuildVersionsOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentBuildVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentBuildVersionsOutputResponse(componentSummaryList: \(String(describing: componentSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListComponentBuildVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListComponentBuildVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.componentSummaryList = output.componentSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.componentSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListComponentBuildVersionsOutputResponse: Equatable {
    /// <p>The list of component summaries for the specified semantic version.</p>
    public let componentSummaryList: [ComponentSummary]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        componentSummaryList: [ComponentSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.componentSummaryList = componentSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListComponentBuildVersionsOutputResponseBody: Equatable {
    public let requestId: String?
    public let componentSummaryList: [ComponentSummary]?
    public let nextToken: String?
}

extension ListComponentBuildVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentSummaryListContainer = try containerValues.decodeIfPresent([ComponentSummary?].self, forKey: .componentSummaryList)
        var componentSummaryListDecoded0:[ComponentSummary]? = nil
        if let componentSummaryListContainer = componentSummaryListContainer {
            componentSummaryListDecoded0 = [ComponentSummary]()
            for structure0 in componentSummaryListContainer {
                if let structure0 = structure0 {
                    componentSummaryListDecoded0?.append(structure0)
                }
            }
        }
        componentSummaryList = componentSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListComponentsInputBodyMiddleware: Middleware {
    public let id: String = "ListComponentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentsInput>
    public typealias MOutput = OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentsOutputError>
}

extension ListComponentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentsInput(byName: \(String(describing: byName)), filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), owner: \(String(describing: owner)))"}
}

extension ListComponentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case byName
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if byName != false {
            try encodeContainer.encode(byName, forKey: .byName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

public struct ListComponentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentsInput>
    public typealias MOutput = OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentsOutputError>
}

public struct ListComponentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentsInput>
    public typealias MOutput = OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentsOutputError>
}

public struct ListComponentsInput: Equatable {
    /// <p>Returns the list of component build versions for the specified semantic version.</p>
    public let byName: Bool
    /// <p>The filters.</p>
    public let filters: [Filter]?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?
    /// <p>The owner defines which components you want to list. By default, this request will only
    ///       show components owned by your account. You can use this field to specify if you want to view
    ///       components owned by yourself, by Amazon, or those components that have been shared with you by
    ///       other customers.</p>
    public let owner: Ownership?

    public init (
        byName: Bool = false,
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        owner: Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListComponentsInputBody: Equatable {
    public let owner: Ownership?
    public let filters: [Filter]?
    public let byName: Bool
    public let maxResults: Int
    public let nextToken: String?
}

extension ListComponentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byName
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let byNameDecoded = try containerValues.decode(Bool.self, forKey: .byName)
        byName = byNameDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentsOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentsOutputResponse(componentVersionList: \(String(describing: componentVersionList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListComponentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.componentVersionList = output.componentVersionList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.componentVersionList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListComponentsOutputResponse: Equatable {
    /// <p>The list of component semantic versions.</p>
    public let componentVersionList: [ComponentVersion]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        componentVersionList: [ComponentVersion]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.componentVersionList = componentVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListComponentsOutputResponseBody: Equatable {
    public let requestId: String?
    public let componentVersionList: [ComponentVersion]?
    public let nextToken: String?
}

extension ListComponentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentVersionList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentVersionListContainer = try containerValues.decodeIfPresent([ComponentVersion?].self, forKey: .componentVersionList)
        var componentVersionListDecoded0:[ComponentVersion]? = nil
        if let componentVersionListContainer = componentVersionListContainer {
            componentVersionListDecoded0 = [ComponentVersion]()
            for structure0 in componentVersionListContainer {
                if let structure0 = structure0 {
                    componentVersionListDecoded0?.append(structure0)
                }
            }
        }
        componentVersionList = componentVersionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListContainerRecipesInputBodyMiddleware: Middleware {
    public let id: String = "ListContainerRecipesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContainerRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContainerRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContainerRecipesInput>
    public typealias MOutput = OperationOutput<ListContainerRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContainerRecipesOutputError>
}

extension ListContainerRecipesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContainerRecipesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), owner: \(String(describing: owner)))"}
}

extension ListContainerRecipesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

public struct ListContainerRecipesInputHeadersMiddleware: Middleware {
    public let id: String = "ListContainerRecipesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContainerRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContainerRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContainerRecipesInput>
    public typealias MOutput = OperationOutput<ListContainerRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContainerRecipesOutputError>
}

public struct ListContainerRecipesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListContainerRecipesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListContainerRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListContainerRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListContainerRecipesInput>
    public typealias MOutput = OperationOutput<ListContainerRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListContainerRecipesOutputError>
}

public struct ListContainerRecipesInput: Equatable {
    /// <p>Request filters that are used to narrow the list of container images that are returned.</p>
    public let filters: [Filter]?
    /// <p>The maximum number of results to return in the list.</p>
    public let maxResults: Int
    /// <p>Provides a token for pagination, which determines where to begin the next set of results when the current set reaches the maximum for one request.</p>
    public let nextToken: String?
    /// <p>Returns container recipes belonging to the specified owner, that have been shared with you. You can omit this field to return container recipes belonging to your account.</p>
    public let owner: Ownership?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        owner: Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListContainerRecipesInputBody: Equatable {
    public let owner: Ownership?
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListContainerRecipesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContainerRecipesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContainerRecipesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContainerRecipesOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContainerRecipesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListContainerRecipesOutputResponse(containerRecipeSummaryList: \(String(describing: containerRecipeSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListContainerRecipesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListContainerRecipesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.containerRecipeSummaryList = output.containerRecipeSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.containerRecipeSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListContainerRecipesOutputResponse: Equatable {
    /// <p>The list of container recipes returned for the request.</p>
    public let containerRecipeSummaryList: [ContainerRecipeSummary]?
    /// <p>The next token field is used for paginated responses. When this is not empty, there are additional container recipes that the service has not included in this response. Use this token with the next request to retrieve additional list items.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        containerRecipeSummaryList: [ContainerRecipeSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.containerRecipeSummaryList = containerRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListContainerRecipesOutputResponseBody: Equatable {
    public let requestId: String?
    public let containerRecipeSummaryList: [ContainerRecipeSummary]?
    public let nextToken: String?
}

extension ListContainerRecipesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerRecipeSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeSummaryListContainer = try containerValues.decodeIfPresent([ContainerRecipeSummary?].self, forKey: .containerRecipeSummaryList)
        var containerRecipeSummaryListDecoded0:[ContainerRecipeSummary]? = nil
        if let containerRecipeSummaryListContainer = containerRecipeSummaryListContainer {
            containerRecipeSummaryListDecoded0 = [ContainerRecipeSummary]()
            for structure0 in containerRecipeSummaryListContainer {
                if let structure0 = structure0 {
                    containerRecipeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        containerRecipeSummaryList = containerRecipeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDistributionConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListDistributionConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionConfigurationsInput>
    public typealias MOutput = OperationOutput<ListDistributionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionConfigurationsOutputError>
}

extension ListDistributionConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionConfigurationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDistributionConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDistributionConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDistributionConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionConfigurationsInput>
    public typealias MOutput = OperationOutput<ListDistributionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionConfigurationsOutputError>
}

public struct ListDistributionConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDistributionConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionConfigurationsInput>
    public typealias MOutput = OperationOutput<ListDistributionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionConfigurationsOutputError>
}

public struct ListDistributionConfigurationsInput: Equatable {
    /// <p>The filters.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>name</code> - The name of this distribution configuration.</p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDistributionConfigurationsInputBody: Equatable {
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListDistributionConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDistributionConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDistributionConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionConfigurationsOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionConfigurationsOutputResponse(distributionConfigurationSummaryList: \(String(describing: distributionConfigurationSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListDistributionConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDistributionConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.distributionConfigurationSummaryList = output.distributionConfigurationSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.distributionConfigurationSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListDistributionConfigurationsOutputResponse: Equatable {
    /// <p>The list of distributions.</p>
    public let distributionConfigurationSummaryList: [DistributionConfigurationSummary]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        distributionConfigurationSummaryList: [DistributionConfigurationSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListDistributionConfigurationsOutputResponseBody: Equatable {
    public let requestId: String?
    public let distributionConfigurationSummaryList: [DistributionConfigurationSummary]?
    public let nextToken: String?
}

extension ListDistributionConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionConfigurationSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationSummaryListContainer = try containerValues.decodeIfPresent([DistributionConfigurationSummary?].self, forKey: .distributionConfigurationSummaryList)
        var distributionConfigurationSummaryListDecoded0:[DistributionConfigurationSummary]? = nil
        if let distributionConfigurationSummaryListContainer = distributionConfigurationSummaryListContainer {
            distributionConfigurationSummaryListDecoded0 = [DistributionConfigurationSummary]()
            for structure0 in distributionConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    distributionConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        distributionConfigurationSummaryList = distributionConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImageBuildVersionsInputBodyMiddleware: Middleware {
    public let id: String = "ListImageBuildVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImageBuildVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImageBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImageBuildVersionsInput>
    public typealias MOutput = OperationOutput<ListImageBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImageBuildVersionsOutputError>
}

extension ListImageBuildVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImageBuildVersionsInput(filters: \(String(describing: filters)), imageVersionArn: \(String(describing: imageVersionArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImageBuildVersionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case imageVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let imageVersionArn = imageVersionArn {
            try encodeContainer.encode(imageVersionArn, forKey: .imageVersionArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListImageBuildVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListImageBuildVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImageBuildVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImageBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImageBuildVersionsInput>
    public typealias MOutput = OperationOutput<ListImageBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImageBuildVersionsOutputError>
}

public struct ListImageBuildVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImageBuildVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImageBuildVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImageBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImageBuildVersionsInput>
    public typealias MOutput = OperationOutput<ListImageBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImageBuildVersionsOutputError>
}

public struct ListImageBuildVersionsInput: Equatable {
    /// <p>The filters.</p>
    public let filters: [Filter]?
    /// <p>The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve.</p>
    public let imageVersionArn: String?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        imageVersionArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.imageVersionArn = imageVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImageBuildVersionsInputBody: Equatable {
    public let imageVersionArn: String?
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListImageBuildVersionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case imageVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageVersionArn)
        imageVersionArn = imageVersionArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageBuildVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImageBuildVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImageBuildVersionsOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImageBuildVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImageBuildVersionsOutputResponse(imageSummaryList: \(String(describing: imageSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListImageBuildVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImageBuildVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageSummaryList = output.imageSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageBuildVersionsOutputResponse: Equatable {
    /// <p>The list of image build versions.</p>
    public let imageSummaryList: [ImageSummary]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageSummaryList: [ImageSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageBuildVersionsOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageSummaryList: [ImageSummary]?
    public let nextToken: String?
}

extension ListImageBuildVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageSummaryListContainer = try containerValues.decodeIfPresent([ImageSummary?].self, forKey: .imageSummaryList)
        var imageSummaryListDecoded0:[ImageSummary]? = nil
        if let imageSummaryListContainer = imageSummaryListContainer {
            imageSummaryListDecoded0 = [ImageSummary]()
            for structure0 in imageSummaryListContainer {
                if let structure0 = structure0 {
                    imageSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageSummaryList = imageSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImagePackagesInputBodyMiddleware: Middleware {
    public let id: String = "ListImagePackagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePackagesInput>
    public typealias MOutput = OperationOutput<ListImagePackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePackagesOutputError>
}

extension ListImagePackagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagePackagesInput(imageBuildVersionArn: \(String(describing: imageBuildVersionArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImagePackagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageBuildVersionArn = imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListImagePackagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListImagePackagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePackagesInput>
    public typealias MOutput = OperationOutput<ListImagePackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePackagesOutputError>
}

public struct ListImagePackagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImagePackagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePackagesInput>
    public typealias MOutput = OperationOutput<ListImagePackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePackagesOutputError>
}

public struct ListImagePackagesInput: Equatable {
    /// <p>Filter results for the ListImagePackages request by the Image Build Version ARN</p>
    public let imageBuildVersionArn: String?
    /// <p>The maxiumum number of results to return from the ListImagePackages request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously truncated response.</p>
    public let nextToken: String?

    public init (
        imageBuildVersionArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePackagesInputBody: Equatable {
    public let imageBuildVersionArn: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListImagePackagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePackagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePackagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagePackagesOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePackagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagePackagesOutputResponse(imagePackageList: \(String(describing: imagePackageList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListImagePackagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImagePackagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imagePackageList = output.imagePackageList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imagePackageList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePackagesOutputResponse: Equatable {
    /// <p>The list of Image Packages returned in the response.</p>
    public let imagePackageList: [ImagePackage]?
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously truncated response.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imagePackageList: [ImagePackage]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.imagePackageList = imagePackageList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePackagesOutputResponseBody: Equatable {
    public let requestId: String?
    public let imagePackageList: [ImagePackage]?
    public let nextToken: String?
}

extension ListImagePackagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imagePackageList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePackageListContainer = try containerValues.decodeIfPresent([ImagePackage?].self, forKey: .imagePackageList)
        var imagePackageListDecoded0:[ImagePackage]? = nil
        if let imagePackageListContainer = imagePackageListContainer {
            imagePackageListDecoded0 = [ImagePackage]()
            for structure0 in imagePackageListContainer {
                if let structure0 = structure0 {
                    imagePackageListDecoded0?.append(structure0)
                }
            }
        }
        imagePackageList = imagePackageListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImagePipelineImagesInputBodyMiddleware: Middleware {
    public let id: String = "ListImagePipelineImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePipelineImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePipelineImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePipelineImagesInput>
    public typealias MOutput = OperationOutput<ListImagePipelineImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePipelineImagesOutputError>
}

extension ListImagePipelineImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagePipelineImagesInput(filters: \(String(describing: filters)), imagePipelineArn: \(String(describing: imagePipelineArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImagePipelineImagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case imagePipelineArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let imagePipelineArn = imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListImagePipelineImagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListImagePipelineImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePipelineImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePipelineImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePipelineImagesInput>
    public typealias MOutput = OperationOutput<ListImagePipelineImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePipelineImagesOutputError>
}

public struct ListImagePipelineImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImagePipelineImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePipelineImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePipelineImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePipelineImagesInput>
    public typealias MOutput = OperationOutput<ListImagePipelineImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePipelineImagesOutputError>
}

public struct ListImagePipelineImagesInput: Equatable {
    /// <p>The filters.</p>
    public let filters: [Filter]?
    /// <p>The Amazon Resource Name (ARN) of the image pipeline whose images you want to view.</p>
    public let imagePipelineArn: String?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        imagePipelineArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.imagePipelineArn = imagePipelineArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePipelineImagesInputBody: Equatable {
    public let imagePipelineArn: String?
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListImagePipelineImagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case imagePipelineArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelineImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePipelineImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagePipelineImagesOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePipelineImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagePipelineImagesOutputResponse(imageSummaryList: \(String(describing: imageSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListImagePipelineImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImagePipelineImagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageSummaryList = output.imageSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePipelineImagesOutputResponse: Equatable {
    /// <p>The list of images built by this pipeline.</p>
    public let imageSummaryList: [ImageSummary]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageSummaryList: [ImageSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePipelineImagesOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageSummaryList: [ImageSummary]?
    public let nextToken: String?
}

extension ListImagePipelineImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageSummaryListContainer = try containerValues.decodeIfPresent([ImageSummary?].self, forKey: .imageSummaryList)
        var imageSummaryListDecoded0:[ImageSummary]? = nil
        if let imageSummaryListContainer = imageSummaryListContainer {
            imageSummaryListDecoded0 = [ImageSummary]()
            for structure0 in imageSummaryListContainer {
                if let structure0 = structure0 {
                    imageSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageSummaryList = imageSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImagePipelinesInputBodyMiddleware: Middleware {
    public let id: String = "ListImagePipelinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePipelinesInput>
    public typealias MOutput = OperationOutput<ListImagePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePipelinesOutputError>
}

extension ListImagePipelinesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagePipelinesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListImagePipelinesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListImagePipelinesInputHeadersMiddleware: Middleware {
    public let id: String = "ListImagePipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePipelinesInput>
    public typealias MOutput = OperationOutput<ListImagePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePipelinesOutputError>
}

public struct ListImagePipelinesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImagePipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagePipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagePipelinesInput>
    public typealias MOutput = OperationOutput<ListImagePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagePipelinesOutputError>
}

public struct ListImagePipelinesInput: Equatable {
    /// <p>The filters.</p>
    public let filters: [Filter]?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePipelinesInputBody: Equatable {
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListImagePipelinesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelinesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePipelinesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagePipelinesOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePipelinesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagePipelinesOutputResponse(imagePipelineList: \(String(describing: imagePipelineList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListImagePipelinesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImagePipelinesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imagePipelineList = output.imagePipelineList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imagePipelineList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePipelinesOutputResponse: Equatable {
    /// <p>The list of image pipelines.</p>
    public let imagePipelineList: [ImagePipeline]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imagePipelineList: [ImagePipeline]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.imagePipelineList = imagePipelineList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePipelinesOutputResponseBody: Equatable {
    public let requestId: String?
    public let imagePipelineList: [ImagePipeline]?
    public let nextToken: String?
}

extension ListImagePipelinesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imagePipelineList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineListContainer = try containerValues.decodeIfPresent([ImagePipeline?].self, forKey: .imagePipelineList)
        var imagePipelineListDecoded0:[ImagePipeline]? = nil
        if let imagePipelineListContainer = imagePipelineListContainer {
            imagePipelineListDecoded0 = [ImagePipeline]()
            for structure0 in imagePipelineListContainer {
                if let structure0 = structure0 {
                    imagePipelineListDecoded0?.append(structure0)
                }
            }
        }
        imagePipelineList = imagePipelineListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImageRecipesInputBodyMiddleware: Middleware {
    public let id: String = "ListImageRecipesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImageRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImageRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImageRecipesInput>
    public typealias MOutput = OperationOutput<ListImageRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImageRecipesOutputError>
}

extension ListImageRecipesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImageRecipesInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), owner: \(String(describing: owner)))"}
}

extension ListImageRecipesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

public struct ListImageRecipesInputHeadersMiddleware: Middleware {
    public let id: String = "ListImageRecipesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImageRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImageRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImageRecipesInput>
    public typealias MOutput = OperationOutput<ListImageRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImageRecipesOutputError>
}

public struct ListImageRecipesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImageRecipesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImageRecipesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImageRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImageRecipesInput>
    public typealias MOutput = OperationOutput<ListImageRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImageRecipesOutputError>
}

public struct ListImageRecipesInput: Equatable {
    /// <p>The filters.</p>
    public let filters: [Filter]?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?
    /// <p>The owner defines which image recipes you want to list. By default, this request will only
    ///       show image recipes owned by your account. You can use this field to specify if you want to
    ///       view image recipes owned by yourself, by Amazon, or those image recipes that have been shared
    ///       with you by other customers.</p>
    public let owner: Ownership?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        owner: Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListImageRecipesInputBody: Equatable {
    public let owner: Ownership?
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListImageRecipesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageRecipesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImageRecipesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImageRecipesOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImageRecipesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImageRecipesOutputResponse(imageRecipeSummaryList: \(String(describing: imageRecipeSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListImageRecipesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImageRecipesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageRecipeSummaryList = output.imageRecipeSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageRecipeSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageRecipesOutputResponse: Equatable {
    /// <p>The list of image pipelines.</p>
    public let imageRecipeSummaryList: [ImageRecipeSummary]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageRecipeSummaryList: [ImageRecipeSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.imageRecipeSummaryList = imageRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageRecipesOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageRecipeSummaryList: [ImageRecipeSummary]?
    public let nextToken: String?
}

extension ListImageRecipesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageRecipeSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeSummaryListContainer = try containerValues.decodeIfPresent([ImageRecipeSummary?].self, forKey: .imageRecipeSummaryList)
        var imageRecipeSummaryListDecoded0:[ImageRecipeSummary]? = nil
        if let imageRecipeSummaryListContainer = imageRecipeSummaryListContainer {
            imageRecipeSummaryListDecoded0 = [ImageRecipeSummary]()
            for structure0 in imageRecipeSummaryListContainer {
                if let structure0 = structure0 {
                    imageRecipeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageRecipeSummaryList = imageRecipeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImagesInputBodyMiddleware: Middleware {
    public let id: String = "ListImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagesInput>
    public typealias MOutput = OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagesOutputError>
}

extension ListImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagesInput(byName: \(String(describing: byName)), filters: \(String(describing: filters)), includeDeprecated: \(String(describing: includeDeprecated)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), owner: \(String(describing: owner)))"}
}

extension ListImagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case byName
        case filters
        case includeDeprecated
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if byName != false {
            try encodeContainer.encode(byName, forKey: .byName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let includeDeprecated = includeDeprecated {
            try encodeContainer.encode(includeDeprecated, forKey: .includeDeprecated)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

public struct ListImagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagesInput>
    public typealias MOutput = OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagesOutputError>
}

public struct ListImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListImagesInput>
    public typealias MOutput = OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListImagesOutputError>
}

public struct ListImagesInput: Equatable {
    /// <p>Requests a list of images with a specific recipe name.</p>
    public let byName: Bool
    /// <p>The filters.</p>
    public let filters: [Filter]?
    /// <p>Includes deprecated images in the response list.</p>
    public let includeDeprecated: Bool?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?
    /// <p>The owner defines which images you want to list. By default, this request will only show
    ///       images owned by your account. You can use this field to specify if you want to view images
    ///       owned by yourself, by Amazon, or those images that have been shared with you by other
    ///       customers.</p>
    public let owner: Ownership?

    public init (
        byName: Bool = false,
        filters: [Filter]? = nil,
        includeDeprecated: Bool? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        owner: Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListImagesInputBody: Equatable {
    public let owner: Ownership?
    public let filters: [Filter]?
    public let byName: Bool
    public let maxResults: Int
    public let nextToken: String?
    public let includeDeprecated: Bool?
}

extension ListImagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byName
        case filters
        case includeDeprecated
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let byNameDecoded = try containerValues.decode(Bool.self, forKey: .byName)
        byName = byNameDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeDeprecatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeDeprecated)
        includeDeprecated = includeDeprecatedDecoded
    }
}

extension ListImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagesOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListImagesOutputResponse(imageVersionList: \(String(describing: imageVersionList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListImagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageVersionList = output.imageVersionList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageVersionList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagesOutputResponse: Equatable {
    /// <p>The list of image semantic versions.</p>
    public let imageVersionList: [ImageVersion]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageVersionList: [ImageVersion]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.imageVersionList = imageVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagesOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageVersionList: [ImageVersion]?
    public let nextToken: String?
}

extension ListImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageVersionList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageVersionListContainer = try containerValues.decodeIfPresent([ImageVersion?].self, forKey: .imageVersionList)
        var imageVersionListDecoded0:[ImageVersion]? = nil
        if let imageVersionListContainer = imageVersionListContainer {
            imageVersionListDecoded0 = [ImageVersion]()
            for structure0 in imageVersionListContainer {
                if let structure0 = structure0 {
                    imageVersionListDecoded0?.append(structure0)
                }
            }
        }
        imageVersionList = imageVersionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInfrastructureConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListInfrastructureConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInfrastructureConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInfrastructureConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInfrastructureConfigurationsInput>
    public typealias MOutput = OperationOutput<ListInfrastructureConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInfrastructureConfigurationsOutputError>
}

extension ListInfrastructureConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInfrastructureConfigurationsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInfrastructureConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInfrastructureConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInfrastructureConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInfrastructureConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInfrastructureConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInfrastructureConfigurationsInput>
    public typealias MOutput = OperationOutput<ListInfrastructureConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInfrastructureConfigurationsOutputError>
}

public struct ListInfrastructureConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInfrastructureConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInfrastructureConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInfrastructureConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInfrastructureConfigurationsInput>
    public typealias MOutput = OperationOutput<ListInfrastructureConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInfrastructureConfigurationsOutputError>
}

public struct ListInfrastructureConfigurationsInput: Equatable {
    /// <p>The filters.</p>
    public let filters: [Filter]?
    /// <p>The maximum items to return in a request.</p>
    public let maxResults: Int
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously
    ///       truncated response.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInfrastructureConfigurationsInputBody: Equatable {
    public let filters: [Filter]?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListInfrastructureConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInfrastructureConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInfrastructureConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInfrastructureConfigurationsOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInfrastructureConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInfrastructureConfigurationsOutputResponse(infrastructureConfigurationSummaryList: \(String(describing: infrastructureConfigurationSummaryList)), nextToken: \(String(describing: nextToken)), requestId: \(String(describing: requestId)))"}
}

extension ListInfrastructureConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListInfrastructureConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.infrastructureConfigurationSummaryList = output.infrastructureConfigurationSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.infrastructureConfigurationSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListInfrastructureConfigurationsOutputResponse: Equatable {
    /// <p>The list of infrastructure configurations.</p>
    public let infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]?
    /// <p>The next token used for paginated responses. When this is not empty, there are additional
    ///       elements that the service has not included in this request. Use this token with the next
    ///       request to retrieve additional objects.</p>
    public let nextToken: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]? = nil,
        nextToken: String? = nil,
        requestId: String? = nil
    )
    {
        self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListInfrastructureConfigurationsOutputResponseBody: Equatable {
    public let requestId: String?
    public let infrastructureConfigurationSummaryList: [InfrastructureConfigurationSummary]?
    public let nextToken: String?
}

extension ListInfrastructureConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case infrastructureConfigurationSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationSummaryListContainer = try containerValues.decodeIfPresent([InfrastructureConfigurationSummary?].self, forKey: .infrastructureConfigurationSummaryList)
        var infrastructureConfigurationSummaryListDecoded0:[InfrastructureConfigurationSummary]? = nil
        if let infrastructureConfigurationSummaryListContainer = infrastructureConfigurationSummaryListContainer {
            infrastructureConfigurationSummaryListDecoded0 = [InfrastructureConfigurationSummary]()
            for structure0 in infrastructureConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    infrastructureConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags for the specified resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Logging: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Logs
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(S3Logs.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension Logging: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Logging(s3Logs: \(String(describing: s3Logs)))"}
}

/// <p>Logging configuration defines where Image Builder uploads your logs.</p>
public struct Logging: Equatable {
    /// <p>The Amazon S3 logging configuration.</p>
    public let s3Logs: S3Logs?

    public init (
        s3Logs: S3Logs? = nil
    )
    {
        self.s3Logs = s3Logs
    }
}

extension OutputResources: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amis
        case containers
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = amis {
            var amisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amis)
            for amilist0 in amis {
                try amisContainer.encode(amilist0)
            }
        }
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for containerlist0 in containers {
                try containersContainer.encode(containerlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisContainer = try containerValues.decodeIfPresent([Ami?].self, forKey: .amis)
        var amisDecoded0:[Ami]? = nil
        if let amisContainer = amisContainer {
            amisDecoded0 = [Ami]()
            for structure0 in amisContainer {
                if let structure0 = structure0 {
                    amisDecoded0?.append(structure0)
                }
            }
        }
        amis = amisDecoded0
        let containersContainer = try containerValues.decodeIfPresent([Container?].self, forKey: .containers)
        var containersDecoded0:[Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
    }
}

extension OutputResources: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputResources(amis: \(String(describing: amis)), containers: \(String(describing: containers)))"}
}

/// <p>The resources produced by this image.</p>
public struct OutputResources: Equatable {
    /// <p>The EC2 AMIs created by this image.</p>
    public let amis: [Ami]?
    /// <p>Container images that the pipeline has generated and stored in the output repository.</p>
    public let containers: [Container]?

    public init (
        amis: [Ami]? = nil,
        containers: [Container]? = nil
    )
    {
        self.amis = amis
        self.containers = containers
    }
}

public enum Ownership {
    case amazon
    case `self`
    case shared
    case sdkUnknown(String)
}

extension Ownership : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Ownership] {
        return [
            .amazon,
            .self,
            .shared,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amazon: return "Amazon"
        case .self: return "Self"
        case .shared: return "Shared"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Ownership(rawValue: rawValue) ?? Ownership.sdkUnknown(rawValue)
    }
}

public enum PipelineExecutionStartCondition {
    case expressionMatchAndDependencyUpdatesAvailable
    case expressionMatchOnly
    case sdkUnknown(String)
}

extension PipelineExecutionStartCondition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PipelineExecutionStartCondition] {
        return [
            .expressionMatchAndDependencyUpdatesAvailable,
            .expressionMatchOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .expressionMatchAndDependencyUpdatesAvailable: return "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
        case .expressionMatchOnly: return "EXPRESSION_MATCH_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PipelineExecutionStartCondition(rawValue: rawValue) ?? PipelineExecutionStartCondition.sdkUnknown(rawValue)
    }
}

public enum PipelineStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension PipelineStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PipelineStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PipelineStatus(rawValue: rawValue) ?? PipelineStatus.sdkUnknown(rawValue)
    }
}

public enum Platform {
    case linux
    case windows
    case sdkUnknown(String)
}

extension Platform : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Platform] {
        return [
            .linux,
            .windows,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .linux: return "Linux"
        case .windows: return "Windows"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
    }
}

public struct PutComponentPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutComponentPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutComponentPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutComponentPolicyInput>
    public typealias MOutput = OperationOutput<PutComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutComponentPolicyOutputError>
}

extension PutComponentPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutComponentPolicyInput(componentArn: \(String(describing: componentArn)), policy: \(String(describing: policy)))"}
}

extension PutComponentPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentArn
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentArn = componentArn {
            try encodeContainer.encode(componentArn, forKey: .componentArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutComponentPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutComponentPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutComponentPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutComponentPolicyInput>
    public typealias MOutput = OperationOutput<PutComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutComponentPolicyOutputError>
}

public struct PutComponentPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutComponentPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutComponentPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutComponentPolicyInput>
    public typealias MOutput = OperationOutput<PutComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutComponentPolicyOutputError>
}

public struct PutComponentPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component that this policy should be applied to.</p>
    public let componentArn: String?
    /// <p>The policy to apply.</p>
    public let policy: String?

    public init (
        componentArn: String? = nil,
        policy: String? = nil
    )
    {
        self.componentArn = componentArn
        self.policy = policy
    }
}

struct PutComponentPolicyInputBody: Equatable {
    public let componentArn: String?
    public let policy: String?
}

extension PutComponentPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentArn
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutComponentPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutComponentPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutComponentPolicyOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutComponentPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutComponentPolicyOutputResponse(componentArn: \(String(describing: componentArn)), requestId: \(String(describing: requestId)))"}
}

extension PutComponentPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutComponentPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.componentArn = output.componentArn
            self.requestId = output.requestId
        } else {
            self.componentArn = nil
            self.requestId = nil
        }
    }
}

public struct PutComponentPolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the component that this policy was applied to.</p>
    public let componentArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        componentArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.componentArn = componentArn
        self.requestId = requestId
    }
}

struct PutComponentPolicyOutputResponseBody: Equatable {
    public let requestId: String?
    public let componentArn: String?
}

extension PutComponentPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
    }
}

public struct PutContainerRecipePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutContainerRecipePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContainerRecipePolicyInput>
    public typealias MOutput = OperationOutput<PutContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContainerRecipePolicyOutputError>
}

extension PutContainerRecipePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutContainerRecipePolicyInput(containerRecipeArn: \(String(describing: containerRecipeArn)), policy: \(String(describing: policy)))"}
}

extension PutContainerRecipePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case containerRecipeArn
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutContainerRecipePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutContainerRecipePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContainerRecipePolicyInput>
    public typealias MOutput = OperationOutput<PutContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContainerRecipePolicyOutputError>
}

public struct PutContainerRecipePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutContainerRecipePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutContainerRecipePolicyInput>
    public typealias MOutput = OperationOutput<PutContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutContainerRecipePolicyOutputError>
}

public struct PutContainerRecipePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container recipe that this policy should be applied to.</p>
    public let containerRecipeArn: String?
    /// <p>The policy to apply to the container recipe.</p>
    public let policy: String?

    public init (
        containerRecipeArn: String? = nil,
        policy: String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.policy = policy
    }
}

struct PutContainerRecipePolicyInputBody: Equatable {
    public let containerRecipeArn: String?
    public let policy: String?
}

extension PutContainerRecipePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerRecipeArn
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContainerRecipePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContainerRecipePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutContainerRecipePolicyOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContainerRecipePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutContainerRecipePolicyOutputResponse(containerRecipeArn: \(String(describing: containerRecipeArn)), requestId: \(String(describing: requestId)))"}
}

extension PutContainerRecipePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutContainerRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct PutContainerRecipePolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the container recipe that this policy was applied to.</p>
    public let containerRecipeArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        containerRecipeArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct PutContainerRecipePolicyOutputResponseBody: Equatable {
    public let requestId: String?
    public let containerRecipeArn: String?
}

extension PutContainerRecipePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

public struct PutImagePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutImagePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImagePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImagePolicyInput>
    public typealias MOutput = OperationOutput<PutImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImagePolicyOutputError>
}

extension PutImagePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImagePolicyInput(imageArn: \(String(describing: imageArn)), policy: \(String(describing: policy)))"}
}

extension PutImagePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageArn
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutImagePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutImagePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImagePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImagePolicyInput>
    public typealias MOutput = OperationOutput<PutImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImagePolicyOutputError>
}

public struct PutImagePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutImagePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImagePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImagePolicyInput>
    public typealias MOutput = OperationOutput<PutImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImagePolicyOutputError>
}

public struct PutImagePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image that this policy should be applied to.</p>
    public let imageArn: String?
    /// <p>The policy to apply.</p>
    public let policy: String?

    public init (
        imageArn: String? = nil,
        policy: String? = nil
    )
    {
        self.imageArn = imageArn
        self.policy = policy
    }
}

struct PutImagePolicyInputBody: Equatable {
    public let imageArn: String?
    public let policy: String?
}

extension PutImagePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageArn
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutImagePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImagePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImagePolicyOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImagePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImagePolicyOutputResponse(imageArn: \(String(describing: imageArn)), requestId: \(String(describing: requestId)))"}
}

extension PutImagePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutImagePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageArn = output.imageArn
            self.requestId = output.requestId
        } else {
            self.imageArn = nil
            self.requestId = nil
        }
    }
}

public struct PutImagePolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image that this policy was applied to.</p>
    public let imageArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.imageArn = imageArn
        self.requestId = requestId
    }
}

struct PutImagePolicyOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageArn: String?
}

extension PutImagePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
    }
}

public struct PutImageRecipePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutImageRecipePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageRecipePolicyInput>
    public typealias MOutput = OperationOutput<PutImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageRecipePolicyOutputError>
}

extension PutImageRecipePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageRecipePolicyInput(imageRecipeArn: \(String(describing: imageRecipeArn)), policy: \(String(describing: policy)))"}
}

extension PutImageRecipePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageRecipeArn
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutImageRecipePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutImageRecipePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageRecipePolicyInput>
    public typealias MOutput = OperationOutput<PutImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageRecipePolicyOutputError>
}

public struct PutImageRecipePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutImageRecipePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageRecipePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageRecipePolicyInput>
    public typealias MOutput = OperationOutput<PutImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageRecipePolicyOutputError>
}

public struct PutImageRecipePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to.</p>
    public let imageRecipeArn: String?
    /// <p>The policy to apply.</p>
    public let policy: String?

    public init (
        imageRecipeArn: String? = nil,
        policy: String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.policy = policy
    }
}

struct PutImageRecipePolicyInputBody: Equatable {
    public let imageRecipeArn: String?
    public let policy: String?
}

extension PutImageRecipePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageRecipeArn
        case policy
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutImageRecipePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageRecipePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageRecipePolicyOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageRecipePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageRecipePolicyOutputResponse(imageRecipeArn: \(String(describing: imageRecipeArn)), requestId: \(String(describing: requestId)))"}
}

extension PutImageRecipePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutImageRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct PutImageRecipePolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the image recipe that this policy was applied to.</p>
    public let imageRecipeArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        imageRecipeArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct PutImageRecipePolicyOutputResponseBody: Equatable {
    public let requestId: String?
    public let imageRecipeArn: String?
}

extension PutImageRecipePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource that you are trying to create already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDependencyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDependencyException(message: \(String(describing: message)))"}
}

extension ResourceDependencyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceDependencyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to mutate or delete a resource with a dependency that prohibits this
///       action. See the error message for more details.</p>
public struct ResourceDependencyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDependencyExceptionBody: Equatable {
    public let message: String?
}

extension ResourceDependencyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource that you are trying to operate on is currently in use. Review the message
///       details and retry later.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>At least one of the resources referenced by your request does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Logs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3BucketName
        case s3KeyPrefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
    }
}

extension S3Logs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Logs(s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)))"}
}

/// <p>Amazon S3 logging configuration.</p>
public struct S3Logs: Equatable {
    /// <p>The Amazon S3 bucket in which to store the logs.</p>
    public let s3BucketName: String?
    /// <p>The Amazon S3 path in which to store the logs.</p>
    public let s3KeyPrefix: String?

    public init (
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil
    )
    {
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
    }
}

extension Schedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionStartCondition
        case scheduleExpression
        case timezone
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionStartCondition = pipelineExecutionStartCondition {
            try encodeContainer.encode(pipelineExecutionStartCondition.rawValue, forKey: .pipelineExecutionStartCondition)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let pipelineExecutionStartConditionDecoded = try containerValues.decodeIfPresent(PipelineExecutionStartCondition.self, forKey: .pipelineExecutionStartCondition)
        pipelineExecutionStartCondition = pipelineExecutionStartConditionDecoded
    }
}

extension Schedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Schedule(pipelineExecutionStartCondition: \(String(describing: pipelineExecutionStartCondition)), scheduleExpression: \(String(describing: scheduleExpression)), timezone: \(String(describing: timezone)))"}
}

/// <p>A schedule configures how often and when a pipeline will automatically create a new image.</p>
public struct Schedule: Equatable {
    /// <p>The condition configures when the pipeline should trigger a new image build. When the
    ///         <code>pipelineExecutionStartCondition</code> is set to
    ///         <code>EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE</code>, and you use semantic version
    ///       filters on the source image or components in your image recipe, EC2 Image Builder will build a
    ///       new image only when there are new versions of the image or components in your recipe that
    ///       match the semantic version filter. When it is set to <code>EXPRESSION_MATCH_ONLY</code>, it
    ///       will build a new image every time the CRON expression matches the current time. For semantic
    ///       version syntax, see <a href="https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_CreateComponent.html">CreateComponent</a> in the <i> EC2 Image Builder API
    ///       Reference</i>.</p>
    public let pipelineExecutionStartCondition: PipelineExecutionStartCondition?
    /// <p>The cron expression determines how often EC2 Image Builder evaluates your
    ///         <code>pipelineExecutionStartCondition</code>.</p>
    ///          <p>For information on how to format a cron expression in Image Builder, see <a href="https://docs.aws.amazon.com/imagebuilder/latest/userguide/image-builder-cron.html">Use cron
    ///         expressions in EC2 Image Builder</a>.</p>
    public let scheduleExpression: String?
    /// <p>The timezone that applies to the scheduling expression. For example, "Etc/UTC",
    ///       "America/Los_Angeles" in the <a href="https://www.joda.org/joda-time/timezones.html">IANA
    ///         timezone format</a>. If not specified this defaults to UTC.</p>
    public let timezone: String?

    public init (
        pipelineExecutionStartCondition: PipelineExecutionStartCondition? = nil,
        scheduleExpression: String? = nil,
        timezone: String? = nil
    )
    {
        self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
        self.scheduleExpression = scheduleExpression
        self.timezone = timezone
    }
}

extension ServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceException(message: \(String(describing: message)))"}
}

extension ServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the service encounters an unrecoverable exception.</p>
public struct ServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceExceptionBody: Equatable {
    public let message: String?
}

extension ServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the number of permitted resources or operations for this service. For service quotas, see <a href="https://docs.aws.amazon.com/general/latest/gr/imagebuilder.html#limits_imagebuilder">EC2 Image Builder endpoints and quotas</a>.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The service is unable to process your request at this time.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartImagePipelineExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartImagePipelineExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImagePipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImagePipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImagePipelineExecutionInput>
    public typealias MOutput = OperationOutput<StartImagePipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImagePipelineExecutionOutputError>
}

extension StartImagePipelineExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImagePipelineExecutionInput(clientToken: \(String(describing: clientToken)), imagePipelineArn: \(String(describing: imagePipelineArn)))"}
}

extension StartImagePipelineExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imagePipelineArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imagePipelineArn = imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
    }
}

public struct StartImagePipelineExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartImagePipelineExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImagePipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImagePipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImagePipelineExecutionInput>
    public typealias MOutput = OperationOutput<StartImagePipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImagePipelineExecutionOutputError>
}

public struct StartImagePipelineExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartImagePipelineExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartImagePipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartImagePipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartImagePipelineExecutionInput>
    public typealias MOutput = OperationOutput<StartImagePipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartImagePipelineExecutionOutputError>
}

public struct StartImagePipelineExecutionInput: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke.</p>
    public let imagePipelineArn: String?

    public init (
        clientToken: String? = nil,
        imagePipelineArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
    }
}

struct StartImagePipelineExecutionInputBody: Equatable {
    public let imagePipelineArn: String?
    public let clientToken: String?
}

extension StartImagePipelineExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imagePipelineArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartImagePipelineExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImagePipelineExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImagePipelineExecutionOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImagePipelineExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartImagePipelineExecutionOutputResponse(clientToken: \(String(describing: clientToken)), imageBuildVersionArn: \(String(describing: imageBuildVersionArn)), requestId: \(String(describing: requestId)))"}
}

extension StartImagePipelineExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartImagePipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct StartImagePipelineExecutionOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the image that was created by this request.</p>
    public let imageBuildVersionArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        imageBuildVersionArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct StartImagePipelineExecutionOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let imageBuildVersionArn: String?
}

extension StartImagePipelineExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to tag.</p>
    public let resourceArn: String?
    /// <p>The tags to apply to the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TargetContainerRepository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case repositoryName
        case service
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ContainerRepositoryService.self, forKey: .service)
        service = serviceDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension TargetContainerRepository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetContainerRepository(repositoryName: \(String(describing: repositoryName)), service: \(String(describing: service)))"}
}

/// <p>The container repository where the output container image is stored.</p>
public struct TargetContainerRepository: Equatable {
    /// <p>The name of the container repository where the output container image is stored. This name is prefixed by the repository location.</p>
    public let repositoryName: String?
    /// <p>Specifies the service in which this image was registered.</p>
    public let service: ContainerRepositoryService?

    public init (
        repositoryName: String? = nil,
        service: ContainerRepositoryService? = nil
    )
    {
        self.repositoryName = repositoryName
        self.service = service
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource that you want to untag.</p>
    public let resourceArn: String?
    /// <p>The tag keys to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDistributionConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDistributionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDistributionConfigurationOutputError>
}

extension UpdateDistributionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDistributionConfigurationInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), distributionConfigurationArn: \(String(describing: distributionConfigurationArn)), distributions: \(String(describing: distributions)))"}
}

extension UpdateDistributionConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case distributionConfigurationArn
        case distributions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distributionlist0 in distributions {
                try distributionsContainer.encode(distributionlist0)
            }
        }
    }
}

public struct UpdateDistributionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDistributionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDistributionConfigurationOutputError>
}

public struct UpdateDistributionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDistributionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDistributionConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDistributionConfigurationOutputError>
}

public struct UpdateDistributionConfigurationInput: Equatable {
    /// <p>The idempotency token of the distribution configuration.</p>
    public var clientToken: String?
    /// <p>The description of the distribution configuration.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration that you want to update.</p>
    public let distributionConfigurationArn: String?
    /// <p>The distributions of the distribution configuration.</p>
    public let distributions: [Distribution]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        distributionConfigurationArn: String? = nil,
        distributions: [Distribution]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.distributions = distributions
    }
}

struct UpdateDistributionConfigurationInputBody: Equatable {
    public let distributionConfigurationArn: String?
    public let description: String?
    public let distributions: [Distribution]?
    public let clientToken: String?
}

extension UpdateDistributionConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case distributionConfigurationArn
        case distributions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDistributionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDistributionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDistributionConfigurationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDistributionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDistributionConfigurationOutputResponse(clientToken: \(String(describing: clientToken)), distributionConfigurationArn: \(String(describing: distributionConfigurationArn)), requestId: \(String(describing: requestId)))"}
}

extension UpdateDistributionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateDistributionConfigurationOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration that was updated by this
    ///       request.</p>
    public let distributionConfigurationArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        distributionConfigurationArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct UpdateDistributionConfigurationOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let distributionConfigurationArn: String?
}

extension UpdateDistributionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

public struct UpdateImagePipelineInputBodyMiddleware: Middleware {
    public let id: String = "UpdateImagePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateImagePipelineInput>
    public typealias MOutput = OperationOutput<UpdateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateImagePipelineOutputError>
}

extension UpdateImagePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateImagePipelineInput(clientToken: \(String(describing: clientToken)), containerRecipeArn: \(String(describing: containerRecipeArn)), description: \(String(describing: description)), distributionConfigurationArn: \(String(describing: distributionConfigurationArn)), enhancedImageMetadataEnabled: \(String(describing: enhancedImageMetadataEnabled)), imagePipelineArn: \(String(describing: imagePipelineArn)), imageRecipeArn: \(String(describing: imageRecipeArn)), imageTestsConfiguration: \(String(describing: imageTestsConfiguration)), infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)), schedule: \(String(describing: schedule)), status: \(String(describing: status)))"}
}

extension UpdateImagePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imagePipelineArn
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case schedule
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imagePipelineArn = imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateImagePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateImagePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateImagePipelineInput>
    public typealias MOutput = OperationOutput<UpdateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateImagePipelineOutputError>
}

public struct UpdateImagePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateImagePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateImagePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateImagePipelineInput>
    public typealias MOutput = OperationOutput<UpdateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateImagePipelineOutputError>
}

public struct UpdateImagePipelineInput: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the container pipeline to update.</p>
    public let containerRecipeArn: String?
    /// <p>The description of the image pipeline.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the distribution configuration that will be used to
    ///       configure and distribute images updated by this image pipeline.</p>
    public let distributionConfigurationArn: String?
    /// <p> Collects additional information about the image being created, including the operating
    ///       system (OS) version and package list. This information is used to enhance the overall
    ///       experience of using EC2 Image Builder. Enabled by default.</p>
    public let enhancedImageMetadataEnabled: Bool?
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that you want to update.</p>
    public let imagePipelineArn: String?
    /// <p>The Amazon Resource Name (ARN) of the image recipe that will be used to configure images
    ///       updated by this image pipeline.</p>
    public let imageRecipeArn: String?
    /// <p>The image test configuration of the image pipeline.</p>
    public let imageTestsConfiguration: ImageTestsConfiguration?
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to
    ///       build images updated by this image pipeline.</p>
    public let infrastructureConfigurationArn: String?
    /// <p>The schedule of the image pipeline.</p>
    public let schedule: Schedule?
    /// <p>The status of the image pipeline.</p>
    public let status: PipelineStatus?

    public init (
        clientToken: String? = nil,
        containerRecipeArn: String? = nil,
        description: String? = nil,
        distributionConfigurationArn: String? = nil,
        enhancedImageMetadataEnabled: Bool? = nil,
        imagePipelineArn: String? = nil,
        imageRecipeArn: String? = nil,
        imageTestsConfiguration: ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: String? = nil,
        schedule: Schedule? = nil,
        status: PipelineStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imagePipelineArn = imagePipelineArn
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.schedule = schedule
        self.status = status
    }
}

struct UpdateImagePipelineInputBody: Equatable {
    public let imagePipelineArn: String?
    public let description: String?
    public let imageRecipeArn: String?
    public let containerRecipeArn: String?
    public let infrastructureConfigurationArn: String?
    public let distributionConfigurationArn: String?
    public let imageTestsConfiguration: ImageTestsConfiguration?
    public let enhancedImageMetadataEnabled: Bool?
    public let schedule: Schedule?
    public let status: PipelineStatus?
    public let clientToken: String?
}

extension UpdateImagePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imagePipelineArn
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case schedule
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateImagePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateImagePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateImagePipelineOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateImagePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateImagePipelineOutputResponse(clientToken: \(String(describing: clientToken)), imagePipelineArn: \(String(describing: imagePipelineArn)), requestId: \(String(describing: requestId)))"}
}

extension UpdateImagePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateImagePipelineOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the image pipeline that was updated by this request.</p>
    public let imagePipelineArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        imagePipelineArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct UpdateImagePipelineOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let imagePipelineArn: String?
}

extension UpdateImagePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

public struct UpdateInfrastructureConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateInfrastructureConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInfrastructureConfigurationOutputError>
}

extension UpdateInfrastructureConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInfrastructureConfigurationInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)), instanceProfileName: \(String(describing: instanceProfileName)), instanceTypes: \(String(describing: instanceTypes)), keyPair: \(String(describing: keyPair)), logging: \(String(describing: logging)), resourceTags: \(String(describing: resourceTags)), securityGroupIds: \(String(describing: securityGroupIds)), snsTopicArn: \(String(describing: snsTopicArn)), subnetId: \(String(describing: subnetId)), terminateInstanceOnFailure: \(String(describing: terminateInstanceOnFailure)))"}
}

extension UpdateInfrastructureConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case infrastructureConfigurationArn
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetypelist0 in instanceTypes {
                try instanceTypesContainer.encode(instancetypelist0)
            }
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resourceTags)
            for (dictKey0, resourcetagmap0) in resourceTags {
                try resourceTagsContainer.encode(resourcetagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let terminateInstanceOnFailure = terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }
}

public struct UpdateInfrastructureConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateInfrastructureConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInfrastructureConfigurationOutputError>
}

public struct UpdateInfrastructureConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateInfrastructureConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateInfrastructureConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateInfrastructureConfigurationOutputError>
}

public struct UpdateInfrastructureConfigurationInput: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public var clientToken: String?
    /// <p>The description of the infrastructure configuration.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
    ///       update.</p>
    public let infrastructureConfigurationArn: String?
    /// <p>The instance profile to associate with the instance used to customize your EC2 AMI.</p>
    public let instanceProfileName: String?
    /// <p>The instance types of the infrastructure configuration. You can specify one or more
    ///       instance types to use for this build. The service will pick one of these instance types based
    ///       on availability.</p>
    public let instanceTypes: [String]?
    /// <p>The key pair of the infrastructure configuration. This can be used to log on to and debug
    ///       the instance used to create your image.</p>
    public let keyPair: String?
    /// <p>The logging configuration of the infrastructure configuration.</p>
    public let logging: Logging?
    /// <p>The tags attached to the resource created by Image Builder.</p>
    public let resourceTags: [String:String]?
    /// <p>The security group IDs to associate with the instance used to customize your EC2 AMI.</p>
    public let securityGroupIds: [String]?
    /// <p>The SNS topic on which to send image build events.</p>
    public let snsTopicArn: String?
    /// <p>The subnet ID to place the instance used to customize your EC2 AMI in.</p>
    public let subnetId: String?
    /// <p>The terminate instance on failure setting of the infrastructure configuration. Set to
    ///       false if you want Image Builder to retain the instance used to configure your AMI if the build
    ///       or test phase of your workflow fails.</p>
    public let terminateInstanceOnFailure: Bool?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        infrastructureConfigurationArn: String? = nil,
        instanceProfileName: String? = nil,
        instanceTypes: [String]? = nil,
        keyPair: String? = nil,
        logging: Logging? = nil,
        resourceTags: [String:String]? = nil,
        securityGroupIds: [String]? = nil,
        snsTopicArn: String? = nil,
        subnetId: String? = nil,
        terminateInstanceOnFailure: Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

struct UpdateInfrastructureConfigurationInputBody: Equatable {
    public let infrastructureConfigurationArn: String?
    public let description: String?
    public let instanceTypes: [String]?
    public let instanceProfileName: String?
    public let securityGroupIds: [String]?
    public let subnetId: String?
    public let logging: Logging?
    public let keyPair: String?
    public let terminateInstanceOnFailure: Bool?
    public let snsTopicArn: String?
    public let clientToken: String?
    public let resourceTags: [String:String]?
}

extension UpdateInfrastructureConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case description
        case infrastructureConfigurationArn
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case terminateInstanceOnFailure
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [String:String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension UpdateInfrastructureConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInfrastructureConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInfrastructureConfigurationOutputError: Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInfrastructureConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateInfrastructureConfigurationOutputResponse(clientToken: \(String(describing: clientToken)), infrastructureConfigurationArn: \(String(describing: infrastructureConfigurationArn)), requestId: \(String(describing: requestId)))"}
}

extension UpdateInfrastructureConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clientToken = output.clientToken
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateInfrastructureConfigurationOutputResponse: Equatable {
    /// <p>The idempotency token used to make this request idempotent.</p>
    public let clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by
    ///       this request.</p>
    public let infrastructureConfigurationArn: String?
    /// <p>The request ID that uniquely identifies this request.</p>
    public let requestId: String?

    public init (
        clientToken: String? = nil,
        infrastructureConfigurationArn: String? = nil,
        requestId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct UpdateInfrastructureConfigurationOutputResponseBody: Equatable {
    public let requestId: String?
    public let clientToken: String?
    public let infrastructureConfigurationArn: String?
}

extension UpdateInfrastructureConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}
