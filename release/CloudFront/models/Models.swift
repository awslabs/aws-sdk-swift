// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDenied: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDenied(message: \(String(describing: message)))"}
}

extension AccessDenied: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AccessDeniedBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access denied.</p>
public struct AccessDenied: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedBody: Equatable {
    public let message: String?
}

extension AccessDeniedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ActiveTrustedKeyGroups: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for kgkeypairids0 in items {
                try itemsContainer.encode(kgkeypairids0, forKey: Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([KGKeyPairIds].self, forKey: .member)
                var itemsBuffer:[KGKeyPairIds]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [KGKeyPairIds]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension ActiveTrustedKeyGroups: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveTrustedKeyGroups(enabled: \(String(describing: enabled)), items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension ActiveTrustedKeyGroups: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of key groups, and the public keys in each key group,
/// 			that CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
public struct ActiveTrustedKeyGroups: Equatable {
    /// <p>This field is <code>true</code> if any of the key groups have public keys that CloudFront can use
    /// 			to verify the signatures of signed URLs and signed cookies. If not, this field is
    /// 			<code>false</code>.</p>
    public let enabled: Bool?
    /// <p>A list of key groups, including the identifiers of the public keys in each key group that
    /// 			CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
    public let items: [KGKeyPairIds]?
    /// <p>The number of key groups in the list.</p>
    public let quantity: Int?

    public init (
        enabled: Bool? = nil,
        items: [KGKeyPairIds]? = nil,
        quantity: Int? = nil
    )
    {
        self.enabled = enabled
        self.items = items
        self.quantity = quantity
    }
}

extension ActiveTrustedSigners: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for signer0 in items {
                try itemsContainer.encode(signer0, forKey: Key("Signer"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Signer{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Signer>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Signer].self, forKey: .member)
                var itemsBuffer:[Signer]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Signer]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension ActiveTrustedSigners: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActiveTrustedSigners(enabled: \(String(describing: enabled)), items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension ActiveTrustedSigners: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of AWS accounts and the active CloudFront key pairs in each account that CloudFront can use
/// 			to verify the signatures of signed URLs and signed cookies.</p>
public struct ActiveTrustedSigners: Equatable {
    /// <p>This field is <code>true</code> if any of the AWS accounts in the list have active CloudFront
    /// 			key pairs that CloudFront can use to verify the signatures of signed URLs and signed cookies.
    /// 			If not, this field is <code>false</code>.</p>
    public let enabled: Bool?
    /// <p>A list of AWS accounts and the identifiers of active CloudFront key pairs in each account that
    /// 			CloudFront can use to verify the signatures of signed URLs and signed cookies.</p>
    public let items: [Signer]?
    /// <p>The number of AWS accounts in the list.</p>
    public let quantity: Int?

    public init (
        enabled: Bool? = nil,
        items: [Signer]? = nil,
        quantity: Int? = nil
    )
    {
        self.enabled = enabled
        self.items = items
        self.quantity = quantity
    }
}

extension AliasICPRecordal: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cNAME = "CNAME"
        case iCPRecordalStatus = "ICPRecordalStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cNAME = cNAME {
            try container.encode(cNAME, forKey: Key("cNAME"))
        }
        if let iCPRecordalStatus = iCPRecordalStatus {
            try container.encode(iCPRecordalStatus, forKey: Key("iCPRecordalStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cNAMEDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cNAME)
        cNAME = cNAMEDecoded
        let iCPRecordalStatusDecoded = try containerValues.decodeIfPresent(ICPRecordalStatus.self, forKey: .iCPRecordalStatus)
        iCPRecordalStatus = iCPRecordalStatusDecoded
    }
}

extension AliasICPRecordal: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AliasICPRecordal(cNAME: \(String(describing: cNAME)), iCPRecordalStatus: \(String(describing: iCPRecordalStatus)))"}
}

extension AliasICPRecordal: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>AWS services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
/// 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
/// 			recordal status for CNAMEs associated with distributions. The status is returned in the CloudFront response; you can't configure
/// 			it yourself.</p>
/// 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
/// 			Signup, Accounts, and Credentials</a> in <i>Getting Started with AWS services in China</i>.</p>
public struct AliasICPRecordal: Equatable {
    /// <p>A domain name associated with a distribution. </p>
    public let cNAME: String?
    /// <p>The Internet Content Provider (ICP) recordal status for a CNAME. The ICPRecordalStatus is set to
    /// 			APPROVED for all CNAMEs (aliases) in regions outside of China. </p>
    /// 		       <p>The status values returned are the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <b>APPROVED</b> indicates that the associated CNAME has a valid ICP recordal number.
    /// 			Multiple CNAMEs can be associated with a distribution, and CNAMEs can correspond to different ICP recordals. To be marked as
    /// 			APPROVED, that is, valid to use with China region, a CNAME must have one ICP recordal number associated with it.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>SUSPENDED</b> indicates that the associated CNAME does not have a valid ICP recordal
    /// 				number.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>PENDING</b> indicates that CloudFront can't determine the ICP recordal status of the
    /// 				CNAME associated with the distribution because there was an error in trying to determine the status. You can try again
    /// 				to see if the error is resolved in which case CloudFront returns an APPROVED or SUSPENDED status.</p>
    ///             </li>
    ///          </ul>
    public let iCPRecordalStatus: ICPRecordalStatus?

    public init (
        cNAME: String? = nil,
        iCPRecordalStatus: ICPRecordalStatus? = nil
    )
    {
        self.cNAME = cNAME
        self.iCPRecordalStatus = iCPRecordalStatus
    }
}

extension Aliases: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("CNAME"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CNAME{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CNAME>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension Aliases: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Aliases(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension Aliases: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
/// 			for this distribution. </p>
public struct Aliases: Equatable {
    /// <p>A complex type that contains the CNAME aliases, if any, that you want to associate with
    /// 			this distribution.</p>
    public let items: [String]?
    /// <p>The number of CNAME aliases, if any, that you want to associate with this
    /// 			distribution.</p>
    public let quantity: Int?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension AllowedMethods: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachedMethods = "CachedMethods"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cachedMethods = cachedMethods {
            try container.encode(cachedMethods, forKey: Key("cachedMethods"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Method].self, forKey: .member)
                var itemsBuffer:[Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Method]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let cachedMethodsDecoded = try containerValues.decodeIfPresent(CachedMethods.self, forKey: .cachedMethods)
        cachedMethods = cachedMethodsDecoded
    }
}

extension AllowedMethods: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllowedMethods(cachedMethods: \(String(describing: cachedMethods)), items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension AllowedMethods: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
/// 			Amazon S3 bucket or your custom origin. There are three choices:</p>
/// 		       <ul>
///             <li>
/// 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
/// 			         </li>
///             <li>
/// 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
/// 					requests.</p>
/// 			         </li>
///             <li>
/// 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
/// 						<code>DELETE</code> requests.</p>
/// 			         </li>
///          </ul>
/// 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
/// 			to your custom origin so users can't perform operations that you don't want them to. For
/// 			example, you might not want users to have permissions to delete objects from your
/// 			origin.</p>
public struct AllowedMethods: Equatable {
    /// <p>A complex type that controls whether CloudFront caches the response to requests using the
    /// 			specified HTTP methods. There are two choices:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>CloudFront caches responses to <code>GET</code> and <code>HEAD</code> requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>CloudFront caches responses to <code>GET</code>, <code>HEAD</code>, and
    /// 						<code>OPTIONS</code> requests.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>If you pick the second choice for your Amazon S3 Origin, you may need to forward
    /// 			Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the
    /// 			responses to be cached correctly. </p>
    public let cachedMethods: CachedMethods?
    /// <p>A complex type that contains the HTTP methods that you want CloudFront to process and forward
    /// 			to your origin.</p>
    public let items: [Method]?
    /// <p>The number of HTTP methods that you want CloudFront to forward to your origin. Valid values
    /// 			are 2 (for <code>GET</code> and <code>HEAD</code> requests), 3 (for <code>GET</code>,
    /// 				<code>HEAD</code>, and <code>OPTIONS</code> requests) and 7 (for <code>GET, HEAD, OPTIONS,
    /// 				PUT, PATCH, POST</code>, and <code>DELETE</code> requests).</p>
    public let quantity: Int?

    public init (
        cachedMethods: CachedMethods? = nil,
        items: [Method]? = nil,
        quantity: Int? = nil
    )
    {
        self.cachedMethods = cachedMethods
        self.items = items
        self.quantity = quantity
    }
}

extension BatchTooLarge: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchTooLarge(message: \(String(describing: message)))"}
}

extension BatchTooLarge: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<BatchTooLargeBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Invalidation batch specified is too large.</p>
public struct BatchTooLarge: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BatchTooLargeBody: Equatable {
    public let message: String?
}

extension BatchTooLargeBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CNAMEAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CNAMEAlreadyExists(message: \(String(describing: message)))"}
}

extension CNAMEAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CNAMEAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CNAME specified is already defined for CloudFront.</p>
public struct CNAMEAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CNAMEAlreadyExistsBody: Equatable {
    public let message: String?
}

extension CNAMEAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CacheBehavior: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case pathPattern = "PathPattern"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: Key("allowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: Key("cachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: Key("compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: Key("defaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: Key("fieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: Key("forwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: Key("functionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: Key("lambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: Key("maxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: Key("minTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: Key("originRequestPolicyId"))
        }
        if let pathPattern = pathPattern {
            try container.encode(pathPattern, forKey: Key("pathPattern"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: Key("realtimeLogConfigArn"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: Key("smoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: Key("targetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: Key("trustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: Key("trustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: Key("viewerProtocolPolicy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pathPattern)
        pathPattern = pathPatternDecoded
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension CacheBehavior: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CacheBehavior(allowedMethods: \(String(describing: allowedMethods)), cachePolicyId: \(String(describing: cachePolicyId)), compress: \(String(describing: compress)), defaultTTL: \(String(describing: defaultTTL)), fieldLevelEncryptionId: \(String(describing: fieldLevelEncryptionId)), forwardedValues: \(String(describing: forwardedValues)), functionAssociations: \(String(describing: functionAssociations)), lambdaFunctionAssociations: \(String(describing: lambdaFunctionAssociations)), maxTTL: \(String(describing: maxTTL)), minTTL: \(String(describing: minTTL)), originRequestPolicyId: \(String(describing: originRequestPolicyId)), pathPattern: \(String(describing: pathPattern)), realtimeLogConfigArn: \(String(describing: realtimeLogConfigArn)), smoothStreaming: \(String(describing: smoothStreaming)), targetOriginId: \(String(describing: targetOriginId)), trustedKeyGroups: \(String(describing: trustedKeyGroups)), trustedSigners: \(String(describing: trustedSigners)), viewerProtocolPolicy: \(String(describing: viewerProtocolPolicy)))"}
}

extension CacheBehavior: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that describes how CloudFront processes requests.</p>
/// 		       <p>You must create at least as many cache behaviors (including the default cache behavior) as
/// 			you have origins if you want CloudFront to serve objects from all of the origins. Each cache
/// 			behavior specifies the one origin from which you want CloudFront to get objects. If you have
/// 			two origins and only the default cache behavior, the default cache behavior will cause
/// 			CloudFront to get objects from one of the origins, but the other origin is never used.</p>
/// 		       <p>For the current quota (formerly known as limit) on the number of cache behaviors that you
/// 			can add to a distribution, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
/// 		       <p>If you don’t want to specify any cache behaviors, include only an empty
/// 			<code>CacheBehaviors</code> element. Don’t include an empty <code>CacheBehavior</code>
/// 			element because this is invalid.</p>
/// 		       <p>To delete all cache behaviors in an existing distribution, update the distribution
/// 			configuration and include only an empty <code>CacheBehaviors</code> element.</p>
/// 		       <p>To add, change, or remove one or more cache behaviors, update the distribution
/// 			configuration and specify all of the cache behaviors that you want to include in the updated
/// 			distribution.</p>
/// 		       <p>For more information about cache behaviors, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesCacheBehavior">Cache Behavior Settings</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
public struct CacheBehavior: Equatable {
    /// <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
    /// 			Amazon S3 bucket or your custom origin. There are three choices:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
    /// 					requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
    /// 						<code>DELETE</code> requests.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
    /// 			to your custom origin so users can't perform operations that you don't want them to. For
    /// 			example, you might not want users to have permissions to delete objects from your
    /// 			origin.</p>
    public let allowedMethods: AllowedMethods?
    /// <p>The unique identifier of the cache policy that is attached to this cache behavior. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    ///             <i>Amazon CloudFront Developer Guide</i>.</p>
    ///         <p>A <code>CacheBehavior</code> must include either a
    ///             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
    ///             use a <code>CachePolicyId</code>.</p>
    public let cachePolicyId: String?
    /// <p>Whether you want CloudFront to automatically compress certain files for this cache behavior.
    /// 			If so, specify true; if not, specify false. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html">Serving Compressed Files</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public let compress: Bool?
    /// <p>This field is deprecated. We recommend that you use the <code>DefaultTTL</code> field in a
    /// 			cache policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>The default amount of time that you want objects to stay in CloudFront caches before CloudFront
    /// 			forwards another request to your origin to determine whether the object has been updated. The
    /// 			value that you specify applies only when your origin does not add HTTP headers such as
    /// 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
    /// 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
    /// 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    @available(*, deprecated)
    public let defaultTTL: Int?
    /// <p>The value of <code>ID</code> for the field-level encryption configuration that you want CloudFront
    /// 			to use for encrypting specific fields of data for this cache behavior.</p>
    public let fieldLevelEncryptionId: String?
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html">Working with policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to include values in the cache key, use a cache policy. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send values to the origin but not include them in the cache key, use an
    /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
    ///             <i>Amazon CloudFront Developer Guide</i>.</p>
    ///         <p>A <code>CacheBehavior</code> must include either a
    ///             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
    ///             use a <code>CachePolicyId</code>.</p>
    /// 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
    @available(*, deprecated)
    public let forwardedValues: ForwardedValues?
    /// <p>A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must
    /// 			be published to the <code>LIVE</code> stage to associate them with a cache
    /// 			behavior.</p>
    public let functionAssociations: FunctionAssociations?
    /// <p>A complex type that contains zero or more Lambda function associations for a cache
    /// 			behavior.</p>
    public let lambdaFunctionAssociations: LambdaFunctionAssociations?
    /// <p>This field is deprecated. We recommend that you use the <code>MaxTTL</code> field in a cache
    /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront
    /// 			forwards another request to your origin to determine whether the object has been updated. The
    /// 			value that you specify applies only when your origin adds HTTP headers such as
    /// 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
    /// 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
    /// 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    @available(*, deprecated)
    public let maxTTL: Int?
    /// <p>This field is deprecated. We recommend that you use the <code>MinTTL</code> field in a cache
    /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront
    /// 			forwards another request to your origin to determine whether the object has been updated. For
    /// 			more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">
    /// 				Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the <i>
    /// 				Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>You must specify <code>0</code> for <code>MinTTL</code> if you configure CloudFront to
    /// 			forward all headers to your origin (under <code>Headers</code>, if you specify <code>1</code>
    /// 			for <code>Quantity</code> and <code>*</code> for <code>Name</code>).</p>
    @available(*, deprecated)
    public let minTTL: Int?
    /// <p>The unique identifier of the origin request policy that is attached to this cache behavior.
    /// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let originRequestPolicyId: String?
    /// <p>The pattern (for example, <code>images/*.jpg</code>) that specifies which requests to
    /// 			apply the behavior to. When CloudFront receives a viewer request, the requested path is compared
    /// 			with path patterns in the order in which cache behaviors are listed in the
    /// 			distribution.</p>
    /// 		       <note>
    /// 			         <p>You can optionally include a slash (<code>/</code>) at the beginning of the path
    /// 				pattern. For example, <code>/images/*.jpg</code>. CloudFront behavior is the same with or without
    /// 				the leading <code>/</code>.</p>
    /// 		       </note>
    /// 		       <p>The path pattern for the default cache behavior is <code>*</code> and cannot be
    /// 			changed. If the request for an object does not match the path pattern for any cache behaviors,
    /// 			CloudFront applies the behavior in the default cache behavior.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesPathPattern">Path
    /// 				Pattern</a> in the <i> Amazon CloudFront Developer Guide</i>.</p>
    public let pathPattern: String?
    /// <p>The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this
    /// 			cache behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let realtimeLogConfigArn: String?
    /// <p>Indicates whether you want to distribute media files in the Microsoft Smooth Streaming
    /// 			format using the origin that is associated with this cache behavior. If so, specify
    /// 				<code>true</code>; if not, specify <code>false</code>. If you specify <code>true</code> for
    /// 				<code>SmoothStreaming</code>, you can still distribute other content using this cache
    /// 			behavior if the content matches the value of <code>PathPattern</code>. </p>
    public let smoothStreaming: Bool?
    /// <p>The value of <code>ID</code> for the origin that you want CloudFront to route requests to
    /// 			when they match this cache behavior.</p>
    public let targetOriginId: String?
    /// <p>A list of key groups that CloudFront can use to validate signed URLs or signed cookies.</p>
    /// 		       <p>When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed
    /// 			cookies for all requests that match the cache behavior. The URLs or cookies must be
    /// 			signed with a private key whose corresponding public key is in the key group. The signed
    /// 			URL or cookie contains information about which public key CloudFront should use to verify the
    /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let trustedKeyGroups: TrustedKeyGroups?
    /// <important>
    /// 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
    /// 				<code>TrustedSigners</code>.</p>
    /// 		       </important>
    /// 		       <p>A list of AWS account IDs whose public keys CloudFront can use to validate signed URLs or signed
    /// 			cookies.</p>
    /// 		       <p>When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies
    /// 			for all requests that match the cache behavior. The URLs or cookies must be signed with
    /// 			the private key of a CloudFront key pair in the trusted signer’s AWS account. The signed URL
    /// 			or cookie contains information about which public key CloudFront should use to verify the
    /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let trustedSigners: TrustedSigners?
    /// <p>The protocol that viewers can use to access the files in the origin specified by
    /// 				<code>TargetOriginId</code> when a request matches the path pattern in
    /// 				<code>PathPattern</code>. You can specify the following options:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>allow-all</code>: Viewers can use HTTP or HTTPS.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>redirect-to-https</code>: If a viewer submits an HTTP request, CloudFront returns
    /// 					an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The
    /// 					viewer then resubmits the request using the new URL. </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>https-only</code>: If a viewer sends an HTTP request, CloudFront returns an HTTP
    /// 					status code of 403 (Forbidden). </p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information about requiring the HTTPS protocol, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html">Requiring HTTPS Between Viewers and CloudFront</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <note>
    /// 			         <p>The only way to guarantee that viewers retrieve an object that was fetched from the origin
    /// 				using HTTPS is never to use any other protocol to fetch the object. If you have
    /// 				recently changed from HTTP to HTTPS, we recommend that you clear your objects’ cache
    /// 				because cached objects are protocol agnostic. That means that an edge location will
    /// 				return an object from the cache regardless of whether the current request protocol
    /// 				matches the protocol used previously. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing Cache Expiration</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       </note>
    public let viewerProtocolPolicy: ViewerProtocolPolicy?

    public init (
        allowedMethods: AllowedMethods? = nil,
        cachePolicyId: String? = nil,
        compress: Bool? = nil,
        defaultTTL: Int? = nil,
        fieldLevelEncryptionId: String? = nil,
        forwardedValues: ForwardedValues? = nil,
        functionAssociations: FunctionAssociations? = nil,
        lambdaFunctionAssociations: LambdaFunctionAssociations? = nil,
        maxTTL: Int? = nil,
        minTTL: Int? = nil,
        originRequestPolicyId: String? = nil,
        pathPattern: String? = nil,
        realtimeLogConfigArn: String? = nil,
        smoothStreaming: Bool? = nil,
        targetOriginId: String? = nil,
        trustedKeyGroups: TrustedKeyGroups? = nil,
        trustedSigners: TrustedSigners? = nil,
        viewerProtocolPolicy: ViewerProtocolPolicy? = nil
    )
    {
        self.allowedMethods = allowedMethods
        self.cachePolicyId = cachePolicyId
        self.compress = compress
        self.defaultTTL = defaultTTL
        self.fieldLevelEncryptionId = fieldLevelEncryptionId
        self.forwardedValues = forwardedValues
        self.functionAssociations = functionAssociations
        self.lambdaFunctionAssociations = lambdaFunctionAssociations
        self.maxTTL = maxTTL
        self.minTTL = minTTL
        self.originRequestPolicyId = originRequestPolicyId
        self.pathPattern = pathPattern
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.smoothStreaming = smoothStreaming
        self.targetOriginId = targetOriginId
        self.trustedKeyGroups = trustedKeyGroups
        self.trustedSigners = trustedSigners
        self.viewerProtocolPolicy = viewerProtocolPolicy
    }
}

extension CacheBehaviors: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for cachebehavior0 in items {
                try itemsContainer.encode(cachebehavior0, forKey: Key("CacheBehavior"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CacheBehavior{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CacheBehavior>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CacheBehavior].self, forKey: .member)
                var itemsBuffer:[CacheBehavior]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CacheBehavior]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CacheBehaviors: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CacheBehaviors(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension CacheBehaviors: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains zero or more <code>CacheBehavior</code> elements.
/// 		</p>
public struct CacheBehaviors: Equatable {
    /// <p>Optional: A complex type that contains cache behaviors for this distribution. If
    /// 				<code>Quantity</code> is <code>0</code>, you can omit <code>Items</code>.</p>
    public let items: [CacheBehavior]?
    /// <p>The number of cache behaviors for this distribution. </p>
    public let quantity: Int?

    public init (
        items: [CacheBehavior]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension CachePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: Key("cachePolicyConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CachePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicy(cachePolicyConfig: \(String(describing: cachePolicyConfig)), id: \(String(describing: id)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension CachePolicy: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A cache policy.</p>
/// 		       <p>When it’s attached to a cache behavior, the cache policy determines the
/// 			following:</p>
/// 		       <ul>
///             <li>
/// 				           <p>The values that CloudFront includes in the cache key. These values can include HTTP headers,
/// 					cookies, and URL query strings. CloudFront uses the cache key to find an object in its
/// 					cache that it can return to the viewer.</p>
/// 			         </li>
///             <li>
/// 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
/// 					in the CloudFront cache.</p>
/// 			         </li>
///          </ul>
/// 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
/// 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
/// 			find a valid object in its cache that matches the request’s cache key. If you want to
/// 			send values to the origin but <i>not</i> include them in the cache key,
/// 			use <code>OriginRequestPolicy</code>.</p>
public struct CachePolicy: Equatable {
    /// <p>The cache policy configuration.</p>
    public let cachePolicyConfig: CachePolicyConfig?
    /// <p>The unique identifier for the cache policy.</p>
    public let id: String?
    /// <p>The date and time when the cache policy was last modified.</p>
    public let lastModifiedTime: Date?

    public init (
        cachePolicyConfig: CachePolicyConfig? = nil,
        id: String? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.id = id
        self.lastModifiedTime = lastModifiedTime
    }
}

extension CachePolicyAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicyAlreadyExists(message: \(String(describing: message)))"}
}

extension CachePolicyAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CachePolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A cache policy with this name already exists. You must provide a unique name. To
/// 			modify an existing cache policy, use <code>UpdateCachePolicy</code>.</p>
public struct CachePolicyAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CachePolicyAlreadyExistsBody: Equatable {
    public let message: String?
}

extension CachePolicyAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CachePolicyConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case defaultTTL = "DefaultTTL"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case name = "Name"
        case parametersInCacheKeyAndForwardedToOrigin = "ParametersInCacheKeyAndForwardedToOrigin"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: Key("defaultTTL"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: Key("maxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: Key("minTTL"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin {
            try container.encode(parametersInCacheKeyAndForwardedToOrigin, forKey: Key("parametersInCacheKeyAndForwardedToOrigin"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let parametersInCacheKeyAndForwardedToOriginDecoded = try containerValues.decodeIfPresent(ParametersInCacheKeyAndForwardedToOrigin.self, forKey: .parametersInCacheKeyAndForwardedToOrigin)
        parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOriginDecoded
    }
}

extension CachePolicyConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicyConfig(comment: \(String(describing: comment)), defaultTTL: \(String(describing: defaultTTL)), maxTTL: \(String(describing: maxTTL)), minTTL: \(String(describing: minTTL)), name: \(String(describing: name)), parametersInCacheKeyAndForwardedToOrigin: \(String(describing: parametersInCacheKeyAndForwardedToOrigin)))"}
}

extension CachePolicyConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A cache policy configuration.</p>
/// 		       <p>This configuration determines the following:</p>
/// 		       <ul>
///             <li>
/// 				           <p>The values that CloudFront includes in the cache key. These values can include HTTP headers,
/// 					cookies, and URL query strings. CloudFront uses the cache key to find an object in its
/// 					cache that it can return to the viewer.</p>
/// 			         </li>
///             <li>
/// 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
/// 					in the CloudFront cache.</p>
/// 			         </li>
///          </ul>
/// 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
/// 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
/// 			find a valid object in its cache that matches the request’s cache key. If you want to
/// 			send values to the origin but <i>not</i> include them in the cache key,
/// 			use <code>OriginRequestPolicy</code>.</p>
public struct CachePolicyConfig: Equatable {
    /// <p>A comment to describe the cache policy. The comment cannot be longer than 128
    /// 			characters.</p>
    public let comment: String?
    /// <p>The default amount of time, in seconds, that you want objects to stay in the CloudFront
    /// 			cache before CloudFront sends another request to the origin to see if the object has been
    /// 			updated. CloudFront uses this value as the object’s time to live (TTL) only when the origin
    /// 			does <i>not</i> send <code>Cache-Control</code> or <code>Expires</code>
    /// 			headers with the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>The default value for this field is 86400 seconds (one day). If the value of
    /// 			<code>MinTTL</code> is more than 86400 seconds, then the default value for this field is
    /// 			the same as the value of <code>MinTTL</code>.</p>
    public let defaultTTL: Int?
    /// <p>The maximum amount of time, in seconds, that objects stay in the CloudFront cache
    /// 			before CloudFront sends another request to the origin to see if the object has been updated.
    /// 			CloudFront uses this value only when the origin sends <code>Cache-Control</code> or
    /// 			<code>Expires</code> headers with the object. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>The default value for this field is 31536000 seconds (one year). If the value of
    /// 			<code>MinTTL</code> or <code>DefaultTTL</code> is more than 31536000 seconds, then the
    /// 			default value for this field is the same as the value of <code>DefaultTTL</code>.</p>
    public let maxTTL: Int?
    /// <p>The minimum amount of time, in seconds, that you want objects to stay in the CloudFront
    /// 			cache before CloudFront sends another request to the origin to see if the object has been
    /// 			updated. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays in an Edge Cache (Expiration)</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let minTTL: Int?
    /// <p>A unique name to identify the cache policy.</p>
    public let name: String?
    /// <p>The HTTP headers, cookies, and URL query strings to include in the cache key. The
    /// 			values included in the cache key are automatically included in requests that CloudFront sends
    /// 			to the origin.</p>
    public let parametersInCacheKeyAndForwardedToOrigin: ParametersInCacheKeyAndForwardedToOrigin?

    public init (
        comment: String? = nil,
        defaultTTL: Int? = nil,
        maxTTL: Int? = nil,
        minTTL: Int? = nil,
        name: String? = nil,
        parametersInCacheKeyAndForwardedToOrigin: ParametersInCacheKeyAndForwardedToOrigin? = nil
    )
    {
        self.comment = comment
        self.defaultTTL = defaultTTL
        self.maxTTL = maxTTL
        self.minTTL = minTTL
        self.name = name
        self.parametersInCacheKeyAndForwardedToOrigin = parametersInCacheKeyAndForwardedToOrigin
    }
}

public enum CachePolicyCookieBehavior {
    case all
    case allexcept
    case `none`
    case whitelist
    case sdkUnknown(String)
}

extension CachePolicyCookieBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CachePolicyCookieBehavior] {
        return [
            .all,
            .allexcept,
            .none,
            .whitelist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "all"
        case .allexcept: return "allExcept"
        case .none: return "none"
        case .whitelist: return "whitelist"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CachePolicyCookieBehavior(rawValue: rawValue) ?? CachePolicyCookieBehavior.sdkUnknown(rawValue)
    }
}

extension CachePolicyCookiesConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: Key("cookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: Key("cookies"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(CachePolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension CachePolicyCookiesConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicyCookiesConfig(cookieBehavior: \(String(describing: cookieBehavior)), cookies: \(String(describing: cookies)))"}
}

extension CachePolicyCookiesConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
/// 			are included in the cache key and automatically included in requests that CloudFront sends to
/// 			the origin.</p>
public struct CachePolicyCookiesConfig: Equatable {
    /// <p>Determines whether any cookies in viewer requests are included in the cache key and
    /// 			automatically included in requests that CloudFront sends to the origin. Valid values
    /// 			are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>none</code> – Cookies in viewer requests are not included in the cache key and are
    /// 					not automatically included in requests that CloudFront sends to the origin. Even when
    /// 					this field is set to <code>none</code>, any cookies that are listed in an
    /// 					<code>OriginRequestPolicy</code>
    ///                   <i>are</i> included in origin
    /// 					requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>whitelist</code> – The cookies in viewer requests that are listed in the
    /// 					<code>CookieNames</code> type are included in the cache key and automatically
    /// 					included in requests that CloudFront sends to the origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>allExcept</code> – All cookies in viewer requests that are <i>
    ///                      <b>not</b>
    ///                   </i> listed in the <code>CookieNames</code>
    /// 					type are included in the cache key and automatically included in requests that
    /// 					CloudFront sends to the origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>all</code> – All cookies in viewer requests are included in the cache key and are
    /// 					automatically included in requests that CloudFront sends to the origin.</p>
    /// 			         </li>
    ///          </ul>
    public let cookieBehavior: CachePolicyCookieBehavior?
    /// <p>Contains a list of cookie names.</p>
    public let cookies: CookieNames?

    public init (
        cookieBehavior: CachePolicyCookieBehavior? = nil,
        cookies: CookieNames? = nil
    )
    {
        self.cookieBehavior = cookieBehavior
        self.cookies = cookies
    }
}

public enum CachePolicyHeaderBehavior {
    case `none`
    case whitelist
    case sdkUnknown(String)
}

extension CachePolicyHeaderBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CachePolicyHeaderBehavior] {
        return [
            .none,
            .whitelist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "none"
        case .whitelist: return "whitelist"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CachePolicyHeaderBehavior(rawValue: rawValue) ?? CachePolicyHeaderBehavior.sdkUnknown(rawValue)
    }
}

extension CachePolicyHeadersConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: Key("headerBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: Key("headers"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(CachePolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension CachePolicyHeadersConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicyHeadersConfig(headerBehavior: \(String(describing: headerBehavior)), headers: \(String(describing: headers)))"}
}

extension CachePolicyHeadersConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An object that determines whether any HTTP headers (and if so, which headers) are included
/// 			in the cache key and automatically included in requests that CloudFront sends to the
/// 			origin.</p>
public struct CachePolicyHeadersConfig: Equatable {
    /// <p>Determines whether any HTTP headers are included in the cache key and automatically
    /// 			included in requests that CloudFront sends to the origin. Valid values are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>none</code> – HTTP headers are not included in the cache key and are not
    /// 					automatically included in requests that CloudFront sends to the origin. Even when this
    /// 					field is set to <code>none</code>, any headers that are listed in an
    /// 					<code>OriginRequestPolicy</code>
    ///                   <i>are</i> included in origin
    /// 					requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>whitelist</code> – The HTTP headers that are listed in the <code>Headers</code> type
    /// 					are included in the cache key and are automatically included in requests that
    /// 					CloudFront sends to the origin.</p>
    /// 			         </li>
    ///          </ul>
    public let headerBehavior: CachePolicyHeaderBehavior?
    /// <p>Contains a list of HTTP header names.</p>
    public let headers: Headers?

    public init (
        headerBehavior: CachePolicyHeaderBehavior? = nil,
        headers: Headers? = nil
    )
    {
        self.headerBehavior = headerBehavior
        self.headers = headers
    }
}

extension CachePolicyInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicyInUse(message: \(String(describing: message)))"}
}

extension CachePolicyInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CachePolicyInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete the cache policy because it is attached to one or more cache
/// 			behaviors.</p>
public struct CachePolicyInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CachePolicyInUseBody: Equatable {
    public let message: String?
}

extension CachePolicyInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CachePolicyList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for cachepolicysummary0 in items {
                try itemsContainer.encode(cachepolicysummary0, forKey: Key("CachePolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CachePolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CachePolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CachePolicySummary].self, forKey: .member)
                var itemsBuffer:[CachePolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CachePolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CachePolicyList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicyList(items: \(String(describing: items)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension CachePolicyList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of cache policies.</p>
public struct CachePolicyList: Equatable {
    /// <p>Contains the cache policies in the list.</p>
    public let items: [CachePolicySummary]?
    /// <p>The maximum number of cache policies requested.</p>
    public let maxItems: Int?
    /// <p>If there are more items in the list than are in this response, this element is
    /// 			present. It contains the value that you should use in the <code>Marker</code> field of a
    /// 			subsequent request to continue listing cache policies where you left off.</p>
    public let nextMarker: String?
    /// <p>The total number of cache policies returned in the response.</p>
    public let quantity: Int?

    public init (
        items: [CachePolicySummary]? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

public enum CachePolicyQueryStringBehavior {
    case all
    case allexcept
    case `none`
    case whitelist
    case sdkUnknown(String)
}

extension CachePolicyQueryStringBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CachePolicyQueryStringBehavior] {
        return [
            .all,
            .allexcept,
            .none,
            .whitelist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "all"
        case .allexcept: return "allExcept"
        case .none: return "none"
        case .whitelist: return "whitelist"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CachePolicyQueryStringBehavior(rawValue: rawValue) ?? CachePolicyQueryStringBehavior.sdkUnknown(rawValue)
    }
}

extension CachePolicyQueryStringsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: Key("queryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: Key("queryStrings"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(CachePolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension CachePolicyQueryStringsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicyQueryStringsConfig(queryStringBehavior: \(String(describing: queryStringBehavior)), queryStrings: \(String(describing: queryStrings)))"}
}

extension CachePolicyQueryStringsConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An object that determines whether any URL query strings in viewer requests (and if so, which
/// 			query strings) are included in the cache key and automatically included in requests that
/// 			CloudFront sends to the origin.</p>
public struct CachePolicyQueryStringsConfig: Equatable {
    /// <p>Determines whether any URL query strings in viewer requests are included in the cache key
    /// 			and automatically included in requests that CloudFront sends to the origin. Valid values
    /// 			are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>none</code> – Query strings in viewer requests are not included in the cache key and
    /// 					are not automatically included in requests that CloudFront sends to the origin. Even
    /// 					when this field is set to <code>none</code>, any query strings that are listed
    /// 					in an <code>OriginRequestPolicy</code>
    ///                   <i>are</i> included in
    /// 					origin requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>whitelist</code> – The query strings in viewer requests that are listed in the
    /// 					<code>QueryStringNames</code> type are included in the cache key and
    /// 					automatically included in requests that CloudFront sends to the origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>allExcept</code> – All query strings in viewer requests that are <i>
    ///                      <b>not</b>
    ///                   </i> listed in the
    /// 					<code>QueryStringNames</code> type are included in the cache key and
    /// 					automatically included in requests that CloudFront sends to the origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>all</code> – All query strings in viewer requests are included in the cache key and
    /// 					are automatically included in requests that CloudFront sends to the origin.</p>
    /// 			         </li>
    ///          </ul>
    public let queryStringBehavior: CachePolicyQueryStringBehavior?
    /// <p>Contains the specific query strings in viewer requests that either <i>
    ///                <b>are</b>
    ///             </i> or <i>
    ///                <b>are
    /// 			not</b>
    ///             </i> included in the cache key and automatically included in
    /// 			requests that CloudFront sends to the origin. The behavior depends on whether the
    /// 			<code>QueryStringBehavior</code> field in the <code>CachePolicyQueryStringsConfig</code>
    /// 			type is set to <code>whitelist</code> (the listed query strings <i>
    ///                <b>are</b>
    ///             </i> included) or <code>allExcept</code> (the listed
    /// 			query strings <i>
    ///                <b>are not</b>
    ///             </i> included,
    /// 			but all other query strings are).</p>
    public let queryStrings: QueryStringNames?

    public init (
        queryStringBehavior: CachePolicyQueryStringBehavior? = nil,
        queryStrings: QueryStringNames? = nil
    )
    {
        self.queryStringBehavior = queryStringBehavior
        self.queryStrings = queryStrings
    }
}

extension CachePolicySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachePolicy = "CachePolicy"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cachePolicy = cachePolicy {
            try container.encode(cachePolicy, forKey: Key("cachePolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CachePolicyType.self, forKey: .type)
        type = typeDecoded
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension CachePolicySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachePolicySummary(cachePolicy: \(String(describing: cachePolicy)), type: \(String(describing: type)))"}
}

extension CachePolicySummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains a cache policy.</p>
public struct CachePolicySummary: Equatable {
    /// <p>The cache policy.</p>
    public let cachePolicy: CachePolicy?
    /// <p>The type of cache policy, either <code>managed</code> (created by AWS) or
    /// 			<code>custom</code> (created in this AWS account).</p>
    public let type: CachePolicyType?

    public init (
        cachePolicy: CachePolicy? = nil,
        type: CachePolicyType? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.type = type
    }
}

public enum CachePolicyType {
    case custom
    case managed
    case sdkUnknown(String)
}

extension CachePolicyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CachePolicyType] {
        return [
            .custom,
            .managed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "custom"
        case .managed: return "managed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CachePolicyType(rawValue: rawValue) ?? CachePolicyType.sdkUnknown(rawValue)
    }
}

extension CachedMethods: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for method0 in items {
                try itemsContainer.encode(method0, forKey: Key("Method"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Method{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Method>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Method].self, forKey: .member)
                var itemsBuffer:[Method]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Method]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CachedMethods: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CachedMethods(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension CachedMethods: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that controls whether CloudFront caches the response to requests using the
/// 			specified HTTP methods. There are two choices:</p>
/// 		       <ul>
///             <li>
/// 				           <p>CloudFront caches responses to <code>GET</code> and <code>HEAD</code> requests.</p>
/// 			         </li>
///             <li>
/// 				           <p>CloudFront caches responses to <code>GET</code>, <code>HEAD</code>, and
/// 						<code>OPTIONS</code> requests.</p>
/// 			         </li>
///          </ul>
/// 		       <p>If you pick the second choice for your Amazon S3 Origin, you may need to forward
/// 			Access-Control-Request-Method, Access-Control-Request-Headers, and Origin headers for the
/// 			responses to be cached correctly. </p>
public struct CachedMethods: Equatable {
    /// <p>A complex type that contains the HTTP methods that you want CloudFront to cache responses
    /// 			to.</p>
    public let items: [Method]?
    /// <p>The number of HTTP methods for which you want CloudFront to cache responses. Valid values are
    /// 				<code>2</code> (for caching responses to <code>GET</code> and <code>HEAD</code> requests)
    /// 			and <code>3</code> (for caching responses to <code>GET</code>, <code>HEAD</code>, and
    /// 				<code>OPTIONS</code> requests).</p>
    public let quantity: Int?

    public init (
        items: [Method]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension CannotChangeImmutablePublicKeyFields: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CannotChangeImmutablePublicKeyFields(message: \(String(describing: message)))"}
}

extension CannotChangeImmutablePublicKeyFields: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CannotChangeImmutablePublicKeyFieldsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't change the value of a public key.</p>
public struct CannotChangeImmutablePublicKeyFields: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CannotChangeImmutablePublicKeyFieldsBody: Equatable {
    public let message: String?
}

extension CannotChangeImmutablePublicKeyFieldsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum CertificateSource {
    case acm
    case cloudfront
    case iam
    case sdkUnknown(String)
}

extension CertificateSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CertificateSource] {
        return [
            .acm,
            .cloudfront,
            .iam,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .acm: return "acm"
        case .cloudfront: return "cloudfront"
        case .iam: return "iam"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CertificateSource(rawValue: rawValue) ?? CertificateSource.sdkUnknown(rawValue)
    }
}

extension CloudFrontOriginAccessIdentity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: Key("cloudFrontOriginAccessIdentityConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: Key("s3CanonicalUserId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CloudFrontOriginAccessIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFrontOriginAccessIdentity(cloudFrontOriginAccessIdentityConfig: \(String(describing: cloudFrontOriginAccessIdentityConfig)), id: \(String(describing: id)), s3CanonicalUserId: \(String(describing: s3CanonicalUserId)))"}
}

extension CloudFrontOriginAccessIdentity: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>CloudFront origin access identity.</p>
public struct CloudFrontOriginAccessIdentity: Equatable {
    /// <p>The current configuration information for the identity. </p>
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig?
    /// <p>The ID for the origin access identity, for example, <code>E74FTE3AJFJ256A</code>.
    /// 		</p>
    public let id: String?
    /// <p>The Amazon S3 canonical user ID for the origin access identity, used when giving the origin
    /// 			access identity read permission to an object in Amazon S3. </p>
    public let s3CanonicalUserId: String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig? = nil,
        id: String? = nil,
        s3CanonicalUserId: String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.id = id
        self.s3CanonicalUserId = s3CanonicalUserId
    }
}

extension CloudFrontOriginAccessIdentityAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFrontOriginAccessIdentityAlreadyExists(message: \(String(describing: message)))"}
}

extension CloudFrontOriginAccessIdentityAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CloudFrontOriginAccessIdentityAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>If the <code>CallerReference</code> is a value you already sent in a previous request to create an identity but the content
/// 			of the <code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request, CloudFront returns a
/// 			<code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
public struct CloudFrontOriginAccessIdentityAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudFrontOriginAccessIdentityAlreadyExistsBody: Equatable {
    public let message: String?
}

extension CloudFrontOriginAccessIdentityAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontOriginAccessIdentityConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: Key("callerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontOriginAccessIdentityConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFrontOriginAccessIdentityConfig(callerReference: \(String(describing: callerReference)), comment: \(String(describing: comment)))"}
}

extension CloudFrontOriginAccessIdentityConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Origin access identity configuration. Send a <code>GET</code> request to the
/// 					<code>/<i>CloudFront API version</i>/CloudFront/identity ID/config</code> resource.
/// 		</p>
public struct CloudFrontOriginAccessIdentityConfig: Equatable {
    /// <p>A unique value (for example, a date-time stamp) that ensures that the request can't be replayed.</p>
    /// 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
    /// 			<code>CloudFrontOriginAccessIdentityConfig</code> object), a new origin access identity is
    /// 			created.</p>
    /// 		       <p>If the <code>CallerReference</code> is a value already sent in a previous identity
    /// 			request, and the content of the <code>CloudFrontOriginAccessIdentityConfig</code> is identical
    /// 			to the original request (ignoring white space), the response includes the same information
    /// 			returned to the original request. </p>
    /// 		       <p>If the <code>CallerReference</code> is a value you already sent in a previous request
    /// 			to create an identity, but the content of the
    /// 			<code>CloudFrontOriginAccessIdentityConfig</code> is different from the original request,
    /// 			CloudFront returns a <code>CloudFrontOriginAccessIdentityAlreadyExists</code> error. </p>
    public let callerReference: String?
    /// <p>A comment to describe the origin access identity. The comment cannot be longer
    /// 			than 128 characters.</p>
    public let comment: String?

    public init (
        callerReference: String? = nil,
        comment: String? = nil
    )
    {
        self.callerReference = callerReference
        self.comment = comment
    }
}

extension CloudFrontOriginAccessIdentityInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFrontOriginAccessIdentityInUse(message: \(String(describing: message)))"}
}

extension CloudFrontOriginAccessIdentityInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CloudFrontOriginAccessIdentityInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Origin Access Identity specified is already in use.</p>
public struct CloudFrontOriginAccessIdentityInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudFrontOriginAccessIdentityInUseBody: Equatable {
    public let message: String?
}

extension CloudFrontOriginAccessIdentityInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudFrontOriginAccessIdentityList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: Key("isTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for cloudfrontoriginaccessidentitysummary0 in items {
                try itemsContainer.encode(cloudfrontoriginaccessidentitysummary0, forKey: Key("CloudFrontOriginAccessIdentitySummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CloudFrontOriginAccessIdentitySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CloudFrontOriginAccessIdentitySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CloudFrontOriginAccessIdentitySummary].self, forKey: .member)
                var itemsBuffer:[CloudFrontOriginAccessIdentitySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CloudFrontOriginAccessIdentitySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CloudFrontOriginAccessIdentityList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFrontOriginAccessIdentityList(isTruncated: \(String(describing: isTruncated)), items: \(String(describing: items)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension CloudFrontOriginAccessIdentityList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Lists the origin access identities for CloudFront.Send a <code>GET</code> request to the
/// 					<code>/<i>CloudFront API version</i>/origin-access-identity/cloudfront</code>
/// 			resource. The response includes a <code>CloudFrontOriginAccessIdentityList</code> element with
/// 			zero or more <code>CloudFrontOriginAccessIdentitySummary</code> child elements. By default,
/// 			your entire list of origin access identities is returned in one single page. If the list is
/// 			long, you can paginate it using the <code>MaxItems</code> and <code>Marker</code>
/// 			parameters.</p>
public struct CloudFrontOriginAccessIdentityList: Equatable {
    /// <p>A flag that indicates whether more origin access identities remain to be listed. If
    /// 			your results were truncated, you can make a follow-up pagination request using the
    /// 				<code>Marker</code> request parameter to retrieve more items in the list.</p>
    public let isTruncated: Bool?
    /// <p>A complex type that contains one <code>CloudFrontOriginAccessIdentitySummary</code>
    /// 			element for each origin access identity that was created by the current AWS
    /// 			account.</p>
    public let items: [CloudFrontOriginAccessIdentitySummary]?
    /// <p>Use this when paginating results to indicate where to begin in your list of origin
    /// 			access identities. The results include identities in the list that occur after the marker. To
    /// 			get the next page of results, set the <code>Marker</code> to the value of the
    /// 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
    /// 			identity on that page). </p>
    public let marker: String?
    /// <p>The maximum number of origin access identities you want in the response body.
    /// 		</p>
    public let maxItems: Int?
    /// <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
    /// 			the value you can use for the <code>Marker</code> request parameter to continue listing your
    /// 			origin access identities where they left off. </p>
    public let nextMarker: String?
    /// <p>The number of CloudFront origin access identities that were created by the current AWS
    /// 			account. </p>
    public let quantity: Int?

    public init (
        isTruncated: Bool? = nil,
        items: [CloudFrontOriginAccessIdentitySummary]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.isTruncated = isTruncated
        self.items = items
        self.marker = marker
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension CloudFrontOriginAccessIdentitySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case id = "Id"
        case s3CanonicalUserId = "S3CanonicalUserId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let s3CanonicalUserId = s3CanonicalUserId {
            try container.encode(s3CanonicalUserId, forKey: Key("s3CanonicalUserId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let s3CanonicalUserIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3CanonicalUserId)
        s3CanonicalUserId = s3CanonicalUserIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CloudFrontOriginAccessIdentitySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudFrontOriginAccessIdentitySummary(comment: \(String(describing: comment)), id: \(String(describing: id)), s3CanonicalUserId: \(String(describing: s3CanonicalUserId)))"}
}

extension CloudFrontOriginAccessIdentitySummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Summary of the information about a CloudFront origin access identity.</p>
public struct CloudFrontOriginAccessIdentitySummary: Equatable {
    /// <p>The comment for this origin access identity, as originally specified when
    /// 			created.</p>
    public let comment: String?
    /// <p>The ID for the origin access identity. For example:
    /// 			<code>E74FTE3AJFJ256A</code>.</p>
    public let id: String?
    /// <p>The Amazon S3 canonical user ID for the origin access identity, which you use when giving
    /// 			the origin access identity read permission to an object in Amazon S3.</p>
    public let s3CanonicalUserId: String?

    public init (
        comment: String? = nil,
        id: String? = nil,
        s3CanonicalUserId: String? = nil
    )
    {
        self.comment = comment
        self.id = id
        self.s3CanonicalUserId = s3CanonicalUserId
    }
}

extension ContentTypeProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType = "ContentType"
        case format = "Format"
        case profileId = "ProfileId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let contentType = contentType {
            try container.encode(contentType, forKey: Key("contentType"))
        }
        if let format = format {
            try container.encode(format, forKey: Key("format"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: Key("profileId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension ContentTypeProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContentTypeProfile(contentType: \(String(describing: contentType)), format: \(String(describing: format)), profileId: \(String(describing: profileId)))"}
}

extension ContentTypeProfile: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A field-level encryption content type profile. </p>
public struct ContentTypeProfile: Equatable {
    /// <p>The content type for a field-level encryption content type-profile mapping. </p>
    public let contentType: String?
    /// <p>The format for a field-level encryption content type-profile mapping. </p>
    public let format: Format?
    /// <p>The profile ID for a field-level encryption content type-profile mapping. </p>
    public let profileId: String?

    public init (
        contentType: String? = nil,
        format: Format? = nil,
        profileId: String? = nil
    )
    {
        self.contentType = contentType
        self.format = format
        self.profileId = profileId
    }
}

extension ContentTypeProfileConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentTypeProfiles = "ContentTypeProfiles"
        case forwardWhenContentTypeIsUnknown = "ForwardWhenContentTypeIsUnknown"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let contentTypeProfiles = contentTypeProfiles {
            try container.encode(contentTypeProfiles, forKey: Key("contentTypeProfiles"))
        }
        if let forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown {
            try container.encode(forwardWhenContentTypeIsUnknown, forKey: Key("forwardWhenContentTypeIsUnknown"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenContentTypeIsUnknownDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forwardWhenContentTypeIsUnknown)
        forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknownDecoded
        let contentTypeProfilesDecoded = try containerValues.decodeIfPresent(ContentTypeProfiles.self, forKey: .contentTypeProfiles)
        contentTypeProfiles = contentTypeProfilesDecoded
    }
}

extension ContentTypeProfileConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContentTypeProfileConfig(contentTypeProfiles: \(String(describing: contentTypeProfiles)), forwardWhenContentTypeIsUnknown: \(String(describing: forwardWhenContentTypeIsUnknown)))"}
}

extension ContentTypeProfileConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The configuration for a field-level encryption content type-profile mapping. </p>
public struct ContentTypeProfileConfig: Equatable {
    /// <p>The configuration for a field-level encryption content type-profile. </p>
    public let contentTypeProfiles: ContentTypeProfiles?
    /// <p>The setting in a field-level encryption content type-profile mapping that specifies what to do
    /// 			when an unknown content type is provided for the profile. If true, content is
    /// 			forwarded without being encrypted when the content type is unknown. If false (the
    /// 			default), an error is returned when the content type is unknown. </p>
    public let forwardWhenContentTypeIsUnknown: Bool?

    public init (
        contentTypeProfiles: ContentTypeProfiles? = nil,
        forwardWhenContentTypeIsUnknown: Bool? = nil
    )
    {
        self.contentTypeProfiles = contentTypeProfiles
        self.forwardWhenContentTypeIsUnknown = forwardWhenContentTypeIsUnknown
    }
}

extension ContentTypeProfiles: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for contenttypeprofile0 in items {
                try itemsContainer.encode(contenttypeprofile0, forKey: Key("ContentTypeProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct ContentTypeProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.ContentTypeProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([ContentTypeProfile].self, forKey: .member)
                var itemsBuffer:[ContentTypeProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [ContentTypeProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension ContentTypeProfiles: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContentTypeProfiles(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension ContentTypeProfiles: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Field-level encryption content type-profile. </p>
public struct ContentTypeProfiles: Equatable {
    /// <p>Items in a field-level encryption content type-profile mapping. </p>
    public let items: [ContentTypeProfile]?
    /// <p>The number of field-level encryption content type-profile mappings. </p>
    public let quantity: Int?

    public init (
        items: [ContentTypeProfile]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension CookieNames: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CookieNames: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CookieNames(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension CookieNames: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains a list of cookie names.</p>
public struct CookieNames: Equatable {
    /// <p>A list of cookie names.</p>
    public let items: [String]?
    /// <p>The number of cookie names in the <code>Items</code> list.</p>
    public let quantity: Int?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension CookiePreference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forward = "Forward"
        case whitelistedNames = "WhitelistedNames"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let forward = forward {
            try container.encode(forward, forKey: Key("forward"))
        }
        if let whitelistedNames = whitelistedNames {
            try container.encode(whitelistedNames, forKey: Key("whitelistedNames"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardDecoded = try containerValues.decodeIfPresent(ItemSelection.self, forKey: .forward)
        forward = forwardDecoded
        let whitelistedNamesDecoded = try containerValues.decodeIfPresent(CookieNames.self, forKey: .whitelistedNames)
        whitelistedNames = whitelistedNamesDecoded
    }
}

extension CookiePreference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CookiePreference(forward: \(String(describing: forward)), whitelistedNames: \(String(describing: whitelistedNames)))"}
}

extension CookiePreference: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>This field is deprecated. We recommend that you use a cache policy or an origin
/// 			request policy instead of this field.</p>
/// 		       <p>If you want to include cookies in the cache key, use <code>CookiesConfig</code> in a
/// 			cache policy. See <code>CachePolicy</code>.</p>
/// 		       <p>If you want to send cookies to the origin but not include them in the cache key, use
/// 			<code>CookiesConfig</code> in an origin request policy. See
/// 			<code>OriginRequestPolicy</code>.</p>
/// 		       <p>A complex type that specifies whether you want CloudFront to forward cookies to the origin
/// 			and, if so, which ones. For more information about forwarding cookies to the origin, see
/// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html">Caching Content
/// 				Based on Cookies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
public struct CookiePreference: Equatable {
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include cookies in the cache key, use a cache policy. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send cookies to the origin but not include them in the cache key, use origin
    /// 			request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>Specifies which cookies to forward to the origin for this cache behavior: all, none, or
    /// 			the list of cookies specified in the <code>WhitelistedNames</code> complex type.</p>
    /// 		       <p>Amazon S3 doesn't process cookies. When the cache behavior is forwarding requests to an
    /// 			Amazon S3 origin, specify none for the <code>Forward</code> element.</p>
    public let forward: ItemSelection?
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include cookies in the cache key, use a cache policy. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send cookies to the origin but not include them in the cache key, use an
    /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>Required if you specify <code>whitelist</code> for the value of <code>Forward</code>.
    /// 			A complex type that specifies how many different cookies you want CloudFront to forward to the
    /// 			origin for this cache behavior and, if you want to forward selected cookies, the names of
    /// 			those cookies.</p>
    /// 		       <p>If you specify <code>all</code> or <code>none</code> for the value of <code>Forward</code>, omit
    /// 				<code>WhitelistedNames</code>. If you change the value of <code>Forward</code> from
    /// 			<code>whitelist</code> to <code>all</code> or <code>none</code> and you don't delete the <code>WhitelistedNames</code>
    /// 			element and its child elements, CloudFront deletes them automatically.</p>
    /// 		       <p>For the current limit on the number of cookie names that you can whitelist for each
    /// 			cache behavior, see <a href="https://docs.aws.amazon.com/general/latest/gr/xrefaws_service_limits.html#limits_cloudfront">
    /// 				CloudFront Limits</a> in the <i>AWS General Reference</i>.</p>
    public let whitelistedNames: CookieNames?

    public init (
        forward: ItemSelection? = nil,
        whitelistedNames: CookieNames? = nil
    )
    {
        self.forward = forward
        self.whitelistedNames = whitelistedNames
    }
}

public struct CreateCachePolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(cachePolicyConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCachePolicyOutputError>
}

extension CreateCachePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCachePolicyInput(cachePolicyConfig: \(String(describing: cachePolicyConfig)))"}
}

extension CreateCachePolicyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCachePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: Key("CachePolicyConfig"))
        }
    }
}

public struct CreateCachePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCachePolicyOutputError>
}

public struct CreateCachePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCachePolicyInput>
    public typealias MOutput = OperationOutput<CreateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCachePolicyOutputError>
}

public struct CreateCachePolicyInput: Equatable {
    /// <p>A cache policy configuration.</p>
    public let cachePolicyConfig: CachePolicyConfig?

    public init (
        cachePolicyConfig: CachePolicyConfig? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
    }
}

struct CreateCachePolicyInputBody: Equatable {
    public let cachePolicyConfig: CachePolicyConfig?
}

extension CreateCachePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension CreateCachePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCachePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyAlreadyExists" : self = .cachePolicyAlreadyExists(try CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCachePolicies" : self = .tooManyCachePolicies(try TooManyCachePolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInCachePolicy" : self = .tooManyCookiesInCachePolicy(try TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInCachePolicy" : self = .tooManyHeadersInCachePolicy(try TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInCachePolicy" : self = .tooManyQueryStringsInCachePolicy(try TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCachePolicyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyAlreadyExists(CachePolicyAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case tooManyCachePolicies(TooManyCachePolicies)
    case tooManyCookiesInCachePolicy(TooManyCookiesInCachePolicy)
    case tooManyHeadersInCachePolicy(TooManyHeadersInCachePolicy)
    case tooManyQueryStringsInCachePolicy(TooManyQueryStringsInCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCachePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCachePolicyOutputResponse(cachePolicy: \(String(describing: cachePolicy)), eTag: \(String(describing: eTag)), location: \(String(describing: location)))"}
}

extension CreateCachePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CachePolicy = try responseDecoder.decode(responseBody: unwrappedData)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct CreateCachePolicyOutputResponse: Equatable {
    /// <p>A cache policy.</p>
    public let cachePolicy: CachePolicy?
    /// <p>The current version of the cache policy.</p>
    public let eTag: String?
    /// <p>The fully qualified URI of the cache policy just created.</p>
    public let location: String?

    public init (
        cachePolicy: CachePolicy? = nil,
        eTag: String? = nil,
        location: String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCachePolicyOutputResponseBody: Equatable {
    public let cachePolicy: CachePolicy?
}

extension CreateCachePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

public struct CreateCloudFrontOriginAccessIdentityInputBodyMiddleware: Middleware {
    public let id: String = "CreateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(cloudFrontOriginAccessIdentityConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

extension CreateCloudFrontOriginAccessIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCloudFrontOriginAccessIdentityInput(cloudFrontOriginAccessIdentityConfig: \(String(describing: cloudFrontOriginAccessIdentityConfig)))"}
}

extension CreateCloudFrontOriginAccessIdentityInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateCloudFrontOriginAccessIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

public struct CreateCloudFrontOriginAccessIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

public struct CreateCloudFrontOriginAccessIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<CreateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCloudFrontOriginAccessIdentityOutputError>
}

/// <p>The request to create a new origin access identity (OAI). An origin access identity is a
/// 			special CloudFront user that you can associate with Amazon S3 origins, so that you can secure all or
/// 			just some of your Amazon S3 content. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html">
/// 			Restricting Access to Amazon S3 Content by Using an Origin Access Identity</a> in the
/// 			<i>Amazon CloudFront Developer Guide</i>. </p>
public struct CreateCloudFrontOriginAccessIdentityInput: Equatable {
    /// <p>The current configuration information for the identity.</p>
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
    }
}

struct CreateCloudFrontOriginAccessIdentityInputBody: Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig?
}

extension CreateCloudFrontOriginAccessIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension CreateCloudFrontOriginAccessIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudFrontOriginAccessIdentityAlreadyExists" : self = .cloudFrontOriginAccessIdentityAlreadyExists(try CloudFrontOriginAccessIdentityAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCloudFrontOriginAccessIdentities" : self = .tooManyCloudFrontOriginAccessIdentities(try TooManyCloudFrontOriginAccessIdentities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCloudFrontOriginAccessIdentityOutputError: Equatable {
    case cloudFrontOriginAccessIdentityAlreadyExists(CloudFrontOriginAccessIdentityAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case missingBody(MissingBody)
    case tooManyCloudFrontOriginAccessIdentities(TooManyCloudFrontOriginAccessIdentities)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCloudFrontOriginAccessIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(String(describing: cloudFrontOriginAccessIdentity)), eTag: \(String(describing: eTag)), location: \(String(describing: location)))"}
}

extension CreateCloudFrontOriginAccessIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: unwrappedData)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct CreateCloudFrontOriginAccessIdentityOutputResponse: Equatable {
    /// <p>The origin access identity's information.</p>
    public let cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity?
    /// <p>The current version of the origin access identity created.</p>
    public let eTag: String?
    /// <p>The fully qualified URI of the new origin access identity just created.</p>
    public let location: String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity? = nil,
        eTag: String? = nil,
        location: String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
        self.location = location
    }
}

struct CreateCloudFrontOriginAccessIdentityOutputResponseBody: Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity?
}

extension CreateCloudFrontOriginAccessIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

public struct CreateDistributionInputBodyMiddleware: Middleware {
    public let id: String = "CreateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfig = input.operationInput.distributionConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(distributionConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionOutputError>
}

extension CreateDistributionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDistributionInput(distributionConfig: \(String(describing: distributionConfig)))"}
}

extension CreateDistributionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: Key("DistributionConfig"))
        }
    }
}

public struct CreateDistributionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionOutputError>
}

public struct CreateDistributionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionInput>
    public typealias MOutput = OperationOutput<CreateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionOutputError>
}

/// <p>The request to create a new distribution.</p>
public struct CreateDistributionInput: Equatable {
    /// <p>The distribution's configuration information.</p>
    public let distributionConfig: DistributionConfig?

    public init (
        distributionConfig: DistributionConfig? = nil
    )
    {
        self.distributionConfig = distributionConfig
    }
}

struct CreateDistributionInputBody: Equatable {
    public let distributionConfig: DistributionConfig?
}

extension CreateDistributionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension CreateDistributionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDistributionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionAlreadyExists" : self = .distributionAlreadyExists(try DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProtocolSettings" : self = .invalidProtocolSettings(try InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributions" : self = .tooManyDistributions(try TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case distributionAlreadyExists(DistributionAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidProtocolSettings(InvalidProtocolSettings)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributions(TooManyDistributions)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDistributionOutputResponse(distribution: \(String(describing: distribution)), eTag: \(String(describing: eTag)), location: \(String(describing: location)))"}
}

extension CreateDistributionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: Distribution = try responseDecoder.decode(responseBody: unwrappedData)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct CreateDistributionOutputResponse: Equatable {
    /// <p>The distribution's information.</p>
    public let distribution: Distribution?
    /// <p>The current version of the distribution created.</p>
    public let eTag: String?
    /// <p>The fully qualified URI of the new distribution resource just created.</p>
    public let location: String?

    public init (
        distribution: Distribution? = nil,
        eTag: String? = nil,
        location: String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionOutputResponseBody: Equatable {
    public let distribution: Distribution?
}

extension CreateDistributionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct CreateDistributionWithTagsInputBodyMiddleware: Middleware {
    public let id: String = "CreateDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfigWithTags = input.operationInput.distributionConfigWithTags {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(distributionConfigWithTags)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionWithTagsOutputError>
}

extension CreateDistributionWithTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDistributionWithTagsInput(distributionConfigWithTags: \(String(describing: distributionConfigWithTags)))"}
}

extension CreateDistributionWithTagsInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateDistributionWithTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let distributionConfigWithTags = distributionConfigWithTags {
            try container.encode(distributionConfigWithTags, forKey: Key("DistributionConfigWithTags"))
        }
    }
}

public struct CreateDistributionWithTagsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDistributionWithTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionWithTagsOutputError>
}

public struct CreateDistributionWithTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDistributionWithTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDistributionWithTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "WithTags", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDistributionWithTagsInput>
    public typealias MOutput = OperationOutput<CreateDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDistributionWithTagsOutputError>
}

/// <p>The request to create a new distribution with tags. </p>
public struct CreateDistributionWithTagsInput: Equatable {
    /// <p>The distribution's configuration information. </p>
    public let distributionConfigWithTags: DistributionConfigWithTags?

    public init (
        distributionConfigWithTags: DistributionConfigWithTags? = nil
    )
    {
        self.distributionConfigWithTags = distributionConfigWithTags
    }
}

struct CreateDistributionWithTagsInputBody: Equatable {
    public let distributionConfigWithTags: DistributionConfigWithTags?
}

extension CreateDistributionWithTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionConfigWithTags = "DistributionConfigWithTags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(DistributionConfigWithTags.self, forKey: .distributionConfigWithTags)
        distributionConfigWithTags = distributionConfigWithTagsDecoded
    }
}

extension CreateDistributionWithTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateDistributionWithTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionAlreadyExists" : self = .distributionAlreadyExists(try DistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidProtocolSettings" : self = .invalidProtocolSettings(try InvalidProtocolSettings(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributions" : self = .tooManyDistributions(try TooManyDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionWithTagsOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case distributionAlreadyExists(DistributionAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidProtocolSettings(InvalidProtocolSettings)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTagging(InvalidTagging)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributions(TooManyDistributions)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionWithTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDistributionWithTagsOutputResponse(distribution: \(String(describing: distribution)), eTag: \(String(describing: eTag)), location: \(String(describing: location)))"}
}

extension CreateDistributionWithTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: Distribution = try responseDecoder.decode(responseBody: unwrappedData)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct CreateDistributionWithTagsOutputResponse: Equatable {
    /// <p>The distribution's information. </p>
    public let distribution: Distribution?
    /// <p>The current version of the distribution created.</p>
    public let eTag: String?
    /// <p>The fully qualified URI of the new distribution resource just created.</p>
    public let location: String?

    public init (
        distribution: Distribution? = nil,
        eTag: String? = nil,
        location: String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
        self.location = location
    }
}

struct CreateDistributionWithTagsOutputResponseBody: Equatable {
    public let distribution: Distribution?
}

extension CreateDistributionWithTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct CreateFieldLevelEncryptionConfigInputBodyMiddleware: Middleware {
    public let id: String = "CreateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(fieldLevelEncryptionConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

extension CreateFieldLevelEncryptionConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFieldLevelEncryptionConfigInput(fieldLevelEncryptionConfig: \(String(describing: fieldLevelEncryptionConfig)))"}
}

extension CreateFieldLevelEncryptionConfigInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: Key("FieldLevelEncryptionConfig"))
        }
    }
}

public struct CreateFieldLevelEncryptionConfigInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

public struct CreateFieldLevelEncryptionConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<CreateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFieldLevelEncryptionConfigOutputError>
}

public struct CreateFieldLevelEncryptionConfigInput: Equatable {
    /// <p>The request to create a new field-level encryption configuration.</p>
    public let fieldLevelEncryptionConfig: FieldLevelEncryptionConfig?

    public init (
        fieldLevelEncryptionConfig: FieldLevelEncryptionConfig? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct CreateFieldLevelEncryptionConfigInputBody: Equatable {
    public let fieldLevelEncryptionConfig: FieldLevelEncryptionConfig?
}

extension CreateFieldLevelEncryptionConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension CreateFieldLevelEncryptionConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFieldLevelEncryptionConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FieldLevelEncryptionConfigAlreadyExists" : self = .fieldLevelEncryptionConfigAlreadyExists(try FieldLevelEncryptionConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryArgProfileEmpty" : self = .queryArgProfileEmpty(try QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionConfigs" : self = .tooManyFieldLevelEncryptionConfigs(try TooManyFieldLevelEncryptionConfigs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionContentTypeProfiles" : self = .tooManyFieldLevelEncryptionContentTypeProfiles(try TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionQueryArgProfiles" : self = .tooManyFieldLevelEncryptionQueryArgProfiles(try TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFieldLevelEncryptionConfigOutputError: Equatable {
    case fieldLevelEncryptionConfigAlreadyExists(FieldLevelEncryptionConfigAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case queryArgProfileEmpty(QueryArgProfileEmpty)
    case tooManyFieldLevelEncryptionConfigs(TooManyFieldLevelEncryptionConfigs)
    case tooManyFieldLevelEncryptionContentTypeProfiles(TooManyFieldLevelEncryptionContentTypeProfiles)
    case tooManyFieldLevelEncryptionQueryArgProfiles(TooManyFieldLevelEncryptionQueryArgProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldLevelEncryptionConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFieldLevelEncryptionConfigOutputResponse(eTag: \(String(describing: eTag)), fieldLevelEncryption: \(String(describing: fieldLevelEncryption)), location: \(String(describing: location)))"}
}

extension CreateFieldLevelEncryptionConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryption = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct CreateFieldLevelEncryptionConfigOutputResponse: Equatable {
    /// <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>Returned when you create a new field-level encryption configuration.</p>
    public let fieldLevelEncryption: FieldLevelEncryption?
    /// <p>The fully qualified URI of the new configuration resource just created.</p>
    public let location: String?

    public init (
        eTag: String? = nil,
        fieldLevelEncryption: FieldLevelEncryption? = nil,
        location: String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
        self.location = location
    }
}

struct CreateFieldLevelEncryptionConfigOutputResponseBody: Equatable {
    public let fieldLevelEncryption: FieldLevelEncryption?
}

extension CreateFieldLevelEncryptionConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

public struct CreateFieldLevelEncryptionProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(fieldLevelEncryptionProfileConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

extension CreateFieldLevelEncryptionProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFieldLevelEncryptionProfileInput(fieldLevelEncryptionProfileConfig: \(String(describing: fieldLevelEncryptionProfileConfig)))"}
}

extension CreateFieldLevelEncryptionProfileInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFieldLevelEncryptionProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

public struct CreateFieldLevelEncryptionProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

public struct CreateFieldLevelEncryptionProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<CreateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFieldLevelEncryptionProfileOutputError>
}

public struct CreateFieldLevelEncryptionProfileInput: Equatable {
    /// <p>The request to create a field-level encryption profile.</p>
    public let fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig?

    public init (
        fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct CreateFieldLevelEncryptionProfileInputBody: Equatable {
    public let fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig?
}

extension CreateFieldLevelEncryptionProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension CreateFieldLevelEncryptionProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFieldLevelEncryptionProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FieldLevelEncryptionProfileAlreadyExists" : self = .fieldLevelEncryptionProfileAlreadyExists(try FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileSizeExceeded" : self = .fieldLevelEncryptionProfileSizeExceeded(try FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionEncryptionEntities" : self = .tooManyFieldLevelEncryptionEncryptionEntities(try TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionFieldPatterns" : self = .tooManyFieldLevelEncryptionFieldPatterns(try TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionProfiles" : self = .tooManyFieldLevelEncryptionProfiles(try TooManyFieldLevelEncryptionProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFieldLevelEncryptionProfileOutputError: Equatable {
    case fieldLevelEncryptionProfileAlreadyExists(FieldLevelEncryptionProfileAlreadyExists)
    case fieldLevelEncryptionProfileSizeExceeded(FieldLevelEncryptionProfileSizeExceeded)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case noSuchPublicKey(NoSuchPublicKey)
    case tooManyFieldLevelEncryptionEncryptionEntities(TooManyFieldLevelEncryptionEncryptionEntities)
    case tooManyFieldLevelEncryptionFieldPatterns(TooManyFieldLevelEncryptionFieldPatterns)
    case tooManyFieldLevelEncryptionProfiles(TooManyFieldLevelEncryptionProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFieldLevelEncryptionProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFieldLevelEncryptionProfileOutputResponse(eTag: \(String(describing: eTag)), fieldLevelEncryptionProfile: \(String(describing: fieldLevelEncryptionProfile)), location: \(String(describing: location)))"}
}

extension CreateFieldLevelEncryptionProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct CreateFieldLevelEncryptionProfileOutputResponse: Equatable {
    /// <p>The current version of the field level encryption profile. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>Returned when you create a new field-level encryption profile.</p>
    public let fieldLevelEncryptionProfile: FieldLevelEncryptionProfile?
    /// <p>The fully qualified URI of the new profile resource just created.</p>
    public let location: String?

    public init (
        eTag: String? = nil,
        fieldLevelEncryptionProfile: FieldLevelEncryptionProfile? = nil,
        location: String? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
        self.location = location
    }
}

struct CreateFieldLevelEncryptionProfileOutputResponseBody: Equatable {
    public let fieldLevelEncryptionProfile: FieldLevelEncryptionProfile?
}

extension CreateFieldLevelEncryptionProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

public struct CreateFunctionInputBodyMiddleware: Middleware {
    public let id: String = "CreateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

extension CreateFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionInput(functionCode: \(String(describing: functionCode)), functionConfig: \(String(describing: functionConfig)), name: \(String(describing: name)))"}
}

extension CreateFunctionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: Key("functionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: Key("functionConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }
}

public struct CreateFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInput: Equatable {
    /// <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
    /// 			code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let functionCode: Data?
    /// <p>Configuration information about the function, including an optional comment and the
    /// 			function’s runtime.</p>
    public let functionConfig: FunctionConfig?
    /// <p>A name to identify the function.</p>
    public let name: String?

    public init (
        functionCode: Data? = nil,
        functionConfig: FunctionConfig? = nil,
        name: String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.name = name
    }
}

struct CreateFunctionInputBody: Equatable {
    public let name: String?
    public let functionConfig: FunctionConfig?
    public let functionCode: Data?
}

extension CreateFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension CreateFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FunctionAlreadyExists" : self = .functionAlreadyExists(try FunctionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FunctionSizeLimitExceeded" : self = .functionSizeLimitExceeded(try FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctions" : self = .tooManyFunctions(try TooManyFunctions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Equatable {
    case functionAlreadyExists(FunctionAlreadyExists)
    case functionSizeLimitExceeded(FunctionSizeLimitExceeded)
    case invalidArgument(InvalidArgument)
    case tooManyFunctions(TooManyFunctions)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionOutputResponse(eTag: \(String(describing: eTag)), functionSummary: \(String(describing: functionSummary)), location: \(String(describing: location)))"}
}

extension CreateFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FunctionSummary = try responseDecoder.decode(responseBody: unwrappedData)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct CreateFunctionOutputResponse: Equatable {
    /// <p>The version identifier for the current version of the CloudFront function.</p>
    public let eTag: String?
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public let functionSummary: FunctionSummary?
    /// <p>The URL of the CloudFront function. Use the URL to manage the function with the CloudFront
    /// 			API.</p>
    public let location: String?

    public init (
        eTag: String? = nil,
        functionSummary: FunctionSummary? = nil,
        location: String? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
        self.location = location
    }
}

struct CreateFunctionOutputResponseBody: Equatable {
    public let functionSummary: FunctionSummary?
}

extension CreateFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

public struct CreateInvalidationInputBodyMiddleware: Middleware {
    public let id: String = "CreateInvalidationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let invalidationBatch = input.operationInput.invalidationBatch {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(invalidationBatch)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInvalidationOutputError>
}

extension CreateInvalidationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInvalidationInput(distributionId: \(String(describing: distributionId)), invalidationBatch: \(String(describing: invalidationBatch)))"}
}

extension CreateInvalidationInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateInvalidationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: Key("InvalidationBatch"))
        }
    }
}

public struct CreateInvalidationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateInvalidationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInvalidationOutputError>
}

public struct CreateInvalidationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateInvalidationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateInvalidationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateInvalidationInput>
    public typealias MOutput = OperationOutput<CreateInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateInvalidationOutputError>
}

/// <p>The request to create an invalidation.</p>
public struct CreateInvalidationInput: Equatable {
    /// <p>The distribution's id.</p>
    public let distributionId: String?
    /// <p>The batch information for the invalidation.</p>
    public let invalidationBatch: InvalidationBatch?

    public init (
        distributionId: String? = nil,
        invalidationBatch: InvalidationBatch? = nil
    )
    {
        self.distributionId = distributionId
        self.invalidationBatch = invalidationBatch
    }
}

struct CreateInvalidationInputBody: Equatable {
    public let invalidationBatch: InvalidationBatch?
}

extension CreateInvalidationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidationBatch = "InvalidationBatch"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension CreateInvalidationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateInvalidationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BatchTooLarge" : self = .batchTooLarge(try BatchTooLarge(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyInvalidationsInProgress" : self = .tooManyInvalidationsInProgress(try TooManyInvalidationsInProgress(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInvalidationOutputError: Equatable {
    case accessDenied(AccessDenied)
    case batchTooLarge(BatchTooLarge)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case missingBody(MissingBody)
    case noSuchDistribution(NoSuchDistribution)
    case tooManyInvalidationsInProgress(TooManyInvalidationsInProgress)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInvalidationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateInvalidationOutputResponse(invalidation: \(String(describing: invalidation)), location: \(String(describing: location)))"}
}

extension CreateInvalidationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: Invalidation = try responseDecoder.decode(responseBody: unwrappedData)
                self.invalidation = output
            } else {
                self.invalidation = nil
            }
        } else {
            self.invalidation = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct CreateInvalidationOutputResponse: Equatable {
    /// <p>The invalidation's information.</p>
    public let invalidation: Invalidation?
    /// <p>The fully qualified URI of the distribution and invalidation batch request, including
    /// 			the <code>Invalidation ID</code>.</p>
    public let location: String?

    public init (
        invalidation: Invalidation? = nil,
        location: String? = nil
    )
    {
        self.invalidation = invalidation
        self.location = location
    }
}

struct CreateInvalidationOutputResponseBody: Equatable {
    public let invalidation: Invalidation?
}

extension CreateInvalidationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidation = "Invalidation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

public struct CreateKeyGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyGroupConfig = input.operationInput.keyGroupConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(keyGroupConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateKeyGroupOutputError>
}

extension CreateKeyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateKeyGroupInput(keyGroupConfig: \(String(describing: keyGroupConfig)))"}
}

extension CreateKeyGroupInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateKeyGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: Key("KeyGroupConfig"))
        }
    }
}

public struct CreateKeyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateKeyGroupOutputError>
}

public struct CreateKeyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateKeyGroupInput>
    public typealias MOutput = OperationOutput<CreateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateKeyGroupOutputError>
}

public struct CreateKeyGroupInput: Equatable {
    /// <p>A key group configuration.</p>
    public let keyGroupConfig: KeyGroupConfig?

    public init (
        keyGroupConfig: KeyGroupConfig? = nil
    )
    {
        self.keyGroupConfig = keyGroupConfig
    }
}

struct CreateKeyGroupInputBody: Equatable {
    public let keyGroupConfig: KeyGroupConfig?
}

extension CreateKeyGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension CreateKeyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateKeyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyGroupAlreadyExists" : self = .keyGroupAlreadyExists(try KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroups" : self = .tooManyKeyGroups(try TooManyKeyGroups(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeysInKeyGroup" : self = .tooManyPublicKeysInKeyGroup(try TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateKeyGroupOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case keyGroupAlreadyExists(KeyGroupAlreadyExists)
    case tooManyKeyGroups(TooManyKeyGroups)
    case tooManyPublicKeysInKeyGroup(TooManyPublicKeysInKeyGroup)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateKeyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateKeyGroupOutputResponse(eTag: \(String(describing: eTag)), keyGroup: \(String(describing: keyGroup)), location: \(String(describing: location)))"}
}

extension CreateKeyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: KeyGroup = try responseDecoder.decode(responseBody: unwrappedData)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct CreateKeyGroupOutputResponse: Equatable {
    /// <p>The identifier for this version of the key group.</p>
    public let eTag: String?
    /// <p>The key group that was just created.</p>
    public let keyGroup: KeyGroup?
    /// <p>The URL of the key group.</p>
    public let location: String?

    public init (
        eTag: String? = nil,
        keyGroup: KeyGroup? = nil,
        location: String? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
        self.location = location
    }
}

struct CreateKeyGroupOutputResponseBody: Equatable {
    public let keyGroup: KeyGroup?
}

extension CreateKeyGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

public struct CreateMonitoringSubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateMonitoringSubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let monitoringSubscription = input.operationInput.monitoringSubscription {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(monitoringSubscription)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMonitoringSubscriptionOutputError>
}

extension CreateMonitoringSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMonitoringSubscriptionInput(distributionId: \(String(describing: distributionId)), monitoringSubscription: \(String(describing: monitoringSubscription)))"}
}

extension CreateMonitoringSubscriptionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateMonitoringSubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let monitoringSubscription = monitoringSubscription {
            try container.encode(monitoringSubscription, forKey: Key("MonitoringSubscription"))
        }
    }
}

public struct CreateMonitoringSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMonitoringSubscriptionOutputError>
}

public struct CreateMonitoringSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMonitoringSubscriptionInput>
    public typealias MOutput = OperationOutput<CreateMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMonitoringSubscriptionOutputError>
}

public struct CreateMonitoringSubscriptionInput: Equatable {
    /// <p>The ID of the distribution that you are enabling metrics for.</p>
    public let distributionId: String?
    /// <p>A monitoring subscription. This structure contains information about whether additional
    /// 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
    public let monitoringSubscription: MonitoringSubscription?

    public init (
        distributionId: String? = nil,
        monitoringSubscription: MonitoringSubscription? = nil
    )
    {
        self.distributionId = distributionId
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionInputBody: Equatable {
    public let monitoringSubscription: MonitoringSubscription?
}

extension CreateMonitoringSubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension CreateMonitoringSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateMonitoringSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMonitoringSubscriptionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMonitoringSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMonitoringSubscriptionOutputResponse(monitoringSubscription: \(String(describing: monitoringSubscription)))"}
}

extension CreateMonitoringSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MonitoringSubscription = try responseDecoder.decode(responseBody: unwrappedData)
                self.monitoringSubscription = output
            } else {
                self.monitoringSubscription = nil
            }
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct CreateMonitoringSubscriptionOutputResponse: Equatable {
    /// <p>A monitoring subscription. This structure contains information about whether additional
    /// 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
    public let monitoringSubscription: MonitoringSubscription?

    public init (
        monitoringSubscription: MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct CreateMonitoringSubscriptionOutputResponseBody: Equatable {
    public let monitoringSubscription: MonitoringSubscription?
}

extension CreateMonitoringSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

public struct CreateOriginRequestPolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(originRequestPolicyConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOriginRequestPolicyOutputError>
}

extension CreateOriginRequestPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOriginRequestPolicyInput(originRequestPolicyConfig: \(String(describing: originRequestPolicyConfig)))"}
}

extension CreateOriginRequestPolicyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateOriginRequestPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: Key("OriginRequestPolicyConfig"))
        }
    }
}

public struct CreateOriginRequestPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOriginRequestPolicyOutputError>
}

public struct CreateOriginRequestPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<CreateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOriginRequestPolicyOutputError>
}

public struct CreateOriginRequestPolicyInput: Equatable {
    /// <p>An origin request policy configuration.</p>
    public let originRequestPolicyConfig: OriginRequestPolicyConfig?

    public init (
        originRequestPolicyConfig: OriginRequestPolicyConfig? = nil
    )
    {
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct CreateOriginRequestPolicyInputBody: Equatable {
    public let originRequestPolicyConfig: OriginRequestPolicyConfig?
}

extension CreateOriginRequestPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension CreateOriginRequestPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateOriginRequestPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyAlreadyExists" : self = .originRequestPolicyAlreadyExists(try OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInOriginRequestPolicy" : self = .tooManyCookiesInOriginRequestPolicy(try TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInOriginRequestPolicy" : self = .tooManyHeadersInOriginRequestPolicy(try TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginRequestPolicies" : self = .tooManyOriginRequestPolicies(try TooManyOriginRequestPolicies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInOriginRequestPolicy" : self = .tooManyQueryStringsInOriginRequestPolicy(try TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOriginRequestPolicyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case originRequestPolicyAlreadyExists(OriginRequestPolicyAlreadyExists)
    case tooManyCookiesInOriginRequestPolicy(TooManyCookiesInOriginRequestPolicy)
    case tooManyHeadersInOriginRequestPolicy(TooManyHeadersInOriginRequestPolicy)
    case tooManyOriginRequestPolicies(TooManyOriginRequestPolicies)
    case tooManyQueryStringsInOriginRequestPolicy(TooManyQueryStringsInOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOriginRequestPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOriginRequestPolicyOutputResponse(eTag: \(String(describing: eTag)), location: \(String(describing: location)), originRequestPolicy: \(String(describing: originRequestPolicy)))"}
}

extension CreateOriginRequestPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: OriginRequestPolicy = try responseDecoder.decode(responseBody: unwrappedData)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct CreateOriginRequestPolicyOutputResponse: Equatable {
    /// <p>The current version of the origin request policy.</p>
    public let eTag: String?
    /// <p>The fully qualified URI of the origin request policy just created.</p>
    public let location: String?
    /// <p>An origin request policy.</p>
    public let originRequestPolicy: OriginRequestPolicy?

    public init (
        eTag: String? = nil,
        location: String? = nil,
        originRequestPolicy: OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.originRequestPolicy = originRequestPolicy
    }
}

struct CreateOriginRequestPolicyOutputResponseBody: Equatable {
    public let originRequestPolicy: OriginRequestPolicy?
}

extension CreateOriginRequestPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

public struct CreatePublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "CreatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let publicKeyConfig = input.operationInput.publicKeyConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(publicKeyConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicKeyOutputError>
}

extension CreatePublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePublicKeyInput(publicKeyConfig: \(String(describing: publicKeyConfig)))"}
}

extension CreatePublicKeyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreatePublicKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: Key("PublicKeyConfig"))
        }
    }
}

public struct CreatePublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicKeyOutputError>
}

public struct CreatePublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublicKeyInput>
    public typealias MOutput = OperationOutput<CreatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublicKeyOutputError>
}

public struct CreatePublicKeyInput: Equatable {
    /// <p>A CloudFront public key configuration.</p>
    public let publicKeyConfig: PublicKeyConfig?

    public init (
        publicKeyConfig: PublicKeyConfig? = nil
    )
    {
        self.publicKeyConfig = publicKeyConfig
    }
}

struct CreatePublicKeyInputBody: Equatable {
    public let publicKeyConfig: PublicKeyConfig?
}

extension CreatePublicKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension CreatePublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreatePublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicKeyAlreadyExists" : self = .publicKeyAlreadyExists(try PublicKeyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeys" : self = .tooManyPublicKeys(try TooManyPublicKeys(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublicKeyOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case publicKeyAlreadyExists(PublicKeyAlreadyExists)
    case tooManyPublicKeys(TooManyPublicKeys)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePublicKeyOutputResponse(eTag: \(String(describing: eTag)), location: \(String(describing: location)), publicKey: \(String(describing: publicKey)))"}
}

extension CreatePublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PublicKey = try responseDecoder.decode(responseBody: unwrappedData)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct CreatePublicKeyOutputResponse: Equatable {
    /// <p>The identifier for this version of the public key.</p>
    public let eTag: String?
    /// <p>The URL of the public key.</p>
    public let location: String?
    /// <p>The public key.</p>
    public let publicKey: PublicKey?

    public init (
        eTag: String? = nil,
        location: String? = nil,
        publicKey: PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.publicKey = publicKey
    }
}

struct CreatePublicKeyOutputResponseBody: Equatable {
    public let publicKey: PublicKey?
}

extension CreatePublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct CreateRealtimeLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "CreateRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRealtimeLogConfigOutputError>
}

extension CreateRealtimeLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRealtimeLogConfigInput(endPoints: \(String(describing: endPoints)), fields: \(String(describing: fields)), name: \(String(describing: name)), samplingRate: \(String(describing: samplingRate)))"}
}

extension CreateRealtimeLogConfigInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateRealtimeLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("endPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: Key("samplingRate"))
        }
    }
}

public struct CreateRealtimeLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRealtimeLogConfigOutputError>
}

public struct CreateRealtimeLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<CreateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRealtimeLogConfigOutputError>
}

public struct CreateRealtimeLogConfigInput: Equatable {
    /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
    /// 			log data.</p>
    public let endPoints: [EndPoint]?
    /// <p>A list of fields to include in each real-time log record.</p>
    /// 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let fields: [String]?
    /// <p>A unique name to identify this real-time log configuration.</p>
    public let name: String?
    /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
    /// 			percentage of viewer requests that are represented in the real-time log data. You must
    /// 			provide an integer between 1 and 100, inclusive.</p>
    public let samplingRate: Int?

    public init (
        endPoints: [EndPoint]? = nil,
        fields: [String]? = nil,
        name: String? = nil,
        samplingRate: Int? = nil
    )
    {
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct CreateRealtimeLogConfigInputBody: Equatable {
    public let endPoints: [EndPoint]?
    public let fields: [String]?
    public let name: String?
    public let samplingRate: Int?
}

extension CreateRealtimeLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([EndPoint].self, forKey: .member)
                var endPointsBuffer:[EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var fieldsBuffer:[String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension CreateRealtimeLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateRealtimeLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigAlreadyExists" : self = .realtimeLogConfigAlreadyExists(try RealtimeLogConfigAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRealtimeLogConfigs" : self = .tooManyRealtimeLogConfigs(try TooManyRealtimeLogConfigs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRealtimeLogConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case realtimeLogConfigAlreadyExists(RealtimeLogConfigAlreadyExists)
    case tooManyRealtimeLogConfigs(TooManyRealtimeLogConfigs)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRealtimeLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRealtimeLogConfigOutputResponse(realtimeLogConfig: \(String(describing: realtimeLogConfig)))"}
}

extension CreateRealtimeLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct CreateRealtimeLogConfigOutputResponse: Equatable {
    /// <p>A real-time log configuration.</p>
    public let realtimeLogConfig: RealtimeLogConfig?

    public init (
        realtimeLogConfig: RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct CreateRealtimeLogConfigOutputResponseBody: Equatable {
    public let realtimeLogConfig: RealtimeLogConfig?
}

extension CreateRealtimeLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

public struct CreateStreamingDistributionInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(streamingDistributionConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingDistributionOutputError>
}

extension CreateStreamingDistributionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingDistributionInput(streamingDistributionConfig: \(String(describing: streamingDistributionConfig)))"}
}

extension CreateStreamingDistributionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: Key("StreamingDistributionConfig"))
        }
    }
}

public struct CreateStreamingDistributionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingDistributionOutputError>
}

public struct CreateStreamingDistributionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingDistributionInput>
    public typealias MOutput = OperationOutput<CreateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingDistributionOutputError>
}

/// <p>The request to create a new streaming distribution.</p>
public struct CreateStreamingDistributionInput: Equatable {
    /// <p>The streaming distribution's configuration information.</p>
    public let streamingDistributionConfig: StreamingDistributionConfig?

    public init (
        streamingDistributionConfig: StreamingDistributionConfig? = nil
    )
    {
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct CreateStreamingDistributionInputBody: Equatable {
    public let streamingDistributionConfig: StreamingDistributionConfig?
}

extension CreateStreamingDistributionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension CreateStreamingDistributionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStreamingDistributionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionAlreadyExists" : self = .streamingDistributionAlreadyExists(try StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributions" : self = .tooManyStreamingDistributions(try TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingDistributionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case missingBody(MissingBody)
    case streamingDistributionAlreadyExists(StreamingDistributionAlreadyExists)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyStreamingDistributions(TooManyStreamingDistributions)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingDistributionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingDistributionOutputResponse(eTag: \(String(describing: eTag)), location: \(String(describing: location)), streamingDistribution: \(String(describing: streamingDistribution)))"}
}

extension CreateStreamingDistributionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: StreamingDistribution = try responseDecoder.decode(responseBody: unwrappedData)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct CreateStreamingDistributionOutputResponse: Equatable {
    /// <p>The current version of the streaming distribution created.</p>
    public let eTag: String?
    /// <p>The fully qualified URI of the new streaming distribution resource just created.</p>
    public let location: String?
    /// <p>The streaming distribution's information.</p>
    public let streamingDistribution: StreamingDistribution?

    public init (
        eTag: String? = nil,
        location: String? = nil,
        streamingDistribution: StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionOutputResponseBody: Equatable {
    public let streamingDistribution: StreamingDistribution?
}

extension CreateStreamingDistributionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

public struct CreateStreamingDistributionWithTagsInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamingDistributionWithTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfigWithTags = input.operationInput.streamingDistributionConfigWithTags {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(streamingDistributionConfigWithTags)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingDistributionWithTagsOutputError>
}

extension CreateStreamingDistributionWithTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingDistributionWithTagsInput(streamingDistributionConfigWithTags: \(String(describing: streamingDistributionConfigWithTags)))"}
}

extension CreateStreamingDistributionWithTagsInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension CreateStreamingDistributionWithTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let streamingDistributionConfigWithTags = streamingDistributionConfigWithTags {
            try container.encode(streamingDistributionConfigWithTags, forKey: Key("StreamingDistributionConfigWithTags"))
        }
    }
}

public struct CreateStreamingDistributionWithTagsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamingDistributionWithTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingDistributionWithTagsOutputError>
}

public struct CreateStreamingDistributionWithTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamingDistributionWithTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamingDistributionWithTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "WithTags", value: nil))
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamingDistributionWithTagsInput>
    public typealias MOutput = OperationOutput<CreateStreamingDistributionWithTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamingDistributionWithTagsOutputError>
}

/// <p>The request to create a new streaming distribution with tags.</p>
public struct CreateStreamingDistributionWithTagsInput: Equatable {
    /// <p> The streaming distribution's configuration information. </p>
    public let streamingDistributionConfigWithTags: StreamingDistributionConfigWithTags?

    public init (
        streamingDistributionConfigWithTags: StreamingDistributionConfigWithTags? = nil
    )
    {
        self.streamingDistributionConfigWithTags = streamingDistributionConfigWithTags
    }
}

struct CreateStreamingDistributionWithTagsInputBody: Equatable {
    public let streamingDistributionConfigWithTags: StreamingDistributionConfigWithTags?
}

extension CreateStreamingDistributionWithTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionConfigWithTags = "StreamingDistributionConfigWithTags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigWithTagsDecoded = try containerValues.decodeIfPresent(StreamingDistributionConfigWithTags.self, forKey: .streamingDistributionConfigWithTags)
        streamingDistributionConfigWithTags = streamingDistributionConfigWithTagsDecoded
    }
}

extension CreateStreamingDistributionWithTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateStreamingDistributionWithTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOrigin" : self = .invalidOrigin(try InvalidOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionAlreadyExists" : self = .streamingDistributionAlreadyExists(try StreamingDistributionAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributions" : self = .tooManyStreamingDistributions(try TooManyStreamingDistributions(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingDistributionWithTagsOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidOrigin(InvalidOrigin)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidTagging(InvalidTagging)
    case missingBody(MissingBody)
    case streamingDistributionAlreadyExists(StreamingDistributionAlreadyExists)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyStreamingDistributions(TooManyStreamingDistributions)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingDistributionWithTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamingDistributionWithTagsOutputResponse(eTag: \(String(describing: eTag)), location: \(String(describing: location)), streamingDistribution: \(String(describing: streamingDistribution)))"}
}

extension CreateStreamingDistributionWithTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let locationHeaderValue = httpResponse.headers.value(for: "Location") {
            self.location = locationHeaderValue
        } else {
            self.location = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: StreamingDistribution = try responseDecoder.decode(responseBody: unwrappedData)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct CreateStreamingDistributionWithTagsOutputResponse: Equatable {
    /// <p>The current version of the distribution created.</p>
    public let eTag: String?
    /// <p>The fully qualified URI of the new streaming distribution resource just created.</p>
    public let location: String?
    /// <p>The streaming distribution's information. </p>
    public let streamingDistribution: StreamingDistribution?

    public init (
        eTag: String? = nil,
        location: String? = nil,
        streamingDistribution: StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.location = location
        self.streamingDistribution = streamingDistribution
    }
}

struct CreateStreamingDistributionWithTagsOutputResponseBody: Equatable {
    public let streamingDistribution: StreamingDistribution?
}

extension CreateStreamingDistributionWithTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension CustomErrorResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCachingMinTTL = "ErrorCachingMinTTL"
        case errorCode = "ErrorCode"
        case responseCode = "ResponseCode"
        case responsePagePath = "ResponsePagePath"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let errorCachingMinTTL = errorCachingMinTTL {
            try container.encode(errorCachingMinTTL, forKey: Key("errorCachingMinTTL"))
        }
        if let errorCode = errorCode {
            try container.encode(errorCode, forKey: Key("errorCode"))
        }
        if let responseCode = responseCode {
            try container.encode(responseCode, forKey: Key("responseCode"))
        }
        if let responsePagePath = responsePagePath {
            try container.encode(responsePagePath, forKey: Key("responsePagePath"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let responsePagePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responsePagePath)
        responsePagePath = responsePagePathDecoded
        let responseCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responseCode)
        responseCode = responseCodeDecoded
        let errorCachingMinTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .errorCachingMinTTL)
        errorCachingMinTTL = errorCachingMinTTLDecoded
    }
}

extension CustomErrorResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomErrorResponse(errorCachingMinTTL: \(String(describing: errorCachingMinTTL)), errorCode: \(String(describing: errorCode)), responseCode: \(String(describing: responseCode)), responsePagePath: \(String(describing: responsePagePath)))"}
}

extension CustomErrorResponse: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that controls:</p>
/// 		       <ul>
///             <li>
/// 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
/// 					messages before returning the response to the viewer. </p>
/// 			         </li>
///             <li>
/// 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
/// 			         </li>
///          </ul>
/// 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
/// 				<i>Amazon CloudFront Developer Guide</i>.</p>
public struct CustomErrorResponse: Equatable {
    /// <p>The minimum amount of time, in seconds, that you want CloudFront to cache the HTTP status
    /// 			code specified in <code>ErrorCode</code>. When this time period has elapsed, CloudFront queries your
    /// 			origin to see whether the problem that caused the error has been resolved and the requested
    /// 			object is now available.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing
    /// 				Error Responses</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let errorCachingMinTTL: Int?
    /// <p>The HTTP status code for which you want to specify a custom error page and/or a caching
    /// 			duration.</p>
    public let errorCode: Int?
    /// <p>The HTTP status code that you want CloudFront to return to the viewer along with the custom
    /// 			error page. There are a variety of reasons that you might want CloudFront to return a status code
    /// 			different from the status code that your origin returned to CloudFront, for example:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Some Internet devices (some firewalls and corporate proxies, for example) intercept
    /// 					HTTP 4xx and 5xx and prevent the response from being returned to the viewer. If you
    /// 					substitute <code>200</code>, the response typically won't be intercepted.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>If you don't care about distinguishing among different client errors or server
    /// 					errors, you can specify <code>400</code> or <code>500</code> as the
    /// 						<code>ResponseCode</code> for all 4xx or 5xx errors.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You might want to return a <code>200</code> status code (OK) and static website so
    /// 					your customers don't know that your website is down.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>If you specify a value for <code>ResponseCode</code>, you must also specify a value for
    /// 			<code>ResponsePagePath</code>.</p>
    public let responseCode: String?
    /// <p>The path to the custom error page that you want CloudFront to return to a viewer when your
    /// 			origin returns the HTTP status code specified by <code>ErrorCode</code>, for example,
    /// 				<code>/4xx-errors/403-forbidden.html</code>. If you want to store your objects and your
    /// 			custom error pages in different locations, your distribution must include a cache behavior for
    /// 			which the following is true:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The value of <code>PathPattern</code> matches the path to your custom error
    /// 					messages. For example, suppose you saved custom error pages for 4xx errors in an Amazon S3
    /// 					bucket in a directory named <code>/4xx-errors</code>. Your distribution must include a
    /// 					cache behavior for which the path pattern routes requests for your custom error pages to
    /// 					that location, for example, <code>/4xx-errors/*</code>. </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The value of <code>TargetOriginId</code> specifies the value of the <code>ID</code>
    /// 					element for the origin that contains your custom error pages.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>If you specify a value for <code>ResponsePagePath</code>, you must also specify a value
    /// 			for <code>ResponseCode</code>.</p>
    /// 		       <p>We recommend that you store custom error pages in an Amazon S3 bucket. If you store custom
    /// 			error pages on an HTTP server and the server starts to return 5xx errors, CloudFront can't get the
    /// 			files that you want to return to viewers because the origin server is unavailable.</p>
    public let responsePagePath: String?

    public init (
        errorCachingMinTTL: Int? = nil,
        errorCode: Int? = nil,
        responseCode: String? = nil,
        responsePagePath: String? = nil
    )
    {
        self.errorCachingMinTTL = errorCachingMinTTL
        self.errorCode = errorCode
        self.responseCode = responseCode
        self.responsePagePath = responsePagePath
    }
}

extension CustomErrorResponses: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for customerrorresponse0 in items {
                try itemsContainer.encode(customerrorresponse0, forKey: Key("CustomErrorResponse"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct CustomErrorResponse{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.CustomErrorResponse>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([CustomErrorResponse].self, forKey: .member)
                var itemsBuffer:[CustomErrorResponse]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [CustomErrorResponse]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CustomErrorResponses: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomErrorResponses(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension CustomErrorResponses: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that controls:</p>
/// 		       <ul>
///             <li>
/// 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
/// 					messages before returning the response to the viewer.</p>
/// 			         </li>
///             <li>
/// 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
/// 			         </li>
///          </ul>
/// 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
/// 				<i>Amazon CloudFront Developer Guide</i>.</p>
public struct CustomErrorResponses: Equatable {
    /// <p>A complex type that contains a <code>CustomErrorResponse</code> element for each HTTP
    /// 			status code for which you want to specify a custom error page and/or a caching duration.
    /// 		</p>
    public let items: [CustomErrorResponse]?
    /// <p>The number of HTTP status codes for which you want to specify a custom error page
    /// 			and/or a caching duration. If <code>Quantity</code> is <code>0</code>, you can omit
    /// 				<code>Items</code>.</p>
    public let quantity: Int?

    public init (
        items: [CustomErrorResponse]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension CustomHeaders: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for origincustomheader0 in items {
                try itemsContainer.encode(origincustomheader0, forKey: Key("OriginCustomHeader"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginCustomHeader{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginCustomHeader>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([OriginCustomHeader].self, forKey: .member)
                var itemsBuffer:[OriginCustomHeader]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [OriginCustomHeader]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension CustomHeaders: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomHeaders(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension CustomHeaders: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains the list of Custom Headers for each origin. </p>
public struct CustomHeaders: Equatable {
    /// <p>
    ///             <b>Optional</b>: A list that contains one
    /// 				<code>OriginCustomHeader</code> element for each custom header that you want CloudFront to forward
    /// 			to the origin. If Quantity is <code>0</code>, omit <code>Items</code>.</p>
    public let items: [OriginCustomHeader]?
    /// <p>The number of custom headers, if any, for this distribution.</p>
    public let quantity: Int?

    public init (
        items: [OriginCustomHeader]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension CustomOriginConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hTTPPort = "HTTPPort"
        case hTTPSPort = "HTTPSPort"
        case originKeepaliveTimeout = "OriginKeepaliveTimeout"
        case originProtocolPolicy = "OriginProtocolPolicy"
        case originReadTimeout = "OriginReadTimeout"
        case originSslProtocols = "OriginSslProtocols"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let hTTPPort = hTTPPort {
            try container.encode(hTTPPort, forKey: Key("hTTPPort"))
        }
        if let hTTPSPort = hTTPSPort {
            try container.encode(hTTPSPort, forKey: Key("hTTPSPort"))
        }
        if let originKeepaliveTimeout = originKeepaliveTimeout {
            try container.encode(originKeepaliveTimeout, forKey: Key("originKeepaliveTimeout"))
        }
        if let originProtocolPolicy = originProtocolPolicy {
            try container.encode(originProtocolPolicy, forKey: Key("originProtocolPolicy"))
        }
        if let originReadTimeout = originReadTimeout {
            try container.encode(originReadTimeout, forKey: Key("originReadTimeout"))
        }
        if let originSslProtocols = originSslProtocols {
            try container.encode(originSslProtocols, forKey: Key("originSslProtocols"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hTTPPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .hTTPPort)
        hTTPPort = hTTPPortDecoded
        let hTTPSPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .hTTPSPort)
        hTTPSPort = hTTPSPortDecoded
        let originProtocolPolicyDecoded = try containerValues.decodeIfPresent(OriginProtocolPolicy.self, forKey: .originProtocolPolicy)
        originProtocolPolicy = originProtocolPolicyDecoded
        let originSslProtocolsDecoded = try containerValues.decodeIfPresent(OriginSslProtocols.self, forKey: .originSslProtocols)
        originSslProtocols = originSslProtocolsDecoded
        let originReadTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .originReadTimeout)
        originReadTimeout = originReadTimeoutDecoded
        let originKeepaliveTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .originKeepaliveTimeout)
        originKeepaliveTimeout = originKeepaliveTimeoutDecoded
    }
}

extension CustomOriginConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomOriginConfig(hTTPPort: \(String(describing: hTTPPort)), hTTPSPort: \(String(describing: hTTPSPort)), originKeepaliveTimeout: \(String(describing: originKeepaliveTimeout)), originProtocolPolicy: \(String(describing: originProtocolPolicy)), originReadTimeout: \(String(describing: originReadTimeout)), originSslProtocols: \(String(describing: originSslProtocols)))"}
}

extension CustomOriginConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A custom origin. A custom origin is any origin that is <i>not</i> an Amazon S3
/// 			bucket, with one exception. An Amazon S3 bucket that is <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html">configured with
/// 			static website hosting</a>
///             <i>is</i> a custom origin.</p>
public struct CustomOriginConfig: Equatable {
    /// <p>The HTTP port that CloudFront uses to connect to the origin. Specify the HTTP port that the origin
    /// 			listens on.</p>
    public let hTTPPort: Int?
    /// <p>The HTTPS port that CloudFront uses to connect to the origin. Specify the HTTPS port that the
    /// 			origin listens on.</p>
    public let hTTPSPort: Int?
    /// <p>Specifies how long, in seconds, CloudFront persists its connection to the origin. The minimum
    /// 			timeout is 1 second, the maximum is 60 seconds, and the default (if you don’t specify
    /// 			otherwise) is 5 seconds.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginKeepaliveTimeout">Origin Keep-alive Timeout</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let originKeepaliveTimeout: Int?
    /// <p>Specifies the protocol (HTTP or HTTPS) that CloudFront uses to connect to the origin. Valid values
    /// 			are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>http-only</code> – CloudFront always uses HTTP to connect to the
    /// 					origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>match-viewer</code> – CloudFront connects to the origin using the same
    /// 					protocol that the viewer used to connect to CloudFront.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>https-only</code> – CloudFront always uses HTTPS to connect to the
    /// 					origin.</p>
    /// 			         </li>
    ///          </ul>
    public let originProtocolPolicy: OriginProtocolPolicy?
    /// <p>Specifies how long, in seconds, CloudFront waits for a response from the origin. This is also
    /// 			known as the <i>origin response timeout</i>. The minimum timeout is 1
    /// 			second, the maximum is 60 seconds, and the default (if you don’t specify otherwise) is
    /// 			30 seconds.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout">Origin Response Timeout</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let originReadTimeout: Int?
    /// <p>Specifies the minimum SSL/TLS protocol that CloudFront uses when connecting to your origin over
    /// 			HTTPS. Valid values include <code>SSLv3</code>, <code>TLSv1</code>,
    /// 			<code>TLSv1.1</code>, and <code>TLSv1.2</code>.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginSSLProtocols">Minimum Origin SSL Protocol</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let originSslProtocols: OriginSslProtocols?

    public init (
        hTTPPort: Int? = nil,
        hTTPSPort: Int? = nil,
        originKeepaliveTimeout: Int? = nil,
        originProtocolPolicy: OriginProtocolPolicy? = nil,
        originReadTimeout: Int? = nil,
        originSslProtocols: OriginSslProtocols? = nil
    )
    {
        self.hTTPPort = hTTPPort
        self.hTTPSPort = hTTPSPort
        self.originKeepaliveTimeout = originKeepaliveTimeout
        self.originProtocolPolicy = originProtocolPolicy
        self.originReadTimeout = originReadTimeout
        self.originSslProtocols = originSslProtocols
    }
}

extension DefaultCacheBehavior: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedMethods = "AllowedMethods"
        case cachePolicyId = "CachePolicyId"
        case compress = "Compress"
        case defaultTTL = "DefaultTTL"
        case fieldLevelEncryptionId = "FieldLevelEncryptionId"
        case forwardedValues = "ForwardedValues"
        case functionAssociations = "FunctionAssociations"
        case lambdaFunctionAssociations = "LambdaFunctionAssociations"
        case maxTTL = "MaxTTL"
        case minTTL = "MinTTL"
        case originRequestPolicyId = "OriginRequestPolicyId"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case smoothStreaming = "SmoothStreaming"
        case targetOriginId = "TargetOriginId"
        case trustedKeyGroups = "TrustedKeyGroups"
        case trustedSigners = "TrustedSigners"
        case viewerProtocolPolicy = "ViewerProtocolPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let allowedMethods = allowedMethods {
            try container.encode(allowedMethods, forKey: Key("allowedMethods"))
        }
        if let cachePolicyId = cachePolicyId {
            try container.encode(cachePolicyId, forKey: Key("cachePolicyId"))
        }
        if let compress = compress {
            try container.encode(compress, forKey: Key("compress"))
        }
        if let defaultTTL = defaultTTL {
            try container.encode(defaultTTL, forKey: Key("defaultTTL"))
        }
        if let fieldLevelEncryptionId = fieldLevelEncryptionId {
            try container.encode(fieldLevelEncryptionId, forKey: Key("fieldLevelEncryptionId"))
        }
        if let forwardedValues = forwardedValues {
            try container.encode(forwardedValues, forKey: Key("forwardedValues"))
        }
        if let functionAssociations = functionAssociations {
            try container.encode(functionAssociations, forKey: Key("functionAssociations"))
        }
        if let lambdaFunctionAssociations = lambdaFunctionAssociations {
            try container.encode(lambdaFunctionAssociations, forKey: Key("lambdaFunctionAssociations"))
        }
        if let maxTTL = maxTTL {
            try container.encode(maxTTL, forKey: Key("maxTTL"))
        }
        if let minTTL = minTTL {
            try container.encode(minTTL, forKey: Key("minTTL"))
        }
        if let originRequestPolicyId = originRequestPolicyId {
            try container.encode(originRequestPolicyId, forKey: Key("originRequestPolicyId"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: Key("realtimeLogConfigArn"))
        }
        if let smoothStreaming = smoothStreaming {
            try container.encode(smoothStreaming, forKey: Key("smoothStreaming"))
        }
        if let targetOriginId = targetOriginId {
            try container.encode(targetOriginId, forKey: Key("targetOriginId"))
        }
        if let trustedKeyGroups = trustedKeyGroups {
            try container.encode(trustedKeyGroups, forKey: Key("trustedKeyGroups"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: Key("trustedSigners"))
        }
        if let viewerProtocolPolicy = viewerProtocolPolicy {
            try container.encode(viewerProtocolPolicy, forKey: Key("viewerProtocolPolicy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetOriginIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetOriginId)
        targetOriginId = targetOriginIdDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let trustedKeyGroupsDecoded = try containerValues.decodeIfPresent(TrustedKeyGroups.self, forKey: .trustedKeyGroups)
        trustedKeyGroups = trustedKeyGroupsDecoded
        let viewerProtocolPolicyDecoded = try containerValues.decodeIfPresent(ViewerProtocolPolicy.self, forKey: .viewerProtocolPolicy)
        viewerProtocolPolicy = viewerProtocolPolicyDecoded
        let allowedMethodsDecoded = try containerValues.decodeIfPresent(AllowedMethods.self, forKey: .allowedMethods)
        allowedMethods = allowedMethodsDecoded
        let smoothStreamingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .smoothStreaming)
        smoothStreaming = smoothStreamingDecoded
        let compressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .compress)
        compress = compressDecoded
        let lambdaFunctionAssociationsDecoded = try containerValues.decodeIfPresent(LambdaFunctionAssociations.self, forKey: .lambdaFunctionAssociations)
        lambdaFunctionAssociations = lambdaFunctionAssociationsDecoded
        let functionAssociationsDecoded = try containerValues.decodeIfPresent(FunctionAssociations.self, forKey: .functionAssociations)
        functionAssociations = functionAssociationsDecoded
        let fieldLevelEncryptionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fieldLevelEncryptionId)
        fieldLevelEncryptionId = fieldLevelEncryptionIdDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
        let cachePolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cachePolicyId)
        cachePolicyId = cachePolicyIdDecoded
        let originRequestPolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originRequestPolicyId)
        originRequestPolicyId = originRequestPolicyIdDecoded
        let forwardedValuesDecoded = try containerValues.decodeIfPresent(ForwardedValues.self, forKey: .forwardedValues)
        forwardedValues = forwardedValuesDecoded
        let minTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minTTL)
        minTTL = minTTLDecoded
        let defaultTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .defaultTTL)
        defaultTTL = defaultTTLDecoded
        let maxTTLDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxTTL)
        maxTTL = maxTTLDecoded
    }
}

extension DefaultCacheBehavior: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultCacheBehavior(allowedMethods: \(String(describing: allowedMethods)), cachePolicyId: \(String(describing: cachePolicyId)), compress: \(String(describing: compress)), defaultTTL: \(String(describing: defaultTTL)), fieldLevelEncryptionId: \(String(describing: fieldLevelEncryptionId)), forwardedValues: \(String(describing: forwardedValues)), functionAssociations: \(String(describing: functionAssociations)), lambdaFunctionAssociations: \(String(describing: lambdaFunctionAssociations)), maxTTL: \(String(describing: maxTTL)), minTTL: \(String(describing: minTTL)), originRequestPolicyId: \(String(describing: originRequestPolicyId)), realtimeLogConfigArn: \(String(describing: realtimeLogConfigArn)), smoothStreaming: \(String(describing: smoothStreaming)), targetOriginId: \(String(describing: targetOriginId)), trustedKeyGroups: \(String(describing: trustedKeyGroups)), trustedSigners: \(String(describing: trustedSigners)), viewerProtocolPolicy: \(String(describing: viewerProtocolPolicy)))"}
}

extension DefaultCacheBehavior: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that describes the default cache behavior if you don’t specify a
/// 			<code>CacheBehavior</code> element or if request URLs don’t match any of the values of
/// 			<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly
/// 			one default cache behavior.</p>
public struct DefaultCacheBehavior: Equatable {
    /// <p>A complex type that controls which HTTP methods CloudFront processes and forwards to your
    /// 			Amazon S3 bucket or your custom origin. There are three choices:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>CloudFront forwards only <code>GET</code> and <code>HEAD</code> requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>CloudFront forwards only <code>GET</code>, <code>HEAD</code>, and <code>OPTIONS</code>
    /// 					requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>CloudFront forwards <code>GET, HEAD, OPTIONS, PUT, PATCH, POST</code>, and
    /// 						<code>DELETE</code> requests.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>If you pick the third choice, you may need to restrict access to your Amazon S3 bucket or
    /// 			to your custom origin so users can't perform operations that you don't want them to. For
    /// 			example, you might not want users to have permissions to delete objects from your
    /// 			origin.</p>
    public let allowedMethods: AllowedMethods?
    /// <p>The unique identifier of the cache policy that is attached to the default cache behavior.
    /// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    ///             <i>Amazon CloudFront Developer Guide</i>.</p>
    ///         <p>A <code>DefaultCacheBehavior</code> must include either a
    ///             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
    ///             use a <code>CachePolicyId</code>.</p>
    public let cachePolicyId: String?
    /// <p>Whether you want CloudFront to automatically compress certain files for this cache behavior.
    /// 			If so, specify <code>true</code>; if not, specify <code>false</code>. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html">Serving Compressed Files</a> in
    /// 			the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let compress: Bool?
    /// <p>This field is deprecated. We recommend that you use the <code>DefaultTTL</code> field in a
    /// 			cache policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>The default amount of time that you want objects to stay in CloudFront caches before CloudFront
    /// 			forwards another request to your origin to determine whether the object has been updated. The
    /// 			value that you specify applies only when your origin does not add HTTP headers such as
    /// 				<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
    /// 				<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
    /// 					in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    @available(*, deprecated)
    public let defaultTTL: Int?
    /// <p>The value of <code>ID</code> for the field-level encryption configuration that you want CloudFront
    /// 			to use for encrypting specific fields of data for the default cache behavior.</p>
    public let fieldLevelEncryptionId: String?
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin request
    /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/working-with-policies.html">Working with policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to include values in the cache key, use a cache policy. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send values to the origin but not include them in the cache key, use an
    /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
    ///             <i>Amazon CloudFront Developer Guide</i>.</p>
    ///         <p>A <code>DefaultCacheBehavior</code> must include either a
    ///             <code>CachePolicyId</code> or <code>ForwardedValues</code>. We recommend that you
    ///             use a <code>CachePolicyId</code>.</p>
    /// 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
    @available(*, deprecated)
    public let forwardedValues: ForwardedValues?
    /// <p>A list of CloudFront functions that are associated with this cache behavior. CloudFront functions must
    /// 			be published to the <code>LIVE</code> stage to associate them with a cache
    /// 			behavior.</p>
    public let functionAssociations: FunctionAssociations?
    /// <p>A complex type that contains zero or more Lambda function associations for a cache
    /// 			behavior.</p>
    public let lambdaFunctionAssociations: LambdaFunctionAssociations?
    /// <p>This field is deprecated. We recommend that you use the <code>MaxTTL</code> field in a cache
    /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>The maximum amount of time that you want objects to stay in CloudFront caches before CloudFront
    /// 			forwards another request to your origin to determine whether the object has been updated. The
    /// 			value that you specify applies only when your origin adds HTTP headers such as
    /// 			<code>Cache-Control max-age</code>, <code>Cache-Control s-maxage</code>, and
    /// 			<code>Expires</code> to objects. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
    /// 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    @available(*, deprecated)
    public let maxTTL: Int?
    /// <p>This field is deprecated. We recommend that you use the <code>MinTTL</code> field in a cache
    /// 			policy instead of this field. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html">Using the managed cache policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>The minimum amount of time that you want objects to stay in CloudFront caches before CloudFront
    /// 			forwards another request to your origin to determine whether the object has been updated. For
    /// 			more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing How Long Content Stays
    /// 				in an Edge Cache (Expiration)</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>You must specify <code>0</code> for <code>MinTTL</code> if you configure CloudFront to
    /// 			forward all headers to your origin (under <code>Headers</code>, if you specify <code>1</code>
    /// 			for <code>Quantity</code> and <code>*</code> for <code>Name</code>).</p>
    @available(*, deprecated)
    public let minTTL: Int?
    /// <p>The unique identifier of the origin request policy that is attached to the default cache
    /// 			behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> or <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html">Using the managed origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let originRequestPolicyId: String?
    /// <p>The Amazon Resource Name (ARN) of the real-time log configuration that is attached to this
    /// 			cache behavior. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let realtimeLogConfigArn: String?
    /// <p>Indicates whether you want to distribute media files in the Microsoft Smooth Streaming
    /// 			format using the origin that is associated with this cache behavior. If so, specify
    /// 				<code>true</code>; if not, specify <code>false</code>. If you specify <code>true</code> for
    /// 				<code>SmoothStreaming</code>, you can still distribute other content using this cache
    /// 			behavior if the content matches the value of <code>PathPattern</code>. </p>
    public let smoothStreaming: Bool?
    /// <p>The value of <code>ID</code> for the origin that you want CloudFront to route requests to when
    /// 			they use the default cache behavior.</p>
    public let targetOriginId: String?
    /// <p>A list of key groups that CloudFront can use to validate signed URLs or signed cookies.</p>
    /// 		       <p>When a cache behavior contains trusted key groups, CloudFront requires signed URLs or signed
    /// 			cookies for all requests that match the cache behavior. The URLs or cookies must be
    /// 			signed with a private key whose corresponding public key is in the key group. The signed
    /// 			URL or cookie contains information about which public key CloudFront should use to verify the
    /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let trustedKeyGroups: TrustedKeyGroups?
    /// <important>
    /// 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
    /// 				<code>TrustedSigners</code>.</p>
    /// 		       </important>
    /// 		       <p>A list of AWS account IDs whose public keys CloudFront can use to validate signed URLs or signed
    /// 			cookies.</p>
    /// 		       <p>When a cache behavior contains trusted signers, CloudFront requires signed URLs or signed cookies
    /// 			for all requests that match the cache behavior. The URLs or cookies must be signed with
    /// 			the private key of a CloudFront key pair in a trusted signer’s AWS account. The signed URL or
    /// 			cookie contains information about which public key CloudFront should use to verify the
    /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let trustedSigners: TrustedSigners?
    /// <p>The protocol that viewers can use to access the files in the origin specified by
    /// 				<code>TargetOriginId</code> when a request matches the path pattern in
    /// 				<code>PathPattern</code>. You can specify the following options:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>allow-all</code>: Viewers can use HTTP or HTTPS.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>redirect-to-https</code>: If a viewer submits an HTTP request, CloudFront returns
    /// 					an HTTP status code of 301 (Moved Permanently) to the viewer along with the HTTPS URL. The
    /// 					viewer then resubmits the request using the new URL.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>https-only</code>: If a viewer sends an HTTP request, CloudFront returns an HTTP
    /// 					status code of 403 (Forbidden).</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information about requiring the HTTPS protocol, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-viewers-to-cloudfront.html">Requiring HTTPS Between Viewers and CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <note>
    /// 			         <p>The only way to guarantee that viewers retrieve an object that was fetched from
    /// 				the origin using HTTPS is never to use any other protocol to fetch the object. If
    /// 				you have recently changed from HTTP to HTTPS, we recommend that you clear your
    /// 				objects’ cache because cached objects are protocol agnostic. That means that an edge
    /// 				location will return an object from the cache regardless of whether the current
    /// 				request protocol matches the protocol used previously. For more information, see
    /// 				<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html">Managing Cache
    /// 				Expiration</a> in the
    /// 					<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       </note>
    public let viewerProtocolPolicy: ViewerProtocolPolicy?

    public init (
        allowedMethods: AllowedMethods? = nil,
        cachePolicyId: String? = nil,
        compress: Bool? = nil,
        defaultTTL: Int? = nil,
        fieldLevelEncryptionId: String? = nil,
        forwardedValues: ForwardedValues? = nil,
        functionAssociations: FunctionAssociations? = nil,
        lambdaFunctionAssociations: LambdaFunctionAssociations? = nil,
        maxTTL: Int? = nil,
        minTTL: Int? = nil,
        originRequestPolicyId: String? = nil,
        realtimeLogConfigArn: String? = nil,
        smoothStreaming: Bool? = nil,
        targetOriginId: String? = nil,
        trustedKeyGroups: TrustedKeyGroups? = nil,
        trustedSigners: TrustedSigners? = nil,
        viewerProtocolPolicy: ViewerProtocolPolicy? = nil
    )
    {
        self.allowedMethods = allowedMethods
        self.cachePolicyId = cachePolicyId
        self.compress = compress
        self.defaultTTL = defaultTTL
        self.fieldLevelEncryptionId = fieldLevelEncryptionId
        self.forwardedValues = forwardedValues
        self.functionAssociations = functionAssociations
        self.lambdaFunctionAssociations = lambdaFunctionAssociations
        self.maxTTL = maxTTL
        self.minTTL = minTTL
        self.originRequestPolicyId = originRequestPolicyId
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.smoothStreaming = smoothStreaming
        self.targetOriginId = targetOriginId
        self.trustedKeyGroups = trustedKeyGroups
        self.trustedSigners = trustedSigners
        self.viewerProtocolPolicy = viewerProtocolPolicy
    }
}

extension DeleteCachePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCachePolicyInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeleteCachePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCachePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCachePolicyInput>
    public typealias MOutput = OperationOutput<DeleteCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCachePolicyOutputError>
}

public struct DeleteCachePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCachePolicyInput>
    public typealias MOutput = OperationOutput<DeleteCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCachePolicyOutputError>
}

public struct DeleteCachePolicyInput: Equatable {
    /// <p>The unique identifier for the cache policy that you are deleting. To get the
    /// 			identifier, you can use <code>ListCachePolicies</code>.</p>
    public let id: String?
    /// <p>The version of the cache policy that you are deleting. The version is the cache
    /// 			policy’s <code>ETag</code> value, which you can get using
    /// 			<code>ListCachePolicies</code>, <code>GetCachePolicy</code>, or
    /// 			<code>GetCachePolicyConfig</code>.</p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCachePolicyInputBody: Equatable {
}

extension DeleteCachePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCachePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCachePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyInUse" : self = .cachePolicyInUse(try CachePolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCachePolicyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyInUse(CachePolicyInUse)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCachePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCachePolicyOutputResponse()"}
}

extension DeleteCachePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCachePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteCachePolicyOutputResponseBody: Equatable {
}

extension DeleteCachePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCloudFrontOriginAccessIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCloudFrontOriginAccessIdentityInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeleteCloudFrontOriginAccessIdentityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCloudFrontOriginAccessIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCloudFrontOriginAccessIdentityOutputError>
}

public struct DeleteCloudFrontOriginAccessIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<DeleteCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCloudFrontOriginAccessIdentityOutputError>
}

/// <p>Deletes a origin access identity.</p>
public struct DeleteCloudFrontOriginAccessIdentityInput: Equatable {
    /// <p>The origin access identity's ID.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header you received from a previous <code>GET</code>
    /// 			or <code>PUT</code> request. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteCloudFrontOriginAccessIdentityInputBody: Equatable {
}

extension DeleteCloudFrontOriginAccessIdentityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudFrontOriginAccessIdentityInUse" : self = .cloudFrontOriginAccessIdentityInUse(try CloudFrontOriginAccessIdentityInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCloudFrontOriginAccessIdentityOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cloudFrontOriginAccessIdentityInUse(CloudFrontOriginAccessIdentityInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCloudFrontOriginAccessIdentityOutputResponse()"}
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCloudFrontOriginAccessIdentityOutputResponse: Equatable {

    public init() {}
}

struct DeleteCloudFrontOriginAccessIdentityOutputResponseBody: Equatable {
}

extension DeleteCloudFrontOriginAccessIdentityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDistributionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDistributionInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeleteDistributionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDistributionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDistributionInput>
    public typealias MOutput = OperationOutput<DeleteDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDistributionOutputError>
}

public struct DeleteDistributionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDistributionInput>
    public typealias MOutput = OperationOutput<DeleteDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDistributionOutputError>
}

/// <p>This action deletes a web distribution. To delete a web distribution using the CloudFront
/// 			API, perform the following steps.</p>
/// 		       <p>
/// 			         <b>To delete a web distribution using the CloudFront API:</b>
/// 		       </p>
/// 		       <ol>
///             <li>
/// 				           <p>Disable the web distribution </p>
/// 			         </li>
///             <li>
/// 				           <p>Submit a <code>GET Distribution Config</code> request to get the current
/// 					configuration and the <code>Etag</code> header for the distribution.</p>
/// 			         </li>
///             <li>
/// 				           <p>Update the XML document that was returned in the response to your <code>GET
/// 						Distribution Config</code> request to change the value of <code>Enabled</code> to
/// 						<code>false</code>.</p>
/// 			         </li>
///             <li>
/// 				           <p>Submit a <code>PUT Distribution Config</code> request to update the configuration
/// 					for your distribution. In the request body, include the XML document that you updated in
/// 					Step 3. Set the value of the HTTP <code>If-Match</code> header to the value of the
/// 						<code>ETag</code> header that CloudFront returned when you submitted the <code>GET
/// 						Distribution Config</code> request in Step 2.</p>
/// 			         </li>
///             <li>
/// 				           <p>Review the response to the <code>PUT Distribution Config</code> request to confirm
/// 					that the distribution was successfully disabled.</p>
/// 			         </li>
///             <li>
/// 				           <p>Submit a <code>GET Distribution</code> request to confirm that your changes have
/// 					propagated. When propagation is complete, the value of <code>Status</code> is
/// 						<code>Deployed</code>.</p>
/// 			         </li>
///             <li>
/// 				           <p>Submit a <code>DELETE Distribution</code> request. Set the value of the HTTP
/// 						<code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront
/// 					returned when you submitted the <code>GET Distribution Config</code> request in Step
/// 					6.</p>
/// 			         </li>
///             <li>
/// 				           <p>Review the response to your <code>DELETE Distribution</code> request to confirm
/// 					that the distribution was successfully deleted.</p>
/// 			         </li>
///          </ol>
/// 		       <p>For information about deleting a distribution using the CloudFront console, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html">Deleting a Distribution</a> in the
/// 				<i>Amazon CloudFront Developer Guide</i>.</p>
public struct DeleteDistributionInput: Equatable {
    /// <p>The distribution ID. </p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when you disabled the
    /// 			distribution. For example: <code>E2QWRUHAPOMQZL</code>. </p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteDistributionInputBody: Equatable {
}

extension DeleteDistributionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDistributionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteDistributionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DistributionNotDisabled" : self = .distributionNotDisabled(try DistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDistributionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case distributionNotDisabled(DistributionNotDisabled)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchDistribution(NoSuchDistribution)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDistributionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDistributionOutputResponse()"}
}

extension DeleteDistributionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDistributionOutputResponse: Equatable {

    public init() {}
}

struct DeleteDistributionOutputResponseBody: Equatable {
}

extension DeleteDistributionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFieldLevelEncryptionConfigInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeleteFieldLevelEncryptionConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFieldLevelEncryptionConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFieldLevelEncryptionConfigOutputError>
}

public struct DeleteFieldLevelEncryptionConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<DeleteFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFieldLevelEncryptionConfigOutputError>
}

public struct DeleteFieldLevelEncryptionConfigInput: Equatable {
    /// <p>The ID of the configuration you want to delete from CloudFront.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			configuration identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionConfigInputBody: Equatable {
}

extension DeleteFieldLevelEncryptionConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFieldLevelEncryptionConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionConfigInUse" : self = .fieldLevelEncryptionConfigInUse(try FieldLevelEncryptionConfigInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFieldLevelEncryptionConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionConfigInUse(FieldLevelEncryptionConfigInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFieldLevelEncryptionConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFieldLevelEncryptionConfigOutputResponse()"}
}

extension DeleteFieldLevelEncryptionConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFieldLevelEncryptionConfigOutputResponse: Equatable {

    public init() {}
}

struct DeleteFieldLevelEncryptionConfigOutputResponseBody: Equatable {
}

extension DeleteFieldLevelEncryptionConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFieldLevelEncryptionProfileInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeleteFieldLevelEncryptionProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFieldLevelEncryptionProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFieldLevelEncryptionProfileOutputError>
}

public struct DeleteFieldLevelEncryptionProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<DeleteFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFieldLevelEncryptionProfileOutputError>
}

public struct DeleteFieldLevelEncryptionProfileInput: Equatable {
    /// <p>Request the ID of the profile you want to delete from CloudFront.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			profile to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteFieldLevelEncryptionProfileInputBody: Equatable {
}

extension DeleteFieldLevelEncryptionProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFieldLevelEncryptionProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFieldLevelEncryptionProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileInUse" : self = .fieldLevelEncryptionProfileInUse(try FieldLevelEncryptionProfileInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFieldLevelEncryptionProfileOutputError: Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionProfileInUse(FieldLevelEncryptionProfileInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFieldLevelEncryptionProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFieldLevelEncryptionProfileOutputResponse()"}
}

extension DeleteFieldLevelEncryptionProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFieldLevelEncryptionProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteFieldLevelEncryptionProfileOutputResponseBody: Equatable {
}

extension DeleteFieldLevelEncryptionProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionInput(ifMatch: \(String(describing: ifMatch)), name: \(String(describing: name)))"}
}

extension DeleteFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInput: Equatable {
    /// <p>The current version (<code>ETag</code> value) of the function that you are deleting, which
    /// 			you can get using <code>DescribeFunction</code>.</p>
    public let ifMatch: String?
    /// <p>The name of the function that you are deleting.</p>
    public let name: String?

    public init (
        ifMatch: String? = nil,
        name: String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct DeleteFunctionInputBody: Equatable {
}

extension DeleteFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FunctionInUse" : self = .functionInUse(try FunctionInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Equatable {
    case functionInUse(FunctionInUse)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionOutputResponse()"}
}

extension DeleteFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Equatable {

    public init() {}
}

struct DeleteFunctionOutputResponseBody: Equatable {
}

extension DeleteFunctionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteKeyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteKeyGroupInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeleteKeyGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteKeyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteKeyGroupInput>
    public typealias MOutput = OperationOutput<DeleteKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteKeyGroupOutputError>
}

public struct DeleteKeyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteKeyGroupInput>
    public typealias MOutput = OperationOutput<DeleteKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteKeyGroupOutputError>
}

public struct DeleteKeyGroupInput: Equatable {
    /// <p>The identifier of the key group that you are deleting. To get the identifier, use
    /// 			<code>ListKeyGroups</code>.</p>
    public let id: String?
    /// <p>The version of the key group that you are deleting. The version is the key group’s
    /// 			<code>ETag</code> value. To get the <code>ETag</code>, use <code>GetKeyGroup</code> or
    /// 			<code>GetKeyGroupConfig</code>.</p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteKeyGroupInputBody: Equatable {
}

extension DeleteKeyGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteKeyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteKeyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUse" : self = .resourceInUse(try ResourceInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteKeyGroupOutputError: Equatable {
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchResource(NoSuchResource)
    case preconditionFailed(PreconditionFailed)
    case resourceInUse(ResourceInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteKeyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteKeyGroupOutputResponse()"}
}

extension DeleteKeyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteKeyGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteKeyGroupOutputResponseBody: Equatable {
}

extension DeleteKeyGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMonitoringSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMonitoringSubscriptionInput(distributionId: \(String(describing: distributionId)))"}
}

extension DeleteMonitoringSubscriptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteMonitoringSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMonitoringSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMonitoringSubscriptionOutputError>
}

public struct DeleteMonitoringSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMonitoringSubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMonitoringSubscriptionOutputError>
}

public struct DeleteMonitoringSubscriptionInput: Equatable {
    /// <p>The ID of the distribution that you are disabling metrics for.</p>
    public let distributionId: String?

    public init (
        distributionId: String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct DeleteMonitoringSubscriptionInputBody: Equatable {
}

extension DeleteMonitoringSubscriptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMonitoringSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteMonitoringSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMonitoringSubscriptionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMonitoringSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMonitoringSubscriptionOutputResponse()"}
}

extension DeleteMonitoringSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMonitoringSubscriptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteMonitoringSubscriptionOutputResponseBody: Equatable {
}

extension DeleteMonitoringSubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteOriginRequestPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOriginRequestPolicyInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeleteOriginRequestPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteOriginRequestPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<DeleteOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOriginRequestPolicyOutputError>
}

public struct DeleteOriginRequestPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<DeleteOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOriginRequestPolicyOutputError>
}

public struct DeleteOriginRequestPolicyInput: Equatable {
    /// <p>The unique identifier for the origin request policy that you are deleting. To get the
    /// 			identifier, you can use <code>ListOriginRequestPolicies</code>.</p>
    public let id: String?
    /// <p>The version of the origin request policy that you are deleting. The version is the origin
    /// 			request policy’s <code>ETag</code> value, which you can get using
    /// 			<code>ListOriginRequestPolicies</code>, <code>GetOriginRequestPolicy</code>, or
    /// 			<code>GetOriginRequestPolicyConfig</code>.</p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteOriginRequestPolicyInputBody: Equatable {
}

extension DeleteOriginRequestPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteOriginRequestPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteOriginRequestPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalDelete" : self = .illegalDelete(try IllegalDelete(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyInUse" : self = .originRequestPolicyInUse(try OriginRequestPolicyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOriginRequestPolicyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case illegalDelete(IllegalDelete)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case originRequestPolicyInUse(OriginRequestPolicyInUse)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOriginRequestPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOriginRequestPolicyOutputResponse()"}
}

extension DeleteOriginRequestPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteOriginRequestPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteOriginRequestPolicyOutputResponseBody: Equatable {
}

extension DeleteOriginRequestPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePublicKeyInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeletePublicKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePublicKeyInput>
    public typealias MOutput = OperationOutput<DeletePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePublicKeyOutputError>
}

public struct DeletePublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePublicKeyInput>
    public typealias MOutput = OperationOutput<DeletePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePublicKeyOutputError>
}

public struct DeletePublicKeyInput: Equatable {
    /// <p>The ID of the public key you want to remove from CloudFront.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			public key identity to delete. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeletePublicKeyInputBody: Equatable {
}

extension DeletePublicKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeletePublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PublicKeyInUse" : self = .publicKeyInUse(try PublicKeyInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePublicKeyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case publicKeyInUse(PublicKeyInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePublicKeyOutputResponse()"}
}

extension DeletePublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublicKeyOutputResponse: Equatable {

    public init() {}
}

struct DeletePublicKeyOutputResponseBody: Equatable {
}

extension DeletePublicKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRealtimeLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRealtimeLogConfigOutputError>
}

extension DeleteRealtimeLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRealtimeLogConfigInput(aRN: \(String(describing: aRN)), name: \(String(describing: name)))"}
}

extension DeleteRealtimeLogConfigInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension DeleteRealtimeLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("aRN"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }
}

public struct DeleteRealtimeLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRealtimeLogConfigOutputError>
}

public struct DeleteRealtimeLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<DeleteRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRealtimeLogConfigOutputError>
}

public struct DeleteRealtimeLogConfigInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the real-time log configuration to delete.</p>
    public let aRN: String?
    /// <p>The name of the real-time log configuration to delete.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct DeleteRealtimeLogConfigInputBody: Equatable {
    public let name: String?
    public let aRN: String?
}

extension DeleteRealtimeLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension DeleteRealtimeLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRealtimeLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigInUse" : self = .realtimeLogConfigInUse(try RealtimeLogConfigInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRealtimeLogConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case realtimeLogConfigInUse(RealtimeLogConfigInUse)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRealtimeLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRealtimeLogConfigOutputResponse()"}
}

extension DeleteRealtimeLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRealtimeLogConfigOutputResponse: Equatable {

    public init() {}
}

struct DeleteRealtimeLogConfigOutputResponseBody: Equatable {
}

extension DeleteRealtimeLogConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStreamingDistributionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamingDistributionInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension DeleteStreamingDistributionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteStreamingDistributionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamingDistributionInput>
    public typealias MOutput = OperationOutput<DeleteStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamingDistributionOutputError>
}

public struct DeleteStreamingDistributionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamingDistributionInput>
    public typealias MOutput = OperationOutput<DeleteStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamingDistributionOutputError>
}

/// <p>The request to delete a streaming distribution.</p>
public struct DeleteStreamingDistributionInput: Equatable {
    /// <p>The distribution ID. </p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when you disabled the
    /// 			streaming distribution. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct DeleteStreamingDistributionInputBody: Equatable {
}

extension DeleteStreamingDistributionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteStreamingDistributionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteStreamingDistributionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamingDistributionNotDisabled" : self = .streamingDistributionNotDisabled(try StreamingDistributionNotDisabled(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamingDistributionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case preconditionFailed(PreconditionFailed)
    case streamingDistributionNotDisabled(StreamingDistributionNotDisabled)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamingDistributionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamingDistributionOutputResponse()"}
}

extension DeleteStreamingDistributionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamingDistributionOutputResponse: Equatable {

    public init() {}
}

struct DeleteStreamingDistributionOutputResponseBody: Equatable {
}

extension DeleteStreamingDistributionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFunctionInput(name: \(String(describing: name)), stage: \(String(describing: stage)))"}
}

extension DescribeFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFunctionInput>
    public typealias MOutput = OperationOutput<DescribeFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFunctionOutputError>
}

public struct DescribeFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = URLQueryItem(name: "Stage".urlPercentEncoding(), value: String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFunctionInput>
    public typealias MOutput = OperationOutput<DescribeFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFunctionOutputError>
}

public struct DescribeFunctionInput: Equatable {
    /// <p>The name of the function that you are getting information about.</p>
    public let name: String?
    /// <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
    public let stage: FunctionStage?

    public init (
        name: String? = nil,
        stage: FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct DescribeFunctionInputBody: Equatable {
}

extension DescribeFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFunctionOutputError: Equatable {
    case noSuchFunctionExists(NoSuchFunctionExists)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFunctionOutputResponse(eTag: \(String(describing: eTag)), functionSummary: \(String(describing: functionSummary)))"}
}

extension DescribeFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FunctionSummary = try responseDecoder.decode(responseBody: unwrappedData)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct DescribeFunctionOutputResponse: Equatable {
    /// <p>The version identifier for the current version of the CloudFront function.</p>
    public let eTag: String?
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public let functionSummary: FunctionSummary?

    public init (
        eTag: String? = nil,
        functionSummary: FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct DescribeFunctionOutputResponseBody: Equatable {
    public let functionSummary: FunctionSummary?
}

extension DescribeFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

extension Distribution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case activeTrustedKeyGroups = "ActiveTrustedKeyGroups"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case aliasICPRecordals = "AliasICPRecordals"
        case distributionConfig = "DistributionConfig"
        case domainName = "DomainName"
        case id = "Id"
        case inProgressInvalidationBatches = "InProgressInvalidationBatches"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("aRN"))
        }
        if let activeTrustedKeyGroups = activeTrustedKeyGroups {
            try container.encode(activeTrustedKeyGroups, forKey: Key("activeTrustedKeyGroups"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: Key("activeTrustedSigners"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("aliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: Key("AliasICPRecordal"))
            }
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: Key("distributionConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("domainName"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let inProgressInvalidationBatches = inProgressInvalidationBatches {
            try container.encode(inProgressInvalidationBatches, forKey: Key("inProgressInvalidationBatches"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let inProgressInvalidationBatchesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .inProgressInvalidationBatches)
        inProgressInvalidationBatches = inProgressInvalidationBatchesDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let activeTrustedKeyGroupsDecoded = try containerValues.decodeIfPresent(ActiveTrustedKeyGroups.self, forKey: .activeTrustedKeyGroups)
        activeTrustedKeyGroups = activeTrustedKeyGroupsDecoded
        let distributionConfigDecoded = try containerValues.decodeIfPresent(DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension Distribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Distribution(aRN: \(String(describing: aRN)), activeTrustedKeyGroups: \(String(describing: activeTrustedKeyGroups)), activeTrustedSigners: \(String(describing: activeTrustedSigners)), aliasICPRecordals: \(String(describing: aliasICPRecordals)), distributionConfig: \(String(describing: distributionConfig)), domainName: \(String(describing: domainName)), id: \(String(describing: id)), inProgressInvalidationBatches: \(String(describing: inProgressInvalidationBatches)), lastModifiedTime: \(String(describing: lastModifiedTime)), status: \(String(describing: status)))"}
}

extension Distribution: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A distribution tells CloudFront where you want content to be delivered from, and the details about how to
/// 			track and manage content delivery.</p>
public struct Distribution: Equatable {
    /// <p>The ARN (Amazon Resource Name) for the distribution. For example:
    /// 				<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
    /// 				<code>123456789012</code> is your AWS account ID.</p>
    public let aRN: String?
    /// <p>CloudFront automatically adds this field to the response if you’ve configured a cache
    /// 			behavior in this distribution to serve private content using key groups. This field
    /// 			contains a list of key groups and the public keys in each key group that CloudFront can use to
    /// 			verify the signatures of signed URLs or signed cookies.</p>
    public let activeTrustedKeyGroups: ActiveTrustedKeyGroups?
    /// <important>
    /// 			         <p>We recommend using <code>TrustedKeyGroups</code> instead of
    /// 				<code>TrustedSigners</code>.</p>
    /// 		       </important>
    /// 		       <p>CloudFront automatically adds this field to the response if you’ve configured a cache behavior in
    /// 			this distribution to serve private content using trusted signers. This field contains a
    /// 			list of AWS account IDs and the active CloudFront key pairs in each account that CloudFront can use
    /// 			to verify the signatures of signed URLs or signed cookies.</p>
    public let activeTrustedSigners: ActiveTrustedSigners?
    /// <p>AWS services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
    /// 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
    /// 			recordal status for CNAMEs associated with distributions.</p>
    /// 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
    /// 			Signup, Accounts, and Credentials</a> in <i>Getting Started with AWS services in China</i>.</p>
    public let aliasICPRecordals: [AliasICPRecordal]?
    /// <p>The current configuration information for the distribution. Send a <code>GET</code>
    /// 			request to the <code>/<i>CloudFront API version</i>/distribution ID/config</code>
    /// 			resource.</p>
    public let distributionConfig: DistributionConfig?
    /// <p>The domain name corresponding to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>. </p>
    public let domainName: String?
    /// <p>The identifier for the distribution. For example: <code>EDFDVBD632BHDS5</code>.
    /// 		</p>
    public let id: String?
    /// <p>The number of invalidation batches currently in progress. </p>
    public let inProgressInvalidationBatches: Int?
    /// <p>The date and time the distribution was last modified. </p>
    public let lastModifiedTime: Date?
    /// <p>This response element indicates the current status of the distribution. When the status
    /// 			is <code>Deployed</code>, the distribution's information is fully propagated to all CloudFront edge
    /// 			locations. </p>
    public let status: String?

    public init (
        aRN: String? = nil,
        activeTrustedKeyGroups: ActiveTrustedKeyGroups? = nil,
        activeTrustedSigners: ActiveTrustedSigners? = nil,
        aliasICPRecordals: [AliasICPRecordal]? = nil,
        distributionConfig: DistributionConfig? = nil,
        domainName: String? = nil,
        id: String? = nil,
        inProgressInvalidationBatches: Int? = nil,
        lastModifiedTime: Date? = nil,
        status: String? = nil
    )
    {
        self.aRN = aRN
        self.activeTrustedKeyGroups = activeTrustedKeyGroups
        self.activeTrustedSigners = activeTrustedSigners
        self.aliasICPRecordals = aliasICPRecordals
        self.distributionConfig = distributionConfig
        self.domainName = domainName
        self.id = id
        self.inProgressInvalidationBatches = inProgressInvalidationBatches
        self.lastModifiedTime = lastModifiedTime
        self.status = status
    }
}

extension DistributionAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionAlreadyExists(message: \(String(describing: message)))"}
}

extension DistributionAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller reference you attempted to create the distribution with is associated with another distribution.</p>
public struct DistributionAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DistributionAlreadyExistsBody: Equatable {
    public let message: String?
}

extension DistributionAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DistributionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case defaultRootObject = "DefaultRootObject"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case isIPV6Enabled = "IsIPV6Enabled"
        case logging = "Logging"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: Key("aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: Key("cacheBehaviors"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: Key("callerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: Key("customErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: Key("defaultCacheBehavior"))
        }
        if let defaultRootObject = defaultRootObject {
            try container.encode(defaultRootObject, forKey: Key("defaultRootObject"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: Key("httpVersion"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: Key("isIPV6Enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: Key("logging"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: Key("originGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: Key("origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: Key("priceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: Key("restrictions"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: Key("viewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: Key("webACLId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let defaultRootObjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultRootObject)
        defaultRootObject = defaultRootObjectDecoded
        let originsDecoded = try containerValues.decodeIfPresent(Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(LoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
    }
}

extension DistributionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionConfig(aliases: \(String(describing: aliases)), cacheBehaviors: \(String(describing: cacheBehaviors)), callerReference: \(String(describing: callerReference)), comment: \(String(describing: comment)), customErrorResponses: \(String(describing: customErrorResponses)), defaultCacheBehavior: \(String(describing: defaultCacheBehavior)), defaultRootObject: \(String(describing: defaultRootObject)), enabled: \(String(describing: enabled)), httpVersion: \(String(describing: httpVersion)), isIPV6Enabled: \(String(describing: isIPV6Enabled)), logging: \(String(describing: logging)), originGroups: \(String(describing: originGroups)), origins: \(String(describing: origins)), priceClass: \(String(describing: priceClass)), restrictions: \(String(describing: restrictions)), viewerCertificate: \(String(describing: viewerCertificate)), webACLId: \(String(describing: webACLId)))"}
}

extension DistributionConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A distribution configuration.</p>
public struct DistributionConfig: Equatable {
    /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
    /// 			for this distribution.</p>
    public let aliases: Aliases?
    /// <p>A complex type that contains zero or more <code>CacheBehavior</code> elements.
    /// 		</p>
    public let cacheBehaviors: CacheBehaviors?
    /// <p>A unique value (for example, a date-time stamp) that ensures that the request can't be
    /// 			replayed.</p>
    /// 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
    /// 				<code>DistributionConfig</code> object), CloudFront creates a new distribution.</p>
    /// 		       <p>If <code>CallerReference</code> is a value that you already sent in a previous request to
    /// 			create a distribution, CloudFront returns a <code>DistributionAlreadyExists</code> error.</p>
    public let callerReference: String?
    /// <p>An optional comment to describe the distribution. The comment cannot be longer than 128
    /// 			characters.</p>
    public let comment: String?
    /// <p>A complex type that controls the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Whether CloudFront replaces HTTP status codes in the 4xx and 5xx range with custom error
    /// 					messages before returning the response to the viewer.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>How long CloudFront caches HTTP status codes in the 4xx and 5xx range.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information about custom error pages, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/custom-error-pages.html">Customizing Error Responses</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public let customErrorResponses: CustomErrorResponses?
    /// <p>A complex type that describes the default cache behavior if you don't specify a
    /// 				<code>CacheBehavior</code> element or if files don't match any of the values of
    /// 				<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly one
    /// 			default cache behavior.</p>
    public let defaultCacheBehavior: DefaultCacheBehavior?
    /// <p>The object that you want CloudFront to request from your origin (for example,
    /// 				<code>index.html</code>) when a viewer requests the root URL for your distribution
    /// 				(<code>http://www.example.com</code>) instead of an object in your distribution
    /// 				(<code>http://www.example.com/product-description.html</code>). Specifying a default root
    /// 			object avoids exposing the contents of your distribution.</p>
    /// 		       <p>Specify only the object name, for example, <code>index.html</code>. Don't add a
    /// 				<code>/</code> before the object name.</p>
    /// 		       <p>If you don't want to specify a default root object when you create a distribution,
    /// 			include an empty <code>DefaultRootObject</code> element.</p>
    /// 		       <p>To delete the default root object from an existing distribution, update the
    /// 			distribution configuration and include an empty <code>DefaultRootObject</code>
    /// 			element.</p>
    /// 		       <p>To replace the default root object, update the distribution configuration and specify
    /// 			the new object.</p>
    /// 		       <p>For more information about the default root object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/DefaultRootObject.html">Creating a Default Root Object</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public let defaultRootObject: String?
    /// <p>From this field, you can enable or disable the selected distribution.</p>
    public let enabled: Bool?
    /// <p>(Optional) Specify the maximum HTTP version that you want viewers to use to communicate
    /// 			with CloudFront. The default value for new web distributions is http2. Viewers that don't support
    /// 			HTTP/2 automatically use an earlier HTTP version.</p>
    /// 		       <p>For viewers and CloudFront to use HTTP/2, viewers must support TLS 1.2 or later, and must
    /// 			support Server Name Identification (SNI).</p>
    /// 		       <p>In general, configuring CloudFront to communicate with viewers using HTTP/2 reduces latency.
    /// 			You can improve performance by optimizing for HTTP/2. For more information, do an Internet
    /// 			search for "http/2 optimization." </p>
    public let httpVersion: HttpVersion?
    /// <p>If you want CloudFront to respond to IPv6 DNS requests with an IPv6 address for your
    /// 			distribution, specify <code>true</code>. If you specify <code>false</code>, CloudFront responds to
    /// 			IPv6 DNS requests with the DNS response code <code>NOERROR</code> and with no IP addresses.
    /// 			This allows viewers to submit a second request, for an IPv4 address for your distribution. </p>
    /// 		       <p>In general, you should enable IPv6 if you have users on IPv6 networks who want to
    /// 			access your content. However, if you're using signed URLs or signed cookies to restrict access
    /// 			to your content, and if you're using a custom policy that includes the <code>IpAddress</code>
    /// 			parameter to restrict the IP addresses that can access your content, don't enable IPv6. If
    /// 			you want to restrict access to some content by IP address and not restrict access to other
    /// 			content (or restrict access but not by IP address), you can create two distributions. For more
    /// 			information, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html">Creating a Signed URL Using a Custom Policy</a> in the <i>Amazon CloudFront Developer
    /// 				Guide</i>.</p>
    /// 		       <p>If you're using an Amazon Route 53 alias resource record set to route traffic to your CloudFront
    /// 			distribution, you need to create a second alias resource record set when both of the following
    /// 			are true:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>You enable IPv6 for the distribution</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>You're using alternate domain names in the URLs for your objects</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-cloudfront-distribution.html">Routing Traffic
    /// 				to an Amazon CloudFront Web Distribution by Using Your Domain Name</a> in the <i>Amazon Route 53
    /// 				Developer Guide</i>.</p>
    /// 		       <p>If you created a CNAME resource record set, either with Amazon Route 53 or with another DNS
    /// 			service, you don't need to make any changes. A CNAME record will route traffic to your
    /// 			distribution regardless of the IP address format of the viewer request.</p>
    public let isIPV6Enabled: Bool?
    /// <p>A complex type that controls whether access logs are written for the
    /// 			distribution.</p>
    /// 		       <p>For more information about logging, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/AccessLogs.html">Access
    /// 				Logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let logging: LoggingConfig?
    /// <p> A complex type that contains information about origin groups for this
    /// 			distribution.</p>
    public let originGroups: OriginGroups?
    /// <p>A complex type that contains information about origins for this distribution.
    /// 		</p>
    public let origins: Origins?
    /// <p>The price class that corresponds with the maximum price that you want to pay for CloudFront
    /// 			service. If you specify <code>PriceClass_All</code>, CloudFront responds to requests for your
    /// 			objects from all CloudFront edge locations.</p>
    /// 		       <p>If you specify a price class other than <code>PriceClass_All</code>, CloudFront serves your
    /// 			objects from the CloudFront edge location that has the lowest latency among the edge locations in
    /// 			your price class. Viewers who are in or near regions that are excluded from your specified
    /// 			price class may encounter slower performance.</p>
    /// 		       <p>For more information about price classes, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PriceClass.html">Choosing the Price Class
    /// 			for a CloudFront Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>. For
    /// 			information about CloudFront pricing, including how price classes (such as Price Class 100)
    /// 			map to CloudFront regions, see <a href="http://aws.amazon.com/cloudfront/pricing/">Amazon CloudFront
    /// 			Pricing</a>.</p>
    public let priceClass: PriceClass?
    /// <p>A complex type that identifies ways in which you want to restrict distribution of your
    /// 			content.</p>
    public let restrictions: Restrictions?
    /// <p>A complex type that determines the distribution’s SSL/TLS configuration for
    /// 			communicating with viewers.</p>
    public let viewerCertificate: ViewerCertificate?
    /// <p>A unique identifier that specifies the AWS WAF web ACL, if any, to associate
    /// 			with this distribution. To specify a web ACL created using the latest version of AWS
    /// 			WAF, use the ACL ARN, for example
    /// 			<code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>.
    /// 			To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example
    /// 			<code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
    /// 		       <p>AWS WAF is a web application firewall that lets you monitor the HTTP and HTTPS
    /// 			requests that are forwarded to CloudFront, and lets you control access to your content. Based on
    /// 			conditions that you specify, such as the IP addresses that requests originate from or the
    /// 			values of query strings, CloudFront responds to requests either with the requested content or with
    /// 			an HTTP 403 status code (Forbidden). You can also configure CloudFront to return a custom error page
    /// 			when a request is blocked. For more information about AWS WAF, see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/what-is-aws-waf.html">AWS WAF
    /// 				Developer Guide</a>. </p>
    public let webACLId: String?

    public init (
        aliases: Aliases? = nil,
        cacheBehaviors: CacheBehaviors? = nil,
        callerReference: String? = nil,
        comment: String? = nil,
        customErrorResponses: CustomErrorResponses? = nil,
        defaultCacheBehavior: DefaultCacheBehavior? = nil,
        defaultRootObject: String? = nil,
        enabled: Bool? = nil,
        httpVersion: HttpVersion? = nil,
        isIPV6Enabled: Bool? = nil,
        logging: LoggingConfig? = nil,
        originGroups: OriginGroups? = nil,
        origins: Origins? = nil,
        priceClass: PriceClass? = nil,
        restrictions: Restrictions? = nil,
        viewerCertificate: ViewerCertificate? = nil,
        webACLId: String? = nil
    )
    {
        self.aliases = aliases
        self.cacheBehaviors = cacheBehaviors
        self.callerReference = callerReference
        self.comment = comment
        self.customErrorResponses = customErrorResponses
        self.defaultCacheBehavior = defaultCacheBehavior
        self.defaultRootObject = defaultRootObject
        self.enabled = enabled
        self.httpVersion = httpVersion
        self.isIPV6Enabled = isIPV6Enabled
        self.logging = logging
        self.originGroups = originGroups
        self.origins = origins
        self.priceClass = priceClass
        self.restrictions = restrictions
        self.viewerCertificate = viewerCertificate
        self.webACLId = webACLId
    }
}

extension DistributionConfigWithTags: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case distributionConfig = "DistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: Key("distributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: Key("tags"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension DistributionConfigWithTags: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionConfigWithTags(distributionConfig: \(String(describing: distributionConfig)), tags: \(String(describing: tags)))"}
}

extension DistributionConfigWithTags: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A distribution Configuration and a list of tags to be associated with the
/// 			distribution.</p>
public struct DistributionConfigWithTags: Equatable {
    /// <p>A distribution configuration.</p>
    public let distributionConfig: DistributionConfig?
    /// <p>A complex type that contains zero or more <code>Tag</code> elements.</p>
    public let tags: Tags?

    public init (
        distributionConfig: DistributionConfig? = nil,
        tags: Tags? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.tags = tags
    }
}

extension DistributionIdList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: Key("isTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("DistributionId"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension DistributionIdList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionIdList(isTruncated: \(String(describing: isTruncated)), items: \(String(describing: items)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension DistributionIdList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of distribution IDs.</p>
public struct DistributionIdList: Equatable {
    /// <p>A flag that indicates whether more distribution IDs remain to be listed. If your
    /// 			results were truncated, you can make a subsequent request using the <code>Marker</code>
    /// 			request field to retrieve more distribution IDs in the list.</p>
    public let isTruncated: Bool?
    /// <p>Contains the distribution IDs in the list.</p>
    public let items: [String]?
    /// <p>The value provided in the <code>Marker</code> request field.</p>
    public let marker: String?
    /// <p>The maximum number of distribution IDs requested.</p>
    public let maxItems: Int?
    /// <p>Contains the value that you should use in the <code>Marker</code> field of a
    /// 			subsequent request to continue listing distribution IDs where you left off.</p>
    public let nextMarker: String?
    /// <p>The total number of distribution IDs returned in the response.</p>
    public let quantity: Int?

    public init (
        isTruncated: Bool? = nil,
        items: [String]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.isTruncated = isTruncated
        self.items = items
        self.marker = marker
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension DistributionList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: Key("isTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for distributionsummary0 in items {
                try itemsContainer.encode(distributionsummary0, forKey: Key("DistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct DistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.DistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([DistributionSummary].self, forKey: .member)
                var itemsBuffer:[DistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [DistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension DistributionList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionList(isTruncated: \(String(describing: isTruncated)), items: \(String(describing: items)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension DistributionList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A distribution list.</p>
public struct DistributionList: Equatable {
    /// <p>A flag that indicates whether more distributions remain to be listed. If your results
    /// 			were truncated, you can make a follow-up pagination request using the <code>Marker</code>
    /// 			request parameter to retrieve more distributions in the list.</p>
    public let isTruncated: Bool?
    /// <p>A complex type that contains one <code>DistributionSummary</code> element for each
    /// 			distribution that was created by the current AWS account.</p>
    public let items: [DistributionSummary]?
    /// <p>The value you provided for the <code>Marker</code> request parameter.</p>
    public let marker: String?
    /// <p>The value you provided for the <code>MaxItems</code> request parameter.</p>
    public let maxItems: Int?
    /// <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
    /// 			the value you can use for the <code>Marker</code> request parameter to continue listing your
    /// 			distributions where they left off. </p>
    public let nextMarker: String?
    /// <p>The number of distributions that were created by the current AWS account. </p>
    public let quantity: Int?

    public init (
        isTruncated: Bool? = nil,
        items: [DistributionSummary]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.isTruncated = isTruncated
        self.items = items
        self.marker = marker
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension DistributionNotDisabled: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionNotDisabled(message: \(String(describing: message)))"}
}

extension DistributionNotDisabled: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DistributionNotDisabledBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CloudFront distribution is not disabled. You must disable
/// 			the distribution before you can delete it.</p>
public struct DistributionNotDisabled: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DistributionNotDisabledBody: Equatable {
    public let message: String?
}

extension DistributionNotDisabledBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DistributionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case aliasICPRecordals = "AliasICPRecordals"
        case aliases = "Aliases"
        case cacheBehaviors = "CacheBehaviors"
        case comment = "Comment"
        case customErrorResponses = "CustomErrorResponses"
        case defaultCacheBehavior = "DefaultCacheBehavior"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case httpVersion = "HttpVersion"
        case id = "Id"
        case isIPV6Enabled = "IsIPV6Enabled"
        case lastModifiedTime = "LastModifiedTime"
        case originGroups = "OriginGroups"
        case origins = "Origins"
        case priceClass = "PriceClass"
        case restrictions = "Restrictions"
        case status = "Status"
        case viewerCertificate = "ViewerCertificate"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("aRN"))
        }
        if let aliasICPRecordals = aliasICPRecordals {
            var aliasICPRecordalsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("aliasICPRecordals"))
            for aliasicprecordal0 in aliasICPRecordals {
                try aliasICPRecordalsContainer.encode(aliasicprecordal0, forKey: Key("AliasICPRecordal"))
            }
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: Key("aliases"))
        }
        if let cacheBehaviors = cacheBehaviors {
            try container.encode(cacheBehaviors, forKey: Key("cacheBehaviors"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let customErrorResponses = customErrorResponses {
            try container.encode(customErrorResponses, forKey: Key("customErrorResponses"))
        }
        if let defaultCacheBehavior = defaultCacheBehavior {
            try container.encode(defaultCacheBehavior, forKey: Key("defaultCacheBehavior"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("domainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let httpVersion = httpVersion {
            try container.encode(httpVersion, forKey: Key("httpVersion"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let isIPV6Enabled = isIPV6Enabled {
            try container.encode(isIPV6Enabled, forKey: Key("isIPV6Enabled"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
        if let originGroups = originGroups {
            try container.encode(originGroups, forKey: Key("originGroups"))
        }
        if let origins = origins {
            try container.encode(origins, forKey: Key("origins"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: Key("priceClass"))
        }
        if let restrictions = restrictions {
            try container.encode(restrictions, forKey: Key("restrictions"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let viewerCertificate = viewerCertificate {
            try container.encode(viewerCertificate, forKey: Key("viewerCertificate"))
        }
        if let webACLId = webACLId {
            try container.encode(webACLId, forKey: Key("webACLId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let originsDecoded = try containerValues.decodeIfPresent(Origins.self, forKey: .origins)
        origins = originsDecoded
        let originGroupsDecoded = try containerValues.decodeIfPresent(OriginGroups.self, forKey: .originGroups)
        originGroups = originGroupsDecoded
        let defaultCacheBehaviorDecoded = try containerValues.decodeIfPresent(DefaultCacheBehavior.self, forKey: .defaultCacheBehavior)
        defaultCacheBehavior = defaultCacheBehaviorDecoded
        let cacheBehaviorsDecoded = try containerValues.decodeIfPresent(CacheBehaviors.self, forKey: .cacheBehaviors)
        cacheBehaviors = cacheBehaviorsDecoded
        let customErrorResponsesDecoded = try containerValues.decodeIfPresent(CustomErrorResponses.self, forKey: .customErrorResponses)
        customErrorResponses = customErrorResponsesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let viewerCertificateDecoded = try containerValues.decodeIfPresent(ViewerCertificate.self, forKey: .viewerCertificate)
        viewerCertificate = viewerCertificateDecoded
        let restrictionsDecoded = try containerValues.decodeIfPresent(Restrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let httpVersionDecoded = try containerValues.decodeIfPresent(HttpVersion.self, forKey: .httpVersion)
        httpVersion = httpVersionDecoded
        let isIPV6EnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isIPV6Enabled)
        isIPV6Enabled = isIPV6EnabledDecoded
        if containerValues.contains(.aliasICPRecordals) {
            struct KeyVal0{struct AliasICPRecordal{}}
            let aliasICPRecordalsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AliasICPRecordal>.CodingKeys.self, forKey: .aliasICPRecordals)
            if let aliasICPRecordalsWrappedContainer = aliasICPRecordalsWrappedContainer {
                let aliasICPRecordalsContainer = try aliasICPRecordalsWrappedContainer.decodeIfPresent([AliasICPRecordal].self, forKey: .member)
                var aliasICPRecordalsBuffer:[AliasICPRecordal]? = nil
                if let aliasICPRecordalsContainer = aliasICPRecordalsContainer {
                    aliasICPRecordalsBuffer = [AliasICPRecordal]()
                    for structureContainer0 in aliasICPRecordalsContainer {
                        aliasICPRecordalsBuffer?.append(structureContainer0)
                    }
                }
                aliasICPRecordals = aliasICPRecordalsBuffer
            } else {
                aliasICPRecordals = []
            }
        } else {
            aliasICPRecordals = nil
        }
    }
}

extension DistributionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DistributionSummary(aRN: \(String(describing: aRN)), aliasICPRecordals: \(String(describing: aliasICPRecordals)), aliases: \(String(describing: aliases)), cacheBehaviors: \(String(describing: cacheBehaviors)), comment: \(String(describing: comment)), customErrorResponses: \(String(describing: customErrorResponses)), defaultCacheBehavior: \(String(describing: defaultCacheBehavior)), domainName: \(String(describing: domainName)), enabled: \(String(describing: enabled)), httpVersion: \(String(describing: httpVersion)), id: \(String(describing: id)), isIPV6Enabled: \(String(describing: isIPV6Enabled)), lastModifiedTime: \(String(describing: lastModifiedTime)), originGroups: \(String(describing: originGroups)), origins: \(String(describing: origins)), priceClass: \(String(describing: priceClass)), restrictions: \(String(describing: restrictions)), status: \(String(describing: status)), viewerCertificate: \(String(describing: viewerCertificate)), webACLId: \(String(describing: webACLId)))"}
}

extension DistributionSummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A summary of the information about a CloudFront distribution.</p>
public struct DistributionSummary: Equatable {
    /// <p>The ARN (Amazon Resource Name) for the distribution. For example:
    /// 				<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
    /// 				<code>123456789012</code> is your AWS account ID.</p>
    public let aRN: String?
    /// <p>AWS services in China customers must file for an Internet Content Provider (ICP) recordal if they want to serve content
    /// 			publicly on an alternate domain name, also known as a CNAME, that they've added to CloudFront. AliasICPRecordal provides the ICP
    /// 			recordal status for CNAMEs associated with distributions.</p>
    /// 		       <p>For more information about ICP recordals, see  <a href="https://docs.amazonaws.cn/en_us/aws/latest/userguide/accounts-and-credentials.html">
    /// 			Signup, Accounts, and Credentials</a> in <i>Getting Started with AWS services in China</i>.</p>
    public let aliasICPRecordals: [AliasICPRecordal]?
    /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
    /// 			for this distribution.</p>
    public let aliases: Aliases?
    /// <p>A complex type that contains zero or more <code>CacheBehavior</code>
    /// 			elements.</p>
    public let cacheBehaviors: CacheBehaviors?
    /// <p>The comment originally specified when this distribution was created.</p>
    public let comment: String?
    /// <p>A complex type that contains zero or more <code>CustomErrorResponses</code>
    /// 			elements.</p>
    public let customErrorResponses: CustomErrorResponses?
    /// <p>A complex type that describes the default cache behavior if you don't specify a
    /// 				<code>CacheBehavior</code> element or if files don't match any of the values of
    /// 				<code>PathPattern</code> in <code>CacheBehavior</code> elements. You must create exactly one
    /// 			default cache behavior.</p>
    public let defaultCacheBehavior: DefaultCacheBehavior?
    /// <p>The domain name that corresponds to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>.</p>
    public let domainName: String?
    /// <p>Whether the distribution is enabled to accept user requests for content.</p>
    public let enabled: Bool?
    /// <p> Specify the maximum HTTP version that you want viewers to use to communicate with
    /// 			CloudFront. The default value for new web distributions is <code>http2</code>. Viewers that don't
    /// 			support <code>HTTP/2</code> will automatically use an earlier version.</p>
    public let httpVersion: HttpVersion?
    /// <p>The identifier for the distribution. For example:
    /// 			<code>EDFDVBD632BHDS5</code>.</p>
    public let id: String?
    /// <p>Whether CloudFront responds to IPv6 DNS requests with an IPv6 address for your
    /// 			distribution.</p>
    public let isIPV6Enabled: Bool?
    /// <p>The date and time the distribution was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p> A complex type that contains information about origin groups for this
    /// 			distribution.</p>
    public let originGroups: OriginGroups?
    /// <p>A complex type that contains information about origins for this distribution.</p>
    public let origins: Origins?
    /// <p>A complex type that contains information about price class for this streaming
    /// 			distribution. </p>
    public let priceClass: PriceClass?
    /// <p>A complex type that identifies ways in which you want to restrict distribution of your
    /// 			content.</p>
    public let restrictions: Restrictions?
    /// <p>The current status of the distribution. When the status is <code>Deployed</code>, the
    /// 			distribution's information is propagated to all CloudFront edge locations.</p>
    public let status: String?
    /// <p>A complex type that determines the distribution’s SSL/TLS configuration for
    /// 			communicating with viewers.</p>
    public let viewerCertificate: ViewerCertificate?
    /// <p>The Web ACL Id (if any) associated with the distribution.</p>
    public let webACLId: String?

    public init (
        aRN: String? = nil,
        aliasICPRecordals: [AliasICPRecordal]? = nil,
        aliases: Aliases? = nil,
        cacheBehaviors: CacheBehaviors? = nil,
        comment: String? = nil,
        customErrorResponses: CustomErrorResponses? = nil,
        defaultCacheBehavior: DefaultCacheBehavior? = nil,
        domainName: String? = nil,
        enabled: Bool? = nil,
        httpVersion: HttpVersion? = nil,
        id: String? = nil,
        isIPV6Enabled: Bool? = nil,
        lastModifiedTime: Date? = nil,
        originGroups: OriginGroups? = nil,
        origins: Origins? = nil,
        priceClass: PriceClass? = nil,
        restrictions: Restrictions? = nil,
        status: String? = nil,
        viewerCertificate: ViewerCertificate? = nil,
        webACLId: String? = nil
    )
    {
        self.aRN = aRN
        self.aliasICPRecordals = aliasICPRecordals
        self.aliases = aliases
        self.cacheBehaviors = cacheBehaviors
        self.comment = comment
        self.customErrorResponses = customErrorResponses
        self.defaultCacheBehavior = defaultCacheBehavior
        self.domainName = domainName
        self.enabled = enabled
        self.httpVersion = httpVersion
        self.id = id
        self.isIPV6Enabled = isIPV6Enabled
        self.lastModifiedTime = lastModifiedTime
        self.originGroups = originGroups
        self.origins = origins
        self.priceClass = priceClass
        self.restrictions = restrictions
        self.status = status
        self.viewerCertificate = viewerCertificate
        self.webACLId = webACLId
    }
}

extension EncryptionEntities: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for encryptionentity0 in items {
                try itemsContainer.encode(encryptionentity0, forKey: Key("EncryptionEntity"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct EncryptionEntity{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.EncryptionEntity>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([EncryptionEntity].self, forKey: .member)
                var itemsBuffer:[EncryptionEntity]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [EncryptionEntity]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension EncryptionEntities: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionEntities(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension EncryptionEntities: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Complex data type for field-level encryption profiles that includes all of the encryption entities. </p>
public struct EncryptionEntities: Equatable {
    /// <p>An array of field patterns in a field-level encryption content type-profile mapping. </p>
    public let items: [EncryptionEntity]?
    /// <p>Number of field pattern items in a field-level encryption content type-profile mapping. </p>
    public let quantity: Int?

    public init (
        items: [EncryptionEntity]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension EncryptionEntity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldPatterns = "FieldPatterns"
        case providerId = "ProviderId"
        case publicKeyId = "PublicKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let fieldPatterns = fieldPatterns {
            try container.encode(fieldPatterns, forKey: Key("fieldPatterns"))
        }
        if let providerId = providerId {
            try container.encode(providerId, forKey: Key("providerId"))
        }
        if let publicKeyId = publicKeyId {
            try container.encode(publicKeyId, forKey: Key("publicKeyId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicKeyId)
        publicKeyId = publicKeyIdDecoded
        let providerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerId)
        providerId = providerIdDecoded
        let fieldPatternsDecoded = try containerValues.decodeIfPresent(FieldPatterns.self, forKey: .fieldPatterns)
        fieldPatterns = fieldPatternsDecoded
    }
}

extension EncryptionEntity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionEntity(fieldPatterns: \(String(describing: fieldPatterns)), providerId: \(String(describing: providerId)), publicKeyId: \(String(describing: publicKeyId)))"}
}

extension EncryptionEntity: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Complex data type for field-level encryption profiles that includes the encryption key and field pattern specifications. </p>
public struct EncryptionEntity: Equatable {
    /// <p>Field patterns in a field-level encryption content type profile specify the fields that you want to be encrypted. You can provide the
    /// 			full field name, or any beginning characters followed by a wildcard (*). You can't overlap field patterns. For example, you can't have
    /// 			both ABC* and AB*. Note that field patterns are case-sensitive. </p>
    public let fieldPatterns: FieldPatterns?
    /// <p>The provider associated with the public key being used for encryption. This value must also be provided with the private key
    /// 		for applications to be able to decrypt data.</p>
    public let providerId: String?
    /// <p>The public key associated with a set of field-level encryption patterns, to be used when encrypting the fields that match
    /// 			the patterns. </p>
    public let publicKeyId: String?

    public init (
        fieldPatterns: FieldPatterns? = nil,
        providerId: String? = nil,
        publicKeyId: String? = nil
    )
    {
        self.fieldPatterns = fieldPatterns
        self.providerId = providerId
        self.publicKeyId = publicKeyId
    }
}

extension EndPoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kinesisStreamConfig = "KinesisStreamConfig"
        case streamType = "StreamType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let kinesisStreamConfig = kinesisStreamConfig {
            try container.encode(kinesisStreamConfig, forKey: Key("kinesisStreamConfig"))
        }
        if let streamType = streamType {
            try container.encode(streamType, forKey: Key("streamType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamType)
        streamType = streamTypeDecoded
        let kinesisStreamConfigDecoded = try containerValues.decodeIfPresent(KinesisStreamConfig.self, forKey: .kinesisStreamConfig)
        kinesisStreamConfig = kinesisStreamConfigDecoded
    }
}

extension EndPoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndPoint(kinesisStreamConfig: \(String(describing: kinesisStreamConfig)), streamType: \(String(describing: streamType)))"}
}

extension EndPoint: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
/// 			log data in a real-time log configuration.</p>
public struct EndPoint: Equatable {
    /// <p>Contains information about the Amazon Kinesis data stream where you are sending
    /// 			real-time log data.</p>
    public let kinesisStreamConfig: KinesisStreamConfig?
    /// <p>The type of data stream where you are sending real-time log data. The only valid value is
    /// 			<code>Kinesis</code>.</p>
    public let streamType: String?

    public init (
        kinesisStreamConfig: KinesisStreamConfig? = nil,
        streamType: String? = nil
    )
    {
        self.kinesisStreamConfig = kinesisStreamConfig
        self.streamType = streamType
    }
}

public enum EventType {
    case originRequest
    case originResponse
    case viewerRequest
    case viewerResponse
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .originRequest,
            .originResponse,
            .viewerRequest,
            .viewerResponse,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .originRequest: return "origin-request"
        case .originResponse: return "origin-response"
        case .viewerRequest: return "viewer-request"
        case .viewerResponse: return "viewer-response"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension FieldLevelEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: Key("fieldLevelEncryptionConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension FieldLevelEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryption(fieldLevelEncryptionConfig: \(String(describing: fieldLevelEncryptionConfig)), id: \(String(describing: id)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension FieldLevelEncryption: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type that includes the profile configurations and other options specified for field-level encryption. </p>
public struct FieldLevelEncryption: Equatable {
    /// <p>A complex data type that includes the profile configurations specified for field-level encryption. </p>
    public let fieldLevelEncryptionConfig: FieldLevelEncryptionConfig?
    /// <p>The configuration ID for a field-level encryption configuration which includes a set of profiles that specify certain
    /// 		selected data fields to be encrypted by specific public keys.</p>
    public let id: String?
    /// <p>The last time the field-level encryption configuration was changed. </p>
    public let lastModifiedTime: Date?

    public init (
        fieldLevelEncryptionConfig: FieldLevelEncryptionConfig? = nil,
        id: String? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
        self.id = id
        self.lastModifiedTime = lastModifiedTime
    }
}

extension FieldLevelEncryptionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: Key("callerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: Key("contentTypeProfileConfig"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: Key("queryArgProfileConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension FieldLevelEncryptionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionConfig(callerReference: \(String(describing: callerReference)), comment: \(String(describing: comment)), contentTypeProfileConfig: \(String(describing: contentTypeProfileConfig)), queryArgProfileConfig: \(String(describing: queryArgProfileConfig)))"}
}

extension FieldLevelEncryptionConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type that includes the profile configurations specified for field-level encryption. </p>
public struct FieldLevelEncryptionConfig: Equatable {
    /// <p>A unique number that ensures the request can't be replayed.</p>
    public let callerReference: String?
    /// <p>An optional comment about the configuration. The comment cannot be longer than 128
    /// 			characters.</p>
    public let comment: String?
    /// <p>A complex data type that specifies when to forward content if a content type isn't recognized and profiles to use as by default
    /// 			in a request if a query argument doesn't specify a profile to use.</p>
    public let contentTypeProfileConfig: ContentTypeProfileConfig?
    /// <p>A complex data type that specifies when to forward content if a profile isn't found and the profile that can be provided as a
    /// 			query argument in a request.</p>
    public let queryArgProfileConfig: QueryArgProfileConfig?

    public init (
        callerReference: String? = nil,
        comment: String? = nil,
        contentTypeProfileConfig: ContentTypeProfileConfig? = nil,
        queryArgProfileConfig: QueryArgProfileConfig? = nil
    )
    {
        self.callerReference = callerReference
        self.comment = comment
        self.contentTypeProfileConfig = contentTypeProfileConfig
        self.queryArgProfileConfig = queryArgProfileConfig
    }
}

extension FieldLevelEncryptionConfigAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionConfigAlreadyExists(message: \(String(describing: message)))"}
}

extension FieldLevelEncryptionConfigAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FieldLevelEncryptionConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration for field-level encryption already exists.</p>
public struct FieldLevelEncryptionConfigAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionConfigAlreadyExistsBody: Equatable {
    public let message: String?
}

extension FieldLevelEncryptionConfigAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionConfigInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionConfigInUse(message: \(String(describing: message)))"}
}

extension FieldLevelEncryptionConfigInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FieldLevelEncryptionConfigInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration for field-level encryption is in use.</p>
public struct FieldLevelEncryptionConfigInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionConfigInUseBody: Equatable {
    public let message: String?
}

extension FieldLevelEncryptionConfigInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for fieldlevelencryptionsummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionsummary0, forKey: Key("FieldLevelEncryptionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([FieldLevelEncryptionSummary].self, forKey: .member)
                var itemsBuffer:[FieldLevelEncryptionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [FieldLevelEncryptionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension FieldLevelEncryptionList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionList(items: \(String(describing: items)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension FieldLevelEncryptionList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>List of field-level encrpytion configurations.</p>
public struct FieldLevelEncryptionList: Equatable {
    /// <p>An array of field-level encryption items.</p>
    public let items: [FieldLevelEncryptionSummary]?
    /// <p>The maximum number of elements you want in the response body. </p>
    public let maxItems: Int?
    /// <p>If there are more elements to be listed, this element is present and contains
    /// 			the value that you can use for the <code>Marker</code> request parameter to continue
    /// 			listing your configurations where you left off.</p>
    public let nextMarker: String?
    /// <p>The number of field-level encryption items.</p>
    public let quantity: Int?

    public init (
        items: [FieldLevelEncryptionSummary]? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension FieldLevelEncryptionProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: Key("fieldLevelEncryptionProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension FieldLevelEncryptionProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionProfile(fieldLevelEncryptionProfileConfig: \(String(describing: fieldLevelEncryptionProfileConfig)), id: \(String(describing: id)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension FieldLevelEncryptionProfile: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type for field-level encryption profiles.</p>
public struct FieldLevelEncryptionProfile: Equatable {
    /// <p>A complex data type that includes the profile name and the encryption entities for the field-level encryption profile.</p>
    public let fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig?
    /// <p>The ID for a field-level encryption profile configuration which includes a set of profiles that specify certain
    /// 			selected data fields to be encrypted by specific public keys.</p>
    public let id: String?
    /// <p>The last time the field-level encryption profile was updated.</p>
    public let lastModifiedTime: Date?

    public init (
        fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig? = nil,
        id: String? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
        self.id = id
        self.lastModifiedTime = lastModifiedTime
    }
}

extension FieldLevelEncryptionProfileAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionProfileAlreadyExists(message: \(String(describing: message)))"}
}

extension FieldLevelEncryptionProfileAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FieldLevelEncryptionProfileAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified profile for field-level encryption already exists.</p>
public struct FieldLevelEncryptionProfileAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileAlreadyExistsBody: Equatable {
    public let message: String?
}

extension FieldLevelEncryptionProfileAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionProfileConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: Key("callerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: Key("encryptionEntities"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
    }
}

extension FieldLevelEncryptionProfileConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionProfileConfig(callerReference: \(String(describing: callerReference)), comment: \(String(describing: comment)), encryptionEntities: \(String(describing: encryptionEntities)), name: \(String(describing: name)))"}
}

extension FieldLevelEncryptionProfileConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type of profiles for the field-level encryption.</p>
public struct FieldLevelEncryptionProfileConfig: Equatable {
    /// <p>A unique number that ensures that the request can't be replayed.</p>
    public let callerReference: String?
    /// <p>An optional comment for the field-level encryption profile. The comment cannot be longer
    /// 			than 128 characters.</p>
    public let comment: String?
    /// <p>A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and
    /// 			field patterns for specifying which fields to encrypt with this key.</p>
    public let encryptionEntities: EncryptionEntities?
    /// <p>Profile name for the field-level encryption profile.</p>
    public let name: String?

    public init (
        callerReference: String? = nil,
        comment: String? = nil,
        encryptionEntities: EncryptionEntities? = nil,
        name: String? = nil
    )
    {
        self.callerReference = callerReference
        self.comment = comment
        self.encryptionEntities = encryptionEntities
        self.name = name
    }
}

extension FieldLevelEncryptionProfileInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionProfileInUse(message: \(String(describing: message)))"}
}

extension FieldLevelEncryptionProfileInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FieldLevelEncryptionProfileInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified profile for field-level encryption is in use.</p>
public struct FieldLevelEncryptionProfileInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileInUseBody: Equatable {
    public let message: String?
}

extension FieldLevelEncryptionProfileInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionProfileList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for fieldlevelencryptionprofilesummary0 in items {
                try itemsContainer.encode(fieldlevelencryptionprofilesummary0, forKey: Key("FieldLevelEncryptionProfileSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldLevelEncryptionProfileSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldLevelEncryptionProfileSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([FieldLevelEncryptionProfileSummary].self, forKey: .member)
                var itemsBuffer:[FieldLevelEncryptionProfileSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [FieldLevelEncryptionProfileSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension FieldLevelEncryptionProfileList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionProfileList(items: \(String(describing: items)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension FieldLevelEncryptionProfileList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>List of field-level encryption profiles.</p>
public struct FieldLevelEncryptionProfileList: Equatable {
    /// <p>The field-level encryption profile items.</p>
    public let items: [FieldLevelEncryptionProfileSummary]?
    /// <p>The maximum number of field-level encryption profiles you want in the response body. </p>
    public let maxItems: Int?
    /// <p>If there are more elements to be listed, this element is present and contains
    /// 			the value that you can use for the <code>Marker</code> request parameter to continue
    /// 			listing your profiles where you left off.</p>
    public let nextMarker: String?
    /// <p>The number of field-level encryption profiles.</p>
    public let quantity: Int?

    public init (
        items: [FieldLevelEncryptionProfileSummary]? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension FieldLevelEncryptionProfileSizeExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionProfileSizeExceeded(message: \(String(describing: message)))"}
}

extension FieldLevelEncryptionProfileSizeExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FieldLevelEncryptionProfileSizeExceededBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum size of a profile for field-level encryption was exceeded.</p>
public struct FieldLevelEncryptionProfileSizeExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FieldLevelEncryptionProfileSizeExceededBody: Equatable {
    public let message: String?
}

extension FieldLevelEncryptionProfileSizeExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FieldLevelEncryptionProfileSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case encryptionEntities = "EncryptionEntities"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let encryptionEntities = encryptionEntities {
            try container.encode(encryptionEntities, forKey: Key("encryptionEntities"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let encryptionEntitiesDecoded = try containerValues.decodeIfPresent(EncryptionEntities.self, forKey: .encryptionEntities)
        encryptionEntities = encryptionEntitiesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension FieldLevelEncryptionProfileSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionProfileSummary(comment: \(String(describing: comment)), encryptionEntities: \(String(describing: encryptionEntities)), id: \(String(describing: id)), lastModifiedTime: \(String(describing: lastModifiedTime)), name: \(String(describing: name)))"}
}

extension FieldLevelEncryptionProfileSummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The field-level encryption profile summary.</p>
public struct FieldLevelEncryptionProfileSummary: Equatable {
    /// <p>An optional comment for the field-level encryption profile summary. The comment cannot be
    /// 			longer than 128 characters.</p>
    public let comment: String?
    /// <p>A complex data type of encryption entities for the field-level encryption profile that include the public key ID, provider, and
    /// 			field patterns for specifying which fields to encrypt with this key.</p>
    public let encryptionEntities: EncryptionEntities?
    /// <p>ID for the field-level encryption profile summary.</p>
    public let id: String?
    /// <p>The time when the the field-level encryption profile summary was last updated.</p>
    public let lastModifiedTime: Date?
    /// <p>Name for the field-level encryption profile summary.</p>
    public let name: String?

    public init (
        comment: String? = nil,
        encryptionEntities: EncryptionEntities? = nil,
        id: String? = nil,
        lastModifiedTime: Date? = nil,
        name: String? = nil
    )
    {
        self.comment = comment
        self.encryptionEntities = encryptionEntities
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.name = name
    }
}

extension FieldLevelEncryptionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case contentTypeProfileConfig = "ContentTypeProfileConfig"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case queryArgProfileConfig = "QueryArgProfileConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let contentTypeProfileConfig = contentTypeProfileConfig {
            try container.encode(contentTypeProfileConfig, forKey: Key("contentTypeProfileConfig"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
        if let queryArgProfileConfig = queryArgProfileConfig {
            try container.encode(queryArgProfileConfig, forKey: Key("queryArgProfileConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let queryArgProfileConfigDecoded = try containerValues.decodeIfPresent(QueryArgProfileConfig.self, forKey: .queryArgProfileConfig)
        queryArgProfileConfig = queryArgProfileConfigDecoded
        let contentTypeProfileConfigDecoded = try containerValues.decodeIfPresent(ContentTypeProfileConfig.self, forKey: .contentTypeProfileConfig)
        contentTypeProfileConfig = contentTypeProfileConfigDecoded
    }
}

extension FieldLevelEncryptionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldLevelEncryptionSummary(comment: \(String(describing: comment)), contentTypeProfileConfig: \(String(describing: contentTypeProfileConfig)), id: \(String(describing: id)), lastModifiedTime: \(String(describing: lastModifiedTime)), queryArgProfileConfig: \(String(describing: queryArgProfileConfig)))"}
}

extension FieldLevelEncryptionSummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A summary of a field-level encryption item.</p>
public struct FieldLevelEncryptionSummary: Equatable {
    /// <p>An optional comment about the field-level encryption item. The comment cannot be longer than
    /// 			128 characters.</p>
    public let comment: String?
    /// <p>
    /// 			A summary of a content type-profile mapping.
    /// 		</p>
    public let contentTypeProfileConfig: ContentTypeProfileConfig?
    /// <p>The unique ID of a field-level encryption item.</p>
    public let id: String?
    /// <p>The last time that the summary of field-level encryption items was modified.</p>
    public let lastModifiedTime: Date?
    /// <p>
    /// 			A summary of a query argument-profile mapping.
    /// 		</p>
    public let queryArgProfileConfig: QueryArgProfileConfig?

    public init (
        comment: String? = nil,
        contentTypeProfileConfig: ContentTypeProfileConfig? = nil,
        id: String? = nil,
        lastModifiedTime: Date? = nil,
        queryArgProfileConfig: QueryArgProfileConfig? = nil
    )
    {
        self.comment = comment
        self.contentTypeProfileConfig = contentTypeProfileConfig
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.queryArgProfileConfig = queryArgProfileConfig
    }
}

extension FieldPatterns: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("FieldPattern"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FieldPattern{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FieldPattern>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension FieldPatterns: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldPatterns(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension FieldPatterns: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type that includes the field patterns to match for field-level encryption.</p>
public struct FieldPatterns: Equatable {
    /// <p>An array of the field-level encryption field patterns.</p>
    public let items: [String]?
    /// <p>The number of field-level encryption field patterns.</p>
    public let quantity: Int?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

public enum Format {
    case urlencoded
    case sdkUnknown(String)
}

extension Format : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Format] {
        return [
            .urlencoded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .urlencoded: return "URLEncoded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
    }
}

extension ForwardedValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cookies = "Cookies"
        case headers = "Headers"
        case queryString = "QueryString"
        case queryStringCacheKeys = "QueryStringCacheKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: Key("cookies"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: Key("headers"))
        }
        if let queryString = queryString {
            try container.encode(queryString, forKey: Key("queryString"))
        }
        if let queryStringCacheKeys = queryStringCacheKeys {
            try container.encode(queryStringCacheKeys, forKey: Key("queryStringCacheKeys"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .queryString)
        queryString = queryStringDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CookiePreference.self, forKey: .cookies)
        cookies = cookiesDecoded
        let headersDecoded = try containerValues.decodeIfPresent(Headers.self, forKey: .headers)
        headers = headersDecoded
        let queryStringCacheKeysDecoded = try containerValues.decodeIfPresent(QueryStringCacheKeys.self, forKey: .queryStringCacheKeys)
        queryStringCacheKeys = queryStringCacheKeysDecoded
    }
}

extension ForwardedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForwardedValues(cookies: \(String(describing: cookies)), headers: \(String(describing: headers)), queryString: \(String(describing: queryString)), queryStringCacheKeys: \(String(describing: queryStringCacheKeys)))"}
}

extension ForwardedValues: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>This field is deprecated. We recommend that you use a cache policy or an origin
/// 			request policy instead of this field.</p>
/// 		       <p>If you want to include values in the cache key, use a cache policy. For more information,
/// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
/// 		       <p>If you want to send values to the origin but not include them in the cache key, use an
/// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
/// 		       <p>A complex type that specifies how CloudFront handles query strings, cookies, and HTTP headers.</p>
public struct ForwardedValues: Equatable {
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include cookies in the cache key, use a cache policy. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send cookies to the origin but not include them in the cache key, use an
    /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>A complex type that specifies whether you want CloudFront to forward cookies to the origin
    /// 			and, if so, which ones. For more information about forwarding cookies to the origin, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Cookies.html">How CloudFront Forwards, Caches, and Logs Cookies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let cookies: CookiePreference?
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include headers in the cache key, use a cache policy. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send headers to the origin but not include them in the cache key, use an
    /// 			origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>A complex type that specifies the <code>Headers</code>, if any, that you want CloudFront to forward to the
    /// 			origin for this cache behavior (whitelisted headers). For the headers that you specify, CloudFront also caches
    /// 			separate versions of a specified object that is based on the header values in viewer requests.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html">
    /// 			Caching Content Based on Request Headers</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let headers: Headers?
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include query strings in the cache key, use a cache policy. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send query strings to the origin but not include them in the cache key, use
    /// 			an origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>Indicates whether you want CloudFront to forward query strings to the origin that is
    /// 			associated with this cache behavior and cache based on the query string parameters. CloudFront
    /// 			behavior depends on the value of <code>QueryString</code> and on the values that you specify
    /// 			for <code>QueryStringCacheKeys</code>, if any:</p>
    /// 		       <p>If you specify true for <code>QueryString</code> and you don't specify any values for
    /// 				<code>QueryStringCacheKeys</code>, CloudFront forwards all query string parameters to the origin
    /// 			and caches based on all query string parameters. Depending on how many query string parameters
    /// 			and values you have, this can adversely affect performance because CloudFront must forward more
    /// 			requests to the origin.</p>
    /// 		       <p>If you specify true for <code>QueryString</code> and you specify one or more values for
    /// 				<code>QueryStringCacheKeys</code>, CloudFront forwards all query string parameters to the origin,
    /// 			but it only caches based on the query string parameters that you specify.</p>
    /// 		       <p>If you specify false for <code>QueryString</code>, CloudFront doesn't forward any query
    /// 			string parameters to the origin, and doesn't cache based on query string parameters.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/QueryStringParameters.html">Configuring CloudFront to Cache Based on Query String Parameters</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public let queryString: Bool?
    /// <p>This field is deprecated. We recommend that you use a cache policy or an origin
    /// 			request policy instead of this field.</p>
    /// 		       <p>If you want to include query strings in the cache key, use a cache policy. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-key-create-cache-policy">Creating cache policies</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you want to send query strings to the origin but not include them in the cache key, use
    /// 			an origin request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html#origin-request-create-origin-request-policy">Creating origin request policies</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>A complex type that contains information about the query string parameters that you
    /// 			want CloudFront to use for caching for this cache behavior.</p>
    public let queryStringCacheKeys: QueryStringCacheKeys?

    public init (
        cookies: CookiePreference? = nil,
        headers: Headers? = nil,
        queryString: Bool? = nil,
        queryStringCacheKeys: QueryStringCacheKeys? = nil
    )
    {
        self.cookies = cookies
        self.headers = headers
        self.queryString = queryString
        self.queryStringCacheKeys = queryStringCacheKeys
    }
}

extension FunctionAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionAlreadyExists(message: \(String(describing: message)))"}
}

extension FunctionAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FunctionAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A function with the same name already exists in this AWS account. To create a
/// 			function, you must provide a unique name. To update an existing function, use
/// 			<code>UpdateFunction</code>.</p>
public struct FunctionAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionAlreadyExistsBody: Equatable {
    public let message: String?
}

extension FunctionAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FunctionAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventType = "EventType"
        case functionARN = "FunctionARN"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: Key("eventType"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: Key("functionARN"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
    }
}

extension FunctionAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionAssociation(eventType: \(String(describing: eventType)), functionARN: \(String(describing: functionARN)))"}
}

extension FunctionAssociation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A CloudFront function that is associated with a cache behavior in a CloudFront
/// 			distribution.</p>
public struct FunctionAssociation: Equatable {
    /// <p>The event type of the function, either <code>viewer-request</code> or
    /// 			<code>viewer-response</code>. You cannot use origin-facing event types
    /// 			(<code>origin-request</code> and <code>origin-response</code>) with a CloudFront
    /// 			function.</p>
    public let eventType: EventType?
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    public let functionARN: String?

    public init (
        eventType: EventType? = nil,
        functionARN: String? = nil
    )
    {
        self.eventType = eventType
        self.functionARN = functionARN
    }
}

extension FunctionAssociations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for functionassociation0 in items {
                try itemsContainer.encode(functionassociation0, forKey: Key("FunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([FunctionAssociation].self, forKey: .member)
                var itemsBuffer:[FunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [FunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension FunctionAssociations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionAssociations(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension FunctionAssociations: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of CloudFront functions that are associated with a cache behavior in a CloudFront distribution.
/// 			CloudFront functions must be published to the <code>LIVE</code> stage to associate them with a
/// 			cache behavior.</p>
public struct FunctionAssociations: Equatable {
    /// <p>The CloudFront functions that are associated with a cache behavior in a CloudFront distribution.  CloudFront
    /// 			functions must be published to the <code>LIVE</code> stage to associate them with a
    /// 			cache behavior.</p>
    public let items: [FunctionAssociation]?
    /// <p>The number of CloudFront functions in the list.</p>
    public let quantity: Int?

    public init (
        items: [FunctionAssociation]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension FunctionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case runtime = "Runtime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let runtime = runtime {
            try container.encode(runtime, forKey: Key("runtime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(FunctionRuntime.self, forKey: .runtime)
        runtime = runtimeDecoded
    }
}

extension FunctionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionConfig(comment: \(String(describing: comment)), runtime: \(String(describing: runtime)))"}
}

extension FunctionConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains configuration information about a CloudFront function.</p>
public struct FunctionConfig: Equatable {
    /// <p>A comment to describe the function.</p>
    public let comment: String?
    /// <p>The function’s runtime environment. The only valid value is
    /// 			<code>cloudfront-js-1.0</code>.</p>
    public let runtime: FunctionRuntime?

    public init (
        comment: String? = nil,
        runtime: FunctionRuntime? = nil
    )
    {
        self.comment = comment
        self.runtime = runtime
    }
}

extension FunctionInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionInUse(message: \(String(describing: message)))"}
}

extension FunctionInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FunctionInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete the function because it’s attached to one or more cache
/// 			behaviors.</p>
public struct FunctionInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionInUseBody: Equatable {
    public let message: String?
}

extension FunctionInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FunctionList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for functionsummary0 in items {
                try itemsContainer.encode(functionsummary0, forKey: Key("FunctionSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct FunctionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.FunctionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([FunctionSummary].self, forKey: .member)
                var itemsBuffer:[FunctionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [FunctionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension FunctionList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionList(items: \(String(describing: items)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension FunctionList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of CloudFront functions.</p>
public struct FunctionList: Equatable {
    /// <p>Contains the functions in the list.</p>
    public let items: [FunctionSummary]?
    /// <p>The maximum number of functions requested.</p>
    public let maxItems: Int?
    /// <p>If there are more items in the list than are in this response, this element is
    /// 			present. It contains the value that you should use in the <code>Marker</code> field of a
    /// 			subsequent request to continue listing functions where you left off.</p>
    public let nextMarker: String?
    /// <p>The number of functions returned in the response.</p>
    public let quantity: Int?

    public init (
        items: [FunctionSummary]? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension FunctionMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case functionARN = "FunctionARN"
        case lastModifiedTime = "LastModifiedTime"
        case stage = "Stage"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encode(TimestampWrapper(createdTime, format: .dateTime), forKey: Key("createdTime"))
        }
        if let functionARN = functionARN {
            try container.encode(functionARN, forKey: Key("functionARN"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: Key("stage"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionARN)
        functionARN = functionARNDecoded
        let stageDecoded = try containerValues.decodeIfPresent(FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        var createdTimeBuffer:Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
    }
}

extension FunctionMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionMetadata(createdTime: \(String(describing: createdTime)), functionARN: \(String(describing: functionARN)), lastModifiedTime: \(String(describing: lastModifiedTime)), stage: \(String(describing: stage)))"}
}

extension FunctionMetadata: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains metadata about a CloudFront function.</p>
public struct FunctionMetadata: Equatable {
    /// <p>The date and time when the function was created.</p>
    public let createdTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the function. The ARN uniquely identifies the
    /// 			function.</p>
    public let functionARN: String?
    /// <p>The date and time when the function was most recently updated.</p>
    public let lastModifiedTime: Date?
    /// <p>The stage that the function is in, either <code>DEVELOPMENT</code> or
    /// 			<code>LIVE</code>.</p>
    /// 		       <p>When a function is in the <code>DEVELOPMENT</code> stage, you can test the function with
    /// 				<code>TestFunction</code>, and update it with <code>UpdateFunction</code>.</p>
    /// 		       <p>When a function is in the <code>LIVE</code> stage, you can attach the function to a
    /// 			distribution’s cache behavior, using the function’s ARN.</p>
    public let stage: FunctionStage?

    public init (
        createdTime: Date? = nil,
        functionARN: String? = nil,
        lastModifiedTime: Date? = nil,
        stage: FunctionStage? = nil
    )
    {
        self.createdTime = createdTime
        self.functionARN = functionARN
        self.lastModifiedTime = lastModifiedTime
        self.stage = stage
    }
}

public enum FunctionRuntime {
    case cloudfrontJs10
    case sdkUnknown(String)
}

extension FunctionRuntime : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FunctionRuntime] {
        return [
            .cloudfrontJs10,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudfrontJs10: return "cloudfront-js-1.0"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FunctionRuntime(rawValue: rawValue) ?? FunctionRuntime.sdkUnknown(rawValue)
    }
}

extension FunctionSizeLimitExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionSizeLimitExceeded(message: \(String(describing: message)))"}
}

extension FunctionSizeLimitExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<FunctionSizeLimitExceededBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The function is too large. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct FunctionSizeLimitExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct FunctionSizeLimitExceededBody: Equatable {
    public let message: String?
}

extension FunctionSizeLimitExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum FunctionStage {
    case development
    case live
    case sdkUnknown(String)
}

extension FunctionStage : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FunctionStage] {
        return [
            .development,
            .live,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .development: return "DEVELOPMENT"
        case .live: return "LIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FunctionStage(rawValue: rawValue) ?? FunctionStage.sdkUnknown(rawValue)
    }
}

extension FunctionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionConfig = "FunctionConfig"
        case functionMetadata = "FunctionMetadata"
        case name = "Name"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: Key("functionConfig"))
        }
        if let functionMetadata = functionMetadata {
            try container.encode(functionMetadata, forKey: Key("functionMetadata"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let functionConfigDecoded = try containerValues.decodeIfPresent(FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        let functionMetadataDecoded = try containerValues.decodeIfPresent(FunctionMetadata.self, forKey: .functionMetadata)
        functionMetadata = functionMetadataDecoded
    }
}

extension FunctionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionSummary(functionConfig: \(String(describing: functionConfig)), functionMetadata: \(String(describing: functionMetadata)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

extension FunctionSummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains configuration information and metadata about a CloudFront function.</p>
public struct FunctionSummary: Equatable {
    /// <p>Contains configuration information about a CloudFront function.</p>
    public let functionConfig: FunctionConfig?
    /// <p>Contains metadata about a CloudFront function.</p>
    public let functionMetadata: FunctionMetadata?
    /// <p>The name of the CloudFront function.</p>
    public let name: String?
    /// <p>The status of the CloudFront function.</p>
    public let status: String?

    public init (
        functionConfig: FunctionConfig? = nil,
        functionMetadata: FunctionMetadata? = nil,
        name: String? = nil,
        status: String? = nil
    )
    {
        self.functionConfig = functionConfig
        self.functionMetadata = functionMetadata
        self.name = name
        self.status = status
    }
}

extension GeoRestriction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
        case restrictionType = "RestrictionType"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("Location"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
        if let restrictionType = restrictionType {
            try container.encode(restrictionType, forKey: Key("restrictionType"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restrictionTypeDecoded = try containerValues.decodeIfPresent(GeoRestrictionType.self, forKey: .restrictionType)
        restrictionType = restrictionTypeDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Location{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Location>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension GeoRestriction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoRestriction(items: \(String(describing: items)), quantity: \(String(describing: quantity)), restrictionType: \(String(describing: restrictionType)))"}
}

extension GeoRestriction: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that controls the countries in which your content is distributed. CloudFront
/// 			determines the location of your users using <code>MaxMind</code> GeoIP databases. </p>
public struct GeoRestriction: Equatable {
    /// <p> A complex type that contains a <code>Location</code> element for each country in which
    /// 			you want CloudFront either to distribute your content (<code>whitelist</code>) or not distribute
    /// 			your content (<code>blacklist</code>).</p>
    /// 		       <p>The <code>Location</code> element is a two-letter, uppercase country code for a country
    /// 			that you want to include in your <code>blacklist</code> or <code>whitelist</code>. Include one
    /// 				<code>Location</code> element for each country.</p>
    /// 		       <p>CloudFront and <code>MaxMind</code> both use <code>ISO 3166</code> country codes. For the
    /// 			current list of countries and the corresponding codes, see <code>ISO 3166-1-alpha-2</code>
    /// 			code on the <i>International Organization for Standardization</i> website. You
    /// 			can also refer to the country list on the CloudFront console, which includes both country names and
    /// 			codes.</p>
    public let items: [String]?
    /// <p>When geo restriction is <code>enabled</code>, this is the number of countries in your
    /// 				<code>whitelist</code> or <code>blacklist</code>. Otherwise, when it is not enabled,
    /// 				<code>Quantity</code> is <code>0</code>, and you can omit <code>Items</code>.</p>
    public let quantity: Int?
    /// <p>The method that you want to use to restrict distribution of your content by
    /// 			country:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>none</code>: No geo restriction is enabled, meaning access to content is not
    /// 					restricted by client geo location.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>blacklist</code>: The <code>Location</code> elements specify the countries in
    /// 					which you don't want CloudFront to distribute your content.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>whitelist</code>: The <code>Location</code> elements specify the countries in
    /// 					which you want CloudFront to distribute your content.</p>
    /// 			         </li>
    ///          </ul>
    public let restrictionType: GeoRestrictionType?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil,
        restrictionType: GeoRestrictionType? = nil
    )
    {
        self.items = items
        self.quantity = quantity
        self.restrictionType = restrictionType
    }
}

public enum GeoRestrictionType {
    case blacklist
    case `none`
    case whitelist
    case sdkUnknown(String)
}

extension GeoRestrictionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GeoRestrictionType] {
        return [
            .blacklist,
            .none,
            .whitelist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .blacklist: return "blacklist"
        case .none: return "none"
        case .whitelist: return "whitelist"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GeoRestrictionType(rawValue: rawValue) ?? GeoRestrictionType.sdkUnknown(rawValue)
    }
}

extension GetCachePolicyConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCachePolicyConfigInput(id: \(String(describing: id)))"}
}

extension GetCachePolicyConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCachePolicyConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetCachePolicyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCachePolicyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCachePolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCachePolicyConfigInput>
    public typealias MOutput = OperationOutput<GetCachePolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCachePolicyConfigOutputError>
}

public struct GetCachePolicyConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCachePolicyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCachePolicyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCachePolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCachePolicyConfigInput>
    public typealias MOutput = OperationOutput<GetCachePolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCachePolicyConfigOutputError>
}

public struct GetCachePolicyConfigInput: Equatable {
    /// <p>The unique identifier for the cache policy. If the cache policy is attached to a
    /// 			distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
    /// 			not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListCachePolicies</code>.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyConfigInputBody: Equatable {
}

extension GetCachePolicyConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCachePolicyConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCachePolicyConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCachePolicyConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCachePolicyConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCachePolicyConfigOutputResponse(cachePolicyConfig: \(String(describing: cachePolicyConfig)), eTag: \(String(describing: eTag)))"}
}

extension GetCachePolicyConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CachePolicyConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.cachePolicyConfig = output
            } else {
                self.cachePolicyConfig = nil
            }
        } else {
            self.cachePolicyConfig = nil
        }
    }
}

public struct GetCachePolicyConfigOutputResponse: Equatable {
    /// <p>The cache policy configuration.</p>
    public let cachePolicyConfig: CachePolicyConfig?
    /// <p>The current version of the cache policy.</p>
    public let eTag: String?

    public init (
        cachePolicyConfig: CachePolicyConfig? = nil,
        eTag: String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.eTag = eTag
    }
}

struct GetCachePolicyConfigOutputResponseBody: Equatable {
    public let cachePolicyConfig: CachePolicyConfig?
}

extension GetCachePolicyConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension GetCachePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCachePolicyInput(id: \(String(describing: id)))"}
}

extension GetCachePolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCachePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCachePolicyInput>
    public typealias MOutput = OperationOutput<GetCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCachePolicyOutputError>
}

public struct GetCachePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCachePolicyInput>
    public typealias MOutput = OperationOutput<GetCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCachePolicyOutputError>
}

public struct GetCachePolicyInput: Equatable {
    /// <p>The unique identifier for the cache policy. If the cache policy is attached to a
    /// 			distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
    /// 			not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListCachePolicies</code>.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetCachePolicyInputBody: Equatable {
}

extension GetCachePolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCachePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCachePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCachePolicyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCachePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCachePolicyOutputResponse(cachePolicy: \(String(describing: cachePolicy)), eTag: \(String(describing: eTag)))"}
}

extension GetCachePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CachePolicy = try responseDecoder.decode(responseBody: unwrappedData)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct GetCachePolicyOutputResponse: Equatable {
    /// <p>The cache policy.</p>
    public let cachePolicy: CachePolicy?
    /// <p>The current version of the cache policy.</p>
    public let eTag: String?

    public init (
        cachePolicy: CachePolicy? = nil,
        eTag: String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct GetCachePolicyOutputResponseBody: Equatable {
    public let cachePolicy: CachePolicy?
}

extension GetCachePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

extension GetCloudFrontOriginAccessIdentityConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCloudFrontOriginAccessIdentityConfigInput(id: \(String(describing: id)))"}
}

extension GetCloudFrontOriginAccessIdentityConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCloudFrontOriginAccessIdentityConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetCloudFrontOriginAccessIdentityConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>
    public typealias MOutput = OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCloudFrontOriginAccessIdentityConfigOutputError>
}

public struct GetCloudFrontOriginAccessIdentityConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCloudFrontOriginAccessIdentityConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCloudFrontOriginAccessIdentityConfigInput>
    public typealias MOutput = OperationOutput<GetCloudFrontOriginAccessIdentityConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCloudFrontOriginAccessIdentityConfigOutputError>
}

/// <p>The origin access identity's configuration information. For more information, see
/// 			<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_CloudFrontOriginAccessIdentityConfig.html">CloudFrontOriginAccessIdentityConfig</a>.</p>
public struct GetCloudFrontOriginAccessIdentityConfigInput: Equatable {
    /// <p>The identity's ID. </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityConfigInputBody: Equatable {
}

extension GetCloudFrontOriginAccessIdentityConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCloudFrontOriginAccessIdentityConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFrontOriginAccessIdentityConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCloudFrontOriginAccessIdentityConfigOutputResponse(cloudFrontOriginAccessIdentityConfig: \(String(describing: cloudFrontOriginAccessIdentityConfig)), eTag: \(String(describing: eTag)))"}
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CloudFrontOriginAccessIdentityConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.cloudFrontOriginAccessIdentityConfig = output
            } else {
                self.cloudFrontOriginAccessIdentityConfig = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentityConfig = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetCloudFrontOriginAccessIdentityConfigOutputResponse: Equatable {
    /// <p>The origin access identity's configuration information. </p>
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig?
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig? = nil,
        eTag: String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityConfigOutputResponseBody: Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig?
}

extension GetCloudFrontOriginAccessIdentityConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension GetCloudFrontOriginAccessIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCloudFrontOriginAccessIdentityInput(id: \(String(describing: id)))"}
}

extension GetCloudFrontOriginAccessIdentityInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCloudFrontOriginAccessIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "GetCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCloudFrontOriginAccessIdentityOutputError>
}

public struct GetCloudFrontOriginAccessIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<GetCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCloudFrontOriginAccessIdentityOutputError>
}

/// <p>The request to get an origin access identity's information.</p>
public struct GetCloudFrontOriginAccessIdentityInput: Equatable {
    /// <p>The identity's ID.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetCloudFrontOriginAccessIdentityInputBody: Equatable {
}

extension GetCloudFrontOriginAccessIdentityInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCloudFrontOriginAccessIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCloudFrontOriginAccessIdentityOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCloudFrontOriginAccessIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(String(describing: cloudFrontOriginAccessIdentity)), eTag: \(String(describing: eTag)))"}
}

extension GetCloudFrontOriginAccessIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: unwrappedData)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetCloudFrontOriginAccessIdentityOutputResponse: Equatable {
    /// <p>The origin access identity's information.</p>
    public let cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity?
    /// <p>The current version of the origin access identity's information. For example:
    /// 				<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity? = nil,
        eTag: String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct GetCloudFrontOriginAccessIdentityOutputResponseBody: Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity?
}

extension GetCloudFrontOriginAccessIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

extension GetDistributionConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDistributionConfigInput(id: \(String(describing: id)))"}
}

extension GetDistributionConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDistributionConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetDistributionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDistributionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDistributionConfigInput>
    public typealias MOutput = OperationOutput<GetDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDistributionConfigOutputError>
}

public struct GetDistributionConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDistributionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDistributionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDistributionConfigInput>
    public typealias MOutput = OperationOutput<GetDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDistributionConfigOutputError>
}

/// <p>The request to get a distribution configuration.</p>
public struct GetDistributionConfigInput: Equatable {
    /// <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionConfigInputBody: Equatable {
}

extension GetDistributionConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDistributionConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetDistributionConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDistributionConfigOutputResponse(distributionConfig: \(String(describing: distributionConfig)), eTag: \(String(describing: eTag)))"}
}

extension GetDistributionConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: DistributionConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.distributionConfig = output
            } else {
                self.distributionConfig = nil
            }
        } else {
            self.distributionConfig = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetDistributionConfigOutputResponse: Equatable {
    /// <p>The distribution's configuration information.</p>
    public let distributionConfig: DistributionConfig?
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?

    public init (
        distributionConfig: DistributionConfig? = nil,
        eTag: String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.eTag = eTag
    }
}

struct GetDistributionConfigOutputResponseBody: Equatable {
    public let distributionConfig: DistributionConfig?
}

extension GetDistributionConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension GetDistributionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDistributionInput(id: \(String(describing: id)))"}
}

extension GetDistributionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDistributionInputHeadersMiddleware: Middleware {
    public let id: String = "GetDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDistributionInput>
    public typealias MOutput = OperationOutput<GetDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDistributionOutputError>
}

public struct GetDistributionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDistributionInput>
    public typealias MOutput = OperationOutput<GetDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDistributionOutputError>
}

/// <p>The request to get a distribution's information.</p>
public struct GetDistributionInput: Equatable {
    /// <p>The distribution's ID. If the ID is empty, an empty distribution configuration is returned.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetDistributionInputBody: Equatable {
}

extension GetDistributionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDistributionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetDistributionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDistributionOutputResponse(distribution: \(String(describing: distribution)), eTag: \(String(describing: eTag)))"}
}

extension GetDistributionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: Distribution = try responseDecoder.decode(responseBody: unwrappedData)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetDistributionOutputResponse: Equatable {
    /// <p>The distribution's information.</p>
    public let distribution: Distribution?
    /// <p>The current version of the distribution's information. For example:
    /// 				<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?

    public init (
        distribution: Distribution? = nil,
        eTag: String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct GetDistributionOutputResponseBody: Equatable {
    public let distribution: Distribution?
}

extension GetDistributionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

extension GetFieldLevelEncryptionConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFieldLevelEncryptionConfigInput(id: \(String(describing: id)))"}
}

extension GetFieldLevelEncryptionConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFieldLevelEncryptionConfigOutputError>
}

public struct GetFieldLevelEncryptionConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<GetFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFieldLevelEncryptionConfigOutputError>
}

public struct GetFieldLevelEncryptionConfigInput: Equatable {
    /// <p>Request the ID for the field-level encryption configuration information.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionConfigInputBody: Equatable {
}

extension GetFieldLevelEncryptionConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFieldLevelEncryptionConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFieldLevelEncryptionConfigOutputResponse(eTag: \(String(describing: eTag)), fieldLevelEncryptionConfig: \(String(describing: fieldLevelEncryptionConfig)))"}
}

extension GetFieldLevelEncryptionConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryptionConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryptionConfig = output
            } else {
                self.fieldLevelEncryptionConfig = nil
            }
        } else {
            self.fieldLevelEncryptionConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionConfigOutputResponse: Equatable {
    /// <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>Return the field-level encryption configuration information.</p>
    public let fieldLevelEncryptionConfig: FieldLevelEncryptionConfig?

    public init (
        eTag: String? = nil,
        fieldLevelEncryptionConfig: FieldLevelEncryptionConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
    }
}

struct GetFieldLevelEncryptionConfigOutputResponseBody: Equatable {
    public let fieldLevelEncryptionConfig: FieldLevelEncryptionConfig?
}

extension GetFieldLevelEncryptionConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension GetFieldLevelEncryptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFieldLevelEncryptionInput(id: \(String(describing: id)))"}
}

extension GetFieldLevelEncryptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionInputHeadersMiddleware: Middleware {
    public let id: String = "GetFieldLevelEncryptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFieldLevelEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFieldLevelEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFieldLevelEncryptionInput>
    public typealias MOutput = OperationOutput<GetFieldLevelEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFieldLevelEncryptionOutputError>
}

public struct GetFieldLevelEncryptionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFieldLevelEncryptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFieldLevelEncryptionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFieldLevelEncryptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFieldLevelEncryptionInput>
    public typealias MOutput = OperationOutput<GetFieldLevelEncryptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFieldLevelEncryptionOutputError>
}

public struct GetFieldLevelEncryptionInput: Equatable {
    /// <p>Request the ID for the field-level encryption configuration information.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionInputBody: Equatable {
}

extension GetFieldLevelEncryptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFieldLevelEncryptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFieldLevelEncryptionOutputResponse(eTag: \(String(describing: eTag)), fieldLevelEncryption: \(String(describing: fieldLevelEncryption)))"}
}

extension GetFieldLevelEncryptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryption = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct GetFieldLevelEncryptionOutputResponse: Equatable {
    /// <p>The current version of the field level encryption configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>Return the field-level encryption configuration information.</p>
    public let fieldLevelEncryption: FieldLevelEncryption?

    public init (
        eTag: String? = nil,
        fieldLevelEncryption: FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct GetFieldLevelEncryptionOutputResponseBody: Equatable {
    public let fieldLevelEncryption: FieldLevelEncryption?
}

extension GetFieldLevelEncryptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

extension GetFieldLevelEncryptionProfileConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFieldLevelEncryptionProfileConfigInput(id: \(String(describing: id)))"}
}

extension GetFieldLevelEncryptionProfileConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionProfileConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetFieldLevelEncryptionProfileConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>
    public typealias MOutput = OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFieldLevelEncryptionProfileConfigOutputError>
}

public struct GetFieldLevelEncryptionProfileConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFieldLevelEncryptionProfileConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFieldLevelEncryptionProfileConfigInput>
    public typealias MOutput = OperationOutput<GetFieldLevelEncryptionProfileConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFieldLevelEncryptionProfileConfigOutputError>
}

public struct GetFieldLevelEncryptionProfileConfigInput: Equatable {
    /// <p>Get the ID for the field-level encryption profile configuration information.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileConfigInputBody: Equatable {
}

extension GetFieldLevelEncryptionProfileConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionProfileConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionProfileConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionProfileConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFieldLevelEncryptionProfileConfigOutputResponse(eTag: \(String(describing: eTag)), fieldLevelEncryptionProfileConfig: \(String(describing: fieldLevelEncryptionProfileConfig)))"}
}

extension GetFieldLevelEncryptionProfileConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryptionProfileConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryptionProfileConfig = output
            } else {
                self.fieldLevelEncryptionProfileConfig = nil
            }
        } else {
            self.fieldLevelEncryptionProfileConfig = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileConfigOutputResponse: Equatable {
    /// <p>The current version of the field-level encryption profile configuration result. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>Return the field-level encryption profile configuration information.</p>
    public let fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig?

    public init (
        eTag: String? = nil,
        fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
    }
}

struct GetFieldLevelEncryptionProfileConfigOutputResponseBody: Equatable {
    public let fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig?
}

extension GetFieldLevelEncryptionProfileConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension GetFieldLevelEncryptionProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFieldLevelEncryptionProfileInput(id: \(String(describing: id)))"}
}

extension GetFieldLevelEncryptionProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFieldLevelEncryptionProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFieldLevelEncryptionProfileOutputError>
}

public struct GetFieldLevelEncryptionProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<GetFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFieldLevelEncryptionProfileOutputError>
}

public struct GetFieldLevelEncryptionProfileInput: Equatable {
    /// <p>Get the ID for the field-level encryption profile information.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetFieldLevelEncryptionProfileInputBody: Equatable {
}

extension GetFieldLevelEncryptionProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFieldLevelEncryptionProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFieldLevelEncryptionProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFieldLevelEncryptionProfileOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFieldLevelEncryptionProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFieldLevelEncryptionProfileOutputResponse(eTag: \(String(describing: eTag)), fieldLevelEncryptionProfile: \(String(describing: fieldLevelEncryptionProfile)))"}
}

extension GetFieldLevelEncryptionProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct GetFieldLevelEncryptionProfileOutputResponse: Equatable {
    /// <p>The current version of the field level encryption profile. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>Return the field-level encryption profile information.</p>
    public let fieldLevelEncryptionProfile: FieldLevelEncryptionProfile?

    public init (
        eTag: String? = nil,
        fieldLevelEncryptionProfile: FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct GetFieldLevelEncryptionProfileOutputResponseBody: Equatable {
    public let fieldLevelEncryptionProfile: FieldLevelEncryptionProfile?
}

extension GetFieldLevelEncryptionProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

extension GetFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionInput(name: \(String(describing: name)), stage: \(String(describing: stage)))"}
}

extension GetFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionInput>
    public typealias MOutput = OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = URLQueryItem(name: "Stage".urlPercentEncoding(), value: String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionInput>
    public typealias MOutput = OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionOutputError>
}

public struct GetFunctionInput: Equatable {
    /// <p>The name of the function whose code you are getting.</p>
    public let name: String?
    /// <p>The function’s stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
    public let stage: FunctionStage?

    public init (
        name: String? = nil,
        stage: FunctionStage? = nil
    )
    {
        self.name = name
        self.stage = stage
    }
}

struct GetFunctionInputBody: Equatable {
}

extension GetFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Equatable {
    case noSuchFunctionExists(NoSuchFunctionExists)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionOutputResponse(contentType: \(String(describing: contentType)), eTag: \(String(describing: eTag)), functionCode: \(String(describing: functionCode)))"}
}

extension GetFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.functionCode = unwrappedData
        } else {
            self.functionCode = nil
        }
    }
}

public struct GetFunctionOutputResponse: Equatable {
    /// <p>The content type (media type) of the response.</p>
    public let contentType: String?
    /// <p>The version identifier for the current version of the CloudFront function.</p>
    public let eTag: String?
    /// <p>The function code of a CloudFront function.</p>
    public let functionCode: Data?

    public init (
        contentType: String? = nil,
        eTag: String? = nil,
        functionCode: Data? = nil
    )
    {
        self.contentType = contentType
        self.eTag = eTag
        self.functionCode = functionCode
    }
}

struct GetFunctionOutputResponseBody: Equatable {
    public let functionCode: Data?
}

extension GetFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionCode = "FunctionCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension GetInvalidationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvalidationInput(distributionId: \(String(describing: distributionId)), id: \(String(describing: id)))"}
}

extension GetInvalidationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetInvalidationInputHeadersMiddleware: Middleware {
    public let id: String = "GetInvalidationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvalidationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvalidationInput>
    public typealias MOutput = OperationOutput<GetInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvalidationOutputError>
}

public struct GetInvalidationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInvalidationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvalidationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvalidationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvalidationInput>
    public typealias MOutput = OperationOutput<GetInvalidationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvalidationOutputError>
}

/// <p>The request to get an invalidation's information. </p>
public struct GetInvalidationInput: Equatable {
    /// <p>The distribution's ID.</p>
    public let distributionId: String?
    /// <p>The identifier for the invalidation request, for example,
    /// 			<code>IDFDVBD632BHDS5</code>.</p>
    public let id: String?

    public init (
        distributionId: String? = nil,
        id: String? = nil
    )
    {
        self.distributionId = distributionId
        self.id = id
    }
}

struct GetInvalidationInputBody: Equatable {
}

extension GetInvalidationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetInvalidationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetInvalidationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchInvalidation" : self = .noSuchInvalidation(try NoSuchInvalidation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvalidationOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case noSuchInvalidation(NoSuchInvalidation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvalidationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvalidationOutputResponse(invalidation: \(String(describing: invalidation)))"}
}

extension GetInvalidationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: Invalidation = try responseDecoder.decode(responseBody: unwrappedData)
                self.invalidation = output
            } else {
                self.invalidation = nil
            }
        } else {
            self.invalidation = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetInvalidationOutputResponse: Equatable {
    /// <p>The invalidation's information. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/InvalidationDatatype.html">Invalidation Complex Type</a>. </p>
    public let invalidation: Invalidation?

    public init (
        invalidation: Invalidation? = nil
    )
    {
        self.invalidation = invalidation
    }
}

struct GetInvalidationOutputResponseBody: Equatable {
    public let invalidation: Invalidation?
}

extension GetInvalidationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidation = "Invalidation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationDecoded = try containerValues.decodeIfPresent(Invalidation.self, forKey: .invalidation)
        invalidation = invalidationDecoded
    }
}

extension GetKeyGroupConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKeyGroupConfigInput(id: \(String(describing: id)))"}
}

extension GetKeyGroupConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetKeyGroupConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetKeyGroupConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyGroupConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyGroupConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyGroupConfigInput>
    public typealias MOutput = OperationOutput<GetKeyGroupConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyGroupConfigOutputError>
}

public struct GetKeyGroupConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetKeyGroupConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyGroupConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyGroupConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyGroupConfigInput>
    public typealias MOutput = OperationOutput<GetKeyGroupConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyGroupConfigOutputError>
}

public struct GetKeyGroupConfigInput: Equatable {
    /// <p>The identifier of the key group whose configuration you are getting. To get the
    /// 			identifier, use <code>ListKeyGroups</code>.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupConfigInputBody: Equatable {
}

extension GetKeyGroupConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetKeyGroupConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetKeyGroupConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyGroupConfigOutputError: Equatable {
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyGroupConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKeyGroupConfigOutputResponse(eTag: \(String(describing: eTag)), keyGroupConfig: \(String(describing: keyGroupConfig)))"}
}

extension GetKeyGroupConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: KeyGroupConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.keyGroupConfig = output
            } else {
                self.keyGroupConfig = nil
            }
        } else {
            self.keyGroupConfig = nil
        }
    }
}

public struct GetKeyGroupConfigOutputResponse: Equatable {
    /// <p>The identifier for this version of the key group.</p>
    public let eTag: String?
    /// <p>The key group configuration.</p>
    public let keyGroupConfig: KeyGroupConfig?

    public init (
        eTag: String? = nil,
        keyGroupConfig: KeyGroupConfig? = nil
    )
    {
        self.eTag = eTag
        self.keyGroupConfig = keyGroupConfig
    }
}

struct GetKeyGroupConfigOutputResponseBody: Equatable {
    public let keyGroupConfig: KeyGroupConfig?
}

extension GetKeyGroupConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension GetKeyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKeyGroupInput(id: \(String(describing: id)))"}
}

extension GetKeyGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetKeyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyGroupInput>
    public typealias MOutput = OperationOutput<GetKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyGroupOutputError>
}

public struct GetKeyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetKeyGroupInput>
    public typealias MOutput = OperationOutput<GetKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetKeyGroupOutputError>
}

public struct GetKeyGroupInput: Equatable {
    /// <p>The identifier of the key group that you are getting. To get the identifier, use
    /// 			<code>ListKeyGroups</code>.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetKeyGroupInputBody: Equatable {
}

extension GetKeyGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetKeyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetKeyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetKeyGroupOutputError: Equatable {
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetKeyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetKeyGroupOutputResponse(eTag: \(String(describing: eTag)), keyGroup: \(String(describing: keyGroup)))"}
}

extension GetKeyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: KeyGroup = try responseDecoder.decode(responseBody: unwrappedData)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct GetKeyGroupOutputResponse: Equatable {
    /// <p>The identifier for this version of the key group.</p>
    public let eTag: String?
    /// <p>The key group.</p>
    public let keyGroup: KeyGroup?

    public init (
        eTag: String? = nil,
        keyGroup: KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct GetKeyGroupOutputResponseBody: Equatable {
    public let keyGroup: KeyGroup?
}

extension GetKeyGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension GetMonitoringSubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMonitoringSubscriptionInput(distributionId: \(String(describing: distributionId)))"}
}

extension GetMonitoringSubscriptionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMonitoringSubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "GetMonitoringSubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMonitoringSubscriptionInput>
    public typealias MOutput = OperationOutput<GetMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMonitoringSubscriptionOutputError>
}

public struct GetMonitoringSubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMonitoringSubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMonitoringSubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMonitoringSubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMonitoringSubscriptionInput>
    public typealias MOutput = OperationOutput<GetMonitoringSubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMonitoringSubscriptionOutputError>
}

public struct GetMonitoringSubscriptionInput: Equatable {
    /// <p>The ID of the distribution that you are getting metrics information for.</p>
    public let distributionId: String?

    public init (
        distributionId: String? = nil
    )
    {
        self.distributionId = distributionId
    }
}

struct GetMonitoringSubscriptionInputBody: Equatable {
}

extension GetMonitoringSubscriptionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMonitoringSubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetMonitoringSubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperation" : self = .unsupportedOperation(try UnsupportedOperation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMonitoringSubscriptionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchDistribution(NoSuchDistribution)
    case unsupportedOperation(UnsupportedOperation)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMonitoringSubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMonitoringSubscriptionOutputResponse(monitoringSubscription: \(String(describing: monitoringSubscription)))"}
}

extension GetMonitoringSubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MonitoringSubscription = try responseDecoder.decode(responseBody: unwrappedData)
                self.monitoringSubscription = output
            } else {
                self.monitoringSubscription = nil
            }
        } else {
            self.monitoringSubscription = nil
        }
    }
}

public struct GetMonitoringSubscriptionOutputResponse: Equatable {
    /// <p>A monitoring subscription. This structure contains information about whether additional
    /// 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
    public let monitoringSubscription: MonitoringSubscription?

    public init (
        monitoringSubscription: MonitoringSubscription? = nil
    )
    {
        self.monitoringSubscription = monitoringSubscription
    }
}

struct GetMonitoringSubscriptionOutputResponseBody: Equatable {
    public let monitoringSubscription: MonitoringSubscription?
}

extension GetMonitoringSubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case monitoringSubscription = "MonitoringSubscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringSubscriptionDecoded = try containerValues.decodeIfPresent(MonitoringSubscription.self, forKey: .monitoringSubscription)
        monitoringSubscription = monitoringSubscriptionDecoded
    }
}

extension GetOriginRequestPolicyConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOriginRequestPolicyConfigInput(id: \(String(describing: id)))"}
}

extension GetOriginRequestPolicyConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetOriginRequestPolicyConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetOriginRequestPolicyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOriginRequestPolicyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOriginRequestPolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOriginRequestPolicyConfigInput>
    public typealias MOutput = OperationOutput<GetOriginRequestPolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOriginRequestPolicyConfigOutputError>
}

public struct GetOriginRequestPolicyConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOriginRequestPolicyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOriginRequestPolicyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOriginRequestPolicyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOriginRequestPolicyConfigInput>
    public typealias MOutput = OperationOutput<GetOriginRequestPolicyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOriginRequestPolicyConfigOutputError>
}

public struct GetOriginRequestPolicyConfigInput: Equatable {
    /// <p>The unique identifier for the origin request policy. If the origin request policy is
    /// 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
    /// 			policy is not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListOriginRequestPolicies</code>.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyConfigInputBody: Equatable {
}

extension GetOriginRequestPolicyConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetOriginRequestPolicyConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOriginRequestPolicyConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOriginRequestPolicyConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginRequestPolicyConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOriginRequestPolicyConfigOutputResponse(eTag: \(String(describing: eTag)), originRequestPolicyConfig: \(String(describing: originRequestPolicyConfig)))"}
}

extension GetOriginRequestPolicyConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: OriginRequestPolicyConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.originRequestPolicyConfig = output
            } else {
                self.originRequestPolicyConfig = nil
            }
        } else {
            self.originRequestPolicyConfig = nil
        }
    }
}

public struct GetOriginRequestPolicyConfigOutputResponse: Equatable {
    /// <p>The current version of the origin request policy.</p>
    public let eTag: String?
    /// <p>The origin request policy configuration.</p>
    public let originRequestPolicyConfig: OriginRequestPolicyConfig?

    public init (
        eTag: String? = nil,
        originRequestPolicyConfig: OriginRequestPolicyConfig? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct GetOriginRequestPolicyConfigOutputResponseBody: Equatable {
    public let originRequestPolicyConfig: OriginRequestPolicyConfig?
}

extension GetOriginRequestPolicyConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension GetOriginRequestPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOriginRequestPolicyInput(id: \(String(describing: id)))"}
}

extension GetOriginRequestPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetOriginRequestPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<GetOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOriginRequestPolicyOutputError>
}

public struct GetOriginRequestPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<GetOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOriginRequestPolicyOutputError>
}

public struct GetOriginRequestPolicyInput: Equatable {
    /// <p>The unique identifier for the origin request policy. If the origin request policy is
    /// 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the origin request
    /// 			policy is not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListOriginRequestPolicies</code>.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetOriginRequestPolicyInputBody: Equatable {
}

extension GetOriginRequestPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetOriginRequestPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetOriginRequestPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOriginRequestPolicyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOriginRequestPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOriginRequestPolicyOutputResponse(eTag: \(String(describing: eTag)), originRequestPolicy: \(String(describing: originRequestPolicy)))"}
}

extension GetOriginRequestPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: OriginRequestPolicy = try responseDecoder.decode(responseBody: unwrappedData)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct GetOriginRequestPolicyOutputResponse: Equatable {
    /// <p>The current version of the origin request policy.</p>
    public let eTag: String?
    /// <p>The origin request policy.</p>
    public let originRequestPolicy: OriginRequestPolicy?

    public init (
        eTag: String? = nil,
        originRequestPolicy: OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct GetOriginRequestPolicyOutputResponseBody: Equatable {
    public let originRequestPolicy: OriginRequestPolicy?
}

extension GetOriginRequestPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension GetPublicKeyConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicKeyConfigInput(id: \(String(describing: id)))"}
}

extension GetPublicKeyConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPublicKeyConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetPublicKeyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicKeyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicKeyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicKeyConfigInput>
    public typealias MOutput = OperationOutput<GetPublicKeyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicKeyConfigOutputError>
}

public struct GetPublicKeyConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPublicKeyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicKeyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicKeyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicKeyConfigInput>
    public typealias MOutput = OperationOutput<GetPublicKeyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicKeyConfigOutputError>
}

public struct GetPublicKeyConfigInput: Equatable {
    /// <p>The identifier of the public key whose configuration you are getting.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyConfigInputBody: Equatable {
}

extension GetPublicKeyConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPublicKeyConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicKeyConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchPublicKey(NoSuchPublicKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicKeyConfigOutputResponse(eTag: \(String(describing: eTag)), publicKeyConfig: \(String(describing: publicKeyConfig)))"}
}

extension GetPublicKeyConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PublicKeyConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.publicKeyConfig = output
            } else {
                self.publicKeyConfig = nil
            }
        } else {
            self.publicKeyConfig = nil
        }
    }
}

public struct GetPublicKeyConfigOutputResponse: Equatable {
    /// <p>The identifier for this version of the public key configuration.</p>
    public let eTag: String?
    /// <p>A public key configuration.</p>
    public let publicKeyConfig: PublicKeyConfig?

    public init (
        eTag: String? = nil,
        publicKeyConfig: PublicKeyConfig? = nil
    )
    {
        self.eTag = eTag
        self.publicKeyConfig = publicKeyConfig
    }
}

struct GetPublicKeyConfigOutputResponseBody: Equatable {
    public let publicKeyConfig: PublicKeyConfig?
}

extension GetPublicKeyConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension GetPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicKeyInput(id: \(String(describing: id)))"}
}

extension GetPublicKeyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPublicKeyInput>
    public typealias MOutput = OperationOutput<GetPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPublicKeyOutputError>
}

public struct GetPublicKeyInput: Equatable {
    /// <p>The identifier of the public key you are getting.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetPublicKeyInputBody: Equatable {
}

extension GetPublicKeyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPublicKeyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchPublicKey(NoSuchPublicKey)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPublicKeyOutputResponse(eTag: \(String(describing: eTag)), publicKey: \(String(describing: publicKey)))"}
}

extension GetPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PublicKey = try responseDecoder.decode(responseBody: unwrappedData)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct GetPublicKeyOutputResponse: Equatable {
    /// <p>The identifier for this version of the public key.</p>
    public let eTag: String?
    /// <p>The public key.</p>
    public let publicKey: PublicKey?

    public init (
        eTag: String? = nil,
        publicKey: PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct GetPublicKeyOutputResponseBody: Equatable {
    public let publicKey: PublicKey?
}

extension GetPublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct GetRealtimeLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "GetRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRealtimeLogConfigOutputError>
}

extension GetRealtimeLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRealtimeLogConfigInput(aRN: \(String(describing: aRN)), name: \(String(describing: name)))"}
}

extension GetRealtimeLogConfigInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension GetRealtimeLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("aRN"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }
}

public struct GetRealtimeLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRealtimeLogConfigOutputError>
}

public struct GetRealtimeLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<GetRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRealtimeLogConfigOutputError>
}

public struct GetRealtimeLogConfigInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the real-time log configuration to get.</p>
    public let aRN: String?
    /// <p>The name of the real-time log configuration to get.</p>
    public let name: String?

    public init (
        aRN: String? = nil,
        name: String? = nil
    )
    {
        self.aRN = aRN
        self.name = name
    }
}

struct GetRealtimeLogConfigInputBody: Equatable {
    public let name: String?
    public let aRN: String?
}

extension GetRealtimeLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

extension GetRealtimeLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetRealtimeLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRealtimeLogConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRealtimeLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRealtimeLogConfigOutputResponse(realtimeLogConfig: \(String(describing: realtimeLogConfig)))"}
}

extension GetRealtimeLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct GetRealtimeLogConfigOutputResponse: Equatable {
    /// <p>A real-time log configuration.</p>
    public let realtimeLogConfig: RealtimeLogConfig?

    public init (
        realtimeLogConfig: RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct GetRealtimeLogConfigOutputResponseBody: Equatable {
    public let realtimeLogConfig: RealtimeLogConfig?
}

extension GetRealtimeLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

extension GetStreamingDistributionConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingDistributionConfigInput(id: \(String(describing: id)))"}
}

extension GetStreamingDistributionConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStreamingDistributionConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetStreamingDistributionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingDistributionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingDistributionConfigInput>
    public typealias MOutput = OperationOutput<GetStreamingDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingDistributionConfigOutputError>
}

public struct GetStreamingDistributionConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStreamingDistributionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingDistributionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingDistributionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingDistributionConfigInput>
    public typealias MOutput = OperationOutput<GetStreamingDistributionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingDistributionConfigOutputError>
}

/// <p>To request to get a streaming distribution configuration.</p>
public struct GetStreamingDistributionConfigInput: Equatable {
    /// <p>The streaming distribution's ID.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionConfigInputBody: Equatable {
}

extension GetStreamingDistributionConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStreamingDistributionConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStreamingDistributionConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingDistributionConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingDistributionConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingDistributionConfigOutputResponse(eTag: \(String(describing: eTag)), streamingDistributionConfig: \(String(describing: streamingDistributionConfig)))"}
}

extension GetStreamingDistributionConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: StreamingDistributionConfig = try responseDecoder.decode(responseBody: unwrappedData)
                self.streamingDistributionConfig = output
            } else {
                self.streamingDistributionConfig = nil
            }
        } else {
            self.streamingDistributionConfig = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetStreamingDistributionConfigOutputResponse: Equatable {
    /// <p>The current version of the configuration. For example: <code>E2QWRUHAPOMQZL</code>.
    /// 		</p>
    public let eTag: String?
    /// <p>The streaming distribution's configuration information.</p>
    public let streamingDistributionConfig: StreamingDistributionConfig?

    public init (
        eTag: String? = nil,
        streamingDistributionConfig: StreamingDistributionConfig? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct GetStreamingDistributionConfigOutputResponseBody: Equatable {
    public let streamingDistributionConfig: StreamingDistributionConfig?
}

extension GetStreamingDistributionConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension GetStreamingDistributionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingDistributionInput(id: \(String(describing: id)))"}
}

extension GetStreamingDistributionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetStreamingDistributionInputHeadersMiddleware: Middleware {
    public let id: String = "GetStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingDistributionInput>
    public typealias MOutput = OperationOutput<GetStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingDistributionOutputError>
}

public struct GetStreamingDistributionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamingDistributionInput>
    public typealias MOutput = OperationOutput<GetStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamingDistributionOutputError>
}

/// <p>The request to get a streaming distribution's information.</p>
public struct GetStreamingDistributionInput: Equatable {
    /// <p>The streaming distribution's ID.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetStreamingDistributionInputBody: Equatable {
}

extension GetStreamingDistributionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetStreamingDistributionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetStreamingDistributionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamingDistributionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamingDistributionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamingDistributionOutputResponse(eTag: \(String(describing: eTag)), streamingDistribution: \(String(describing: streamingDistribution)))"}
}

extension GetStreamingDistributionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: StreamingDistribution = try responseDecoder.decode(responseBody: unwrappedData)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct GetStreamingDistributionOutputResponse: Equatable {
    /// <p>The current version of the streaming distribution's information. For example:
    /// 				<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>The streaming distribution's information.</p>
    public let streamingDistribution: StreamingDistribution?

    public init (
        eTag: String? = nil,
        streamingDistribution: StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct GetStreamingDistributionOutputResponseBody: Equatable {
    public let streamingDistribution: StreamingDistribution?
}

extension GetStreamingDistributionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension Headers: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension Headers: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Headers(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension Headers: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains a list of HTTP header names.</p>
public struct Headers: Equatable {
    /// <p>A list of HTTP header names.</p>
    public let items: [String]?
    /// <p>The number of header names in the <code>Items</code> list.</p>
    public let quantity: Int?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

public enum HttpVersion {
    case http11
    case http2
    case sdkUnknown(String)
}

extension HttpVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HttpVersion] {
        return [
            .http11,
            .http2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http11: return "http1.1"
        case .http2: return "http2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HttpVersion(rawValue: rawValue) ?? HttpVersion.sdkUnknown(rawValue)
    }
}

public enum ICPRecordalStatus {
    case approved
    case pending
    case suspended
    case sdkUnknown(String)
}

extension ICPRecordalStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ICPRecordalStatus] {
        return [
            .approved,
            .pending,
            .suspended,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "APPROVED"
        case .pending: return "PENDING"
        case .suspended: return "SUSPENDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ICPRecordalStatus(rawValue: rawValue) ?? ICPRecordalStatus.sdkUnknown(rawValue)
    }
}

extension IllegalDelete: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IllegalDelete(message: \(String(describing: message)))"}
}

extension IllegalDelete: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IllegalDeleteBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot delete a managed policy.</p>
public struct IllegalDelete: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalDeleteBody: Equatable {
    public let message: String?
}

extension IllegalDeleteBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(message: \(String(describing: message)))"}
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration for field-level encryption can't be associated with the specified cache behavior.</p>
public struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Equatable {
    public let message: String?
}

extension IllegalFieldLevelEncryptionConfigAssociationWithCacheBehaviorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IllegalUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IllegalUpdate(message: \(String(describing: message)))"}
}

extension IllegalUpdate: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IllegalUpdateBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The update contains modifications that are not allowed.</p>
public struct IllegalUpdate: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalUpdateBody: Equatable {
    public let message: String?
}

extension IllegalUpdateBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InconsistentQuantities: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InconsistentQuantities(message: \(String(describing: message)))"}
}

extension InconsistentQuantities: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InconsistentQuantitiesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value of <code>Quantity</code> and the size of <code>Items</code> don't match.</p>
public struct InconsistentQuantities: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InconsistentQuantitiesBody: Equatable {
    public let message: String?
}

extension InconsistentQuantitiesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArgument: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArgument(message: \(String(describing: message)))"}
}

extension InvalidArgument: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidArgumentBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An argument is invalid.</p>
public struct InvalidArgument: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentBody: Equatable {
    public let message: String?
}

extension InvalidArgumentBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDefaultRootObject: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidDefaultRootObject(message: \(String(describing: message)))"}
}

extension InvalidDefaultRootObject: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidDefaultRootObjectBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The default root object file name is too big or contains an invalid character.</p>
public struct InvalidDefaultRootObject: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDefaultRootObjectBody: Equatable {
    public let message: String?
}

extension InvalidDefaultRootObjectBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidErrorCode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidErrorCode(message: \(String(describing: message)))"}
}

extension InvalidErrorCode: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidErrorCodeBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid error code was specified.</p>
public struct InvalidErrorCode: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidErrorCodeBody: Equatable {
    public let message: String?
}

extension InvalidErrorCodeBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidForwardCookies: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidForwardCookies(message: \(String(describing: message)))"}
}

extension InvalidForwardCookies: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidForwardCookiesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains forward cookies option which doesn't match with the expectation for the <code>whitelisted</code>
/// 			list of cookie names. Either list of cookie names has been specified when not allowed or list of cookie names is missing when expected.</p>
public struct InvalidForwardCookies: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidForwardCookiesBody: Equatable {
    public let message: String?
}

extension InvalidForwardCookiesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidFunctionAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidFunctionAssociation(message: \(String(describing: message)))"}
}

extension InvalidFunctionAssociation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidFunctionAssociationBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A CloudFront function association is invalid.</p>
public struct InvalidFunctionAssociation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidFunctionAssociationBody: Equatable {
    public let message: String?
}

extension InvalidFunctionAssociationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidGeoRestrictionParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidGeoRestrictionParameter(message: \(String(describing: message)))"}
}

extension InvalidGeoRestrictionParameter: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidGeoRestrictionParameterBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified geo restriction parameter is not valid.</p>
public struct InvalidGeoRestrictionParameter: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidGeoRestrictionParameterBody: Equatable {
    public let message: String?
}

extension InvalidGeoRestrictionParameterBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHeadersForS3Origin: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidHeadersForS3Origin(message: \(String(describing: message)))"}
}

extension InvalidHeadersForS3Origin: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidHeadersForS3OriginBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The headers specified are not valid for an Amazon S3 origin.</p>
public struct InvalidHeadersForS3Origin: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHeadersForS3OriginBody: Equatable {
    public let message: String?
}

extension InvalidHeadersForS3OriginBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIfMatchVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidIfMatchVersion(message: \(String(describing: message)))"}
}

extension InvalidIfMatchVersion: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidIfMatchVersionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>If-Match</code> version is missing or not valid.</p>
public struct InvalidIfMatchVersion: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIfMatchVersionBody: Equatable {
    public let message: String?
}

extension InvalidIfMatchVersionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLambdaFunctionAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLambdaFunctionAssociation(message: \(String(describing: message)))"}
}

extension InvalidLambdaFunctionAssociation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidLambdaFunctionAssociationBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Lambda function association is invalid.</p>
public struct InvalidLambdaFunctionAssociation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLambdaFunctionAssociationBody: Equatable {
    public let message: String?
}

extension InvalidLambdaFunctionAssociationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLocationCode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLocationCode(message: \(String(describing: message)))"}
}

extension InvalidLocationCode: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidLocationCodeBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The location code specified is not valid.</p>
public struct InvalidLocationCode: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLocationCodeBody: Equatable {
    public let message: String?
}

extension InvalidLocationCodeBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMinimumProtocolVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMinimumProtocolVersion(message: \(String(describing: message)))"}
}

extension InvalidMinimumProtocolVersion: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidMinimumProtocolVersionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The minimum protocol version specified is not valid.</p>
public struct InvalidMinimumProtocolVersion: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMinimumProtocolVersionBody: Equatable {
    public let message: String?
}

extension InvalidMinimumProtocolVersionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOrigin: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOrigin(message: \(String(describing: message)))"}
}

extension InvalidOrigin: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidOriginBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon S3 origin server specified does not refer to a valid Amazon S3 bucket.</p>
public struct InvalidOrigin: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension InvalidOriginAccessIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOriginAccessIdentity(message: \(String(describing: message)))"}
}

extension InvalidOriginAccessIdentity: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The origin access identity is not valid or doesn't exist.</p>
public struct InvalidOriginAccessIdentity: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginAccessIdentityBody: Equatable {
    public let message: String?
}

extension InvalidOriginAccessIdentityBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

struct InvalidOriginBody: Equatable {
    public let message: String?
}

extension InvalidOriginBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginKeepaliveTimeout: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOriginKeepaliveTimeout(message: \(String(describing: message)))"}
}

extension InvalidOriginKeepaliveTimeout: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidOriginKeepaliveTimeoutBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The keep alive timeout specified for the origin is not valid.</p>
public struct InvalidOriginKeepaliveTimeout: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginKeepaliveTimeoutBody: Equatable {
    public let message: String?
}

extension InvalidOriginKeepaliveTimeoutBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOriginReadTimeout: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOriginReadTimeout(message: \(String(describing: message)))"}
}

extension InvalidOriginReadTimeout: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidOriginReadTimeoutBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The read timeout specified for the origin is not valid.</p>
public struct InvalidOriginReadTimeout: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOriginReadTimeoutBody: Equatable {
    public let message: String?
}

extension InvalidOriginReadTimeoutBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidProtocolSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidProtocolSettings(message: \(String(describing: message)))"}
}

extension InvalidProtocolSettings: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidProtocolSettingsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot specify SSLv3 as the minimum protocol version if you only want to support only clients that support
/// 			Server Name Indication (SNI).</p>
public struct InvalidProtocolSettings: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidProtocolSettingsBody: Equatable {
    public let message: String?
}

extension InvalidProtocolSettingsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidQueryStringParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidQueryStringParameters(message: \(String(describing: message)))"}
}

extension InvalidQueryStringParameters: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidQueryStringParametersBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The query string parameters specified are not valid.</p>
public struct InvalidQueryStringParameters: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidQueryStringParametersBody: Equatable {
    public let message: String?
}

extension InvalidQueryStringParametersBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRelativePath: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRelativePath(message: \(String(describing: message)))"}
}

extension InvalidRelativePath: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRelativePathBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The relative path is too big, is not URL-encoded, or does not begin with a slash (/).</p>
public struct InvalidRelativePath: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRelativePathBody: Equatable {
    public let message: String?
}

extension InvalidRelativePathBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequiredProtocol: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequiredProtocol(message: \(String(describing: message)))"}
}

extension InvalidRequiredProtocol: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidRequiredProtocolBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation requires the HTTPS protocol. Ensure that you specify the HTTPS protocol in your request, or omit the
/// 			<code>RequiredProtocols</code> element from your distribution configuration.</p>
public struct InvalidRequiredProtocol: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequiredProtocolBody: Equatable {
    public let message: String?
}

extension InvalidRequiredProtocolBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResponseCode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResponseCode(message: \(String(describing: message)))"}
}

extension InvalidResponseCode: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidResponseCodeBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A response code is not valid.</p>
public struct InvalidResponseCode: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResponseCodeBody: Equatable {
    public let message: String?
}

extension InvalidResponseCodeBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTTLOrder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTTLOrder(message: \(String(describing: message)))"}
}

extension InvalidTTLOrder: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidTTLOrderBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The TTL order specified is not valid.</p>
public struct InvalidTTLOrder: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTTLOrderBody: Equatable {
    public let message: String?
}

extension InvalidTTLOrderBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagging: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagging(message: \(String(describing: message)))"}
}

extension InvalidTagging: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidTaggingBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tagging specified is not valid.</p>
public struct InvalidTagging: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTaggingBody: Equatable {
    public let message: String?
}

extension InvalidTaggingBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidViewerCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidViewerCertificate(message: \(String(describing: message)))"}
}

extension InvalidViewerCertificate: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidViewerCertificateBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A viewer certificate specified is not valid.</p>
public struct InvalidViewerCertificate: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidViewerCertificateBody: Equatable {
    public let message: String?
}

extension InvalidViewerCertificateBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebACLId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidWebACLId(message: \(String(describing: message)))"}
}

extension InvalidWebACLId: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidWebACLIdBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A web ACL ID specified is not valid. To specify a web ACL created using the latest
/// 			version of AWS WAF, use the ACL ARN, for example
/// 			<code>arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a</code>.
/// 			To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example
/// 			<code>473e64fd-f30b-4765-81a0-62ad96dd167a</code>.</p>
public struct InvalidWebACLId: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidWebACLIdBody: Equatable {
    public let message: String?
}

extension InvalidWebACLIdBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Invalidation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case invalidationBatch = "InvalidationBatch"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encode(TimestampWrapper(createTime, format: .dateTime), forKey: Key("createTime"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let invalidationBatch = invalidationBatch {
            try container.encode(invalidationBatch, forKey: Key("invalidationBatch"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        var createTimeBuffer:Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let invalidationBatchDecoded = try containerValues.decodeIfPresent(InvalidationBatch.self, forKey: .invalidationBatch)
        invalidationBatch = invalidationBatchDecoded
    }
}

extension Invalidation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Invalidation(createTime: \(String(describing: createTime)), id: \(String(describing: id)), invalidationBatch: \(String(describing: invalidationBatch)), status: \(String(describing: status)))"}
}

extension Invalidation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An invalidation. </p>
public struct Invalidation: Equatable {
    /// <p>The date and time the invalidation request was first made. </p>
    public let createTime: Date?
    /// <p>The identifier for the invalidation request. For example:
    /// 			<code>IDFDVBD632BHDS5</code>.</p>
    public let id: String?
    /// <p>The current invalidation information for the batch request. </p>
    public let invalidationBatch: InvalidationBatch?
    /// <p>The status of the invalidation request. When the invalidation batch is finished, the
    /// 			status is <code>Completed</code>.</p>
    public let status: String?

    public init (
        createTime: Date? = nil,
        id: String? = nil,
        invalidationBatch: InvalidationBatch? = nil,
        status: String? = nil
    )
    {
        self.createTime = createTime
        self.id = id
        self.invalidationBatch = invalidationBatch
        self.status = status
    }
}

extension InvalidationBatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case callerReference = "CallerReference"
        case paths = "Paths"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: Key("callerReference"))
        }
        if let paths = paths {
            try container.encode(paths, forKey: Key("paths"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathsDecoded = try containerValues.decodeIfPresent(Paths.self, forKey: .paths)
        paths = pathsDecoded
        let callerReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
    }
}

extension InvalidationBatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidationBatch(callerReference: \(String(describing: callerReference)), paths: \(String(describing: paths)))"}
}

extension InvalidationBatch: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An invalidation batch.</p>
public struct InvalidationBatch: Equatable {
    /// <p>A value that you specify to uniquely identify an invalidation request. CloudFront uses the
    /// 			value to prevent you from accidentally resubmitting an identical request. Whenever you create
    /// 			a new invalidation request, you must specify a new value for <code>CallerReference</code> and
    /// 			change other values in the request as applicable. One way to ensure that the value of
    /// 				<code>CallerReference</code> is unique is to use a <code>timestamp</code>, for example,
    /// 				<code>20120301090000</code>.</p>
    /// 		       <p>If you make a second invalidation request with the same value for
    /// 				<code>CallerReference</code>, and if the rest of the request is the same, CloudFront doesn't
    /// 			create a new invalidation request. Instead, CloudFront returns information about the invalidation
    /// 			request that you previously created with the same <code>CallerReference</code>.</p>
    /// 		       <p>If <code>CallerReference</code> is a value you already sent in a previous invalidation
    /// 			batch request but the content of any <code>Path</code> is different from the original request,
    /// 			CloudFront returns an <code>InvalidationBatchAlreadyExists</code> error.</p>
    public let callerReference: String?
    /// <p>A complex type that contains information about the objects that you want to invalidate.
    /// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects">Specifying the Objects
    /// 				to Invalidate</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
    public let paths: Paths?

    public init (
        callerReference: String? = nil,
        paths: Paths? = nil
    )
    {
        self.callerReference = callerReference
        self.paths = paths
    }
}

extension InvalidationList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: Key("isTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for invalidationsummary0 in items {
                try itemsContainer.encode(invalidationsummary0, forKey: Key("InvalidationSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct InvalidationSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.InvalidationSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([InvalidationSummary].self, forKey: .member)
                var itemsBuffer:[InvalidationSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [InvalidationSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension InvalidationList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidationList(isTruncated: \(String(describing: isTruncated)), items: \(String(describing: items)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension InvalidationList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The <code>InvalidationList</code> complex type describes the list of invalidation
/// 			objects. For more information about invalidation, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html">Invalidating Objects (Web Distributions Only)</a> in
/// 			the <i>Amazon CloudFront Developer Guide</i>.</p>
public struct InvalidationList: Equatable {
    /// <p>A flag that indicates whether more invalidation batch requests remain to be listed. If
    /// 			your results were truncated, you can make a follow-up pagination request using the
    /// 				<code>Marker</code> request parameter to retrieve more invalidation batches in the
    /// 			list.</p>
    public let isTruncated: Bool?
    /// <p>A complex type that contains one <code>InvalidationSummary</code> element for each
    /// 			invalidation batch created by the current AWS account.</p>
    public let items: [InvalidationSummary]?
    /// <p>The value that you provided for the <code>Marker</code> request parameter.</p>
    public let marker: String?
    /// <p>The value that you provided for the <code>MaxItems</code> request parameter.</p>
    public let maxItems: Int?
    /// <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
    /// 			the value that you can use for the <code>Marker</code> request parameter to continue listing
    /// 			your invalidation batches where they left off.</p>
    public let nextMarker: String?
    /// <p>The number of invalidation batches that were created by the current AWS account.
    /// 		</p>
    public let quantity: Int?

    public init (
        isTruncated: Bool? = nil,
        items: [InvalidationSummary]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.isTruncated = isTruncated
        self.items = items
        self.marker = marker
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension InvalidationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createTime = "CreateTime"
        case id = "Id"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let createTime = createTime {
            try container.encode(TimestampWrapper(createTime, format: .dateTime), forKey: Key("createTime"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createTime)
        var createTimeBuffer:Date? = nil
        if let createTimeDecoded = createTimeDecoded {
            createTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createTimeDecoded, format: .dateTime)
        }
        createTime = createTimeBuffer
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension InvalidationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidationSummary(createTime: \(String(describing: createTime)), id: \(String(describing: id)), status: \(String(describing: status)))"}
}

extension InvalidationSummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A summary of an invalidation request.</p>
public struct InvalidationSummary: Equatable {
    /// <p>The time that an invalidation request was created.</p>
    public let createTime: Date?
    /// <p>The unique ID for an invalidation request.</p>
    public let id: String?
    /// <p>The status of an invalidation request.</p>
    public let status: String?

    public init (
        createTime: Date? = nil,
        id: String? = nil,
        status: String? = nil
    )
    {
        self.createTime = createTime
        self.id = id
        self.status = status
    }
}

public enum ItemSelection {
    case all
    case `none`
    case whitelist
    case sdkUnknown(String)
}

extension ItemSelection : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ItemSelection] {
        return [
            .all,
            .none,
            .whitelist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "all"
        case .none: return "none"
        case .whitelist: return "whitelist"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ItemSelection(rawValue: rawValue) ?? ItemSelection.sdkUnknown(rawValue)
    }
}

extension KGKeyPairIds: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyGroupId = "KeyGroupId"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let keyGroupId = keyGroupId {
            try container.encode(keyGroupId, forKey: Key("keyGroupId"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: Key("keyPairIds"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyGroupId)
        keyGroupId = keyGroupIdDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension KGKeyPairIds: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KGKeyPairIds(keyGroupId: \(String(describing: keyGroupId)), keyPairIds: \(String(describing: keyPairIds)))"}
}

extension KGKeyPairIds: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of identifiers for the public keys that CloudFront can use to verify the
/// 			signatures of signed URLs and signed cookies.</p>
public struct KGKeyPairIds: Equatable {
    /// <p>The identifier of the key group that contains the public keys.</p>
    public let keyGroupId: String?
    /// <p>A list of CloudFront key pair identifiers.</p>
    public let keyPairIds: KeyPairIds?

    public init (
        keyGroupId: String? = nil,
        keyPairIds: KeyPairIds? = nil
    )
    {
        self.keyGroupId = keyGroupId
        self.keyPairIds = keyPairIds
    }
}

extension KeyGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case keyGroupConfig = "KeyGroupConfig"
        case lastModifiedTime = "LastModifiedTime"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: Key("keyGroupConfig"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension KeyGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyGroup(id: \(String(describing: id)), keyGroupConfig: \(String(describing: keyGroupConfig)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension KeyGroup: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A key group.</p>
/// 		       <p>A key group contains a list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
public struct KeyGroup: Equatable {
    /// <p>The identifier for the key group.</p>
    public let id: String?
    /// <p>The key group configuration.</p>
    public let keyGroupConfig: KeyGroupConfig?
    /// <p>The date and time when the key group was last modified.</p>
    public let lastModifiedTime: Date?

    public init (
        id: String? = nil,
        keyGroupConfig: KeyGroupConfig? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.id = id
        self.keyGroupConfig = keyGroupConfig
        self.lastModifiedTime = lastModifiedTime
    }
}

extension KeyGroupAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyGroupAlreadyExists(message: \(String(describing: message)))"}
}

extension KeyGroupAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<KeyGroupAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A key group with this name already exists. You must provide a unique name. To modify an
/// 			existing key group, use <code>UpdateKeyGroup</code>.</p>
public struct KeyGroupAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KeyGroupAlreadyExistsBody: Equatable {
    public let message: String?
}

extension KeyGroupAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyGroupConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case items = "Items"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("PublicKey"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKey{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKey>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension KeyGroupConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyGroupConfig(comment: \(String(describing: comment)), items: \(String(describing: items)), name: \(String(describing: name)))"}
}

extension KeyGroupConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A key group configuration.</p>
/// 		       <p>A key group contains a list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
public struct KeyGroupConfig: Equatable {
    /// <p>A comment to describe the key group. The comment cannot be longer than 128
    /// 			characters.</p>
    public let comment: String?
    /// <p>A list of the identifiers of the public keys in the key group.</p>
    public let items: [String]?
    /// <p>A name to identify the key group.</p>
    public let name: String?

    public init (
        comment: String? = nil,
        items: [String]? = nil,
        name: String? = nil
    )
    {
        self.comment = comment
        self.items = items
        self.name = name
    }
}

extension KeyGroupList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for keygroupsummary0 in items {
                try itemsContainer.encode(keygroupsummary0, forKey: Key("KeyGroupSummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroupSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroupSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([KeyGroupSummary].self, forKey: .member)
                var itemsBuffer:[KeyGroupSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [KeyGroupSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension KeyGroupList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyGroupList(items: \(String(describing: items)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension KeyGroupList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of key groups.</p>
public struct KeyGroupList: Equatable {
    /// <p>A list of key groups.</p>
    public let items: [KeyGroupSummary]?
    /// <p>The maximum number of key groups requested.</p>
    public let maxItems: Int?
    /// <p>If there are more items in the list than are in this response, this element is present. It
    /// 			contains the value that you should use in the <code>Marker</code> field of a subsequent
    /// 			request to continue listing key groups.</p>
    public let nextMarker: String?
    /// <p>The number of key groups returned in the response.</p>
    public let quantity: Int?

    public init (
        items: [KeyGroupSummary]? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension KeyGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyGroup = "KeyGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let keyGroup = keyGroup {
            try container.encode(keyGroup, forKey: Key("keyGroup"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

extension KeyGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyGroupSummary(keyGroup: \(String(describing: keyGroup)))"}
}

extension KeyGroupSummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains information about a key group.</p>
public struct KeyGroupSummary: Equatable {
    /// <p>A key group.</p>
    public let keyGroup: KeyGroup?

    public init (
        keyGroup: KeyGroup? = nil
    )
    {
        self.keyGroup = keyGroup
    }
}

extension KeyPairIds: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("KeyPairId"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyPairId{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyPairId>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension KeyPairIds: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyPairIds(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension KeyPairIds: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of CloudFront key pair identifiers.</p>
public struct KeyPairIds: Equatable {
    /// <p>A list of CloudFront key pair identifiers.</p>
    public let items: [String]?
    /// <p>The number of key pair identifiers in the list.</p>
    public let quantity: Int?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension KinesisStreamConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleARN = "RoleARN"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let roleARN = roleARN {
            try container.encode(roleARN, forKey: Key("roleARN"))
        }
        if let streamARN = streamARN {
            try container.encode(streamARN, forKey: Key("streamARN"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension KinesisStreamConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisStreamConfig(roleARN: \(String(describing: roleARN)), streamARN: \(String(describing: streamARN)))"}
}

extension KinesisStreamConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains information about the Amazon Kinesis data stream where you are sending
/// 			real-time log data.</p>
public struct KinesisStreamConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that
    /// 			CloudFront can use to send real-time log data to your Kinesis data stream.</p>
    /// 		       <p>For more information the IAM role, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-iam-role">Real-time log configuration IAM role</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let roleARN: String?
    /// <p>The Amazon Resource Name (ARN) of the Kinesis data stream where you are sending real-time
    /// 			log data.</p>
    public let streamARN: String?

    public init (
        roleARN: String? = nil,
        streamARN: String? = nil
    )
    {
        self.roleARN = roleARN
        self.streamARN = streamARN
    }
}

extension LambdaFunctionAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventType = "EventType"
        case includeBody = "IncludeBody"
        case lambdaFunctionARN = "LambdaFunctionARN"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let eventType = eventType {
            try container.encode(eventType, forKey: Key("eventType"))
        }
        if let includeBody = includeBody {
            try container.encode(includeBody, forKey: Key("includeBody"))
        }
        if let lambdaFunctionARN = lambdaFunctionARN {
            try container.encode(lambdaFunctionARN, forKey: Key("lambdaFunctionARN"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaFunctionARN)
        lambdaFunctionARN = lambdaFunctionARNDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let includeBodyDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeBody)
        includeBody = includeBodyDecoded
    }
}

extension LambdaFunctionAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionAssociation(eventType: \(String(describing: eventType)), includeBody: \(String(describing: includeBody)), lambdaFunctionARN: \(String(describing: lambdaFunctionARN)))"}
}

extension LambdaFunctionAssociation: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains a Lambda function association.</p>
public struct LambdaFunctionAssociation: Equatable {
    /// <p>Specifies the event type that triggers a Lambda function invocation. You can specify the following values:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>viewer-request</code>: The function executes when CloudFront receives a request from a viewer
    /// 				and before it checks to see whether the requested object is in the edge cache. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>origin-request</code>: The function executes only when CloudFront sends a request to your
    /// 					origin. When the requested object is in the edge cache, the function doesn't
    /// 					execute.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>origin-response</code>: The function executes after CloudFront receives a response from the origin and
    /// 				before it caches the object in the response. When the requested object is in the edge cache, the function doesn't execute.</p>
    /// 			         </li>
    ///             <li>
    ///                <p>
    ///                   <code>viewer-response</code>: The function executes before CloudFront returns the requested object to the viewer.
    /// 				The function executes regardless of whether the object was already in the edge cache.</p>
    /// 				           <p>If the origin returns an HTTP status code other than HTTP 200 (OK), the function doesn't execute.</p>
    /// 			         </li>
    ///          </ul>
    public let eventType: EventType?
    /// <p>A flag that allows a Lambda function to have read access to the body content. For more information,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-include-body-access.html">Accessing the Request Body by Choosing the
    /// 				Include Body Option</a> in the Amazon CloudFront Developer Guide.</p>
    public let includeBody: Bool?
    /// <p>The ARN of the Lambda function. You must specify the ARN of a function version; you can't specify a Lambda alias
    /// 			or $LATEST.</p>
    public let lambdaFunctionARN: String?

    public init (
        eventType: EventType? = nil,
        includeBody: Bool? = nil,
        lambdaFunctionARN: String? = nil
    )
    {
        self.eventType = eventType
        self.includeBody = includeBody
        self.lambdaFunctionARN = lambdaFunctionARN
    }
}

extension LambdaFunctionAssociations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for lambdafunctionassociation0 in items {
                try itemsContainer.encode(lambdafunctionassociation0, forKey: Key("LambdaFunctionAssociation"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct LambdaFunctionAssociation{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.LambdaFunctionAssociation>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([LambdaFunctionAssociation].self, forKey: .member)
                var itemsBuffer:[LambdaFunctionAssociation]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [LambdaFunctionAssociation]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension LambdaFunctionAssociations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaFunctionAssociations(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension LambdaFunctionAssociations: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that specifies a list of Lambda functions associations for a cache
/// 			behavior.</p>
///
/// 		       <p>If you want to invoke one or more Lambda functions triggered by requests that match the
/// 				<code>PathPattern</code> of the cache behavior, specify the applicable values for
/// 				<code>Quantity</code> and <code>Items</code>. Note that there can be up to 4
/// 				<code>LambdaFunctionAssociation</code> items in this list (one for each possible value of
/// 				<code>EventType</code>) and each <code>EventType</code> can be associated with the Lambda
/// 			function only once.</p>
///
/// 		       <p>If you don't want to invoke any Lambda functions for the requests that match
/// 				<code>PathPattern</code>, specify <code>0</code> for <code>Quantity</code> and omit
/// 				<code>Items</code>. </p>
public struct LambdaFunctionAssociations: Equatable {
    /// <p>
    ///             <b>Optional</b>: A complex type that contains <code>LambdaFunctionAssociation</code> items
    /// 			for this cache behavior. If <code>Quantity</code> is <code>0</code>, you can omit <code>Items</code>.</p>
    public let items: [LambdaFunctionAssociation]?
    /// <p>The number of Lambda function associations for this cache behavior.</p>
    public let quantity: Int?

    public init (
        items: [LambdaFunctionAssociation]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension ListCachePoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCachePoliciesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), type: \(String(describing: type)))"}
}

extension ListCachePoliciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCachePoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCachePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCachePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCachePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCachePoliciesInput>
    public typealias MOutput = OperationOutput<ListCachePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCachePoliciesOutputError>
}

public struct ListCachePoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCachePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCachePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCachePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "Type".urlPercentEncoding(), value: String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCachePoliciesInput>
    public typealias MOutput = OperationOutput<ListCachePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCachePoliciesOutputError>
}

public struct ListCachePoliciesInput: Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			cache policies. The response includes cache policies in the list that occur after the
    /// 			marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of cache policies that you want in the response.</p>
    public let maxItems: Int?
    /// <p>A filter to return only the specified kinds of cache policies. Valid values
    /// 			are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>managed</code> – Returns only the managed policies created by AWS.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>custom</code> – Returns only the custom policies created in your AWS
    /// 					account.</p>
    /// 			         </li>
    ///          </ul>
    public let type: CachePolicyType?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        type: CachePolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListCachePoliciesInputBody: Equatable {
}

extension ListCachePoliciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCachePoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCachePoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCachePoliciesOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCachePoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCachePoliciesOutputResponse(cachePolicyList: \(String(describing: cachePolicyList)))"}
}

extension ListCachePoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CachePolicyList = try responseDecoder.decode(responseBody: unwrappedData)
                self.cachePolicyList = output
            } else {
                self.cachePolicyList = nil
            }
        } else {
            self.cachePolicyList = nil
        }
    }
}

public struct ListCachePoliciesOutputResponse: Equatable {
    /// <p>A list of cache policies.</p>
    public let cachePolicyList: CachePolicyList?

    public init (
        cachePolicyList: CachePolicyList? = nil
    )
    {
        self.cachePolicyList = cachePolicyList
    }
}

struct ListCachePoliciesOutputResponseBody: Equatable {
    public let cachePolicyList: CachePolicyList?
}

extension ListCachePoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachePolicyList = "CachePolicyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyListDecoded = try containerValues.decodeIfPresent(CachePolicyList.self, forKey: .cachePolicyList)
        cachePolicyList = cachePolicyListDecoded
    }
}

extension ListCloudFrontOriginAccessIdentitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCloudFrontOriginAccessIdentitiesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListCloudFrontOriginAccessIdentitiesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCloudFrontOriginAccessIdentitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCloudFrontOriginAccessIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>
    public typealias MOutput = OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCloudFrontOriginAccessIdentitiesOutputError>
}

public struct ListCloudFrontOriginAccessIdentitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCloudFrontOriginAccessIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCloudFrontOriginAccessIdentitiesInput>
    public typealias MOutput = OperationOutput<ListCloudFrontOriginAccessIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCloudFrontOriginAccessIdentitiesOutputError>
}

/// <p>The request to list origin access identities. </p>
public struct ListCloudFrontOriginAccessIdentitiesInput: Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of origin
    /// 			access identities. The results include identities in the list that occur after the marker. To
    /// 			get the next page of results, set the <code>Marker</code> to the value of the
    /// 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
    /// 			identity on that page).</p>
    public let marker: String?
    /// <p>The maximum number of origin access identities you want in the response body.
    /// 		</p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCloudFrontOriginAccessIdentitiesInputBody: Equatable {
}

extension ListCloudFrontOriginAccessIdentitiesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListCloudFrontOriginAccessIdentitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCloudFrontOriginAccessIdentitiesOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCloudFrontOriginAccessIdentitiesOutputResponse(cloudFrontOriginAccessIdentityList: \(String(describing: cloudFrontOriginAccessIdentityList)))"}
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CloudFrontOriginAccessIdentityList = try responseDecoder.decode(responseBody: unwrappedData)
                self.cloudFrontOriginAccessIdentityList = output
            } else {
                self.cloudFrontOriginAccessIdentityList = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentityList = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct ListCloudFrontOriginAccessIdentitiesOutputResponse: Equatable {
    /// <p>The <code>CloudFrontOriginAccessIdentityList</code> type. </p>
    public let cloudFrontOriginAccessIdentityList: CloudFrontOriginAccessIdentityList?

    public init (
        cloudFrontOriginAccessIdentityList: CloudFrontOriginAccessIdentityList? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityList
    }
}

struct ListCloudFrontOriginAccessIdentitiesOutputResponseBody: Equatable {
    public let cloudFrontOriginAccessIdentityList: CloudFrontOriginAccessIdentityList?
}

extension ListCloudFrontOriginAccessIdentitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentityList = "CloudFrontOriginAccessIdentityList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityListDecoded = try containerValues.decodeIfPresent(CloudFrontOriginAccessIdentityList.self, forKey: .cloudFrontOriginAccessIdentityList)
        cloudFrontOriginAccessIdentityList = cloudFrontOriginAccessIdentityListDecoded
    }
}

extension ListDistributionsByCachePolicyIdInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByCachePolicyIdInput(cachePolicyId: \(String(describing: cachePolicyId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListDistributionsByCachePolicyIdInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDistributionsByCachePolicyIdInputHeadersMiddleware: Middleware {
    public let id: String = "ListDistributionsByCachePolicyIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByCachePolicyIdInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByCachePolicyIdInput>
    public typealias MOutput = OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByCachePolicyIdOutputError>
}

public struct ListDistributionsByCachePolicyIdInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDistributionsByCachePolicyIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByCachePolicyIdInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByCachePolicyIdInput>
    public typealias MOutput = OperationOutput<ListDistributionsByCachePolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByCachePolicyIdOutputError>
}

public struct ListDistributionsByCachePolicyIdInput: Equatable {
    /// <p>The ID of the cache policy whose associated distribution IDs you want to list.</p>
    public let cachePolicyId: String?
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			distribution IDs. The response includes distribution IDs in the list that occur after
    /// 			the marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of distribution IDs that you want in the response.</p>
    public let maxItems: Int?

    public init (
        cachePolicyId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.cachePolicyId = cachePolicyId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByCachePolicyIdInputBody: Equatable {
}

extension ListDistributionsByCachePolicyIdInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDistributionsByCachePolicyIdOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByCachePolicyIdOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByCachePolicyIdOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByCachePolicyIdOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByCachePolicyIdOutputResponse(distributionIdList: \(String(describing: distributionIdList)))"}
}

extension ListDistributionsByCachePolicyIdOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: DistributionIdList = try responseDecoder.decode(responseBody: unwrappedData)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByCachePolicyIdOutputResponse: Equatable {
    /// <p>A list of distribution IDs.</p>
    public let distributionIdList: DistributionIdList?

    public init (
        distributionIdList: DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByCachePolicyIdOutputResponseBody: Equatable {
    public let distributionIdList: DistributionIdList?
}

extension ListDistributionsByCachePolicyIdOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByKeyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByKeyGroupInput(keyGroupId: \(String(describing: keyGroupId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListDistributionsByKeyGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDistributionsByKeyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ListDistributionsByKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByKeyGroupInput>
    public typealias MOutput = OperationOutput<ListDistributionsByKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByKeyGroupOutputError>
}

public struct ListDistributionsByKeyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDistributionsByKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByKeyGroupInput>
    public typealias MOutput = OperationOutput<ListDistributionsByKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByKeyGroupOutputError>
}

public struct ListDistributionsByKeyGroupInput: Equatable {
    /// <p>The ID of the key group whose associated distribution IDs you are listing.</p>
    public let keyGroupId: String?
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			distribution IDs. The response includes distribution IDs in the list that occur after
    /// 			the marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of distribution IDs that you want in the response.</p>
    public let maxItems: Int?

    public init (
        keyGroupId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.keyGroupId = keyGroupId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsByKeyGroupInputBody: Equatable {
}

extension ListDistributionsByKeyGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDistributionsByKeyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByKeyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByKeyGroupOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByKeyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByKeyGroupOutputResponse(distributionIdList: \(String(describing: distributionIdList)))"}
}

extension ListDistributionsByKeyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: DistributionIdList = try responseDecoder.decode(responseBody: unwrappedData)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByKeyGroupOutputResponse: Equatable {
    /// <p>A list of distribution IDs.</p>
    public let distributionIdList: DistributionIdList?

    public init (
        distributionIdList: DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByKeyGroupOutputResponseBody: Equatable {
    public let distributionIdList: DistributionIdList?
}

extension ListDistributionsByKeyGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

extension ListDistributionsByOriginRequestPolicyIdInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByOriginRequestPolicyIdInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), originRequestPolicyId: \(String(describing: originRequestPolicyId)))"}
}

extension ListDistributionsByOriginRequestPolicyIdInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDistributionsByOriginRequestPolicyIdInputHeadersMiddleware: Middleware {
    public let id: String = "ListDistributionsByOriginRequestPolicyIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>
    public typealias MOutput = OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByOriginRequestPolicyIdOutputError>
}

public struct ListDistributionsByOriginRequestPolicyIdInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDistributionsByOriginRequestPolicyIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByOriginRequestPolicyIdInput>
    public typealias MOutput = OperationOutput<ListDistributionsByOriginRequestPolicyIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByOriginRequestPolicyIdOutputError>
}

public struct ListDistributionsByOriginRequestPolicyIdInput: Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			distribution IDs. The response includes distribution IDs in the list that occur after
    /// 			the marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of distribution IDs that you want in the response.</p>
    public let maxItems: Int?
    /// <p>The ID of the origin request policy whose associated distribution IDs you want to
    /// 			list.</p>
    public let originRequestPolicyId: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        originRequestPolicyId: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.originRequestPolicyId = originRequestPolicyId
    }
}

struct ListDistributionsByOriginRequestPolicyIdInputBody: Equatable {
}

extension ListDistributionsByOriginRequestPolicyIdInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByOriginRequestPolicyIdOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByOriginRequestPolicyIdOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByOriginRequestPolicyIdOutputResponse(distributionIdList: \(String(describing: distributionIdList)))"}
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: DistributionIdList = try responseDecoder.decode(responseBody: unwrappedData)
                self.distributionIdList = output
            } else {
                self.distributionIdList = nil
            }
        } else {
            self.distributionIdList = nil
        }
    }
}

public struct ListDistributionsByOriginRequestPolicyIdOutputResponse: Equatable {
    /// <p>A list of distribution IDs.</p>
    public let distributionIdList: DistributionIdList?

    public init (
        distributionIdList: DistributionIdList? = nil
    )
    {
        self.distributionIdList = distributionIdList
    }
}

struct ListDistributionsByOriginRequestPolicyIdOutputResponseBody: Equatable {
    public let distributionIdList: DistributionIdList?
}

extension ListDistributionsByOriginRequestPolicyIdOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionIdList = "DistributionIdList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionIdListDecoded = try containerValues.decodeIfPresent(DistributionIdList.self, forKey: .distributionIdList)
        distributionIdList = distributionIdListDecoded
    }
}

public struct ListDistributionsByRealtimeLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "ListDistributionsByRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

extension ListDistributionsByRealtimeLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByRealtimeLogConfigInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), realtimeLogConfigArn: \(String(describing: realtimeLogConfigArn)), realtimeLogConfigName: \(String(describing: realtimeLogConfigName)))"}
}

extension ListDistributionsByRealtimeLogConfigInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension ListDistributionsByRealtimeLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let realtimeLogConfigArn = realtimeLogConfigArn {
            try container.encode(realtimeLogConfigArn, forKey: Key("realtimeLogConfigArn"))
        }
        if let realtimeLogConfigName = realtimeLogConfigName {
            try container.encode(realtimeLogConfigName, forKey: Key("realtimeLogConfigName"))
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "ListDistributionsByRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

public struct ListDistributionsByRealtimeLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDistributionsByRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<ListDistributionsByRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByRealtimeLogConfigOutputError>
}

public struct ListDistributionsByRealtimeLogConfigInput: Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			distributions. The response includes distributions in the list that occur after the
    /// 			marker. To get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of distributions that you want in the response.</p>
    public let maxItems: Int?
    /// <p>The Amazon Resource Name (ARN) of the real-time log configuration whose associated
    /// 			distributions you want to list.</p>
    public let realtimeLogConfigArn: String?
    /// <p>The name of the real-time log configuration whose associated distributions you want to
    /// 			list.</p>
    public let realtimeLogConfigName: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        realtimeLogConfigArn: String? = nil,
        realtimeLogConfigName: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.realtimeLogConfigArn = realtimeLogConfigArn
        self.realtimeLogConfigName = realtimeLogConfigName
    }
}

struct ListDistributionsByRealtimeLogConfigInputBody: Equatable {
    public let marker: String?
    public let maxItems: Int?
    public let realtimeLogConfigName: String?
    public let realtimeLogConfigArn: String?
}

extension ListDistributionsByRealtimeLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case marker = "Marker"
        case maxItems = "MaxItems"
        case realtimeLogConfigArn = "RealtimeLogConfigArn"
        case realtimeLogConfigName = "RealtimeLogConfigName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let realtimeLogConfigNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .realtimeLogConfigName)
        realtimeLogConfigName = realtimeLogConfigNameDecoded
        let realtimeLogConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .realtimeLogConfigArn)
        realtimeLogConfigArn = realtimeLogConfigArnDecoded
    }
}

extension ListDistributionsByRealtimeLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByRealtimeLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByRealtimeLogConfigOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByRealtimeLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByRealtimeLogConfigOutputResponse(distributionList: \(String(describing: distributionList)))"}
}

extension ListDistributionsByRealtimeLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: DistributionList = try responseDecoder.decode(responseBody: unwrappedData)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

public struct ListDistributionsByRealtimeLogConfigOutputResponse: Equatable {
    /// <p>A distribution list.</p>
    public let distributionList: DistributionList?

    public init (
        distributionList: DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByRealtimeLogConfigOutputResponseBody: Equatable {
    public let distributionList: DistributionList?
}

extension ListDistributionsByRealtimeLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListDistributionsByWebACLIdInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByWebACLIdInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), webACLId: \(String(describing: webACLId)))"}
}

extension ListDistributionsByWebACLIdInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDistributionsByWebACLIdInputHeadersMiddleware: Middleware {
    public let id: String = "ListDistributionsByWebACLIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByWebACLIdInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByWebACLIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByWebACLIdInput>
    public typealias MOutput = OperationOutput<ListDistributionsByWebACLIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByWebACLIdOutputError>
}

public struct ListDistributionsByWebACLIdInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDistributionsByWebACLIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsByWebACLIdInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsByWebACLIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsByWebACLIdInput>
    public typealias MOutput = OperationOutput<ListDistributionsByWebACLIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsByWebACLIdOutputError>
}

/// <p>The request to list distributions that are associated with a specified AWS WAF web
/// 			ACL. </p>
public struct ListDistributionsByWebACLIdInput: Equatable {
    /// <p>Use <code>Marker</code> and <code>MaxItems</code> to control pagination of results. If
    /// 			you have more than <code>MaxItems</code> distributions that satisfy the request, the response
    /// 			includes a <code>NextMarker</code> element. To get the next page of results, submit another
    /// 			request. For the value of <code>Marker</code>, specify the value of <code>NextMarker</code>
    /// 			from the last response. (For the first request, omit <code>Marker</code>.) </p>
    public let marker: String?
    /// <p>The maximum number of distributions that you want CloudFront to return in the response body.
    /// 			The maximum and default values are both 100.</p>
    public let maxItems: Int?
    /// <p>The ID of the AWS WAF web ACL that you want to list the associated distributions.
    /// 			If you specify "null" for the ID, the request returns a list of the distributions that aren't
    /// 			associated with a web ACL. </p>
    public let webACLId: String?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        webACLId: String? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.webACLId = webACLId
    }
}

struct ListDistributionsByWebACLIdInputBody: Equatable {
}

extension ListDistributionsByWebACLIdInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDistributionsByWebACLIdOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsByWebACLIdOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsByWebACLIdOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case invalidWebACLId(InvalidWebACLId)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsByWebACLIdOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsByWebACLIdOutputResponse(distributionList: \(String(describing: distributionList)))"}
}

extension ListDistributionsByWebACLIdOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: DistributionList = try responseDecoder.decode(responseBody: unwrappedData)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

/// <p>The response to a request to list the distributions that are associated with a
/// 			specified AWS WAF web ACL. </p>
public struct ListDistributionsByWebACLIdOutputResponse: Equatable {
    /// <p>The <code>DistributionList</code> type. </p>
    public let distributionList: DistributionList?

    public init (
        distributionList: DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsByWebACLIdOutputResponseBody: Equatable {
    public let distributionList: DistributionList?
}

extension ListDistributionsByWebACLIdOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListDistributionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListDistributionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDistributionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDistributionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsInput>
    public typealias MOutput = OperationOutput<ListDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsOutputError>
}

public struct ListDistributionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDistributionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDistributionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDistributionsInput>
    public typealias MOutput = OperationOutput<ListDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDistributionsOutputError>
}

/// <p>The request to list your distributions. </p>
public struct ListDistributionsInput: Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of
    /// 			distributions. The results include distributions in the list that occur after the marker. To
    /// 			get the next page of results, set the <code>Marker</code> to the value of the
    /// 				<code>NextMarker</code> from the current page's response (which is also the ID of the last
    /// 			distribution on that page).</p>
    public let marker: String?
    /// <p>The maximum number of distributions you want in the response body.</p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListDistributionsInputBody: Equatable {
}

extension ListDistributionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDistributionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListDistributionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionsOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDistributionsOutputResponse(distributionList: \(String(describing: distributionList)))"}
}

extension ListDistributionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: DistributionList = try responseDecoder.decode(responseBody: unwrappedData)
                self.distributionList = output
            } else {
                self.distributionList = nil
            }
        } else {
            self.distributionList = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct ListDistributionsOutputResponse: Equatable {
    /// <p>The <code>DistributionList</code> type. </p>
    public let distributionList: DistributionList?

    public init (
        distributionList: DistributionList? = nil
    )
    {
        self.distributionList = distributionList
    }
}

struct ListDistributionsOutputResponseBody: Equatable {
    public let distributionList: DistributionList?
}

extension ListDistributionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionList = "DistributionList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionListDecoded = try containerValues.decodeIfPresent(DistributionList.self, forKey: .distributionList)
        distributionList = distributionListDecoded
    }
}

extension ListFieldLevelEncryptionConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFieldLevelEncryptionConfigsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListFieldLevelEncryptionConfigsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFieldLevelEncryptionConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFieldLevelEncryptionConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFieldLevelEncryptionConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFieldLevelEncryptionConfigsInput>
    public typealias MOutput = OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFieldLevelEncryptionConfigsOutputError>
}

public struct ListFieldLevelEncryptionConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFieldLevelEncryptionConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFieldLevelEncryptionConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFieldLevelEncryptionConfigsInput>
    public typealias MOutput = OperationOutput<ListFieldLevelEncryptionConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFieldLevelEncryptionConfigsOutputError>
}

public struct ListFieldLevelEncryptionConfigsInput: Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of configurations. The results include configurations in the list that
    /// 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
    /// 			<code>NextMarker</code> from the current page's response (which is also the ID of the last configuration on that page). </p>
    public let marker: String?
    /// <p>The maximum number of field-level encryption configurations you want in the response body. </p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionConfigsInputBody: Equatable {
}

extension ListFieldLevelEncryptionConfigsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFieldLevelEncryptionConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFieldLevelEncryptionConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFieldLevelEncryptionConfigsOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldLevelEncryptionConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFieldLevelEncryptionConfigsOutputResponse(fieldLevelEncryptionList: \(String(describing: fieldLevelEncryptionList)))"}
}

extension ListFieldLevelEncryptionConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryptionList = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryptionList = output
            } else {
                self.fieldLevelEncryptionList = nil
            }
        } else {
            self.fieldLevelEncryptionList = nil
        }
    }
}

public struct ListFieldLevelEncryptionConfigsOutputResponse: Equatable {
    /// <p>Returns a list of all field-level encryption configurations that have been created in CloudFront for this account.</p>
    public let fieldLevelEncryptionList: FieldLevelEncryptionList?

    public init (
        fieldLevelEncryptionList: FieldLevelEncryptionList? = nil
    )
    {
        self.fieldLevelEncryptionList = fieldLevelEncryptionList
    }
}

struct ListFieldLevelEncryptionConfigsOutputResponseBody: Equatable {
    public let fieldLevelEncryptionList: FieldLevelEncryptionList?
}

extension ListFieldLevelEncryptionConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionList = "FieldLevelEncryptionList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionListDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionList.self, forKey: .fieldLevelEncryptionList)
        fieldLevelEncryptionList = fieldLevelEncryptionListDecoded
    }
}

extension ListFieldLevelEncryptionProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFieldLevelEncryptionProfilesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListFieldLevelEncryptionProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFieldLevelEncryptionProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListFieldLevelEncryptionProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFieldLevelEncryptionProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFieldLevelEncryptionProfilesInput>
    public typealias MOutput = OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFieldLevelEncryptionProfilesOutputError>
}

public struct ListFieldLevelEncryptionProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFieldLevelEncryptionProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFieldLevelEncryptionProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFieldLevelEncryptionProfilesInput>
    public typealias MOutput = OperationOutput<ListFieldLevelEncryptionProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFieldLevelEncryptionProfilesOutputError>
}

public struct ListFieldLevelEncryptionProfilesInput: Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of profiles. The results include profiles in the list that
    /// 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
    /// 			<code>NextMarker</code> from the current page's response (which is also the ID of the last profile on that page). </p>
    public let marker: String?
    /// <p>The maximum number of field-level encryption profiles you want in the response body. </p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFieldLevelEncryptionProfilesInputBody: Equatable {
}

extension ListFieldLevelEncryptionProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFieldLevelEncryptionProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFieldLevelEncryptionProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFieldLevelEncryptionProfilesOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFieldLevelEncryptionProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFieldLevelEncryptionProfilesOutputResponse(fieldLevelEncryptionProfileList: \(String(describing: fieldLevelEncryptionProfileList)))"}
}

extension ListFieldLevelEncryptionProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryptionProfileList = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryptionProfileList = output
            } else {
                self.fieldLevelEncryptionProfileList = nil
            }
        } else {
            self.fieldLevelEncryptionProfileList = nil
        }
    }
}

public struct ListFieldLevelEncryptionProfilesOutputResponse: Equatable {
    /// <p>Returns a list of the field-level encryption profiles that have been created in CloudFront for this account.</p>
    public let fieldLevelEncryptionProfileList: FieldLevelEncryptionProfileList?

    public init (
        fieldLevelEncryptionProfileList: FieldLevelEncryptionProfileList? = nil
    )
    {
        self.fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileList
    }
}

struct ListFieldLevelEncryptionProfilesOutputResponseBody: Equatable {
    public let fieldLevelEncryptionProfileList: FieldLevelEncryptionProfileList?
}

extension ListFieldLevelEncryptionProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfileList = "FieldLevelEncryptionProfileList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileListDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionProfileList.self, forKey: .fieldLevelEncryptionProfileList)
        fieldLevelEncryptionProfileList = fieldLevelEncryptionProfileListDecoded
    }
}

extension ListFunctionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), stage: \(String(describing: stage)))"}
}

extension ListFunctionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFunctionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let stage = input.operationInput.stage {
            let stageQueryItem = URLQueryItem(name: "Stage".urlPercentEncoding(), value: String(stage.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(stageQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInput: Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			functions. The response includes functions in the list that occur after the marker. To
    /// 			get the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of functions that you want in the response.</p>
    public let maxItems: Int?
    /// <p>An optional filter to return only the functions that are in the specified stage,
    /// 			either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
    public let stage: FunctionStage?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        stage: FunctionStage? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.stage = stage
    }
}

struct ListFunctionsInputBody: Equatable {
}

extension ListFunctionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFunctionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionsOutputResponse(functionList: \(String(describing: functionList)))"}
}

extension ListFunctionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FunctionList = try responseDecoder.decode(responseBody: unwrappedData)
                self.functionList = output
            } else {
                self.functionList = nil
            }
        } else {
            self.functionList = nil
        }
    }
}

public struct ListFunctionsOutputResponse: Equatable {
    /// <p>A list of CloudFront functions.</p>
    public let functionList: FunctionList?

    public init (
        functionList: FunctionList? = nil
    )
    {
        self.functionList = functionList
    }
}

struct ListFunctionsOutputResponseBody: Equatable {
    public let functionList: FunctionList?
}

extension ListFunctionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionList = "FunctionList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionListDecoded = try containerValues.decodeIfPresent(FunctionList.self, forKey: .functionList)
        functionList = functionListDecoded
    }
}

extension ListInvalidationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvalidationsInput(distributionId: \(String(describing: distributionId)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListInvalidationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInvalidationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInvalidationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvalidationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvalidationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvalidationsInput>
    public typealias MOutput = OperationOutput<ListInvalidationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvalidationsOutputError>
}

public struct ListInvalidationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInvalidationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvalidationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvalidationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvalidationsInput>
    public typealias MOutput = OperationOutput<ListInvalidationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvalidationsOutputError>
}

/// <p>The request to list invalidations. </p>
public struct ListInvalidationsInput: Equatable {
    /// <p>The distribution's ID.</p>
    public let distributionId: String?
    /// <p>Use this parameter when paginating results to indicate where to begin in your list of
    /// 			invalidation batches. Because the results are returned in decreasing order from most recent to
    /// 			oldest, the most recent results are on the first page, the second page will contain earlier
    /// 			results, and so on. To get the next page of results, set <code>Marker</code> to the value of
    /// 			the <code>NextMarker</code> from the current page's response. This value is the same as the ID
    /// 			of the last invalidation batch on that page. </p>
    public let marker: String?
    /// <p>The maximum number of invalidation batches that you want in the response
    /// 			body.</p>
    public let maxItems: Int?

    public init (
        distributionId: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.distributionId = distributionId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListInvalidationsInputBody: Equatable {
}

extension ListInvalidationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInvalidationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListInvalidationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvalidationsOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchDistribution(NoSuchDistribution)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvalidationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvalidationsOutputResponse(invalidationList: \(String(describing: invalidationList)))"}
}

extension ListInvalidationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: InvalidationList = try responseDecoder.decode(responseBody: unwrappedData)
                self.invalidationList = output
            } else {
                self.invalidationList = nil
            }
        } else {
            self.invalidationList = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct ListInvalidationsOutputResponse: Equatable {
    /// <p>Information about invalidation batches. </p>
    public let invalidationList: InvalidationList?

    public init (
        invalidationList: InvalidationList? = nil
    )
    {
        self.invalidationList = invalidationList
    }
}

struct ListInvalidationsOutputResponseBody: Equatable {
    public let invalidationList: InvalidationList?
}

extension ListInvalidationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invalidationList = "InvalidationList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidationListDecoded = try containerValues.decodeIfPresent(InvalidationList.self, forKey: .invalidationList)
        invalidationList = invalidationListDecoded
    }
}

extension ListKeyGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeyGroupsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListKeyGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListKeyGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListKeyGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeyGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeyGroupsInput>
    public typealias MOutput = OperationOutput<ListKeyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeyGroupsOutputError>
}

public struct ListKeyGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListKeyGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeyGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeyGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeyGroupsInput>
    public typealias MOutput = OperationOutput<ListKeyGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeyGroupsOutputError>
}

public struct ListKeyGroupsInput: Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of key
    /// 			groups. The response includes key groups in the list that occur after the marker. To get
    /// 			the next page of the list, set this field’s value to the value of
    /// 			<code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of key groups that you want in the response.</p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListKeyGroupsInputBody: Equatable {
}

extension ListKeyGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListKeyGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListKeyGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKeyGroupsOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeyGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeyGroupsOutputResponse(keyGroupList: \(String(describing: keyGroupList)))"}
}

extension ListKeyGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: KeyGroupList = try responseDecoder.decode(responseBody: unwrappedData)
                self.keyGroupList = output
            } else {
                self.keyGroupList = nil
            }
        } else {
            self.keyGroupList = nil
        }
    }
}

public struct ListKeyGroupsOutputResponse: Equatable {
    /// <p>A list of key groups.</p>
    public let keyGroupList: KeyGroupList?

    public init (
        keyGroupList: KeyGroupList? = nil
    )
    {
        self.keyGroupList = keyGroupList
    }
}

struct ListKeyGroupsOutputResponseBody: Equatable {
    public let keyGroupList: KeyGroupList?
}

extension ListKeyGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyGroupList = "KeyGroupList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupListDecoded = try containerValues.decodeIfPresent(KeyGroupList.self, forKey: .keyGroupList)
        keyGroupList = keyGroupListDecoded
    }
}

extension ListOriginRequestPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOriginRequestPoliciesInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), type: \(String(describing: type)))"}
}

extension ListOriginRequestPoliciesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListOriginRequestPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListOriginRequestPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOriginRequestPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOriginRequestPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOriginRequestPoliciesInput>
    public typealias MOutput = OperationOutput<ListOriginRequestPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOriginRequestPoliciesOutputError>
}

public struct ListOriginRequestPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOriginRequestPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOriginRequestPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOriginRequestPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "Type".urlPercentEncoding(), value: String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOriginRequestPoliciesInput>
    public typealias MOutput = OperationOutput<ListOriginRequestPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOriginRequestPoliciesOutputError>
}

public struct ListOriginRequestPoliciesInput: Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of
    /// 			origin request policies. The response includes origin request policies in the list that
    /// 			occur after the marker. To get the next page of the list, set this field’s value to the
    /// 			value of <code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of origin request policies that you want in the response.</p>
    public let maxItems: Int?
    /// <p>A filter to return only the specified kinds of origin request policies. Valid values
    /// 			are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>managed</code> – Returns only the managed policies created by AWS.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>custom</code> – Returns only the custom policies created in your AWS
    /// 					account.</p>
    /// 			         </li>
    ///          </ul>
    public let type: OriginRequestPolicyType?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil,
        type: OriginRequestPolicyType? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
        self.type = type
    }
}

struct ListOriginRequestPoliciesInputBody: Equatable {
}

extension ListOriginRequestPoliciesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListOriginRequestPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListOriginRequestPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOriginRequestPoliciesOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOriginRequestPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOriginRequestPoliciesOutputResponse(originRequestPolicyList: \(String(describing: originRequestPolicyList)))"}
}

extension ListOriginRequestPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: OriginRequestPolicyList = try responseDecoder.decode(responseBody: unwrappedData)
                self.originRequestPolicyList = output
            } else {
                self.originRequestPolicyList = nil
            }
        } else {
            self.originRequestPolicyList = nil
        }
    }
}

public struct ListOriginRequestPoliciesOutputResponse: Equatable {
    /// <p>A list of origin request policies.</p>
    public let originRequestPolicyList: OriginRequestPolicyList?

    public init (
        originRequestPolicyList: OriginRequestPolicyList? = nil
    )
    {
        self.originRequestPolicyList = originRequestPolicyList
    }
}

struct ListOriginRequestPoliciesOutputResponseBody: Equatable {
    public let originRequestPolicyList: OriginRequestPolicyList?
}

extension ListOriginRequestPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicyList = "OriginRequestPolicyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyListDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyList.self, forKey: .originRequestPolicyList)
        originRequestPolicyList = originRequestPolicyListDecoded
    }
}

extension ListPublicKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPublicKeysInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListPublicKeysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPublicKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ListPublicKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPublicKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInput: Equatable {
    /// <p>Use this when paginating results to indicate where to begin in your list of public keys. The results include public keys in the list that
    /// 			occur after the marker. To get the next page of results, set the <code>Marker</code> to the value of the
    /// 			<code>NextMarker</code> from the current page's response (which is also the ID of the last public key on that page). </p>
    public let marker: String?
    /// <p>The maximum number of public keys you want in the response body. </p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListPublicKeysInputBody: Equatable {
}

extension ListPublicKeysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPublicKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListPublicKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublicKeysOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublicKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPublicKeysOutputResponse(publicKeyList: \(String(describing: publicKeyList)))"}
}

extension ListPublicKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PublicKeyList = try responseDecoder.decode(responseBody: unwrappedData)
                self.publicKeyList = output
            } else {
                self.publicKeyList = nil
            }
        } else {
            self.publicKeyList = nil
        }
    }
}

public struct ListPublicKeysOutputResponse: Equatable {
    /// <p>Returns a list of all public keys that have been added to CloudFront for this account.</p>
    public let publicKeyList: PublicKeyList?

    public init (
        publicKeyList: PublicKeyList? = nil
    )
    {
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputResponseBody: Equatable {
    public let publicKeyList: PublicKeyList?
}

extension ListPublicKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicKeyList = "PublicKeyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListDecoded = try containerValues.decodeIfPresent(PublicKeyList.self, forKey: .publicKeyList)
        publicKeyList = publicKeyListDecoded
    }
}

extension ListRealtimeLogConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRealtimeLogConfigsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListRealtimeLogConfigsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRealtimeLogConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRealtimeLogConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRealtimeLogConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRealtimeLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRealtimeLogConfigsInput>
    public typealias MOutput = OperationOutput<ListRealtimeLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRealtimeLogConfigsOutputError>
}

public struct ListRealtimeLogConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRealtimeLogConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRealtimeLogConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRealtimeLogConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRealtimeLogConfigsInput>
    public typealias MOutput = OperationOutput<ListRealtimeLogConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRealtimeLogConfigsOutputError>
}

public struct ListRealtimeLogConfigsInput: Equatable {
    /// <p>Use this field when paginating results to indicate where to begin in your list of real-time
    /// 			log configurations. The response includes real-time log configurations in the list that
    /// 			occur after the marker. To get the next page of the list, set this field’s value to the
    /// 			value of <code>NextMarker</code> from the current page’s response.</p>
    public let marker: String?
    /// <p>The maximum number of real-time log configurations that you want in the response.</p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListRealtimeLogConfigsInputBody: Equatable {
}

extension ListRealtimeLogConfigsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRealtimeLogConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListRealtimeLogConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRealtimeLogConfigsOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRealtimeLogConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRealtimeLogConfigsOutputResponse(realtimeLogConfigs: \(String(describing: realtimeLogConfigs)))"}
}

extension ListRealtimeLogConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RealtimeLogConfigs = try responseDecoder.decode(responseBody: unwrappedData)
                self.realtimeLogConfigs = output
            } else {
                self.realtimeLogConfigs = nil
            }
        } else {
            self.realtimeLogConfigs = nil
        }
    }
}

public struct ListRealtimeLogConfigsOutputResponse: Equatable {
    /// <p>A list of real-time log configurations.</p>
    public let realtimeLogConfigs: RealtimeLogConfigs?

    public init (
        realtimeLogConfigs: RealtimeLogConfigs? = nil
    )
    {
        self.realtimeLogConfigs = realtimeLogConfigs
    }
}

struct ListRealtimeLogConfigsOutputResponseBody: Equatable {
    public let realtimeLogConfigs: RealtimeLogConfigs?
}

extension ListRealtimeLogConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case realtimeLogConfigs = "RealtimeLogConfigs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigsDecoded = try containerValues.decodeIfPresent(RealtimeLogConfigs.self, forKey: .realtimeLogConfigs)
        realtimeLogConfigs = realtimeLogConfigsDecoded
    }
}

extension ListStreamingDistributionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamingDistributionsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListStreamingDistributionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListStreamingDistributionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamingDistributionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamingDistributionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamingDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamingDistributionsInput>
    public typealias MOutput = OperationOutput<ListStreamingDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamingDistributionsOutputError>
}

public struct ListStreamingDistributionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamingDistributionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamingDistributionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamingDistributionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamingDistributionsInput>
    public typealias MOutput = OperationOutput<ListStreamingDistributionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamingDistributionsOutputError>
}

/// <p>The request to list your streaming distributions. </p>
public struct ListStreamingDistributionsInput: Equatable {
    /// <p>The value that you provided for the <code>Marker</code> request parameter.</p>
    public let marker: String?
    /// <p>The value that you provided for the <code>MaxItems</code> request parameter.</p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListStreamingDistributionsInputBody: Equatable {
}

extension ListStreamingDistributionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListStreamingDistributionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListStreamingDistributionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamingDistributionsOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamingDistributionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamingDistributionsOutputResponse(streamingDistributionList: \(String(describing: streamingDistributionList)))"}
}

extension ListStreamingDistributionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: StreamingDistributionList = try responseDecoder.decode(responseBody: unwrappedData)
                self.streamingDistributionList = output
            } else {
                self.streamingDistributionList = nil
            }
        } else {
            self.streamingDistributionList = nil
        }
    }
}

/// <p>The returned result of the corresponding request. </p>
public struct ListStreamingDistributionsOutputResponse: Equatable {
    /// <p>The <code>StreamingDistributionList</code> type. </p>
    public let streamingDistributionList: StreamingDistributionList?

    public init (
        streamingDistributionList: StreamingDistributionList? = nil
    )
    {
        self.streamingDistributionList = streamingDistributionList
    }
}

struct ListStreamingDistributionsOutputResponseBody: Equatable {
    public let streamingDistributionList: StreamingDistributionList?
}

extension ListStreamingDistributionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionList = "StreamingDistributionList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionListDecoded = try containerValues.decodeIfPresent(StreamingDistributionList.self, forKey: .streamingDistributionList)
        streamingDistributionList = streamingDistributionListDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resource: \(String(describing: resource)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resource = input.operationInput.resource {
            let resourceQueryItem = URLQueryItem(name: "Resource".urlPercentEncoding(), value: String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p> The request to list tags for a CloudFront resource.</p>
public struct ListTagsForResourceInput: Equatable {
    /// <p> An ARN of a CloudFront resource.</p>
    public let resource: String?

    public init (
        resource: String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: Tags = try responseDecoder.decode(responseBody: unwrappedData)
                self.tags = output
            } else {
                self.tags = nil
            }
        } else {
            self.tags = nil
        }
    }
}

/// <p> The returned result of the corresponding request.</p>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
    public let tags: Tags?

    public init (
        tags: Tags? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: Tags?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension LoggingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case includeCookies = "IncludeCookies"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let includeCookies = includeCookies {
            try container.encode(includeCookies, forKey: Key("includeCookies"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let includeCookiesDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeCookies)
        includeCookies = includeCookiesDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension LoggingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfig(bucket: \(String(describing: bucket)), enabled: \(String(describing: enabled)), includeCookies: \(String(describing: includeCookies)), prefix: \(String(describing: prefix)))"}
}

extension LoggingConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that controls whether access logs are written for the
/// 			distribution.</p>
public struct LoggingConfig: Equatable {
    /// <p>The Amazon S3 bucket to store the access logs in, for example,
    /// 				<code>myawslogbucket.s3.amazonaws.com</code>.</p>
    public let bucket: String?
    /// <p>Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't
    /// 			want to enable logging when you create a distribution or if you want to disable logging for an
    /// 			existing distribution, specify <code>false</code> for <code>Enabled</code>, and specify empty
    /// 				<code>Bucket</code> and <code>Prefix</code> elements. If you specify <code>false</code> for
    /// 				<code>Enabled</code> but you specify values for <code>Bucket</code>, <code>prefix</code>,
    /// 			and <code>IncludeCookies</code>, the values are automatically deleted.</p>
    public let enabled: Bool?
    /// <p>Specifies whether you want CloudFront to include cookies in access logs, specify
    /// 				<code>true</code> for <code>IncludeCookies</code>. If you choose to include cookies in logs,
    /// 			CloudFront logs all cookies regardless of how you configure the cache behaviors for this
    /// 			distribution. If you don't want to include cookies when you create a distribution or if you
    /// 			want to disable include cookies for an existing distribution, specify <code>false</code> for
    /// 				<code>IncludeCookies</code>.</p>
    public let includeCookies: Bool?
    /// <p>An optional string that you want CloudFront to prefix to the access log
    /// 				<code>filenames</code> for this distribution, for example, <code>myprefix/</code>. If you
    /// 			want to enable logging, but you don't want to specify a prefix, you still must include an
    /// 			empty <code>Prefix</code> element in the <code>Logging</code> element.</p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        enabled: Bool? = nil,
        includeCookies: Bool? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.enabled = enabled
        self.includeCookies = includeCookies
        self.prefix = prefix
    }
}

public enum Method {
    case delete
    case `get`
    case head
    case options
    case patch
    case post
    case put
    case sdkUnknown(String)
}

extension Method : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Method] {
        return [
            .delete,
            .get,
            .head,
            .options,
            .patch,
            .post,
            .put,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delete: return "DELETE"
        case .get: return "GET"
        case .head: return "HEAD"
        case .options: return "OPTIONS"
        case .patch: return "PATCH"
        case .post: return "POST"
        case .put: return "PUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Method(rawValue: rawValue) ?? Method.sdkUnknown(rawValue)
    }
}

public enum MinimumProtocolVersion {
    case sslv3
    case tlsv1
    case tlsv112016
    case tlsv12016
    case tlsv122018
    case tlsv122019
    case sdkUnknown(String)
}

extension MinimumProtocolVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MinimumProtocolVersion] {
        return [
            .sslv3,
            .tlsv1,
            .tlsv112016,
            .tlsv12016,
            .tlsv122018,
            .tlsv122019,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sslv3: return "SSLv3"
        case .tlsv1: return "TLSv1"
        case .tlsv112016: return "TLSv1.1_2016"
        case .tlsv12016: return "TLSv1_2016"
        case .tlsv122018: return "TLSv1.2_2018"
        case .tlsv122019: return "TLSv1.2_2019"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MinimumProtocolVersion(rawValue: rawValue) ?? MinimumProtocolVersion.sdkUnknown(rawValue)
    }
}

extension MissingBody: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MissingBody(message: \(String(describing: message)))"}
}

extension MissingBody: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<MissingBodyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation requires a body. Ensure that the body is present and the <code>Content-Type</code> header is set.</p>
public struct MissingBody: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MissingBodyBody: Equatable {
    public let message: String?
}

extension MissingBodyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MonitoringSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case realtimeMetricsSubscriptionConfig = "RealtimeMetricsSubscriptionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig {
            try container.encode(realtimeMetricsSubscriptionConfig, forKey: Key("realtimeMetricsSubscriptionConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionConfigDecoded = try containerValues.decodeIfPresent(RealtimeMetricsSubscriptionConfig.self, forKey: .realtimeMetricsSubscriptionConfig)
        realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfigDecoded
    }
}

extension MonitoringSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MonitoringSubscription(realtimeMetricsSubscriptionConfig: \(String(describing: realtimeMetricsSubscriptionConfig)))"}
}

extension MonitoringSubscription: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A monitoring subscription. This structure contains information about whether additional
/// 			CloudWatch metrics are enabled for a given CloudFront distribution.</p>
public struct MonitoringSubscription: Equatable {
    /// <p>A subscription configuration for additional CloudWatch metrics.</p>
    public let realtimeMetricsSubscriptionConfig: RealtimeMetricsSubscriptionConfig?

    public init (
        realtimeMetricsSubscriptionConfig: RealtimeMetricsSubscriptionConfig? = nil
    )
    {
        self.realtimeMetricsSubscriptionConfig = realtimeMetricsSubscriptionConfig
    }
}

extension NoSuchCachePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchCachePolicy(message: \(String(describing: message)))"}
}

extension NoSuchCachePolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchCachePolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cache policy does not exist.</p>
public struct NoSuchCachePolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchCachePolicyBody: Equatable {
    public let message: String?
}

extension NoSuchCachePolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchCloudFrontOriginAccessIdentity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchCloudFrontOriginAccessIdentity(message: \(String(describing: message)))"}
}

extension NoSuchCloudFrontOriginAccessIdentity: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchCloudFrontOriginAccessIdentityBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified origin access identity does not exist.</p>
public struct NoSuchCloudFrontOriginAccessIdentity: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchCloudFrontOriginAccessIdentityBody: Equatable {
    public let message: String?
}

extension NoSuchCloudFrontOriginAccessIdentityBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchDistribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchDistribution(message: \(String(describing: message)))"}
}

extension NoSuchDistribution: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchDistributionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified distribution does not exist.</p>
public struct NoSuchDistribution: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchDistributionBody: Equatable {
    public let message: String?
}

extension NoSuchDistributionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchFieldLevelEncryptionConfig(message: \(String(describing: message)))"}
}

extension NoSuchFieldLevelEncryptionConfig: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration for field-level encryption doesn't exist.</p>
public struct NoSuchFieldLevelEncryptionConfig: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFieldLevelEncryptionConfigBody: Equatable {
    public let message: String?
}

extension NoSuchFieldLevelEncryptionConfigBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFieldLevelEncryptionProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchFieldLevelEncryptionProfile(message: \(String(describing: message)))"}
}

extension NoSuchFieldLevelEncryptionProfile: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchFieldLevelEncryptionProfileBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified profile for field-level encryption doesn't exist.</p>
public struct NoSuchFieldLevelEncryptionProfile: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFieldLevelEncryptionProfileBody: Equatable {
    public let message: String?
}

extension NoSuchFieldLevelEncryptionProfileBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchFunctionExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchFunctionExists(message: \(String(describing: message)))"}
}

extension NoSuchFunctionExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchFunctionExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The function does not exist.</p>
public struct NoSuchFunctionExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchFunctionExistsBody: Equatable {
    public let message: String?
}

extension NoSuchFunctionExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchInvalidation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchInvalidation(message: \(String(describing: message)))"}
}

extension NoSuchInvalidation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchInvalidationBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified invalidation does not exist.</p>
public struct NoSuchInvalidation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchInvalidationBody: Equatable {
    public let message: String?
}

extension NoSuchInvalidationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOrigin: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchOrigin(message: \(String(describing: message)))"}
}

extension NoSuchOrigin: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchOriginBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No origin exists with the specified <code>Origin Id</code>. </p>
public struct NoSuchOrigin: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOriginBody: Equatable {
    public let message: String?
}

extension NoSuchOriginBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchOriginRequestPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchOriginRequestPolicy(message: \(String(describing: message)))"}
}

extension NoSuchOriginRequestPolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The origin request policy does not exist.</p>
public struct NoSuchOriginRequestPolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchOriginRequestPolicyBody: Equatable {
    public let message: String?
}

extension NoSuchOriginRequestPolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchPublicKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchPublicKey(message: \(String(describing: message)))"}
}

extension NoSuchPublicKey: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchPublicKeyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified public key doesn't exist.</p>
public struct NoSuchPublicKey: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchPublicKeyBody: Equatable {
    public let message: String?
}

extension NoSuchPublicKeyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchRealtimeLogConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchRealtimeLogConfig(message: \(String(describing: message)))"}
}

extension NoSuchRealtimeLogConfig: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchRealtimeLogConfigBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The real-time log configuration does not exist.</p>
public struct NoSuchRealtimeLogConfig: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchRealtimeLogConfigBody: Equatable {
    public let message: String?
}

extension NoSuchRealtimeLogConfigBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchResource(message: \(String(describing: message)))"}
}

extension NoSuchResource: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchResourceBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A resource that was specified is not valid.</p>
public struct NoSuchResource: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchResourceBody: Equatable {
    public let message: String?
}

extension NoSuchResourceBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoSuchStreamingDistribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchStreamingDistribution(message: \(String(describing: message)))"}
}

extension NoSuchStreamingDistribution: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<NoSuchStreamingDistributionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified streaming distribution does not exist.</p>
public struct NoSuchStreamingDistribution: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NoSuchStreamingDistributionBody: Equatable {
    public let message: String?
}

extension NoSuchStreamingDistributionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Origin: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionAttempts = "ConnectionAttempts"
        case connectionTimeout = "ConnectionTimeout"
        case customHeaders = "CustomHeaders"
        case customOriginConfig = "CustomOriginConfig"
        case domainName = "DomainName"
        case id = "Id"
        case originPath = "OriginPath"
        case originShield = "OriginShield"
        case s3OriginConfig = "S3OriginConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let connectionAttempts = connectionAttempts {
            try container.encode(connectionAttempts, forKey: Key("connectionAttempts"))
        }
        if let connectionTimeout = connectionTimeout {
            try container.encode(connectionTimeout, forKey: Key("connectionTimeout"))
        }
        if let customHeaders = customHeaders {
            try container.encode(customHeaders, forKey: Key("customHeaders"))
        }
        if let customOriginConfig = customOriginConfig {
            try container.encode(customOriginConfig, forKey: Key("customOriginConfig"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("domainName"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let originPath = originPath {
            try container.encode(originPath, forKey: Key("originPath"))
        }
        if let originShield = originShield {
            try container.encode(originShield, forKey: Key("originShield"))
        }
        if let s3OriginConfig = s3OriginConfig {
            try container.encode(s3OriginConfig, forKey: Key("s3OriginConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originPath)
        originPath = originPathDecoded
        let customHeadersDecoded = try containerValues.decodeIfPresent(CustomHeaders.self, forKey: .customHeaders)
        customHeaders = customHeadersDecoded
        let s3OriginConfigDecoded = try containerValues.decodeIfPresent(S3OriginConfig.self, forKey: .s3OriginConfig)
        s3OriginConfig = s3OriginConfigDecoded
        let customOriginConfigDecoded = try containerValues.decodeIfPresent(CustomOriginConfig.self, forKey: .customOriginConfig)
        customOriginConfig = customOriginConfigDecoded
        let connectionAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectionAttempts)
        connectionAttempts = connectionAttemptsDecoded
        let connectionTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .connectionTimeout)
        connectionTimeout = connectionTimeoutDecoded
        let originShieldDecoded = try containerValues.decodeIfPresent(OriginShield.self, forKey: .originShield)
        originShield = originShieldDecoded
    }
}

extension Origin: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Origin(connectionAttempts: \(String(describing: connectionAttempts)), connectionTimeout: \(String(describing: connectionTimeout)), customHeaders: \(String(describing: customHeaders)), customOriginConfig: \(String(describing: customOriginConfig)), domainName: \(String(describing: domainName)), id: \(String(describing: id)), originPath: \(String(describing: originPath)), originShield: \(String(describing: originShield)), s3OriginConfig: \(String(describing: s3OriginConfig)))"}
}

extension Origin: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An origin.</p>
/// 		       <p>An origin is the location where content is stored, and from which CloudFront gets content to
/// 			serve to viewers. To specify an origin:</p>
/// 		       <ul>
///             <li>
///                 <p>Use <code>S3OriginConfig</code> to specify an Amazon S3 bucket that is not
/// 					configured with static website hosting.</p>
/// 			         </li>
///             <li>
/// 				           <p>Use <code>CustomOriginConfig</code> to specify all other kinds of origins,
/// 					including:</p>
/// 				           <ul>
///                   <li>
/// 						               <p>An Amazon S3 bucket that is configured with static website hosting</p>
/// 					             </li>
///                   <li>
/// 						               <p>An Elastic Load Balancing load balancer</p>
/// 					             </li>
///                   <li>
/// 						               <p>An AWS Elemental MediaPackage endpoint</p>
/// 					             </li>
///                   <li>
/// 						               <p>An AWS Elemental MediaStore container</p>
/// 					             </li>
///                   <li>
/// 						               <p>Any other HTTP server, running on an Amazon EC2 instance or any other
/// 							kind of host</p>
/// 					             </li>
///                </ul>
/// 			         </li>
///          </ul>
/// 		       <p>For the current maximum number of origins that you can specify per distribution, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html#limits-web-distributions">General Quotas on Web Distributions</a> in the <i>Amazon CloudFront Developer Guide</i>
/// 			(quotas were formerly referred to as limits).</p>
public struct Origin: Equatable {
    /// <p>The number of times that CloudFront attempts to connect to the origin. The minimum number
    ///             is 1, the maximum is 3, and the default (if you don’t specify otherwise) is 3.</p>
    ///         <p>For a custom origin (including an Amazon S3 bucket that’s configured with static
    ///             website hosting), this value also specifies the number of times that CloudFront attempts to
    ///             get a response from the origin, in the case of an <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginResponseTimeout">Origin Response Timeout</a>.</p>
    ///         <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-attempts">Origin Connection Attempts</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let connectionAttempts: Int?
    /// <p>The number of seconds that CloudFront waits when trying to establish a connection to the origin.
    /// 			The minimum timeout is 1 second, the maximum is 10 seconds, and the default (if you
    /// 			don’t specify otherwise) is 10 seconds.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#origin-connection-timeout">Origin Connection Timeout</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let connectionTimeout: Int?
    /// <p>A list of HTTP header names and values that CloudFront adds to the requests that it sends to
    ///             the origin.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html">Adding Custom Headers to Origin Requests</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let customHeaders: CustomHeaders?
    /// <p>Use this type to specify an origin that is not an Amazon S3 bucket, with one exception. If the
    /// 			Amazon S3 bucket is configured with static website hosting, use this type. If the Amazon S3 bucket
    /// 			is not configured with static website hosting, use the <code>S3OriginConfig</code> type
    /// 			instead.</p>
    public let customOriginConfig: CustomOriginConfig?
    /// <p>The domain name for the origin.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesDomainName">Origin Domain Name</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let domainName: String?
    /// <p>A unique identifier for the origin. This value must be unique within the
    /// 			distribution.</p>
    ///         <p>Use this value to specify the <code>TargetOriginId</code> in a
    ///             <code>CacheBehavior</code> or <code>DefaultCacheBehavior</code>.</p>
    public let id: String?
    /// <p>An optional path that CloudFront appends to the origin domain name when CloudFront requests content from
    /// 			the origin.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValuesOriginPath">Origin Path</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let originPath: String?
    /// <p>CloudFront Origin Shield. Using Origin Shield can help reduce the load on your
    ///             origin.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html">Using Origin Shield</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let originShield: OriginShield?
    /// <p>Use this type to specify an origin that is an Amazon S3 bucket that is not configured with static
    /// 			website hosting. To specify any other type of origin, including an Amazon S3 bucket that is
    /// 			configured with static website hosting, use the <code>CustomOriginConfig</code> type
    /// 			instead.</p>
    public let s3OriginConfig: S3OriginConfig?

    public init (
        connectionAttempts: Int? = nil,
        connectionTimeout: Int? = nil,
        customHeaders: CustomHeaders? = nil,
        customOriginConfig: CustomOriginConfig? = nil,
        domainName: String? = nil,
        id: String? = nil,
        originPath: String? = nil,
        originShield: OriginShield? = nil,
        s3OriginConfig: S3OriginConfig? = nil
    )
    {
        self.connectionAttempts = connectionAttempts
        self.connectionTimeout = connectionTimeout
        self.customHeaders = customHeaders
        self.customOriginConfig = customOriginConfig
        self.domainName = domainName
        self.id = id
        self.originPath = originPath
        self.originShield = originShield
        self.s3OriginConfig = s3OriginConfig
    }
}

extension OriginCustomHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headerName = "HeaderName"
        case headerValue = "HeaderValue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let headerName = headerName {
            try container.encode(headerName, forKey: Key("headerName"))
        }
        if let headerValue = headerValue {
            try container.encode(headerValue, forKey: Key("headerValue"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .headerName)
        headerName = headerNameDecoded
        let headerValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .headerValue)
        headerValue = headerValueDecoded
    }
}

extension OriginCustomHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginCustomHeader(headerName: \(String(describing: headerName)), headerValue: \(String(describing: headerValue)))"}
}

extension OriginCustomHeader: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains <code>HeaderName</code> and <code>HeaderValue</code>
/// 			elements, if any, for this distribution. </p>
public struct OriginCustomHeader: Equatable {
    /// <p>The name of a header that you want CloudFront to send to your origin. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/forward-custom-headers.html">Adding Custom
    /// 			Headers to Origin Requests</a> in the <i> Amazon CloudFront Developer Guide</i>.</p>
    public let headerName: String?
    /// <p>The value for the header that you specified in the <code>HeaderName</code>
    /// 			field.</p>
    public let headerValue: String?

    public init (
        headerName: String? = nil,
        headerValue: String? = nil
    )
    {
        self.headerName = headerName
        self.headerValue = headerValue
    }
}

extension OriginGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failoverCriteria = "FailoverCriteria"
        case id = "Id"
        case members = "Members"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let failoverCriteria = failoverCriteria {
            try container.encode(failoverCriteria, forKey: Key("failoverCriteria"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let members = members {
            try container.encode(members, forKey: Key("members"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let failoverCriteriaDecoded = try containerValues.decodeIfPresent(OriginGroupFailoverCriteria.self, forKey: .failoverCriteria)
        failoverCriteria = failoverCriteriaDecoded
        let membersDecoded = try containerValues.decodeIfPresent(OriginGroupMembers.self, forKey: .members)
        members = membersDecoded
    }
}

extension OriginGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginGroup(failoverCriteria: \(String(describing: failoverCriteria)), id: \(String(describing: id)), members: \(String(describing: members)))"}
}

extension OriginGroup: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An origin group includes two origins (a primary origin and a second origin to failover to) and a failover criteria that you specify.
/// 		You create an origin group to support origin failover in CloudFront. When you create or update a distribution, you can specifiy
/// 		the origin group instead of a single origin, and CloudFront will failover from the primary origin to the second origin
/// 		under the failover conditions that you've chosen.</p>
public struct OriginGroup: Equatable {
    /// <p>A complex type that contains information about the failover criteria for an origin group.</p>
    public let failoverCriteria: OriginGroupFailoverCriteria?
    /// <p>The origin group's ID.</p>
    public let id: String?
    /// <p>A complex type that contains information about the origins in an origin group.</p>
    public let members: OriginGroupMembers?

    public init (
        failoverCriteria: OriginGroupFailoverCriteria? = nil,
        id: String? = nil,
        members: OriginGroupMembers? = nil
    )
    {
        self.failoverCriteria = failoverCriteria
        self.id = id
        self.members = members
    }
}

extension OriginGroupFailoverCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statusCodes = "StatusCodes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let statusCodes = statusCodes {
            try container.encode(statusCodes, forKey: Key("statusCodes"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodesDecoded = try containerValues.decodeIfPresent(StatusCodes.self, forKey: .statusCodes)
        statusCodes = statusCodesDecoded
    }
}

extension OriginGroupFailoverCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginGroupFailoverCriteria(statusCodes: \(String(describing: statusCodes)))"}
}

extension OriginGroupFailoverCriteria: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type that includes information about the failover criteria for an origin group, including
/// 		the status codes for which CloudFront will failover from the primary origin to the second origin.</p>
public struct OriginGroupFailoverCriteria: Equatable {
    /// <p>The status codes that, when returned from the primary origin, will trigger CloudFront to failover
    /// 		to the second origin.</p>
    public let statusCodes: StatusCodes?

    public init (
        statusCodes: StatusCodes? = nil
    )
    {
        self.statusCodes = statusCodes
    }
}

extension OriginGroupMember: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case originId = "OriginId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let originId = originId {
            try container.encode(originId, forKey: Key("originId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originId)
        originId = originIdDecoded
    }
}

extension OriginGroupMember: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginGroupMember(originId: \(String(describing: originId)))"}
}

extension OriginGroupMember: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An origin in an origin group.</p>
public struct OriginGroupMember: Equatable {
    /// <p>The ID for an origin in an origin group.</p>
    public let originId: String?

    public init (
        originId: String? = nil
    )
    {
        self.originId = originId
    }
}

extension OriginGroupMembers: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for origingroupmember0 in items {
                try itemsContainer.encode(origingroupmember0, forKey: Key("OriginGroupMember"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroupMember{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroupMember>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([OriginGroupMember].self, forKey: .member)
                var itemsBuffer:[OriginGroupMember]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [OriginGroupMember]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension OriginGroupMembers: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginGroupMembers(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension OriginGroupMembers: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type for the origins included in an origin group.</p>
public struct OriginGroupMembers: Equatable {
    /// <p>Items (origins) in an origin group.</p>
    public let items: [OriginGroupMember]?
    /// <p>The number of origins in an origin group.</p>
    public let quantity: Int?

    public init (
        items: [OriginGroupMember]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension OriginGroups: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for origingroup0 in items {
                try itemsContainer.encode(origingroup0, forKey: Key("OriginGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([OriginGroup].self, forKey: .member)
                var itemsBuffer:[OriginGroup]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [OriginGroup]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension OriginGroups: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginGroups(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension OriginGroups: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type for the origin groups specified for a distribution.</p>
public struct OriginGroups: Equatable {
    /// <p>The items (origin groups) in a distribution.</p>
    public let items: [OriginGroup]?
    /// <p>The number of origin groups.</p>
    public let quantity: Int?

    public init (
        items: [OriginGroup]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

public enum OriginProtocolPolicy {
    case httpOnly
    case httpsOnly
    case matchViewer
    case sdkUnknown(String)
}

extension OriginProtocolPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OriginProtocolPolicy] {
        return [
            .httpOnly,
            .httpsOnly,
            .matchViewer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .httpOnly: return "http-only"
        case .httpsOnly: return "https-only"
        case .matchViewer: return "match-viewer"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OriginProtocolPolicy(rawValue: rawValue) ?? OriginProtocolPolicy.sdkUnknown(rawValue)
    }
}

extension OriginRequestPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: Key("originRequestPolicyConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension OriginRequestPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicy(id: \(String(describing: id)), lastModifiedTime: \(String(describing: lastModifiedTime)), originRequestPolicyConfig: \(String(describing: originRequestPolicyConfig)))"}
}

extension OriginRequestPolicy: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An origin request policy.</p>
/// 		       <p>When it’s attached to a cache behavior, the origin request policy determines the values that
/// 			CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends to
/// 			the origin includes the following:</p>
/// 		       <ul>
///             <li>
/// 				           <p>The request body and the URL path (without the domain name) from the viewer
/// 					request.</p>
/// 			         </li>
///             <li>
/// 				           <p>The headers that CloudFront automatically includes in every origin request, including
/// 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
/// 			         </li>
///             <li>
/// 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the
/// 					cache policy or the origin request policy. These can include items from the
/// 					viewer request and, in the case of headers, additional ones that are added by
/// 					CloudFront.</p>
/// 			         </li>
///          </ul>
/// 		       <p>CloudFront sends a request when it can’t find an object in its cache that matches the request. If
/// 			you want to send values to the origin and also include them in the cache key, use
/// 			<code>CachePolicy</code>.</p>
public struct OriginRequestPolicy: Equatable {
    /// <p>The unique identifier for the origin request policy.</p>
    public let id: String?
    /// <p>The date and time when the origin request policy was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The origin request policy configuration.</p>
    public let originRequestPolicyConfig: OriginRequestPolicyConfig?

    public init (
        id: String? = nil,
        lastModifiedTime: Date? = nil,
        originRequestPolicyConfig: OriginRequestPolicyConfig? = nil
    )
    {
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

extension OriginRequestPolicyAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicyAlreadyExists(message: \(String(describing: message)))"}
}

extension OriginRequestPolicyAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OriginRequestPolicyAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An origin request policy with this name already exists. You must provide a unique
/// 			name. To modify an existing origin request policy, use
/// 			<code>UpdateOriginRequestPolicy</code>.</p>
public struct OriginRequestPolicyAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OriginRequestPolicyAlreadyExistsBody: Equatable {
    public let message: String?
}

extension OriginRequestPolicyAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OriginRequestPolicyConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case cookiesConfig = "CookiesConfig"
        case headersConfig = "HeadersConfig"
        case name = "Name"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: Key("cookiesConfig"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: Key("headersConfig"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: Key("queryStringsConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension OriginRequestPolicyConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicyConfig(comment: \(String(describing: comment)), cookiesConfig: \(String(describing: cookiesConfig)), headersConfig: \(String(describing: headersConfig)), name: \(String(describing: name)), queryStringsConfig: \(String(describing: queryStringsConfig)))"}
}

extension OriginRequestPolicyConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An origin request policy configuration.</p>
/// 		       <p>This configuration determines the values that CloudFront includes in requests that it sends to the
/// 			origin. Each request that CloudFront sends to the origin includes the following:</p>
/// 		       <ul>
///             <li>
/// 				           <p>The request body and the URL path (without the domain name) from the viewer
/// 					request.</p>
/// 			         </li>
///             <li>
/// 				           <p>The headers that CloudFront automatically includes in every origin request, including
/// 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
/// 			         </li>
///             <li>
/// 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the
/// 					cache policy or the origin request policy. These can include items from the
/// 					viewer request and, in the case of headers, additional ones that are added by
/// 					CloudFront.</p>
/// 			         </li>
///          </ul>
/// 		       <p>CloudFront sends a request when it can’t find an object in its cache that matches the request. If
/// 			you want to send values to the origin and also include them in the cache key, use
/// 			<code>CachePolicy</code>.</p>
public struct OriginRequestPolicyConfig: Equatable {
    /// <p>A comment to describe the origin request policy. The comment cannot be longer than 128
    /// 			characters.</p>
    public let comment: String?
    /// <p>The cookies from viewer requests to include in origin requests.</p>
    public let cookiesConfig: OriginRequestPolicyCookiesConfig?
    /// <p>The HTTP headers to include in origin requests. These can include headers from viewer
    /// 			requests and additional headers added by CloudFront.</p>
    public let headersConfig: OriginRequestPolicyHeadersConfig?
    /// <p>A unique name to identify the origin request policy.</p>
    public let name: String?
    /// <p>The URL query strings from viewer requests to include in origin requests.</p>
    public let queryStringsConfig: OriginRequestPolicyQueryStringsConfig?

    public init (
        comment: String? = nil,
        cookiesConfig: OriginRequestPolicyCookiesConfig? = nil,
        headersConfig: OriginRequestPolicyHeadersConfig? = nil,
        name: String? = nil,
        queryStringsConfig: OriginRequestPolicyQueryStringsConfig? = nil
    )
    {
        self.comment = comment
        self.cookiesConfig = cookiesConfig
        self.headersConfig = headersConfig
        self.name = name
        self.queryStringsConfig = queryStringsConfig
    }
}

public enum OriginRequestPolicyCookieBehavior {
    case all
    case `none`
    case whitelist
    case sdkUnknown(String)
}

extension OriginRequestPolicyCookieBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OriginRequestPolicyCookieBehavior] {
        return [
            .all,
            .none,
            .whitelist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "all"
        case .none: return "none"
        case .whitelist: return "whitelist"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OriginRequestPolicyCookieBehavior(rawValue: rawValue) ?? OriginRequestPolicyCookieBehavior.sdkUnknown(rawValue)
    }
}

extension OriginRequestPolicyCookiesConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cookieBehavior = "CookieBehavior"
        case cookies = "Cookies"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cookieBehavior = cookieBehavior {
            try container.encode(cookieBehavior, forKey: Key("cookieBehavior"))
        }
        if let cookies = cookies {
            try container.encode(cookies, forKey: Key("cookies"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cookieBehaviorDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyCookieBehavior.self, forKey: .cookieBehavior)
        cookieBehavior = cookieBehaviorDecoded
        let cookiesDecoded = try containerValues.decodeIfPresent(CookieNames.self, forKey: .cookies)
        cookies = cookiesDecoded
    }
}

extension OriginRequestPolicyCookiesConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicyCookiesConfig(cookieBehavior: \(String(describing: cookieBehavior)), cookies: \(String(describing: cookies)))"}
}

extension OriginRequestPolicyCookiesConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
/// 			are included in requests that CloudFront sends to the origin.</p>
public struct OriginRequestPolicyCookiesConfig: Equatable {
    /// <p>Determines whether cookies in viewer requests are included in requests that CloudFront sends to
    /// 			the origin. Valid values are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>none</code> – Cookies in viewer requests are not included in requests that CloudFront
    /// 					sends to the origin. Even when this field is set to <code>none</code>, any
    /// 					cookies that are listed in a <code>CachePolicy</code>
    ///                   <i>are</i>
    /// 					included in origin requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>whitelist</code> – The cookies in viewer requests that are listed in the
    /// 					<code>CookieNames</code> type are included in requests that CloudFront sends to the
    /// 					origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>all</code> – All cookies in viewer requests are included in requests that CloudFront sends
    /// 					to the origin.</p>
    /// 			         </li>
    ///          </ul>
    public let cookieBehavior: OriginRequestPolicyCookieBehavior?
    /// <p>Contains a list of cookie names.</p>
    public let cookies: CookieNames?

    public init (
        cookieBehavior: OriginRequestPolicyCookieBehavior? = nil,
        cookies: CookieNames? = nil
    )
    {
        self.cookieBehavior = cookieBehavior
        self.cookies = cookies
    }
}

public enum OriginRequestPolicyHeaderBehavior {
    case allviewer
    case allviewerandwhitelistcloudfront
    case `none`
    case whitelist
    case sdkUnknown(String)
}

extension OriginRequestPolicyHeaderBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OriginRequestPolicyHeaderBehavior] {
        return [
            .allviewer,
            .allviewerandwhitelistcloudfront,
            .none,
            .whitelist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allviewer: return "allViewer"
        case .allviewerandwhitelistcloudfront: return "allViewerAndWhitelistCloudFront"
        case .none: return "none"
        case .whitelist: return "whitelist"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OriginRequestPolicyHeaderBehavior(rawValue: rawValue) ?? OriginRequestPolicyHeaderBehavior.sdkUnknown(rawValue)
    }
}

extension OriginRequestPolicyHeadersConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headerBehavior = "HeaderBehavior"
        case headers = "Headers"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let headerBehavior = headerBehavior {
            try container.encode(headerBehavior, forKey: Key("headerBehavior"))
        }
        if let headers = headers {
            try container.encode(headers, forKey: Key("headers"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerBehaviorDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyHeaderBehavior.self, forKey: .headerBehavior)
        headerBehavior = headerBehaviorDecoded
        let headersDecoded = try containerValues.decodeIfPresent(Headers.self, forKey: .headers)
        headers = headersDecoded
    }
}

extension OriginRequestPolicyHeadersConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicyHeadersConfig(headerBehavior: \(String(describing: headerBehavior)), headers: \(String(describing: headers)))"}
}

extension OriginRequestPolicyHeadersConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An object that determines whether any HTTP headers (and if so, which headers) are included
/// 			in requests that CloudFront sends to the origin.</p>
public struct OriginRequestPolicyHeadersConfig: Equatable {
    /// <p>Determines whether any HTTP headers are included in requests that CloudFront sends to the origin.
    /// 			Valid values are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>none</code> – HTTP headers are not included in requests that CloudFront sends to the
    /// 					origin. Even when this field is set to <code>none</code>, any headers that are
    /// 					listed in a <code>CachePolicy</code>
    ///                   <i>are</i> included in origin
    /// 					requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>whitelist</code> – The HTTP headers that are listed in the <code>Headers</code> type
    /// 					are included in requests that CloudFront sends to the origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>allViewer</code> – All HTTP headers in viewer requests are included in requests that
    /// 					CloudFront sends to the origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>allViewerAndWhitelistCloudFront</code> – All HTTP headers in viewer requests and the
    /// 					additional CloudFront headers that are listed in the <code>Headers</code> type are
    /// 					included in requests that CloudFront sends to the origin. The additional headers are
    /// 					added by CloudFront.</p>
    /// 			         </li>
    ///          </ul>
    public let headerBehavior: OriginRequestPolicyHeaderBehavior?
    /// <p>Contains a list of HTTP header names.</p>
    public let headers: Headers?

    public init (
        headerBehavior: OriginRequestPolicyHeaderBehavior? = nil,
        headers: Headers? = nil
    )
    {
        self.headerBehavior = headerBehavior
        self.headers = headers
    }
}

extension OriginRequestPolicyInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicyInUse(message: \(String(describing: message)))"}
}

extension OriginRequestPolicyInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OriginRequestPolicyInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete the origin request policy because it is attached to one or more cache
/// 			behaviors.</p>
public struct OriginRequestPolicyInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OriginRequestPolicyInUseBody: Equatable {
    public let message: String?
}

extension OriginRequestPolicyInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OriginRequestPolicyList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for originrequestpolicysummary0 in items {
                try itemsContainer.encode(originrequestpolicysummary0, forKey: Key("OriginRequestPolicySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct OriginRequestPolicySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.OriginRequestPolicySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([OriginRequestPolicySummary].self, forKey: .member)
                var itemsBuffer:[OriginRequestPolicySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [OriginRequestPolicySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension OriginRequestPolicyList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicyList(items: \(String(describing: items)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension OriginRequestPolicyList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of origin request policies.</p>
public struct OriginRequestPolicyList: Equatable {
    /// <p>Contains the origin request policies in the list.</p>
    public let items: [OriginRequestPolicySummary]?
    /// <p>The maximum number of origin request policies requested.</p>
    public let maxItems: Int?
    /// <p>If there are more items in the list than are in this response, this element is
    /// 			present. It contains the value that you should use in the <code>Marker</code> field of a
    /// 			subsequent request to continue listing origin request policies where you left
    /// 			off.</p>
    public let nextMarker: String?
    /// <p>The total number of origin request policies returned in the response.</p>
    public let quantity: Int?

    public init (
        items: [OriginRequestPolicySummary]? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

public enum OriginRequestPolicyQueryStringBehavior {
    case all
    case `none`
    case whitelist
    case sdkUnknown(String)
}

extension OriginRequestPolicyQueryStringBehavior : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OriginRequestPolicyQueryStringBehavior] {
        return [
            .all,
            .none,
            .whitelist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "all"
        case .none: return "none"
        case .whitelist: return "whitelist"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OriginRequestPolicyQueryStringBehavior(rawValue: rawValue) ?? OriginRequestPolicyQueryStringBehavior.sdkUnknown(rawValue)
    }
}

extension OriginRequestPolicyQueryStringsConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queryStringBehavior = "QueryStringBehavior"
        case queryStrings = "QueryStrings"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let queryStringBehavior = queryStringBehavior {
            try container.encode(queryStringBehavior, forKey: Key("queryStringBehavior"))
        }
        if let queryStrings = queryStrings {
            try container.encode(queryStrings, forKey: Key("queryStrings"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringBehaviorDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyQueryStringBehavior.self, forKey: .queryStringBehavior)
        queryStringBehavior = queryStringBehaviorDecoded
        let queryStringsDecoded = try containerValues.decodeIfPresent(QueryStringNames.self, forKey: .queryStrings)
        queryStrings = queryStringsDecoded
    }
}

extension OriginRequestPolicyQueryStringsConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicyQueryStringsConfig(queryStringBehavior: \(String(describing: queryStringBehavior)), queryStrings: \(String(describing: queryStrings)))"}
}

extension OriginRequestPolicyQueryStringsConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>An object that determines whether any URL query strings in viewer requests (and if so, which
/// 			query strings) are included in requests that CloudFront sends to the origin.</p>
public struct OriginRequestPolicyQueryStringsConfig: Equatable {
    /// <p>Determines whether any URL query strings in viewer requests are included in requests that
    /// 			CloudFront sends to the origin. Valid values are:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>none</code> – Query strings in viewer requests are not included in requests that
    /// 					CloudFront sends to the origin. Even when this field is set to <code>none</code>, any
    /// 					query strings that are listed in a <code>CachePolicy</code>
    /// 					             <i>are</i> included in origin requests.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>whitelist</code> – The query strings in viewer requests that are listed in the
    /// 					<code>QueryStringNames</code> type are included in requests that CloudFront sends to
    /// 					the origin.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>all</code> – All query strings in viewer requests are included in requests that CloudFront
    /// 					sends to the origin.</p>
    /// 			         </li>
    ///          </ul>
    public let queryStringBehavior: OriginRequestPolicyQueryStringBehavior?
    /// <p>Contains a list of the query strings in viewer requests that are included in requests that
    /// 			CloudFront sends to the origin.</p>
    public let queryStrings: QueryStringNames?

    public init (
        queryStringBehavior: OriginRequestPolicyQueryStringBehavior? = nil,
        queryStrings: QueryStringNames? = nil
    )
    {
        self.queryStringBehavior = queryStringBehavior
        self.queryStrings = queryStrings
    }
}

extension OriginRequestPolicySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let originRequestPolicy = originRequestPolicy {
            try container.encode(originRequestPolicy, forKey: Key("originRequestPolicy"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyType.self, forKey: .type)
        type = typeDecoded
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

extension OriginRequestPolicySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginRequestPolicySummary(originRequestPolicy: \(String(describing: originRequestPolicy)), type: \(String(describing: type)))"}
}

extension OriginRequestPolicySummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains an origin request policy.</p>
public struct OriginRequestPolicySummary: Equatable {
    /// <p>The origin request policy.</p>
    public let originRequestPolicy: OriginRequestPolicy?
    /// <p>The type of origin request policy, either <code>managed</code> (created by AWS) or
    /// 			<code>custom</code> (created in this AWS account).</p>
    public let type: OriginRequestPolicyType?

    public init (
        originRequestPolicy: OriginRequestPolicy? = nil,
        type: OriginRequestPolicyType? = nil
    )
    {
        self.originRequestPolicy = originRequestPolicy
        self.type = type
    }
}

public enum OriginRequestPolicyType {
    case custom
    case managed
    case sdkUnknown(String)
}

extension OriginRequestPolicyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OriginRequestPolicyType] {
        return [
            .custom,
            .managed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "custom"
        case .managed: return "managed"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OriginRequestPolicyType(rawValue: rawValue) ?? OriginRequestPolicyType.sdkUnknown(rawValue)
    }
}

extension OriginShield: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case originShieldRegion = "OriginShieldRegion"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let originShieldRegion = originShieldRegion {
            try container.encode(originShieldRegion, forKey: Key("originShieldRegion"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let originShieldRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originShieldRegion)
        originShieldRegion = originShieldRegionDecoded
    }
}

extension OriginShield: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginShield(enabled: \(String(describing: enabled)), originShieldRegion: \(String(describing: originShieldRegion)))"}
}

extension OriginShield: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>CloudFront Origin Shield.</p>
/// 		       <p>Using Origin Shield can help reduce the load on your origin. For more
///             information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html">Using Origin Shield</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
public struct OriginShield: Equatable {
    /// <p>A flag that specifies whether Origin Shield is enabled.</p>
    /// 		       <p>When it’s enabled, CloudFront routes all requests through Origin Shield, which can
    ///             help protect your origin. When it’s disabled, CloudFront might send requests directly to
    ///             your origin from multiple edge locations or regional edge caches.</p>
    public let enabled: Bool?
    /// <p>The AWS Region for Origin Shield.</p>
    /// 		       <p>Specify the AWS Region that has the lowest latency to your origin.
    ///             To specify a region, use the region code, not the region name.
    ///             For example, specify the US East (Ohio) region as <code>us-east-2</code>.</p>
    ///         <p>When you enable CloudFront Origin Shield, you must specify the AWS Region for Origin
    ///             Shield. For the list of AWS Regions that you can specify, and for help choosing the best
    ///             Region for your origin, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/origin-shield.html#choose-origin-shield-region">Choosing the AWS Region for Origin Shield</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let originShieldRegion: String?

    public init (
        enabled: Bool? = nil,
        originShieldRegion: String? = nil
    )
    {
        self.enabled = enabled
        self.originShieldRegion = originShieldRegion
    }
}

extension OriginSslProtocols: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for sslprotocol0 in items {
                try itemsContainer.encode(sslprotocol0, forKey: Key("SslProtocol"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct SslProtocol{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.SslProtocol>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([SslProtocol].self, forKey: .member)
                var itemsBuffer:[SslProtocol]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [SslProtocol]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension OriginSslProtocols: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OriginSslProtocols(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension OriginSslProtocols: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains information about the SSL/TLS protocols that CloudFront can use
/// 			when establishing an HTTPS connection with your origin. </p>
public struct OriginSslProtocols: Equatable {
    /// <p>A list that contains allowed SSL/TLS protocols for this distribution.</p>
    public let items: [SslProtocol]?
    /// <p>The number of SSL/TLS protocols that you want to allow CloudFront to use when establishing an
    /// 			HTTPS connection with this origin. </p>
    public let quantity: Int?

    public init (
        items: [SslProtocol]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension Origins: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for origin0 in items {
                try itemsContainer.encode(origin0, forKey: Key("Origin"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Origin{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Origin>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Origin].self, forKey: .member)
                var itemsBuffer:[Origin]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Origin]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension Origins: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Origins(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension Origins: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains information about the origins for this distribution.</p>
public struct Origins: Equatable {
    /// <p>A list of origins.</p>
    public let items: [Origin]?
    /// <p>The number of origins for this distribution.</p>
    public let quantity: Int?

    public init (
        items: [Origin]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension ParametersInCacheKeyAndForwardedToOrigin: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cookiesConfig = "CookiesConfig"
        case enableAcceptEncodingBrotli = "EnableAcceptEncodingBrotli"
        case enableAcceptEncodingGzip = "EnableAcceptEncodingGzip"
        case headersConfig = "HeadersConfig"
        case queryStringsConfig = "QueryStringsConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cookiesConfig = cookiesConfig {
            try container.encode(cookiesConfig, forKey: Key("cookiesConfig"))
        }
        if let enableAcceptEncodingBrotli = enableAcceptEncodingBrotli {
            try container.encode(enableAcceptEncodingBrotli, forKey: Key("enableAcceptEncodingBrotli"))
        }
        if let enableAcceptEncodingGzip = enableAcceptEncodingGzip {
            try container.encode(enableAcceptEncodingGzip, forKey: Key("enableAcceptEncodingGzip"))
        }
        if let headersConfig = headersConfig {
            try container.encode(headersConfig, forKey: Key("headersConfig"))
        }
        if let queryStringsConfig = queryStringsConfig {
            try container.encode(queryStringsConfig, forKey: Key("queryStringsConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableAcceptEncodingGzipDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAcceptEncodingGzip)
        enableAcceptEncodingGzip = enableAcceptEncodingGzipDecoded
        let enableAcceptEncodingBrotliDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableAcceptEncodingBrotli)
        enableAcceptEncodingBrotli = enableAcceptEncodingBrotliDecoded
        let headersConfigDecoded = try containerValues.decodeIfPresent(CachePolicyHeadersConfig.self, forKey: .headersConfig)
        headersConfig = headersConfigDecoded
        let cookiesConfigDecoded = try containerValues.decodeIfPresent(CachePolicyCookiesConfig.self, forKey: .cookiesConfig)
        cookiesConfig = cookiesConfigDecoded
        let queryStringsConfigDecoded = try containerValues.decodeIfPresent(CachePolicyQueryStringsConfig.self, forKey: .queryStringsConfig)
        queryStringsConfig = queryStringsConfigDecoded
    }
}

extension ParametersInCacheKeyAndForwardedToOrigin: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParametersInCacheKeyAndForwardedToOrigin(cookiesConfig: \(String(describing: cookiesConfig)), enableAcceptEncodingBrotli: \(String(describing: enableAcceptEncodingBrotli)), enableAcceptEncodingGzip: \(String(describing: enableAcceptEncodingGzip)), headersConfig: \(String(describing: headersConfig)), queryStringsConfig: \(String(describing: queryStringsConfig)))"}
}

extension ParametersInCacheKeyAndForwardedToOrigin: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>This object determines the values that CloudFront includes in the cache key. These values can
/// 			include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to find an
/// 			object in its cache that it can return to the viewer.</p>
/// 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
/// 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
/// 			find an object in its cache that matches the request’s cache key. If you want to send
/// 			values to the origin but <i>not</i> include them in the cache key, use
/// 			<code>OriginRequestPolicy</code>.</p>
public struct ParametersInCacheKeyAndForwardedToOrigin: Equatable {
    /// <p>An object that determines whether any cookies in viewer requests (and if so, which cookies)
    /// 			are included in the cache key and automatically included in requests that CloudFront sends to
    /// 			the origin.</p>
    public let cookiesConfig: CachePolicyCookiesConfig?
    /// <p>A flag that can affect whether the <code>Accept-Encoding</code> HTTP header is
    /// 			included in the cache key and included in requests that CloudFront sends to the origin.</p>
    /// 		       <p>This field is related to the <code>EnableAcceptEncodingGzip</code> field. If one or
    /// 			both of these fields is <code>true</code>
    ///             <i>and</i> the viewer request
    /// 			includes the <code>Accept-Encoding</code> header, then CloudFront does the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Normalizes the value of the viewer’s <code>Accept-Encoding</code>
    /// 					header</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Includes the normalized header in the cache key</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Includes the normalized header in the request to the origin, if a request is necessary</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects">Compression support</a> in the
    ///             <i>Amazon CloudFront Developer Guide</i>.</p>
    ///         <p>If you set this value to <code>true</code>, and this cache behavior also has an origin
    /// 			request policy attached, do not include the <code>Accept-Encoding</code> header in the
    /// 			origin request policy. CloudFront always includes the <code>Accept-Encoding</code> header in
    /// 			origin requests when the value of this field is <code>true</code>, so including this
    /// 			header in an origin request policy has no effect.</p>
    /// 		       <p>If both of these fields are <code>false</code>, then CloudFront treats the
    /// 			<code>Accept-Encoding</code> header the same as any other HTTP header in the viewer
    /// 			request. By default, it’s not included in the cache key and it’s not included in origin
    /// 			requests. In this case, you can manually add <code>Accept-Encoding</code> to the headers
    /// 			whitelist like any other HTTP header.</p>
    public let enableAcceptEncodingBrotli: Bool?
    /// <p>A flag that can affect whether the <code>Accept-Encoding</code> HTTP header is
    /// 			included in the cache key and included in requests that CloudFront sends to the origin.</p>
    /// 		       <p>This field is related to the <code>EnableAcceptEncodingBrotli</code> field. If one or
    /// 			both of these fields is <code>true</code>
    ///             <i>and</i> the viewer request
    /// 			includes the <code>Accept-Encoding</code> header, then CloudFront does the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>Normalizes the value of the viewer’s <code>Accept-Encoding</code>
    /// 					header</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Includes the normalized header in the cache key</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Includes the normalized header in the request to the origin, if a request is necessary</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html#cache-policy-compressed-objects">Compression support</a> in the
    ///             <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>If you set this value to <code>true</code>, and this cache behavior also has an origin
    /// 			request policy attached, do not include the <code>Accept-Encoding</code> header in the
    /// 			origin request policy. CloudFront always includes the <code>Accept-Encoding</code> header in
    /// 			origin requests when the value of this field is <code>true</code>, so including this
    /// 			header in an origin request policy has no effect.</p>
    /// 		       <p>If both of these fields are <code>false</code>, then CloudFront treats the
    /// 			<code>Accept-Encoding</code> header the same as any other HTTP header in the viewer
    /// 			request. By default, it’s not included in the cache key and it’s not included in origin
    /// 			requests. In this case, you can manually add <code>Accept-Encoding</code> to the headers
    /// 			whitelist like any other HTTP header.</p>
    public let enableAcceptEncodingGzip: Bool?
    /// <p>An object that determines whether any HTTP headers (and if so, which headers) are
    /// 			included in the cache key and automatically included in requests that CloudFront sends to the
    /// 			origin.</p>
    public let headersConfig: CachePolicyHeadersConfig?
    /// <p>An object that determines whether any URL query strings in viewer requests (and if so, which
    /// 			query strings) are included in the cache key and automatically included in requests that
    /// 			CloudFront sends to the origin.</p>
    public let queryStringsConfig: CachePolicyQueryStringsConfig?

    public init (
        cookiesConfig: CachePolicyCookiesConfig? = nil,
        enableAcceptEncodingBrotli: Bool? = nil,
        enableAcceptEncodingGzip: Bool? = nil,
        headersConfig: CachePolicyHeadersConfig? = nil,
        queryStringsConfig: CachePolicyQueryStringsConfig? = nil
    )
    {
        self.cookiesConfig = cookiesConfig
        self.enableAcceptEncodingBrotli = enableAcceptEncodingBrotli
        self.enableAcceptEncodingGzip = enableAcceptEncodingGzip
        self.headersConfig = headersConfig
        self.queryStringsConfig = queryStringsConfig
    }
}

extension Paths: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("Path"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Path{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Path>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension Paths: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Paths(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension Paths: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains information about the objects that you want to invalidate.
/// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Invalidation.html#invalidation-specifying-objects">Specifying the Objects
/// 				to Invalidate</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
public struct Paths: Equatable {
    /// <p>A complex type that contains a list of the paths that you want to invalidate.</p>
    public let items: [String]?
    /// <p>The number of invalidation paths specified for the objects that you want to invalidate.</p>
    public let quantity: Int?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension PreconditionFailed: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreconditionFailed(message: \(String(describing: message)))"}
}

extension PreconditionFailed: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PreconditionFailedBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The precondition in one or more of the request fields evaluated to
/// 			<code>false</code>.</p>
public struct PreconditionFailed: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PreconditionFailedBody: Equatable {
    public let message: String?
}

extension PreconditionFailedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PriceClass {
    case priceclass100
    case priceclass200
    case priceclassAll
    case sdkUnknown(String)
}

extension PriceClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PriceClass] {
        return [
            .priceclass100,
            .priceclass200,
            .priceclassAll,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .priceclass100: return "PriceClass_100"
        case .priceclass200: return "PriceClass_200"
        case .priceclassAll: return "PriceClass_All"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PriceClass(rawValue: rawValue) ?? PriceClass.sdkUnknown(rawValue)
    }
}

extension PublicKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdTime = "CreatedTime"
        case id = "Id"
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let createdTime = createdTime {
            try container.encode(TimestampWrapper(createdTime, format: .dateTime), forKey: Key("createdTime"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: Key("publicKeyConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        var createdTimeBuffer:Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension PublicKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicKey(createdTime: \(String(describing: createdTime)), id: \(String(describing: id)), publicKeyConfig: \(String(describing: publicKeyConfig)))"}
}

extension PublicKey: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
public struct PublicKey: Equatable {
    /// <p>The date and time when the public key was uploaded.</p>
    public let createdTime: Date?
    /// <p>The identifier of the public key.</p>
    public let id: String?
    /// <p>Configuration information about a public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
    public let publicKeyConfig: PublicKeyConfig?

    public init (
        createdTime: Date? = nil,
        id: String? = nil,
        publicKeyConfig: PublicKeyConfig? = nil
    )
    {
        self.createdTime = createdTime
        self.id = id
        self.publicKeyConfig = publicKeyConfig
    }
}

extension PublicKeyAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicKeyAlreadyExists(message: \(String(describing: message)))"}
}

extension PublicKeyAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PublicKeyAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified public key already exists.</p>
public struct PublicKeyAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PublicKeyAlreadyExistsBody: Equatable {
    public let message: String?
}

extension PublicKeyAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PublicKeyConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case callerReference = "CallerReference"
        case comment = "Comment"
        case encodedKey = "EncodedKey"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: Key("callerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: Key("encodedKey"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let encodedKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension PublicKeyConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicKeyConfig(callerReference: \(String(describing: callerReference)), comment: \(String(describing: comment)), encodedKey: \(String(describing: encodedKey)), name: \(String(describing: name)))"}
}

extension PublicKeyConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Configuration information about a public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
public struct PublicKeyConfig: Equatable {
    /// <p>A string included in the request to help make sure that the request can’t be
    /// 			replayed.</p>
    public let callerReference: String?
    /// <p>A comment to describe the public key. The comment cannot be longer than 128
    /// 			characters.</p>
    public let comment: String?
    /// <p>The public key that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
    public let encodedKey: String?
    /// <p>A name to help identify the public key.</p>
    public let name: String?

    public init (
        callerReference: String? = nil,
        comment: String? = nil,
        encodedKey: String? = nil,
        name: String? = nil
    )
    {
        self.callerReference = callerReference
        self.comment = comment
        self.encodedKey = encodedKey
        self.name = name
    }
}

extension PublicKeyInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicKeyInUse(message: \(String(describing: message)))"}
}

extension PublicKeyInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PublicKeyInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified public key is in use. </p>
public struct PublicKeyInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PublicKeyInUseBody: Equatable {
    public let message: String?
}

extension PublicKeyInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PublicKeyList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for publickeysummary0 in items {
                try itemsContainer.encode(publickeysummary0, forKey: Key("PublicKeySummary"))
            }
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct PublicKeySummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.PublicKeySummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([PublicKeySummary].self, forKey: .member)
                var itemsBuffer:[PublicKeySummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [PublicKeySummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension PublicKeyList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicKeyList(items: \(String(describing: items)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension PublicKeyList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of public keys that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
public struct PublicKeyList: Equatable {
    /// <p>A list of public keys.</p>
    public let items: [PublicKeySummary]?
    /// <p>The maximum number of public keys you want in the response.</p>
    public let maxItems: Int?
    /// <p>If there are more elements to be listed, this element is present and contains
    /// 			the value that you can use for the <code>Marker</code> request parameter to continue
    /// 			listing your public keys where you left off.</p>
    public let nextMarker: String?
    /// <p>The number of public keys in the list.</p>
    public let quantity: Int?

    public init (
        items: [PublicKeySummary]? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension PublicKeySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment = "Comment"
        case createdTime = "CreatedTime"
        case encodedKey = "EncodedKey"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let createdTime = createdTime {
            try container.encode(TimestampWrapper(createdTime, format: .dateTime), forKey: Key("createdTime"))
        }
        if let encodedKey = encodedKey {
            try container.encode(encodedKey, forKey: Key("encodedKey"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        var createdTimeBuffer:Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let encodedKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encodedKey)
        encodedKey = encodedKeyDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension PublicKeySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicKeySummary(comment: \(String(describing: comment)), createdTime: \(String(describing: createdTime)), encodedKey: \(String(describing: encodedKey)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension PublicKeySummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains information about a public key.</p>
public struct PublicKeySummary: Equatable {
    /// <p>A comment to describe the public key. The comment cannot be longer than 128
    /// 			characters.</p>
    public let comment: String?
    /// <p>The date and time when the public key was uploaded.</p>
    public let createdTime: Date?
    /// <p>The public key.</p>
    public let encodedKey: String?
    /// <p>The identifier of the public key.</p>
    public let id: String?
    /// <p>A name to help identify the public key.</p>
    public let name: String?

    public init (
        comment: String? = nil,
        createdTime: Date? = nil,
        encodedKey: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.comment = comment
        self.createdTime = createdTime
        self.encodedKey = encodedKey
        self.id = id
        self.name = name
    }
}

extension PublishFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishFunctionInput(ifMatch: \(String(describing: ifMatch)), name: \(String(describing: name)))"}
}

extension PublishFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct PublishFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "PublishFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishFunctionInput>
    public typealias MOutput = OperationOutput<PublishFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishFunctionOutputError>
}

public struct PublishFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "PublishFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishFunctionInput>
    public typealias MOutput = OperationOutput<PublishFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishFunctionOutputError>
}

public struct PublishFunctionInput: Equatable {
    /// <p>The current version (<code>ETag</code> value) of the function that you are publishing, which
    /// 			you can get using <code>DescribeFunction</code>.</p>
    public let ifMatch: String?
    /// <p>The name of the function that you are publishing.</p>
    public let name: String?

    public init (
        ifMatch: String? = nil,
        name: String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct PublishFunctionInputBody: Equatable {
}

extension PublishFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension PublishFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension PublishFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishFunctionOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishFunctionOutputResponse(functionSummary: \(String(describing: functionSummary)))"}
}

extension PublishFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FunctionSummary = try responseDecoder.decode(responseBody: unwrappedData)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct PublishFunctionOutputResponse: Equatable {
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public let functionSummary: FunctionSummary?

    public init (
        functionSummary: FunctionSummary? = nil
    )
    {
        self.functionSummary = functionSummary
    }
}

struct PublishFunctionOutputResponseBody: Equatable {
    public let functionSummary: FunctionSummary?
}

extension PublishFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

extension QueryArgProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case profileId = "ProfileId"
        case queryArg = "QueryArg"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let profileId = profileId {
            try container.encode(profileId, forKey: Key("profileId"))
        }
        if let queryArg = queryArg {
            try container.encode(queryArg, forKey: Key("queryArg"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryArgDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queryArg)
        queryArg = queryArgDecoded
        let profileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profileId)
        profileId = profileIdDecoded
    }
}

extension QueryArgProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryArgProfile(profileId: \(String(describing: profileId)), queryArg: \(String(describing: queryArg)))"}
}

extension QueryArgProfile: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Query argument-profile mapping for field-level encryption.</p>
public struct QueryArgProfile: Equatable {
    /// <p>ID of profile to use for field-level encryption query argument-profile mapping</p>
    public let profileId: String?
    /// <p>Query argument for field-level encryption query argument-profile mapping.</p>
    public let queryArg: String?

    public init (
        profileId: String? = nil,
        queryArg: String? = nil
    )
    {
        self.profileId = profileId
        self.queryArg = queryArg
    }
}

extension QueryArgProfileConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forwardWhenQueryArgProfileIsUnknown = "ForwardWhenQueryArgProfileIsUnknown"
        case queryArgProfiles = "QueryArgProfiles"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown {
            try container.encode(forwardWhenQueryArgProfileIsUnknown, forKey: Key("forwardWhenQueryArgProfileIsUnknown"))
        }
        if let queryArgProfiles = queryArgProfiles {
            try container.encode(queryArgProfiles, forKey: Key("queryArgProfiles"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardWhenQueryArgProfileIsUnknownDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .forwardWhenQueryArgProfileIsUnknown)
        forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknownDecoded
        let queryArgProfilesDecoded = try containerValues.decodeIfPresent(QueryArgProfiles.self, forKey: .queryArgProfiles)
        queryArgProfiles = queryArgProfilesDecoded
    }
}

extension QueryArgProfileConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryArgProfileConfig(forwardWhenQueryArgProfileIsUnknown: \(String(describing: forwardWhenQueryArgProfileIsUnknown)), queryArgProfiles: \(String(describing: queryArgProfiles)))"}
}

extension QueryArgProfileConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Configuration for query argument-profile mapping for field-level encryption.</p>
public struct QueryArgProfileConfig: Equatable {
    /// <p>Flag to set if you want a request to be forwarded to the origin even if the profile specified by the field-level encryption query argument,
    /// 			fle-profile, is unknown.</p>
    public let forwardWhenQueryArgProfileIsUnknown: Bool?
    /// <p>Profiles specified for query argument-profile mapping for field-level encryption.</p>
    public let queryArgProfiles: QueryArgProfiles?

    public init (
        forwardWhenQueryArgProfileIsUnknown: Bool? = nil,
        queryArgProfiles: QueryArgProfiles? = nil
    )
    {
        self.forwardWhenQueryArgProfileIsUnknown = forwardWhenQueryArgProfileIsUnknown
        self.queryArgProfiles = queryArgProfiles
    }
}

extension QueryArgProfileEmpty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryArgProfileEmpty(message: \(String(describing: message)))"}
}

extension QueryArgProfileEmpty: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<QueryArgProfileEmptyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>No profile specified for the field-level encryption query argument.</p>
public struct QueryArgProfileEmpty: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct QueryArgProfileEmptyBody: Equatable {
    public let message: String?
}

extension QueryArgProfileEmptyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension QueryArgProfiles: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for queryargprofile0 in items {
                try itemsContainer.encode(queryargprofile0, forKey: Key("QueryArgProfile"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct QueryArgProfile{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.QueryArgProfile>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([QueryArgProfile].self, forKey: .member)
                var itemsBuffer:[QueryArgProfile]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [QueryArgProfile]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension QueryArgProfiles: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryArgProfiles(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension QueryArgProfiles: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Query argument-profile mapping for field-level encryption.</p>
public struct QueryArgProfiles: Equatable {
    /// <p>Number of items for query argument-profile mapping for field-level encryption.</p>
    public let items: [QueryArgProfile]?
    /// <p>Number of profiles for query argument-profile mapping for field-level encryption.</p>
    public let quantity: Int?

    public init (
        items: [QueryArgProfile]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension QueryStringCacheKeys: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension QueryStringCacheKeys: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryStringCacheKeys(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension QueryStringCacheKeys: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>This field is deprecated. We recommend that you use a cache policy or an origin
/// 			request policy instead of this field.</p>
/// 		       <p>If you want to include query strings in the cache key, use
/// 			<code>QueryStringsConfig</code> in a cache policy. See
/// 			<code>CachePolicy</code>.</p>
/// 		       <p>If you want to send query strings to the origin but not include them in the cache key,
/// 			use <code>QueryStringsConfig</code> in an origin request policy. See
/// 			<code>OriginRequestPolicy</code>.</p>
/// 		       <p>A complex type that contains information about the query string parameters that you want
/// 			CloudFront to use for caching for a cache behavior.
/// 		</p>
public struct QueryStringCacheKeys: Equatable {
    /// <p>A list that contains the query string parameters that you want CloudFront to use
    /// 			as a basis for caching for a cache behavior. If <code>Quantity</code> is 0, you can omit
    /// 			<code>Items</code>. </p>
    public let items: [String]?
    /// <p>The number of <code>whitelisted</code> query string parameters for a cache
    /// 			behavior.</p>
    public let quantity: Int?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension QueryStringNames: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("Name"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct Name{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Name>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension QueryStringNames: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryStringNames(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension QueryStringNames: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains a list of query string names.</p>
public struct QueryStringNames: Equatable {
    /// <p>A list of query string names.</p>
    public let items: [String]?
    /// <p>The number of query string names in the <code>Items</code> list.</p>
    public let quantity: Int?

    public init (
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension RealtimeLogConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("aRN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("endPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: Key("samplingRate"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([EndPoint].self, forKey: .member)
                var endPointsBuffer:[EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var fieldsBuffer:[String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
    }
}

extension RealtimeLogConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RealtimeLogConfig(aRN: \(String(describing: aRN)), endPoints: \(String(describing: endPoints)), fields: \(String(describing: fields)), name: \(String(describing: name)), samplingRate: \(String(describing: samplingRate)))"}
}

extension RealtimeLogConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A real-time log configuration.</p>
public struct RealtimeLogConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of this real-time log configuration.</p>
    public let aRN: String?
    /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
    /// 			log data for this real-time log configuration.</p>
    public let endPoints: [EndPoint]?
    /// <p>A list of fields that are included in each real-time log record. In an API response, the
    /// 			fields are provided in the same order in which they are sent to the Amazon Kinesis data
    /// 			stream.</p>
    /// 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let fields: [String]?
    /// <p>The unique name of this real-time log configuration.</p>
    public let name: String?
    /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
    /// 			percentage of viewer requests that are represented in the real-time log data. The
    /// 			sampling rate is an integer between 1 and 100, inclusive.</p>
    public let samplingRate: Int?

    public init (
        aRN: String? = nil,
        endPoints: [EndPoint]? = nil,
        fields: [String]? = nil,
        name: String? = nil,
        samplingRate: Int? = nil
    )
    {
        self.aRN = aRN
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

extension RealtimeLogConfigAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RealtimeLogConfigAlreadyExists(message: \(String(describing: message)))"}
}

extension RealtimeLogConfigAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<RealtimeLogConfigAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A real-time log configuration with this name already exists. You must provide a unique name.
/// 			To modify an existing real-time log configuration, use
/// 			<code>UpdateRealtimeLogConfig</code>.</p>
public struct RealtimeLogConfigAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigAlreadyExistsBody: Equatable {
    public let message: String?
}

extension RealtimeLogConfigAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RealtimeLogConfigInUse(message: \(String(describing: message)))"}
}

extension RealtimeLogConfigInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<RealtimeLogConfigInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete the real-time log configuration because it is attached to one or more cache
/// 			behaviors.</p>
public struct RealtimeLogConfigInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigInUseBody: Equatable {
    public let message: String?
}

extension RealtimeLogConfigInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigOwnerMismatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RealtimeLogConfigOwnerMismatch(message: \(String(describing: message)))"}
}

extension RealtimeLogConfigOwnerMismatch: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<RealtimeLogConfigOwnerMismatchBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified real-time log configuration belongs to a different AWS account.</p>
public struct RealtimeLogConfigOwnerMismatch: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RealtimeLogConfigOwnerMismatchBody: Equatable {
    public let message: String?
}

extension RealtimeLogConfigOwnerMismatchBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RealtimeLogConfigs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: Key("isTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for realtimelogconfig0 in items {
                try itemsContainer.encode(realtimelogconfig0, forKey: Key("member"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct member{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([RealtimeLogConfig].self, forKey: .member)
                var itemsBuffer:[RealtimeLogConfig]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [RealtimeLogConfig]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension RealtimeLogConfigs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RealtimeLogConfigs(isTruncated: \(String(describing: isTruncated)), items: \(String(describing: items)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)))"}
}

extension RealtimeLogConfigs: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of real-time log configurations.</p>
public struct RealtimeLogConfigs: Equatable {
    /// <p>A flag that indicates whether there are more real-time log configurations than are contained
    /// 			in this list.</p>
    public let isTruncated: Bool?
    /// <p>Contains the list of real-time log configurations.</p>
    public let items: [RealtimeLogConfig]?
    /// <p>This parameter indicates where this list of real-time log configurations begins. This list
    /// 			includes real-time log configurations that occur after the marker.</p>
    public let marker: String?
    /// <p>The maximum number of real-time log configurations requested.</p>
    public let maxItems: Int?
    /// <p>If there are more items in the list than are in this response, this element is present. It
    /// 			contains the value that you should use in the <code>Marker</code> field of a subsequent
    /// 			request to continue listing real-time log configurations where you left off. </p>
    public let nextMarker: String?

    public init (
        isTruncated: Bool? = nil,
        items: [RealtimeLogConfig]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil
    )
    {
        self.isTruncated = isTruncated
        self.items = items
        self.marker = marker
        self.maxItems = maxItems
        self.nextMarker = nextMarker
    }
}

extension RealtimeMetricsSubscriptionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case realtimeMetricsSubscriptionStatus = "RealtimeMetricsSubscriptionStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus {
            try container.encode(realtimeMetricsSubscriptionStatus, forKey: Key("realtimeMetricsSubscriptionStatus"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeMetricsSubscriptionStatusDecoded = try containerValues.decodeIfPresent(RealtimeMetricsSubscriptionStatus.self, forKey: .realtimeMetricsSubscriptionStatus)
        realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatusDecoded
    }
}

extension RealtimeMetricsSubscriptionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RealtimeMetricsSubscriptionConfig(realtimeMetricsSubscriptionStatus: \(String(describing: realtimeMetricsSubscriptionStatus)))"}
}

extension RealtimeMetricsSubscriptionConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A subscription configuration for additional CloudWatch metrics.</p>
public struct RealtimeMetricsSubscriptionConfig: Equatable {
    /// <p>A flag that indicates whether additional CloudWatch metrics are enabled for a given
    /// 			CloudFront distribution.</p>
    public let realtimeMetricsSubscriptionStatus: RealtimeMetricsSubscriptionStatus?

    public init (
        realtimeMetricsSubscriptionStatus: RealtimeMetricsSubscriptionStatus? = nil
    )
    {
        self.realtimeMetricsSubscriptionStatus = realtimeMetricsSubscriptionStatus
    }
}

public enum RealtimeMetricsSubscriptionStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension RealtimeMetricsSubscriptionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RealtimeMetricsSubscriptionStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "Disabled"
        case .enabled: return "Enabled"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RealtimeMetricsSubscriptionStatus(rawValue: rawValue) ?? RealtimeMetricsSubscriptionStatus.sdkUnknown(rawValue)
    }
}

extension ResourceInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUse(message: \(String(describing: message)))"}
}

extension ResourceInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceInUseBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot delete this resource because it is in use.</p>
public struct ResourceInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseBody: Equatable {
    public let message: String?
}

extension ResourceInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Restrictions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case geoRestriction = "GeoRestriction"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let geoRestriction = geoRestriction {
            try container.encode(geoRestriction, forKey: Key("geoRestriction"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoRestrictionDecoded = try containerValues.decodeIfPresent(GeoRestriction.self, forKey: .geoRestriction)
        geoRestriction = geoRestrictionDecoded
    }
}

extension Restrictions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Restrictions(geoRestriction: \(String(describing: geoRestriction)))"}
}

extension Restrictions: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that identifies ways in which you want to restrict distribution of your
/// 			content.</p>
public struct Restrictions: Equatable {
    /// <p>A complex type that controls the countries in which your content is distributed. CloudFront
    /// 			determines the location of your users using <code>MaxMind</code> GeoIP databases.</p>
    public let geoRestriction: GeoRestriction?

    public init (
        geoRestriction: GeoRestriction? = nil
    )
    {
        self.geoRestriction = geoRestriction
    }
}

extension S3Origin: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("domainName"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: Key("originAccessIdentity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension S3Origin: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Origin(domainName: \(String(describing: domainName)), originAccessIdentity: \(String(describing: originAccessIdentity)))"}
}

extension S3Origin: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains information about the Amazon S3 bucket from which you want
/// 			CloudFront to get your media files for distribution.</p>
public struct S3Origin: Equatable {
    /// <p>The DNS name of the Amazon S3 origin. </p>
    public let domainName: String?
    /// <p>The CloudFront origin access identity to associate with the distribution. Use an origin
    /// 			access identity to configure the distribution so that end users can only access objects in an
    /// 			Amazon S3 bucket through CloudFront.</p>
    /// 		       <p>If you want end users to be able to access objects using either the CloudFront URL or the
    /// 			Amazon S3 URL, specify an empty <code>OriginAccessIdentity</code> element.</p>
    /// 		       <p>To delete the origin access identity from an existing distribution, update the
    /// 			distribution configuration and include an empty <code>OriginAccessIdentity</code>
    /// 			element.</p>
    /// 		       <p>To replace the origin access identity, update the distribution configuration and
    /// 			specify the new origin access identity.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-restricting-access-to-s3.html">Using an Origin Access
    /// 				Identity to Restrict Access to Your Amazon S3 Content</a> in the <i>
    /// 				Amazon CloudFront Developer Guide</i>.</p>
    public let originAccessIdentity: String?

    public init (
        domainName: String? = nil,
        originAccessIdentity: String? = nil
    )
    {
        self.domainName = domainName
        self.originAccessIdentity = originAccessIdentity
    }
}

extension S3OriginConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case originAccessIdentity = "OriginAccessIdentity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let originAccessIdentity = originAccessIdentity {
            try container.encode(originAccessIdentity, forKey: Key("originAccessIdentity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccessIdentityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originAccessIdentity)
        originAccessIdentity = originAccessIdentityDecoded
    }
}

extension S3OriginConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3OriginConfig(originAccessIdentity: \(String(describing: originAccessIdentity)))"}
}

extension S3OriginConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that contains information about the Amazon S3 origin. If the origin is a
/// 			custom origin or an S3 bucket that is configured as a website endpoint, use the
///             <code>CustomOriginConfig</code> element instead.</p>
public struct S3OriginConfig: Equatable {
    /// <p>The CloudFront origin access identity to associate with the origin. Use an origin access
    /// 			identity to configure the origin so that viewers can <i>only</i> access objects
    /// 			in an Amazon S3 bucket through CloudFront. The format of the value is:</p>
    /// 		       <p>origin-access-identity/cloudfront/<i>ID-of-origin-access-identity</i>
    ///          </p>
    /// 		       <p>where <code>
    ///                <i>ID-of-origin-access-identity</i>
    ///             </code> is the value that
    /// 			CloudFront returned in the <code>ID</code> element when you created the origin access
    /// 			identity.</p>
    /// 		       <p>If you want viewers to be able to access objects using either the CloudFront URL or the Amazon S3
    /// 			URL, specify an empty <code>OriginAccessIdentity</code> element.</p>
    /// 		       <p>To delete the origin access identity from an existing distribution, update the
    /// 			distribution configuration and include an empty <code>OriginAccessIdentity</code>
    /// 			element.</p>
    /// 		       <p>To replace the origin access identity, update the distribution configuration and
    /// 			specify the new origin access identity.</p>
    /// 		       <p>For more information about the origin access identity, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through CloudFront</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public let originAccessIdentity: String?

    public init (
        originAccessIdentity: String? = nil
    )
    {
        self.originAccessIdentity = originAccessIdentity
    }
}

public enum SSLSupportMethod {
    case sniOnly
    case staticIp
    case vip
    case sdkUnknown(String)
}

extension SSLSupportMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SSLSupportMethod] {
        return [
            .sniOnly,
            .staticIp,
            .vip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sniOnly: return "sni-only"
        case .staticIp: return "static-ip"
        case .vip: return "vip"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SSLSupportMethod(rawValue: rawValue) ?? SSLSupportMethod.sdkUnknown(rawValue)
    }
}

extension Signer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccountNumber = "AwsAccountNumber"
        case keyPairIds = "KeyPairIds"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let awsAccountNumber = awsAccountNumber {
            try container.encode(awsAccountNumber, forKey: Key("awsAccountNumber"))
        }
        if let keyPairIds = keyPairIds {
            try container.encode(keyPairIds, forKey: Key("keyPairIds"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountNumber)
        awsAccountNumber = awsAccountNumberDecoded
        let keyPairIdsDecoded = try containerValues.decodeIfPresent(KeyPairIds.self, forKey: .keyPairIds)
        keyPairIds = keyPairIdsDecoded
    }
}

extension Signer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Signer(awsAccountNumber: \(String(describing: awsAccountNumber)), keyPairIds: \(String(describing: keyPairIds)))"}
}

extension Signer: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of AWS accounts and the active CloudFront key pairs in each account that CloudFront can use to
/// 			verify the signatures of signed URLs and signed cookies.</p>
public struct Signer: Equatable {
    /// <p>An AWS account number that contains active CloudFront key pairs that CloudFront can use to verify the
    /// 			signatures of signed URLs and signed cookies. If the AWS account that owns the key pairs
    /// 			is the same account that owns the CloudFront distribution, the value of this field is
    /// 			<code>self</code>.</p>
    public let awsAccountNumber: String?
    /// <p>A list of CloudFront key pair identifiers.</p>
    public let keyPairIds: KeyPairIds?

    public init (
        awsAccountNumber: String? = nil,
        keyPairIds: KeyPairIds? = nil
    )
    {
        self.awsAccountNumber = awsAccountNumber
        self.keyPairIds = keyPairIds
    }
}

public enum SslProtocol {
    case sslv3
    case tlsv1
    case tlsv11
    case tlsv12
    case sdkUnknown(String)
}

extension SslProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SslProtocol] {
        return [
            .sslv3,
            .tlsv1,
            .tlsv11,
            .tlsv12,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sslv3: return "SSLv3"
        case .tlsv1: return "TLSv1"
        case .tlsv11: return "TLSv1.1"
        case .tlsv12: return "TLSv1.2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SslProtocol(rawValue: rawValue) ?? SslProtocol.sdkUnknown(rawValue)
    }
}

extension StatusCodes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for integer0 in items {
                try itemsContainer.encode(integer0, forKey: Key("StatusCode"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StatusCode{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StatusCode>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Int].self, forKey: .member)
                var itemsBuffer:[Int]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Int]()
                    for integerContainer0 in itemsContainer {
                        itemsBuffer?.append(integerContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension StatusCodes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatusCodes(items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension StatusCodes: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex data type for the status codes that you specify that, when returned by a primary origin, trigger
/// 		CloudFront to failover to a second origin.</p>
public struct StatusCodes: Equatable {
    /// <p>The items (status codes) for an origin group.</p>
    public let items: [Int]?
    /// <p>The number of status codes.</p>
    public let quantity: Int?

    public init (
        items: [Int]? = nil,
        quantity: Int? = nil
    )
    {
        self.items = items
        self.quantity = quantity
    }
}

extension StreamingDistribution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case activeTrustedSigners = "ActiveTrustedSigners"
        case domainName = "DomainName"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case status = "Status"
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("aRN"))
        }
        if let activeTrustedSigners = activeTrustedSigners {
            try container.encode(activeTrustedSigners, forKey: Key("activeTrustedSigners"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("domainName"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: Key("streamingDistributionConfig"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let activeTrustedSignersDecoded = try containerValues.decodeIfPresent(ActiveTrustedSigners.self, forKey: .activeTrustedSigners)
        activeTrustedSigners = activeTrustedSignersDecoded
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension StreamingDistribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingDistribution(aRN: \(String(describing: aRN)), activeTrustedSigners: \(String(describing: activeTrustedSigners)), domainName: \(String(describing: domainName)), id: \(String(describing: id)), lastModifiedTime: \(String(describing: lastModifiedTime)), status: \(String(describing: status)), streamingDistributionConfig: \(String(describing: streamingDistributionConfig)))"}
}

extension StreamingDistribution: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A streaming distribution tells CloudFront where you want RTMP content to be delivered from, and the details about how to
/// 			track and manage content delivery.</p>
public struct StreamingDistribution: Equatable {
    /// <p>The ARN (Amazon Resource Name) for the distribution. For example:
    /// 			<code>arn:aws:cloudfront::123456789012:distribution/EDFDVBD632BHDS5</code>, where
    /// 			<code>123456789012</code> is your AWS account ID.</p>
    public let aRN: String?
    /// <p>A complex type that lists the AWS accounts, if any, that you included in the
    /// 				<code>TrustedSigners</code> complex type for this distribution. These are the accounts that
    /// 			you want to allow to create signed URLs for private content.</p>
    /// 		       <p>The <code>Signer</code> complex type lists the AWS account number of the trusted
    /// 			signer or <code>self</code> if the signer is the AWS account that created the distribution.
    /// 			The <code>Signer</code> element also includes the IDs of any active CloudFront key pairs that are
    /// 			associated with the trusted signer's AWS account. If no <code>KeyPairId</code> element
    /// 			appears for a <code>Signer</code>, that signer can't create signed URLs.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private
    /// 				Content through CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
    public let activeTrustedSigners: ActiveTrustedSigners?
    /// <p>The domain name that corresponds to the streaming distribution, for example, <code>s5c39gqb8ow64r.cloudfront.net</code>. </p>
    public let domainName: String?
    /// <p>The identifier for the RTMP distribution. For example:
    /// 			<code>EGTXBD79EXAMPLE</code>.</p>
    public let id: String?
    /// <p>The date and time that the distribution was last modified. </p>
    public let lastModifiedTime: Date?
    /// <p>The current status of the RTMP distribution. When the status is <code>Deployed</code>,
    /// 			the distribution's information is propagated to all CloudFront edge locations.</p>
    public let status: String?
    /// <p>The current configuration information for the RTMP distribution.</p>
    public let streamingDistributionConfig: StreamingDistributionConfig?

    public init (
        aRN: String? = nil,
        activeTrustedSigners: ActiveTrustedSigners? = nil,
        domainName: String? = nil,
        id: String? = nil,
        lastModifiedTime: Date? = nil,
        status: String? = nil,
        streamingDistributionConfig: StreamingDistributionConfig? = nil
    )
    {
        self.aRN = aRN
        self.activeTrustedSigners = activeTrustedSigners
        self.domainName = domainName
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.status = status
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

extension StreamingDistributionAlreadyExists: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingDistributionAlreadyExists(message: \(String(describing: message)))"}
}

extension StreamingDistributionAlreadyExists: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StreamingDistributionAlreadyExistsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The caller reference you attempted to create the streaming distribution with
/// 			is associated with another distribution</p>
public struct StreamingDistributionAlreadyExists: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StreamingDistributionAlreadyExistsBody: Equatable {
    public let message: String?
}

extension StreamingDistributionAlreadyExistsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StreamingDistributionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case callerReference = "CallerReference"
        case comment = "Comment"
        case enabled = "Enabled"
        case logging = "Logging"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: Key("aliases"))
        }
        if let callerReference = callerReference {
            try container.encode(callerReference, forKey: Key("callerReference"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let logging = logging {
            try container.encode(logging, forKey: Key("logging"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: Key("priceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: Key("s3Origin"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: Key("trustedSigners"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerReference)
        callerReference = callerReferenceDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(StreamingLoggingConfig.self, forKey: .logging)
        logging = loggingDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension StreamingDistributionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingDistributionConfig(aliases: \(String(describing: aliases)), callerReference: \(String(describing: callerReference)), comment: \(String(describing: comment)), enabled: \(String(describing: enabled)), logging: \(String(describing: logging)), priceClass: \(String(describing: priceClass)), s3Origin: \(String(describing: s3Origin)), trustedSigners: \(String(describing: trustedSigners)))"}
}

extension StreamingDistributionConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>The RTMP distribution's configuration information.</p>
public struct StreamingDistributionConfig: Equatable {
    /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
    /// 			for this streaming distribution. </p>
    public let aliases: Aliases?
    /// <p>A unique value (for example, a date-time stamp) that ensures that the request can't be
    /// 			replayed.</p>
    /// 		       <p>If the value of <code>CallerReference</code> is new (regardless of the content of the
    /// 			<code>StreamingDistributionConfig</code> object), CloudFront creates a new distribution.</p>
    /// 		       <p>If <code>CallerReference</code> is a value that you already sent in a previous request to
    /// 			create a distribution, CloudFront returns a <code>DistributionAlreadyExists</code> error.</p>
    public let callerReference: String?
    /// <p>Any comments you want to include about the streaming distribution. </p>
    public let comment: String?
    /// <p>Whether the streaming distribution is enabled to accept user requests for
    /// 			content.</p>
    public let enabled: Bool?
    /// <p>A complex type that controls whether access logs are written for the streaming
    /// 			distribution. </p>
    public let logging: StreamingLoggingConfig?
    /// <p>A complex type that contains information about price class for this streaming
    /// 			distribution. </p>
    public let priceClass: PriceClass?
    /// <p>A complex type that contains information about the Amazon S3 bucket from which you want
    /// 			CloudFront to get your media files for distribution. </p>
    public let s3Origin: S3Origin?
    /// <p>A complex type that specifies any AWS accounts that you want to permit to create signed
    /// 			URLs for private content. If you want the distribution to use signed URLs, include this
    /// 			element; if you want the distribution to use public URLs, remove this element. For more
    /// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through
    /// 				CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
    public let trustedSigners: TrustedSigners?

    public init (
        aliases: Aliases? = nil,
        callerReference: String? = nil,
        comment: String? = nil,
        enabled: Bool? = nil,
        logging: StreamingLoggingConfig? = nil,
        priceClass: PriceClass? = nil,
        s3Origin: S3Origin? = nil,
        trustedSigners: TrustedSigners? = nil
    )
    {
        self.aliases = aliases
        self.callerReference = callerReference
        self.comment = comment
        self.enabled = enabled
        self.logging = logging
        self.priceClass = priceClass
        self.s3Origin = s3Origin
        self.trustedSigners = trustedSigners
    }
}

extension StreamingDistributionConfigWithTags: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: Key("streamingDistributionConfig"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: Key("tags"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension StreamingDistributionConfigWithTags: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingDistributionConfigWithTags(streamingDistributionConfig: \(String(describing: streamingDistributionConfig)), tags: \(String(describing: tags)))"}
}

extension StreamingDistributionConfigWithTags: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A streaming distribution Configuration and a list of tags to be associated with the
/// 			streaming distribution.</p>
public struct StreamingDistributionConfigWithTags: Equatable {
    /// <p>A streaming distribution Configuration.</p>
    public let streamingDistributionConfig: StreamingDistributionConfig?
    /// <p>A complex type that contains zero or more <code>Tag</code> elements.</p>
    public let tags: Tags?

    public init (
        streamingDistributionConfig: StreamingDistributionConfig? = nil,
        tags: Tags? = nil
    )
    {
        self.streamingDistributionConfig = streamingDistributionConfig
        self.tags = tags
    }
}

extension StreamingDistributionList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isTruncated = "IsTruncated"
        case items = "Items"
        case marker = "Marker"
        case maxItems = "MaxItems"
        case nextMarker = "NextMarker"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let isTruncated = isTruncated {
            try container.encode(isTruncated, forKey: Key("isTruncated"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for streamingdistributionsummary0 in items {
                try itemsContainer.encode(streamingdistributionsummary0, forKey: Key("StreamingDistributionSummary"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("marker"))
        }
        if let maxItems = maxItems {
            try container.encode(maxItems, forKey: Key("maxItems"))
        }
        if let nextMarker = nextMarker {
            try container.encode(nextMarker, forKey: Key("nextMarker"))
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .marker)
        marker = markerDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let maxItemsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
        let isTruncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isTruncated)
        isTruncated = isTruncatedDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct StreamingDistributionSummary{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.StreamingDistributionSummary>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([StreamingDistributionSummary].self, forKey: .member)
                var itemsBuffer:[StreamingDistributionSummary]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [StreamingDistributionSummary]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension StreamingDistributionList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingDistributionList(isTruncated: \(String(describing: isTruncated)), items: \(String(describing: items)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)), nextMarker: \(String(describing: nextMarker)), quantity: \(String(describing: quantity)))"}
}

extension StreamingDistributionList: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A streaming distribution list. </p>
public struct StreamingDistributionList: Equatable {
    /// <p>A flag that indicates whether more streaming distributions remain to be listed. If your
    /// 			results were truncated, you can make a follow-up pagination request using the
    /// 				<code>Marker</code> request parameter to retrieve more distributions in the list. </p>
    public let isTruncated: Bool?
    /// <p>A complex type that contains one <code>StreamingDistributionSummary</code> element for
    /// 			each distribution that was created by the current AWS account.</p>
    public let items: [StreamingDistributionSummary]?
    /// <p>The value you provided for the <code>Marker</code> request parameter. </p>
    public let marker: String?
    /// <p>The value you provided for the <code>MaxItems</code> request parameter. </p>
    public let maxItems: Int?
    /// <p>If <code>IsTruncated</code> is <code>true</code>, this element is present and contains
    /// 			the value you can use for the <code>Marker</code> request parameter to continue listing your
    /// 			RTMP distributions where they left off. </p>
    public let nextMarker: String?
    /// <p>The number of streaming distributions that were created by the current AWS account.
    /// 		</p>
    public let quantity: Int?

    public init (
        isTruncated: Bool? = nil,
        items: [StreamingDistributionSummary]? = nil,
        marker: String? = nil,
        maxItems: Int? = nil,
        nextMarker: String? = nil,
        quantity: Int? = nil
    )
    {
        self.isTruncated = isTruncated
        self.items = items
        self.marker = marker
        self.maxItems = maxItems
        self.nextMarker = nextMarker
        self.quantity = quantity
    }
}

extension StreamingDistributionNotDisabled: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingDistributionNotDisabled(message: \(String(describing: message)))"}
}

extension StreamingDistributionNotDisabled: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<StreamingDistributionNotDisabledBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified CloudFront distribution is not disabled. You must disable
/// 			the distribution before you can delete it.</p>
public struct StreamingDistributionNotDisabled: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StreamingDistributionNotDisabledBody: Equatable {
    public let message: String?
}

extension StreamingDistributionNotDisabledBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StreamingDistributionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case aliases = "Aliases"
        case comment = "Comment"
        case domainName = "DomainName"
        case enabled = "Enabled"
        case id = "Id"
        case lastModifiedTime = "LastModifiedTime"
        case priceClass = "PriceClass"
        case s3Origin = "S3Origin"
        case status = "Status"
        case trustedSigners = "TrustedSigners"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("aRN"))
        }
        if let aliases = aliases {
            try container.encode(aliases, forKey: Key("aliases"))
        }
        if let comment = comment {
            try container.encode(comment, forKey: Key("comment"))
        }
        if let domainName = domainName {
            try container.encode(domainName, forKey: Key("domainName"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("id"))
        }
        if let lastModifiedTime = lastModifiedTime {
            try container.encode(TimestampWrapper(lastModifiedTime, format: .dateTime), forKey: Key("lastModifiedTime"))
        }
        if let priceClass = priceClass {
            try container.encode(priceClass, forKey: Key("priceClass"))
        }
        if let s3Origin = s3Origin {
            try container.encode(s3Origin, forKey: Key("s3Origin"))
        }
        if let status = status {
            try container.encode(status, forKey: Key("status"))
        }
        if let trustedSigners = trustedSigners {
            try container.encode(trustedSigners, forKey: Key("trustedSigners"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedTime)
        var lastModifiedTimeBuffer:Date? = nil
        if let lastModifiedTimeDecoded = lastModifiedTimeDecoded {
            lastModifiedTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(lastModifiedTimeDecoded, format: .dateTime)
        }
        lastModifiedTime = lastModifiedTimeBuffer
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let s3OriginDecoded = try containerValues.decodeIfPresent(S3Origin.self, forKey: .s3Origin)
        s3Origin = s3OriginDecoded
        let aliasesDecoded = try containerValues.decodeIfPresent(Aliases.self, forKey: .aliases)
        aliases = aliasesDecoded
        let trustedSignersDecoded = try containerValues.decodeIfPresent(TrustedSigners.self, forKey: .trustedSigners)
        trustedSigners = trustedSignersDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let priceClassDecoded = try containerValues.decodeIfPresent(PriceClass.self, forKey: .priceClass)
        priceClass = priceClassDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension StreamingDistributionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingDistributionSummary(aRN: \(String(describing: aRN)), aliases: \(String(describing: aliases)), comment: \(String(describing: comment)), domainName: \(String(describing: domainName)), enabled: \(String(describing: enabled)), id: \(String(describing: id)), lastModifiedTime: \(String(describing: lastModifiedTime)), priceClass: \(String(describing: priceClass)), s3Origin: \(String(describing: s3Origin)), status: \(String(describing: status)), trustedSigners: \(String(describing: trustedSigners)))"}
}

extension StreamingDistributionSummary: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p> A summary of the information for a CloudFront streaming distribution.</p>
public struct StreamingDistributionSummary: Equatable {
    /// <p> The ARN (Amazon Resource Name) for the streaming distribution. For example:
    /// 				<code>arn:aws:cloudfront::123456789012:streaming-distribution/EDFDVBD632BHDS5</code>, where
    /// 				<code>123456789012</code> is your AWS account ID.</p>
    public let aRN: String?
    /// <p>A complex type that contains information about CNAMEs (alternate domain names), if any,
    /// 			for this streaming distribution.</p>
    public let aliases: Aliases?
    /// <p>The comment originally specified when this distribution was created.</p>
    public let comment: String?
    /// <p>The domain name corresponding to the distribution, for example, <code>d111111abcdef8.cloudfront.net</code>.</p>
    public let domainName: String?
    /// <p>Whether the distribution is enabled to accept end user requests for content.</p>
    public let enabled: Bool?
    /// <p>The identifier for the distribution, for example, <code>EDFDVBD632BHDS5</code>.</p>
    public let id: String?
    /// <p>The date and time the distribution was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>A complex type that contains information about price class for this streaming
    /// 			distribution. </p>
    public let priceClass: PriceClass?
    /// <p>A complex type that contains information about the Amazon S3 bucket from which you want
    /// 			CloudFront to get your media files for distribution.</p>
    public let s3Origin: S3Origin?
    /// <p> Indicates the current status of the distribution. When the status is
    /// 			<code>Deployed</code>, the distribution's information is fully propagated throughout the
    /// 			Amazon CloudFront system.</p>
    public let status: String?
    /// <p>A complex type that specifies the AWS accounts, if any, that you want to allow to
    /// 			create signed URLs for private content. If you want to require signed URLs in requests for
    /// 			objects in the target origin that match the <code>PathPattern</code> for this cache behavior,
    /// 			specify <code>true</code> for <code>Enabled</code>, and specify the applicable values for
    /// 				<code>Quantity</code> and <code>Items</code>.If you don't want to require signed URLs in
    /// 			requests for objects that match <code>PathPattern</code>, specify <code>false</code> for
    /// 				<code>Enabled</code> and <code>0</code> for <code>Quantity</code>. Omit <code>Items</code>.
    /// 			To add, change, or remove one or more trusted signers, change <code>Enabled</code> to
    /// 				<code>true</code> (if it's currently <code>false</code>), change <code>Quantity</code> as
    /// 			applicable, and specify all of the trusted signers that you want to include in the updated
    /// 			distribution.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private
    /// 			Content through CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>. </p>
    public let trustedSigners: TrustedSigners?

    public init (
        aRN: String? = nil,
        aliases: Aliases? = nil,
        comment: String? = nil,
        domainName: String? = nil,
        enabled: Bool? = nil,
        id: String? = nil,
        lastModifiedTime: Date? = nil,
        priceClass: PriceClass? = nil,
        s3Origin: S3Origin? = nil,
        status: String? = nil,
        trustedSigners: TrustedSigners? = nil
    )
    {
        self.aRN = aRN
        self.aliases = aliases
        self.comment = comment
        self.domainName = domainName
        self.enabled = enabled
        self.id = id
        self.lastModifiedTime = lastModifiedTime
        self.priceClass = priceClass
        self.s3Origin = s3Origin
        self.status = status
        self.trustedSigners = trustedSigners
    }
}

extension StreamingLoggingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case enabled = "Enabled"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let bucket = bucket {
            try container.encode(bucket, forKey: Key("bucket"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let prefix = prefix {
            try container.encode(prefix, forKey: Key("prefix"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension StreamingLoggingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamingLoggingConfig(bucket: \(String(describing: bucket)), enabled: \(String(describing: enabled)), prefix: \(String(describing: prefix)))"}
}

extension StreamingLoggingConfig: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that controls whether access logs are written for this streaming distribution.</p>
public struct StreamingLoggingConfig: Equatable {
    /// <p>The Amazon S3 bucket to store the access logs in, for example, <code>myawslogbucket.s3.amazonaws.com</code>.</p>
    public let bucket: String?
    /// <p>Specifies whether you want CloudFront to save access logs to an Amazon S3 bucket. If you don't
    /// 			want to enable logging when you create a streaming distribution or if you want to disable
    /// 			logging for an existing streaming distribution, specify <code>false</code> for
    /// 				<code>Enabled</code>, and specify <code>empty Bucket</code> and <code>Prefix</code>
    /// 			elements. If you specify <code>false</code> for <code>Enabled</code> but you specify values
    /// 			for <code>Bucket</code> and <code>Prefix</code>, the values are automatically deleted.
    /// 		</p>
    public let enabled: Bool?
    /// <p>An optional string that you want CloudFront to prefix to the access log filenames for this streaming distribution, for example,
    /// 			<code>myprefix/</code>. If you want to enable logging, but you don't want to specify a prefix, you still must include
    /// 			an empty <code>Prefix</code> element in the <code>Logging</code> element.</p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        enabled: Bool? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.enabled = enabled
        self.prefix = prefix
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let key = key {
            try container.encode(key, forKey: Key("key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

extension Tag: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p> A complex type that contains <code>Tag</code> key and <code>Tag</code> value.</p>
public struct Tag: Equatable {
    /// <p> A string that contains <code>Tag</code> key.</p>
    /// 		       <p>The string length should be between 1 and 128 characters. Valid characters include
    /// 				<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, space, and the special characters
    /// 				<code>_ - . : / = + @</code>.</p>
    public let key: String?
    /// <p> A string that contains an optional <code>Tag</code> value.</p>
    /// 		       <p>The string length should be between 0 and 256 characters. Valid characters include
    /// 				<code>a-z</code>, <code>A-Z</code>, <code>0-9</code>, space, and the special characters
    /// 				<code>_ - . : / = + @</code>.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagKeys: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for tagkey0 in items {
                try itemsContainer.encode(tagkey0, forKey: Key("Key"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Key{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Key>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension TagKeys: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagKeys(items: \(String(describing: items)))"}
}

extension TagKeys: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
public struct TagKeys: Equatable {
    /// <p> A complex type that contains <code>Tag</code> key elements.</p>
    public let items: [String]?

    public init (
        items: [String]? = nil
    )
    {
        self.items = items
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tags = input.operationInput.tags {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(tags)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resource: \(String(describing: resource)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let tags = tags {
            try container.encode(tags, forKey: Key("Tags"))
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "Operation", value: "Tag"))
        if let resource = input.operationInput.resource {
            let resourceQueryItem = URLQueryItem(name: "Resource".urlPercentEncoding(), value: String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p> The request to add tags to a CloudFront resource.</p>
public struct TagResourceInput: Equatable {
    /// <p> An ARN of a CloudFront resource.</p>
    public let resource: String?
    /// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
    public let tags: Tags?

    public init (
        resource: String? = nil,
        tags: Tags? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: Tags?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsDecoded = try containerValues.decodeIfPresent(Tags.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tags: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case items = "Items"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for tag0 in items {
                try itemsContainer.encode(tag0, forKey: Key("Tag"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.items) {
            struct KeyVal0{struct Tag{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Tag>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var itemsBuffer:[Tag]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [Tag]()
                    for structureContainer0 in itemsContainer {
                        itemsBuffer?.append(structureContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension Tags: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tags(items: \(String(describing: items)))"}
}

extension Tags: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p> A complex type that contains zero or more <code>Tag</code> elements.</p>
public struct Tags: Equatable {
    /// <p> A complex type that contains <code>Tag</code> elements.</p>
    public let items: [Tag]?

    public init (
        items: [Tag]? = nil
    )
    {
        self.items = items
    }
}

extension TestFunctionFailed: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestFunctionFailed(message: \(String(describing: message)))"}
}

extension TestFunctionFailed: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TestFunctionFailedBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The CloudFront function failed.</p>
public struct TestFunctionFailed: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TestFunctionFailedBody: Equatable {
    public let message: String?
}

extension TestFunctionFailedBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TestFunctionInputBodyMiddleware: Middleware {
    public let id: String = "TestFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestFunctionInput>
    public typealias MOutput = OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestFunctionOutputError>
}

extension TestFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestFunctionInput(eventObject: \(String(describing: eventObject)), ifMatch: \(String(describing: ifMatch)), name: \(String(describing: name)), stage: \(String(describing: stage)))"}
}

extension TestFunctionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension TestFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let eventObject = eventObject {
            try container.encode(eventObject, forKey: Key("eventObject"))
        }
        if let stage = stage {
            try container.encode(stage, forKey: Key("stage"))
        }
    }
}

public struct TestFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "TestFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestFunctionInput>
    public typealias MOutput = OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestFunctionOutputError>
}

public struct TestFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "TestFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<TestFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestFunctionInput>
    public typealias MOutput = OperationOutput<TestFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestFunctionOutputError>
}

public struct TestFunctionInput: Equatable {
    /// <p>The event object to test the function with. For more information about the structure of the
    /// 			event object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let eventObject: Data?
    /// <p>The current version (<code>ETag</code> value) of the function that you are testing, which
    /// 			you can get using <code>DescribeFunction</code>.</p>
    public let ifMatch: String?
    /// <p>The name of the function that you are testing.</p>
    public let name: String?
    /// <p>The stage of the function that you are testing, either <code>DEVELOPMENT</code> or
    /// 			<code>LIVE</code>.</p>
    public let stage: FunctionStage?

    public init (
        eventObject: Data? = nil,
        ifMatch: String? = nil,
        name: String? = nil,
        stage: FunctionStage? = nil
    )
    {
        self.eventObject = eventObject
        self.ifMatch = ifMatch
        self.name = name
        self.stage = stage
    }
}

struct TestFunctionInputBody: Equatable {
    public let stage: FunctionStage?
    public let eventObject: Data?
}

extension TestFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventObject = "EventObject"
        case stage = "Stage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(FunctionStage.self, forKey: .stage)
        stage = stageDecoded
        if containerValues.contains(.eventObject) {
            do {
                let eventObjectDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .eventObject)
                eventObject = eventObjectDecoded
            } catch {
                eventObject = "".data(using: .utf8)
            }
        } else {
            eventObject = nil
        }
    }
}

extension TestFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension TestFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TestFunctionFailed" : self = .testFunctionFailed(try TestFunctionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestFunctionOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case testFunctionFailed(TestFunctionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestFunctionOutputResponse(testResult: \(String(describing: testResult)))"}
}

extension TestFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: TestResult = try responseDecoder.decode(responseBody: unwrappedData)
                self.testResult = output
            } else {
                self.testResult = nil
            }
        } else {
            self.testResult = nil
        }
    }
}

public struct TestFunctionOutputResponse: Equatable {
    /// <p>An object that represents the result of running the function with the provided event
    /// 			object.</p>
    public let testResult: TestResult?

    public init (
        testResult: TestResult? = nil
    )
    {
        self.testResult = testResult
    }
}

struct TestFunctionOutputResponseBody: Equatable {
    public let testResult: TestResult?
}

extension TestFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case testResult = "TestResult"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testResultDecoded = try containerValues.decodeIfPresent(TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
    }
}

extension TestResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case computeUtilization = "ComputeUtilization"
        case functionErrorMessage = "FunctionErrorMessage"
        case functionExecutionLogs = "FunctionExecutionLogs"
        case functionOutput = "FunctionOutput"
        case functionSummary = "FunctionSummary"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let computeUtilization = computeUtilization {
            try container.encode(computeUtilization, forKey: Key("computeUtilization"))
        }
        if let functionErrorMessage = functionErrorMessage {
            try container.encode(functionErrorMessage, forKey: Key("functionErrorMessage"))
        }
        if let functionExecutionLogs = functionExecutionLogs {
            var functionExecutionLogsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("functionExecutionLogs"))
            for string0 in functionExecutionLogs {
                try functionExecutionLogsContainer.encode(string0, forKey: Key("member"))
            }
        }
        if let functionOutput = functionOutput {
            try container.encode(functionOutput, forKey: Key("functionOutput"))
        }
        if let functionSummary = functionSummary {
            try container.encode(functionSummary, forKey: Key("functionSummary"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
        let computeUtilizationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .computeUtilization)
        computeUtilization = computeUtilizationDecoded
        if containerValues.contains(.functionExecutionLogs) {
            struct KeyVal0{struct member{}}
            let functionExecutionLogsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .functionExecutionLogs)
            if let functionExecutionLogsWrappedContainer = functionExecutionLogsWrappedContainer {
                let functionExecutionLogsContainer = try functionExecutionLogsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var functionExecutionLogsBuffer:[String]? = nil
                if let functionExecutionLogsContainer = functionExecutionLogsContainer {
                    functionExecutionLogsBuffer = [String]()
                    for stringContainer0 in functionExecutionLogsContainer {
                        functionExecutionLogsBuffer?.append(stringContainer0)
                    }
                }
                functionExecutionLogs = functionExecutionLogsBuffer
            } else {
                functionExecutionLogs = []
            }
        } else {
            functionExecutionLogs = nil
        }
        let functionErrorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionErrorMessage)
        functionErrorMessage = functionErrorMessageDecoded
        let functionOutputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionOutput)
        functionOutput = functionOutputDecoded
    }
}

extension TestResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestResult(computeUtilization: \(String(describing: computeUtilization)), functionErrorMessage: \(String(describing: functionErrorMessage)), functionExecutionLogs: \(String(describing: functionExecutionLogs)), functionOutput: \(String(describing: functionOutput)), functionSummary: \(String(describing: functionSummary)))"}
}

extension TestResult: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>Contains the result of testing a CloudFront function with <code>TestFunction</code>.</p>
public struct TestResult: Equatable {
    /// <p>The amount of time that the function took to run as a percentage of the maximum
    /// 			allowed time. For example, a compute utilization of 35 means that the function completed
    /// 			in 35% of the maximum allowed time.</p>
    public let computeUtilization: String?
    /// <p>If the result of testing the function was an error, this field contains the error
    /// 			message.</p>
    public let functionErrorMessage: String?
    /// <p>Contains the log lines that the function wrote (if any) when running the test.</p>
    public let functionExecutionLogs: [String]?
    /// <p>The event object returned by the function. For more information about the structure of the
    /// 			event object, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html">Event object
    /// 			structure</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let functionOutput: String?
    /// <p>Contains configuration information and metadata about the CloudFront function that was
    /// 			tested.</p>
    public let functionSummary: FunctionSummary?

    public init (
        computeUtilization: String? = nil,
        functionErrorMessage: String? = nil,
        functionExecutionLogs: [String]? = nil,
        functionOutput: String? = nil,
        functionSummary: FunctionSummary? = nil
    )
    {
        self.computeUtilization = computeUtilization
        self.functionErrorMessage = functionErrorMessage
        self.functionExecutionLogs = functionExecutionLogs
        self.functionOutput = functionOutput
        self.functionSummary = functionSummary
    }
}

extension TooManyCacheBehaviors: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyCacheBehaviors(message: \(String(describing: message)))"}
}

extension TooManyCacheBehaviors: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyCacheBehaviorsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot create more cache behaviors for the distribution.</p>
public struct TooManyCacheBehaviors: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCacheBehaviorsBody: Equatable {
    public let message: String?
}

extension TooManyCacheBehaviorsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCachePolicies: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyCachePolicies(message: \(String(describing: message)))"}
}

extension TooManyCachePolicies: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyCachePoliciesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of cache policies for this AWS account. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyCachePolicies: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCachePoliciesBody: Equatable {
    public let message: String?
}

extension TooManyCachePoliciesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCertificates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyCertificates(message: \(String(describing: message)))"}
}

extension TooManyCertificates: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyCertificatesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot create anymore custom SSL/TLS certificates.</p>
public struct TooManyCertificates: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCertificatesBody: Equatable {
    public let message: String?
}

extension TooManyCertificatesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCloudFrontOriginAccessIdentities: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyCloudFrontOriginAccessIdentities(message: \(String(describing: message)))"}
}

extension TooManyCloudFrontOriginAccessIdentities: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyCloudFrontOriginAccessIdentitiesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of origin access identities allowed.</p>
public struct TooManyCloudFrontOriginAccessIdentities: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCloudFrontOriginAccessIdentitiesBody: Equatable {
    public let message: String?
}

extension TooManyCloudFrontOriginAccessIdentitiesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookieNamesInWhiteList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyCookieNamesInWhiteList(message: \(String(describing: message)))"}
}

extension TooManyCookieNamesInWhiteList: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyCookieNamesInWhiteListBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more cookie names in the whitelist than are allowed per cache behavior.</p>
public struct TooManyCookieNamesInWhiteList: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookieNamesInWhiteListBody: Equatable {
    public let message: String?
}

extension TooManyCookieNamesInWhiteListBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInCachePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyCookiesInCachePolicy(message: \(String(describing: message)))"}
}

extension TooManyCookiesInCachePolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyCookiesInCachePolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of cookies in the cache policy exceeds the maximum. For more information,
/// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyCookiesInCachePolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookiesInCachePolicyBody: Equatable {
    public let message: String?
}

extension TooManyCookiesInCachePolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCookiesInOriginRequestPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyCookiesInOriginRequestPolicy(message: \(String(describing: message)))"}
}

extension TooManyCookiesInOriginRequestPolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyCookiesInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of cookies in the origin request policy exceeds the maximum. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyCookiesInOriginRequestPolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCookiesInOriginRequestPolicyBody: Equatable {
    public let message: String?
}

extension TooManyCookiesInOriginRequestPolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionCNAMEs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributionCNAMEs(message: \(String(describing: message)))"}
}

extension TooManyDistributionCNAMEs: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
public struct TooManyDistributionCNAMEs: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionCNAMEsBody: Equatable {
    public let message: String?
}

extension TooManyDistributionCNAMEsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributions(message: \(String(describing: message)))"}
}

extension TooManyDistributions: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of distributions allowed.</p>
public struct TooManyDistributions: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension TooManyDistributionsAssociatedToCachePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributionsAssociatedToCachePolicy(message: \(String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToCachePolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionsAssociatedToCachePolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of distributions have been associated with the specified cache
/// 			policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyDistributionsAssociatedToCachePolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToCachePolicyBody: Equatable {
    public let message: String?
}

extension TooManyDistributionsAssociatedToCachePolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(message: \(String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of distributions have been associated with the specified configuration for field-level encryption.</p>
public struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfig: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Equatable {
    public let message: String?
}

extension TooManyDistributionsAssociatedToFieldLevelEncryptionConfigBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToKeyGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributionsAssociatedToKeyGroup(message: \(String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToKeyGroup: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionsAssociatedToKeyGroupBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of distributions that reference this key group is more than the maximum
/// 			allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyDistributionsAssociatedToKeyGroup: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToKeyGroupBody: Equatable {
    public let message: String?
}

extension TooManyDistributionsAssociatedToKeyGroupBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributionsAssociatedToOriginRequestPolicy(message: \(String(describing: message)))"}
}

extension TooManyDistributionsAssociatedToOriginRequestPolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionsAssociatedToOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of distributions have been associated with the specified origin
/// 			request policy. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyDistributionsAssociatedToOriginRequestPolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsAssociatedToOriginRequestPolicyBody: Equatable {
    public let message: String?
}

extension TooManyDistributionsAssociatedToOriginRequestPolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyDistributionsBody: Equatable {
    public let message: String?
}

extension TooManyDistributionsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithFunctionAssociations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributionsWithFunctionAssociations(message: \(String(describing: message)))"}
}

extension TooManyDistributionsWithFunctionAssociations: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionsWithFunctionAssociationsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of distributions that are associated with a CloudFront
/// 			function. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyDistributionsWithFunctionAssociations: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithFunctionAssociationsBody: Equatable {
    public let message: String?
}

extension TooManyDistributionsWithFunctionAssociationsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithLambdaAssociations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributionsWithLambdaAssociations(message: \(String(describing: message)))"}
}

extension TooManyDistributionsWithLambdaAssociations: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionsWithLambdaAssociationsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause the maximum number of distributions with Lambda function associations per owner
/// 			to be exceeded.</p>
public struct TooManyDistributionsWithLambdaAssociations: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithLambdaAssociationsBody: Equatable {
    public let message: String?
}

extension TooManyDistributionsWithLambdaAssociationsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyDistributionsWithSingleFunctionARN: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyDistributionsWithSingleFunctionARN(message: \(String(describing: message)))"}
}

extension TooManyDistributionsWithSingleFunctionARN: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyDistributionsWithSingleFunctionARNBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of distributions have been associated with the specified Lambda
/// 			function.</p>
public struct TooManyDistributionsWithSingleFunctionARN: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyDistributionsWithSingleFunctionARNBody: Equatable {
    public let message: String?
}

extension TooManyDistributionsWithSingleFunctionARNBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionConfigs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFieldLevelEncryptionConfigs(message: \(String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionConfigs: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionConfigsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of configurations for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionConfigs: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionConfigsBody: Equatable {
    public let message: String?
}

extension TooManyFieldLevelEncryptionConfigsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionContentTypeProfiles: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFieldLevelEncryptionContentTypeProfiles(message: \(String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionContentTypeProfiles: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionContentTypeProfilesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of content type profiles for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionContentTypeProfiles: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionContentTypeProfilesBody: Equatable {
    public let message: String?
}

extension TooManyFieldLevelEncryptionContentTypeProfilesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionEncryptionEntities: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFieldLevelEncryptionEncryptionEntities(message: \(String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionEncryptionEntities: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionEncryptionEntitiesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of encryption entities for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionEncryptionEntities: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionEncryptionEntitiesBody: Equatable {
    public let message: String?
}

extension TooManyFieldLevelEncryptionEncryptionEntitiesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionFieldPatterns: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFieldLevelEncryptionFieldPatterns(message: \(String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionFieldPatterns: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionFieldPatternsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of field patterns for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionFieldPatterns: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionFieldPatternsBody: Equatable {
    public let message: String?
}

extension TooManyFieldLevelEncryptionFieldPatternsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionProfiles: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFieldLevelEncryptionProfiles(message: \(String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionProfiles: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionProfilesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of profiles for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionProfiles: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionProfilesBody: Equatable {
    public let message: String?
}

extension TooManyFieldLevelEncryptionProfilesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFieldLevelEncryptionQueryArgProfiles: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFieldLevelEncryptionQueryArgProfiles(message: \(String(describing: message)))"}
}

extension TooManyFieldLevelEncryptionQueryArgProfiles: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyFieldLevelEncryptionQueryArgProfilesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of query arg profiles for field-level encryption have been created.</p>
public struct TooManyFieldLevelEncryptionQueryArgProfiles: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFieldLevelEncryptionQueryArgProfilesBody: Equatable {
    public let message: String?
}

extension TooManyFieldLevelEncryptionQueryArgProfilesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctionAssociations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFunctionAssociations(message: \(String(describing: message)))"}
}

extension TooManyFunctionAssociations: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyFunctionAssociationsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of CloudFront function associations for this
/// 			distribution. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyFunctionAssociations: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFunctionAssociationsBody: Equatable {
    public let message: String?
}

extension TooManyFunctionAssociationsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyFunctions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyFunctions(message: \(String(describing: message)))"}
}

extension TooManyFunctions: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyFunctionsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of CloudFront functions for this AWS account. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyFunctions: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyFunctionsBody: Equatable {
    public let message: String?
}

extension TooManyFunctionsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInCachePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyHeadersInCachePolicy(message: \(String(describing: message)))"}
}

extension TooManyHeadersInCachePolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyHeadersInCachePolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of headers in the cache policy exceeds the maximum. For more information,
/// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyHeadersInCachePolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInCachePolicyBody: Equatable {
    public let message: String?
}

extension TooManyHeadersInCachePolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInForwardedValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyHeadersInForwardedValues(message: \(String(describing: message)))"}
}

extension TooManyHeadersInForwardedValues: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyHeadersInForwardedValuesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains too many headers in forwarded values.</p>
public struct TooManyHeadersInForwardedValues: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInForwardedValuesBody: Equatable {
    public let message: String?
}

extension TooManyHeadersInForwardedValuesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyHeadersInOriginRequestPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyHeadersInOriginRequestPolicy(message: \(String(describing: message)))"}
}

extension TooManyHeadersInOriginRequestPolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyHeadersInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of headers in the origin request policy exceeds the maximum. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyHeadersInOriginRequestPolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyHeadersInOriginRequestPolicyBody: Equatable {
    public let message: String?
}

extension TooManyHeadersInOriginRequestPolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyInvalidationsInProgress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyInvalidationsInProgress(message: \(String(describing: message)))"}
}

extension TooManyInvalidationsInProgress: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyInvalidationsInProgressBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of allowable InProgress invalidation batch requests, or invalidation objects.</p>
public struct TooManyInvalidationsInProgress: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyInvalidationsInProgressBody: Equatable {
    public let message: String?
}

extension TooManyInvalidationsInProgressBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyKeyGroups: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyKeyGroups(message: \(String(describing: message)))"}
}

extension TooManyKeyGroups: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyKeyGroupsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of key groups for this AWS account. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyKeyGroups: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

extension TooManyKeyGroupsAssociatedToDistribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyKeyGroupsAssociatedToDistribution(message: \(String(describing: message)))"}
}

extension TooManyKeyGroupsAssociatedToDistribution: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyKeyGroupsAssociatedToDistributionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of key groups referenced by this distribution is more than the maximum
/// 			allowed. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyKeyGroupsAssociatedToDistribution: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyKeyGroupsAssociatedToDistributionBody: Equatable {
    public let message: String?
}

extension TooManyKeyGroupsAssociatedToDistributionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

struct TooManyKeyGroupsBody: Equatable {
    public let message: String?
}

extension TooManyKeyGroupsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyLambdaFunctionAssociations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyLambdaFunctionAssociations(message: \(String(describing: message)))"}
}

extension TooManyLambdaFunctionAssociations: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyLambdaFunctionAssociationsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more Lambda function associations than are allowed per distribution.</p>
public struct TooManyLambdaFunctionAssociations: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyLambdaFunctionAssociationsBody: Equatable {
    public let message: String?
}

extension TooManyLambdaFunctionAssociationsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginCustomHeaders: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyOriginCustomHeaders(message: \(String(describing: message)))"}
}

extension TooManyOriginCustomHeaders: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyOriginCustomHeadersBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains too many origin custom headers.</p>
public struct TooManyOriginCustomHeaders: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginCustomHeadersBody: Equatable {
    public let message: String?
}

extension TooManyOriginCustomHeadersBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginGroupsPerDistribution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyOriginGroupsPerDistribution(message: \(String(describing: message)))"}
}

extension TooManyOriginGroupsPerDistribution: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyOriginGroupsPerDistributionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of origin groups allowed.</p>
public struct TooManyOriginGroupsPerDistribution: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginGroupsPerDistributionBody: Equatable {
    public let message: String?
}

extension TooManyOriginGroupsPerDistributionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOriginRequestPolicies: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyOriginRequestPolicies(message: \(String(describing: message)))"}
}

extension TooManyOriginRequestPolicies: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyOriginRequestPoliciesBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of origin request policies for this AWS account.
/// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyOriginRequestPolicies: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginRequestPoliciesBody: Equatable {
    public let message: String?
}

extension TooManyOriginRequestPoliciesBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyOrigins: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyOrigins(message: \(String(describing: message)))"}
}

extension TooManyOrigins: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyOriginsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot create more origins for the distribution.</p>
public struct TooManyOrigins: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyOriginsBody: Equatable {
    public let message: String?
}

extension TooManyOriginsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeys: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyPublicKeys(message: \(String(describing: message)))"}
}

extension TooManyPublicKeys: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyPublicKeysBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum number of public keys for field-level encryption have been created. To create a new public key, delete one of the existing keys.</p>
public struct TooManyPublicKeys: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPublicKeysBody: Equatable {
    public let message: String?
}

extension TooManyPublicKeysBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyPublicKeysInKeyGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyPublicKeysInKeyGroup(message: \(String(describing: message)))"}
}

extension TooManyPublicKeysInKeyGroup: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyPublicKeysInKeyGroupBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of public keys in this key group is more than the maximum allowed. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyPublicKeysInKeyGroup: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyPublicKeysInKeyGroupBody: Equatable {
    public let message: String?
}

extension TooManyPublicKeysInKeyGroupBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyQueryStringParameters(message: \(String(describing: message)))"}
}

extension TooManyQueryStringParameters: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyQueryStringParametersBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains too many query string parameters.</p>
public struct TooManyQueryStringParameters: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringParametersBody: Equatable {
    public let message: String?
}

extension TooManyQueryStringParametersBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInCachePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyQueryStringsInCachePolicy(message: \(String(describing: message)))"}
}

extension TooManyQueryStringsInCachePolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyQueryStringsInCachePolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of query strings in the cache policy exceeds the maximum. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyQueryStringsInCachePolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringsInCachePolicyBody: Equatable {
    public let message: String?
}

extension TooManyQueryStringsInCachePolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyQueryStringsInOriginRequestPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyQueryStringsInOriginRequestPolicy(message: \(String(describing: message)))"}
}

extension TooManyQueryStringsInOriginRequestPolicy: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyQueryStringsInOriginRequestPolicyBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of query strings in the origin request policy exceeds the maximum. For more
/// 			information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyQueryStringsInOriginRequestPolicy: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyQueryStringsInOriginRequestPolicyBody: Equatable {
    public let message: String?
}

extension TooManyQueryStringsInOriginRequestPolicyBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRealtimeLogConfigs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRealtimeLogConfigs(message: \(String(describing: message)))"}
}

extension TooManyRealtimeLogConfigs: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyRealtimeLogConfigsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have reached the maximum number of real-time log configurations for this AWS account.
/// 			For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/cloudfront-limits.html">Quotas</a> (formerly known as limits) in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct TooManyRealtimeLogConfigs: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRealtimeLogConfigsBody: Equatable {
    public let message: String?
}

extension TooManyRealtimeLogConfigsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributionCNAMEs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyStreamingDistributionCNAMEs(message: \(String(describing: message)))"}
}

extension TooManyStreamingDistributionCNAMEs: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyStreamingDistributionCNAMEsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more CNAMEs than are allowed per distribution.</p>
public struct TooManyStreamingDistributionCNAMEs: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyStreamingDistributionCNAMEsBody: Equatable {
    public let message: String?
}

extension TooManyStreamingDistributionCNAMEsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyStreamingDistributions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyStreamingDistributions(message: \(String(describing: message)))"}
}

extension TooManyStreamingDistributions: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyStreamingDistributionsBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Processing your request would cause you to exceed the maximum number of streaming distributions allowed.</p>
public struct TooManyStreamingDistributions: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyStreamingDistributionsBody: Equatable {
    public let message: String?
}

extension TooManyStreamingDistributionsBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTrustedSigners: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTrustedSigners(message: \(String(describing: message)))"}
}

extension TooManyTrustedSigners: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyTrustedSignersBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request contains more trusted signers than are allowed per distribution.</p>
public struct TooManyTrustedSigners: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTrustedSignersBody: Equatable {
    public let message: String?
}

extension TooManyTrustedSignersBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrustedKeyGroupDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedKeyGroupDoesNotExist(message: \(String(describing: message)))"}
}

extension TrustedKeyGroupDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TrustedKeyGroupDoesNotExistBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified key group does not exist.</p>
public struct TrustedKeyGroupDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TrustedKeyGroupDoesNotExistBody: Equatable {
    public let message: String?
}

extension TrustedKeyGroupDoesNotExistBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrustedKeyGroups: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("KeyGroup"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct KeyGroup{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.KeyGroup>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension TrustedKeyGroups: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedKeyGroups(enabled: \(String(describing: enabled)), items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension TrustedKeyGroups: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of key groups whose public keys CloudFront can use to verify the signatures of signed
/// 			URLs and signed cookies.</p>
public struct TrustedKeyGroups: Equatable {
    /// <p>This field is <code>true</code> if any of the key groups in the list have public keys that
    /// 			CloudFront can use to verify the signatures of signed URLs and signed cookies. If not, this
    /// 			field is <code>false</code>.</p>
    public let enabled: Bool?
    /// <p>A list of key groups identifiers.</p>
    public let items: [String]?
    /// <p>The number of key groups in the list.</p>
    public let quantity: Int?

    public init (
        enabled: Bool? = nil,
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.enabled = enabled
        self.items = items
        self.quantity = quantity
    }
}

extension TrustedSignerDoesNotExist: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedSignerDoesNotExist(message: \(String(describing: message)))"}
}

extension TrustedSignerDoesNotExist: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TrustedSignerDoesNotExistBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of your trusted signers don't exist.</p>
public struct TrustedSignerDoesNotExist: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TrustedSignerDoesNotExistBody: Equatable {
    public let message: String?
}

extension TrustedSignerDoesNotExistBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrustedSigners: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case items = "Items"
        case quantity = "Quantity"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("enabled"))
        }
        if let items = items {
            var itemsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("items"))
            for string0 in items {
                try itemsContainer.encode(string0, forKey: Key("AwsAccountNumber"))
            }
        }
        if let quantity = quantity {
            try container.encode(quantity, forKey: Key("quantity"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let quantityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .quantity)
        quantity = quantityDecoded
        if containerValues.contains(.items) {
            struct KeyVal0{struct AwsAccountNumber{}}
            let itemsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.AwsAccountNumber>.CodingKeys.self, forKey: .items)
            if let itemsWrappedContainer = itemsWrappedContainer {
                let itemsContainer = try itemsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var itemsBuffer:[String]? = nil
                if let itemsContainer = itemsContainer {
                    itemsBuffer = [String]()
                    for stringContainer0 in itemsContainer {
                        itemsBuffer?.append(stringContainer0)
                    }
                }
                items = itemsBuffer
            } else {
                items = []
            }
        } else {
            items = nil
        }
    }
}

extension TrustedSigners: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrustedSigners(enabled: \(String(describing: enabled)), items: \(String(describing: items)), quantity: \(String(describing: quantity)))"}
}

extension TrustedSigners: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A list of AWS accounts whose public keys CloudFront can use to verify the signatures of signed
/// 			URLs and signed cookies.</p>
public struct TrustedSigners: Equatable {
    /// <p>This field is <code>true</code> if any of the AWS accounts have public keys that CloudFront can
    /// 			use to verify the signatures of signed URLs and signed cookies. If not, this field is
    /// 			<code>false</code>.</p>
    public let enabled: Bool?
    /// <p>A list of AWS account identifiers.</p>
    public let items: [String]?
    /// <p>The number of AWS accounts in the list.</p>
    public let quantity: Int?

    public init (
        enabled: Bool? = nil,
        items: [String]? = nil,
        quantity: Int? = nil
    )
    {
        self.enabled = enabled
        self.items = items
        self.quantity = quantity
    }
}

extension UnsupportedOperation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperation(message: \(String(describing: message)))"}
}

extension UnsupportedOperation: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnsupportedOperationBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation is not supported in this region.</p>
public struct UnsupportedOperation: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(tagKeys)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resource: \(String(describing: resource)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let tagKeys = tagKeys {
            try container.encode(tagKeys, forKey: Key("TagKeys"))
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "Operation", value: "Untag"))
        if let resource = input.operationInput.resource {
            let resourceQueryItem = URLQueryItem(name: "Resource".urlPercentEncoding(), value: String(resource).urlPercentEncoding())
            input.builder.withQueryItem(resourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

/// <p> The request to remove tags from a CloudFront resource.</p>
public struct UntagResourceInput: Equatable {
    /// <p> An ARN of a CloudFront resource.</p>
    public let resource: String?
    /// <p> A complex type that contains zero or more <code>Tag</code> key elements.</p>
    public let tagKeys: TagKeys?

    public init (
        resource: String? = nil,
        tagKeys: TagKeys? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let tagKeys: TagKeys?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysDecoded = try containerValues.decodeIfPresent(TagKeys.self, forKey: .tagKeys)
        tagKeys = tagKeysDecoded
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagging" : self = .invalidTagging(try InvalidTagging(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case invalidTagging(InvalidTagging)
    case noSuchResource(NoSuchResource)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateCachePolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCachePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cachePolicyConfig = input.operationInput.cachePolicyConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(cachePolicyConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCachePolicyOutputError>
}

extension UpdateCachePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCachePolicyInput(cachePolicyConfig: \(String(describing: cachePolicyConfig)), id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension UpdateCachePolicyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCachePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cachePolicyConfig = cachePolicyConfig {
            try container.encode(cachePolicyConfig, forKey: Key("CachePolicyConfig"))
        }
    }
}

public struct UpdateCachePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCachePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCachePolicyOutputError>
}

public struct UpdateCachePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCachePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCachePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCachePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCachePolicyInput>
    public typealias MOutput = OperationOutput<UpdateCachePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCachePolicyOutputError>
}

public struct UpdateCachePolicyInput: Equatable {
    /// <p>A cache policy configuration.</p>
    public let cachePolicyConfig: CachePolicyConfig?
    /// <p>The unique identifier for the cache policy that you are updating. The identifier is returned
    /// 			in a cache behavior’s <code>CachePolicyId</code> field in the response to
    /// 			<code>GetDistributionConfig</code>.</p>
    public let id: String?
    /// <p>The version of the cache policy that you are updating. The version is returned in the cache
    /// 			policy’s <code>ETag</code> field in the response to
    /// 			<code>GetCachePolicyConfig</code>.</p>
    public let ifMatch: String?

    public init (
        cachePolicyConfig: CachePolicyConfig? = nil,
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.cachePolicyConfig = cachePolicyConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCachePolicyInputBody: Equatable {
    public let cachePolicyConfig: CachePolicyConfig?
}

extension UpdateCachePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachePolicyConfig = "CachePolicyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyConfigDecoded = try containerValues.decodeIfPresent(CachePolicyConfig.self, forKey: .cachePolicyConfig)
        cachePolicyConfig = cachePolicyConfigDecoded
    }
}

extension UpdateCachePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCachePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CachePolicyAlreadyExists" : self = .cachePolicyAlreadyExists(try CachePolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInCachePolicy" : self = .tooManyCookiesInCachePolicy(try TooManyCookiesInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInCachePolicy" : self = .tooManyHeadersInCachePolicy(try TooManyHeadersInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInCachePolicy" : self = .tooManyQueryStringsInCachePolicy(try TooManyQueryStringsInCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCachePolicyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cachePolicyAlreadyExists(CachePolicyAlreadyExists)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case preconditionFailed(PreconditionFailed)
    case tooManyCookiesInCachePolicy(TooManyCookiesInCachePolicy)
    case tooManyHeadersInCachePolicy(TooManyHeadersInCachePolicy)
    case tooManyQueryStringsInCachePolicy(TooManyQueryStringsInCachePolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCachePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCachePolicyOutputResponse(cachePolicy: \(String(describing: cachePolicy)), eTag: \(String(describing: eTag)))"}
}

extension UpdateCachePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CachePolicy = try responseDecoder.decode(responseBody: unwrappedData)
                self.cachePolicy = output
            } else {
                self.cachePolicy = nil
            }
        } else {
            self.cachePolicy = nil
        }
    }
}

public struct UpdateCachePolicyOutputResponse: Equatable {
    /// <p>A cache policy.</p>
    public let cachePolicy: CachePolicy?
    /// <p>The current version of the cache policy.</p>
    public let eTag: String?

    public init (
        cachePolicy: CachePolicy? = nil,
        eTag: String? = nil
    )
    {
        self.cachePolicy = cachePolicy
        self.eTag = eTag
    }
}

struct UpdateCachePolicyOutputResponseBody: Equatable {
    public let cachePolicy: CachePolicy?
}

extension UpdateCachePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cachePolicy = "CachePolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cachePolicyDecoded = try containerValues.decodeIfPresent(CachePolicy.self, forKey: .cachePolicy)
        cachePolicy = cachePolicyDecoded
    }
}

public struct UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let cloudFrontOriginAccessIdentityConfig = input.operationInput.cloudFrontOriginAccessIdentityConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(cloudFrontOriginAccessIdentityConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

extension UpdateCloudFrontOriginAccessIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCloudFrontOriginAccessIdentityInput(cloudFrontOriginAccessIdentityConfig: \(String(describing: cloudFrontOriginAccessIdentityConfig)), id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension UpdateCloudFrontOriginAccessIdentityInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateCloudFrontOriginAccessIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig {
            try container.encode(cloudFrontOriginAccessIdentityConfig, forKey: Key("CloudFrontOriginAccessIdentityConfig"))
        }
    }
}

public struct UpdateCloudFrontOriginAccessIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCloudFrontOriginAccessIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

public struct UpdateCloudFrontOriginAccessIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCloudFrontOriginAccessIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCloudFrontOriginAccessIdentityInput>
    public typealias MOutput = OperationOutput<UpdateCloudFrontOriginAccessIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCloudFrontOriginAccessIdentityOutputError>
}

/// <p>The request to update an origin access identity.</p>
public struct UpdateCloudFrontOriginAccessIdentityInput: Equatable {
    /// <p>The identity's configuration information.</p>
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig?
    /// <p>The identity's id.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			identity's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig? = nil,
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateCloudFrontOriginAccessIdentityInputBody: Equatable {
    public let cloudFrontOriginAccessIdentityConfig: CloudFrontOriginAccessIdentityConfig?
}

extension UpdateCloudFrontOriginAccessIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentityConfig = "CloudFrontOriginAccessIdentityConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityConfigDecoded = try containerValues.decodeIfPresent(CloudFrontOriginAccessIdentityConfig.self, forKey: .cloudFrontOriginAccessIdentityConfig)
        cloudFrontOriginAccessIdentityConfig = cloudFrontOriginAccessIdentityConfigDecoded
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateCloudFrontOriginAccessIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCloudFrontOriginAccessIdentity" : self = .noSuchCloudFrontOriginAccessIdentity(try NoSuchCloudFrontOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCloudFrontOriginAccessIdentityOutputError: Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case missingBody(MissingBody)
    case noSuchCloudFrontOriginAccessIdentity(NoSuchCloudFrontOriginAccessIdentity)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCloudFrontOriginAccessIdentityOutputResponse(cloudFrontOriginAccessIdentity: \(String(describing: cloudFrontOriginAccessIdentity)), eTag: \(String(describing: eTag)))"}
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CloudFrontOriginAccessIdentity = try responseDecoder.decode(responseBody: unwrappedData)
                self.cloudFrontOriginAccessIdentity = output
            } else {
                self.cloudFrontOriginAccessIdentity = nil
            }
        } else {
            self.cloudFrontOriginAccessIdentity = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct UpdateCloudFrontOriginAccessIdentityOutputResponse: Equatable {
    /// <p>The origin access identity's information.</p>
    public let cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity?
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?

    public init (
        cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity? = nil,
        eTag: String? = nil
    )
    {
        self.cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentity
        self.eTag = eTag
    }
}

struct UpdateCloudFrontOriginAccessIdentityOutputResponseBody: Equatable {
    public let cloudFrontOriginAccessIdentity: CloudFrontOriginAccessIdentity?
}

extension UpdateCloudFrontOriginAccessIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudFrontOriginAccessIdentity = "CloudFrontOriginAccessIdentity"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontOriginAccessIdentityDecoded = try containerValues.decodeIfPresent(CloudFrontOriginAccessIdentity.self, forKey: .cloudFrontOriginAccessIdentity)
        cloudFrontOriginAccessIdentity = cloudFrontOriginAccessIdentityDecoded
    }
}

public struct UpdateDistributionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfig = input.operationInput.distributionConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(distributionConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDistributionOutputError>
}

extension UpdateDistributionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDistributionInput(distributionConfig: \(String(describing: distributionConfig)), id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension UpdateDistributionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateDistributionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let distributionConfig = distributionConfig {
            try container.encode(distributionConfig, forKey: Key("DistributionConfig"))
        }
    }
}

public struct UpdateDistributionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDistributionOutputError>
}

public struct UpdateDistributionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDistributionInput>
    public typealias MOutput = OperationOutput<UpdateDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDistributionOutputError>
}

/// <p>The request to update a distribution.</p>
public struct UpdateDistributionInput: Equatable {
    /// <p>The distribution's configuration information.</p>
    public let distributionConfig: DistributionConfig?
    /// <p>The distribution's id.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        distributionConfig: DistributionConfig? = nil,
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.distributionConfig = distributionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateDistributionInputBody: Equatable {
    public let distributionConfig: DistributionConfig?
}

extension UpdateDistributionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distributionConfig = "DistributionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigDecoded = try containerValues.decodeIfPresent(DistributionConfig.self, forKey: .distributionConfig)
        distributionConfig = distributionConfigDecoded
    }
}

extension UpdateDistributionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateDistributionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior" : self = .illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(try IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDefaultRootObject" : self = .invalidDefaultRootObject(try InvalidDefaultRootObject(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidErrorCode" : self = .invalidErrorCode(try InvalidErrorCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidForwardCookies" : self = .invalidForwardCookies(try InvalidForwardCookies(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidFunctionAssociation" : self = .invalidFunctionAssociation(try InvalidFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidGeoRestrictionParameter" : self = .invalidGeoRestrictionParameter(try InvalidGeoRestrictionParameter(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHeadersForS3Origin" : self = .invalidHeadersForS3Origin(try InvalidHeadersForS3Origin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLambdaFunctionAssociation" : self = .invalidLambdaFunctionAssociation(try InvalidLambdaFunctionAssociation(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLocationCode" : self = .invalidLocationCode(try InvalidLocationCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMinimumProtocolVersion" : self = .invalidMinimumProtocolVersion(try InvalidMinimumProtocolVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginKeepaliveTimeout" : self = .invalidOriginKeepaliveTimeout(try InvalidOriginKeepaliveTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginReadTimeout" : self = .invalidOriginReadTimeout(try InvalidOriginReadTimeout(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidQueryStringParameters" : self = .invalidQueryStringParameters(try InvalidQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRelativePath" : self = .invalidRelativePath(try InvalidRelativePath(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequiredProtocol" : self = .invalidRequiredProtocol(try InvalidRequiredProtocol(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResponseCode" : self = .invalidResponseCode(try InvalidResponseCode(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTTLOrder" : self = .invalidTTLOrder(try InvalidTTLOrder(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidViewerCertificate" : self = .invalidViewerCertificate(try InvalidViewerCertificate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebACLId" : self = .invalidWebACLId(try InvalidWebACLId(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchCachePolicy" : self = .noSuchCachePolicy(try NoSuchCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchDistribution" : self = .noSuchDistribution(try NoSuchDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOrigin" : self = .noSuchOrigin(try NoSuchOrigin(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RealtimeLogConfigOwnerMismatch" : self = .realtimeLogConfigOwnerMismatch(try RealtimeLogConfigOwnerMismatch(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCacheBehaviors" : self = .tooManyCacheBehaviors(try TooManyCacheBehaviors(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificates" : self = .tooManyCertificates(try TooManyCertificates(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookieNamesInWhiteList" : self = .tooManyCookieNamesInWhiteList(try TooManyCookieNamesInWhiteList(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionCNAMEs" : self = .tooManyDistributionCNAMEs(try TooManyDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToCachePolicy" : self = .tooManyDistributionsAssociatedToCachePolicy(try TooManyDistributionsAssociatedToCachePolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToFieldLevelEncryptionConfig" : self = .tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(try TooManyDistributionsAssociatedToFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToKeyGroup" : self = .tooManyDistributionsAssociatedToKeyGroup(try TooManyDistributionsAssociatedToKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsAssociatedToOriginRequestPolicy" : self = .tooManyDistributionsAssociatedToOriginRequestPolicy(try TooManyDistributionsAssociatedToOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithFunctionAssociations" : self = .tooManyDistributionsWithFunctionAssociations(try TooManyDistributionsWithFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithLambdaAssociations" : self = .tooManyDistributionsWithLambdaAssociations(try TooManyDistributionsWithLambdaAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyDistributionsWithSingleFunctionARN" : self = .tooManyDistributionsWithSingleFunctionARN(try TooManyDistributionsWithSingleFunctionARN(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFunctionAssociations" : self = .tooManyFunctionAssociations(try TooManyFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInForwardedValues" : self = .tooManyHeadersInForwardedValues(try TooManyHeadersInForwardedValues(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyKeyGroupsAssociatedToDistribution" : self = .tooManyKeyGroupsAssociatedToDistribution(try TooManyKeyGroupsAssociatedToDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLambdaFunctionAssociations" : self = .tooManyLambdaFunctionAssociations(try TooManyLambdaFunctionAssociations(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginCustomHeaders" : self = .tooManyOriginCustomHeaders(try TooManyOriginCustomHeaders(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOriginGroupsPerDistribution" : self = .tooManyOriginGroupsPerDistribution(try TooManyOriginGroupsPerDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyOrigins" : self = .tooManyOrigins(try TooManyOrigins(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringParameters" : self = .tooManyQueryStringParameters(try TooManyQueryStringParameters(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedKeyGroupDoesNotExist" : self = .trustedKeyGroupDoesNotExist(try TrustedKeyGroupDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDistributionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case illegalFieldLevelEncryptionConfigAssociationWithCacheBehavior(IllegalFieldLevelEncryptionConfigAssociationWithCacheBehavior)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidDefaultRootObject(InvalidDefaultRootObject)
    case invalidErrorCode(InvalidErrorCode)
    case invalidForwardCookies(InvalidForwardCookies)
    case invalidFunctionAssociation(InvalidFunctionAssociation)
    case invalidGeoRestrictionParameter(InvalidGeoRestrictionParameter)
    case invalidHeadersForS3Origin(InvalidHeadersForS3Origin)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case invalidLambdaFunctionAssociation(InvalidLambdaFunctionAssociation)
    case invalidLocationCode(InvalidLocationCode)
    case invalidMinimumProtocolVersion(InvalidMinimumProtocolVersion)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case invalidOriginKeepaliveTimeout(InvalidOriginKeepaliveTimeout)
    case invalidOriginReadTimeout(InvalidOriginReadTimeout)
    case invalidQueryStringParameters(InvalidQueryStringParameters)
    case invalidRelativePath(InvalidRelativePath)
    case invalidRequiredProtocol(InvalidRequiredProtocol)
    case invalidResponseCode(InvalidResponseCode)
    case invalidTTLOrder(InvalidTTLOrder)
    case invalidViewerCertificate(InvalidViewerCertificate)
    case invalidWebACLId(InvalidWebACLId)
    case missingBody(MissingBody)
    case noSuchCachePolicy(NoSuchCachePolicy)
    case noSuchDistribution(NoSuchDistribution)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchOrigin(NoSuchOrigin)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case preconditionFailed(PreconditionFailed)
    case realtimeLogConfigOwnerMismatch(RealtimeLogConfigOwnerMismatch)
    case tooManyCacheBehaviors(TooManyCacheBehaviors)
    case tooManyCertificates(TooManyCertificates)
    case tooManyCookieNamesInWhiteList(TooManyCookieNamesInWhiteList)
    case tooManyDistributionCNAMEs(TooManyDistributionCNAMEs)
    case tooManyDistributionsAssociatedToCachePolicy(TooManyDistributionsAssociatedToCachePolicy)
    case tooManyDistributionsAssociatedToFieldLevelEncryptionConfig(TooManyDistributionsAssociatedToFieldLevelEncryptionConfig)
    case tooManyDistributionsAssociatedToKeyGroup(TooManyDistributionsAssociatedToKeyGroup)
    case tooManyDistributionsAssociatedToOriginRequestPolicy(TooManyDistributionsAssociatedToOriginRequestPolicy)
    case tooManyDistributionsWithFunctionAssociations(TooManyDistributionsWithFunctionAssociations)
    case tooManyDistributionsWithLambdaAssociations(TooManyDistributionsWithLambdaAssociations)
    case tooManyDistributionsWithSingleFunctionARN(TooManyDistributionsWithSingleFunctionARN)
    case tooManyFunctionAssociations(TooManyFunctionAssociations)
    case tooManyHeadersInForwardedValues(TooManyHeadersInForwardedValues)
    case tooManyKeyGroupsAssociatedToDistribution(TooManyKeyGroupsAssociatedToDistribution)
    case tooManyLambdaFunctionAssociations(TooManyLambdaFunctionAssociations)
    case tooManyOriginCustomHeaders(TooManyOriginCustomHeaders)
    case tooManyOriginGroupsPerDistribution(TooManyOriginGroupsPerDistribution)
    case tooManyOrigins(TooManyOrigins)
    case tooManyQueryStringParameters(TooManyQueryStringParameters)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedKeyGroupDoesNotExist(TrustedKeyGroupDoesNotExist)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDistributionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDistributionOutputResponse(distribution: \(String(describing: distribution)), eTag: \(String(describing: eTag)))"}
}

extension UpdateDistributionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: Distribution = try responseDecoder.decode(responseBody: unwrappedData)
                self.distribution = output
            } else {
                self.distribution = nil
            }
        } else {
            self.distribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct UpdateDistributionOutputResponse: Equatable {
    /// <p>The distribution's information.</p>
    public let distribution: Distribution?
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?

    public init (
        distribution: Distribution? = nil,
        eTag: String? = nil
    )
    {
        self.distribution = distribution
        self.eTag = eTag
    }
}

struct UpdateDistributionOutputResponseBody: Equatable {
    public let distribution: Distribution?
}

extension UpdateDistributionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case distribution = "Distribution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionDecoded = try containerValues.decodeIfPresent(Distribution.self, forKey: .distribution)
        distribution = distributionDecoded
    }
}

public struct UpdateFieldLevelEncryptionConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFieldLevelEncryptionConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionConfig = input.operationInput.fieldLevelEncryptionConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(fieldLevelEncryptionConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

extension UpdateFieldLevelEncryptionConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFieldLevelEncryptionConfigInput(fieldLevelEncryptionConfig: \(String(describing: fieldLevelEncryptionConfig)), id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension UpdateFieldLevelEncryptionConfigInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let fieldLevelEncryptionConfig = fieldLevelEncryptionConfig {
            try container.encode(fieldLevelEncryptionConfig, forKey: Key("FieldLevelEncryptionConfig"))
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFieldLevelEncryptionConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

public struct UpdateFieldLevelEncryptionConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFieldLevelEncryptionConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFieldLevelEncryptionConfigInput>
    public typealias MOutput = OperationOutput<UpdateFieldLevelEncryptionConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFieldLevelEncryptionConfigOutputError>
}

public struct UpdateFieldLevelEncryptionConfigInput: Equatable {
    /// <p>Request to update a field-level encryption configuration. </p>
    public let fieldLevelEncryptionConfig: FieldLevelEncryptionConfig?
    /// <p>The ID of the configuration you want to update.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the configuration identity to update.
    /// 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        fieldLevelEncryptionConfig: FieldLevelEncryptionConfig? = nil,
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.fieldLevelEncryptionConfig = fieldLevelEncryptionConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionConfigInputBody: Equatable {
    public let fieldLevelEncryptionConfig: FieldLevelEncryptionConfig?
}

extension UpdateFieldLevelEncryptionConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionConfig = "FieldLevelEncryptionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionConfigDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionConfig.self, forKey: .fieldLevelEncryptionConfig)
        fieldLevelEncryptionConfig = fieldLevelEncryptionConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFieldLevelEncryptionConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionConfig" : self = .noSuchFieldLevelEncryptionConfig(try NoSuchFieldLevelEncryptionConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "QueryArgProfileEmpty" : self = .queryArgProfileEmpty(try QueryArgProfileEmpty(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionContentTypeProfiles" : self = .tooManyFieldLevelEncryptionContentTypeProfiles(try TooManyFieldLevelEncryptionContentTypeProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionQueryArgProfiles" : self = .tooManyFieldLevelEncryptionQueryArgProfiles(try TooManyFieldLevelEncryptionQueryArgProfiles(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFieldLevelEncryptionConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionConfig(NoSuchFieldLevelEncryptionConfig)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case preconditionFailed(PreconditionFailed)
    case queryArgProfileEmpty(QueryArgProfileEmpty)
    case tooManyFieldLevelEncryptionContentTypeProfiles(TooManyFieldLevelEncryptionContentTypeProfiles)
    case tooManyFieldLevelEncryptionQueryArgProfiles(TooManyFieldLevelEncryptionQueryArgProfiles)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldLevelEncryptionConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFieldLevelEncryptionConfigOutputResponse(eTag: \(String(describing: eTag)), fieldLevelEncryption: \(String(describing: fieldLevelEncryption)))"}
}

extension UpdateFieldLevelEncryptionConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryption = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryption = output
            } else {
                self.fieldLevelEncryption = nil
            }
        } else {
            self.fieldLevelEncryption = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionConfigOutputResponse: Equatable {
    /// <p>The value of the <code>ETag</code> header that you received when updating the configuration.
    /// 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>Return the results of updating the configuration.</p>
    public let fieldLevelEncryption: FieldLevelEncryption?

    public init (
        eTag: String? = nil,
        fieldLevelEncryption: FieldLevelEncryption? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryption = fieldLevelEncryption
    }
}

struct UpdateFieldLevelEncryptionConfigOutputResponseBody: Equatable {
    public let fieldLevelEncryption: FieldLevelEncryption?
}

extension UpdateFieldLevelEncryptionConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryption = "FieldLevelEncryption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionDecoded = try containerValues.decodeIfPresent(FieldLevelEncryption.self, forKey: .fieldLevelEncryption)
        fieldLevelEncryption = fieldLevelEncryptionDecoded
    }
}

public struct UpdateFieldLevelEncryptionProfileInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFieldLevelEncryptionProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let fieldLevelEncryptionProfileConfig = input.operationInput.fieldLevelEncryptionProfileConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(fieldLevelEncryptionProfileConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

extension UpdateFieldLevelEncryptionProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFieldLevelEncryptionProfileInput(fieldLevelEncryptionProfileConfig: \(String(describing: fieldLevelEncryptionProfileConfig)), id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)))"}
}

extension UpdateFieldLevelEncryptionProfileInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFieldLevelEncryptionProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig {
            try container.encode(fieldLevelEncryptionProfileConfig, forKey: Key("FieldLevelEncryptionProfileConfig"))
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFieldLevelEncryptionProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

public struct UpdateFieldLevelEncryptionProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFieldLevelEncryptionProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFieldLevelEncryptionProfileInput>
    public typealias MOutput = OperationOutput<UpdateFieldLevelEncryptionProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFieldLevelEncryptionProfileOutputError>
}

public struct UpdateFieldLevelEncryptionProfileInput: Equatable {
    /// <p>Request to update a field-level encryption profile. </p>
    public let fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig?
    /// <p>The ID of the field-level encryption profile request. </p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the profile identity to update.
    /// 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?

    public init (
        fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig? = nil,
        id: String? = nil,
        ifMatch: String? = nil
    )
    {
        self.fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfig
        self.id = id
        self.ifMatch = ifMatch
    }
}

struct UpdateFieldLevelEncryptionProfileInputBody: Equatable {
    public let fieldLevelEncryptionProfileConfig: FieldLevelEncryptionProfileConfig?
}

extension UpdateFieldLevelEncryptionProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfileConfig = "FieldLevelEncryptionProfileConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileConfigDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionProfileConfig.self, forKey: .fieldLevelEncryptionProfileConfig)
        fieldLevelEncryptionProfileConfig = fieldLevelEncryptionProfileConfigDecoded
    }
}

extension UpdateFieldLevelEncryptionProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFieldLevelEncryptionProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileAlreadyExists" : self = .fieldLevelEncryptionProfileAlreadyExists(try FieldLevelEncryptionProfileAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FieldLevelEncryptionProfileSizeExceeded" : self = .fieldLevelEncryptionProfileSizeExceeded(try FieldLevelEncryptionProfileSizeExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFieldLevelEncryptionProfile" : self = .noSuchFieldLevelEncryptionProfile(try NoSuchFieldLevelEncryptionProfile(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionEncryptionEntities" : self = .tooManyFieldLevelEncryptionEncryptionEntities(try TooManyFieldLevelEncryptionEncryptionEntities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyFieldLevelEncryptionFieldPatterns" : self = .tooManyFieldLevelEncryptionFieldPatterns(try TooManyFieldLevelEncryptionFieldPatterns(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFieldLevelEncryptionProfileOutputError: Equatable {
    case accessDenied(AccessDenied)
    case fieldLevelEncryptionProfileAlreadyExists(FieldLevelEncryptionProfileAlreadyExists)
    case fieldLevelEncryptionProfileSizeExceeded(FieldLevelEncryptionProfileSizeExceeded)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFieldLevelEncryptionProfile(NoSuchFieldLevelEncryptionProfile)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case tooManyFieldLevelEncryptionEncryptionEntities(TooManyFieldLevelEncryptionEncryptionEntities)
    case tooManyFieldLevelEncryptionFieldPatterns(TooManyFieldLevelEncryptionFieldPatterns)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFieldLevelEncryptionProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFieldLevelEncryptionProfileOutputResponse(eTag: \(String(describing: eTag)), fieldLevelEncryptionProfile: \(String(describing: fieldLevelEncryptionProfile)))"}
}

extension UpdateFieldLevelEncryptionProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FieldLevelEncryptionProfile = try responseDecoder.decode(responseBody: unwrappedData)
                self.fieldLevelEncryptionProfile = output
            } else {
                self.fieldLevelEncryptionProfile = nil
            }
        } else {
            self.fieldLevelEncryptionProfile = nil
        }
    }
}

public struct UpdateFieldLevelEncryptionProfileOutputResponse: Equatable {
    /// <p>The result of the field-level encryption profile request. </p>
    public let eTag: String?
    /// <p>Return the results of updating the profile.</p>
    public let fieldLevelEncryptionProfile: FieldLevelEncryptionProfile?

    public init (
        eTag: String? = nil,
        fieldLevelEncryptionProfile: FieldLevelEncryptionProfile? = nil
    )
    {
        self.eTag = eTag
        self.fieldLevelEncryptionProfile = fieldLevelEncryptionProfile
    }
}

struct UpdateFieldLevelEncryptionProfileOutputResponseBody: Equatable {
    public let fieldLevelEncryptionProfile: FieldLevelEncryptionProfile?
}

extension UpdateFieldLevelEncryptionProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldLevelEncryptionProfile = "FieldLevelEncryptionProfile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldLevelEncryptionProfileDecoded = try containerValues.decodeIfPresent(FieldLevelEncryptionProfile.self, forKey: .fieldLevelEncryptionProfile)
        fieldLevelEncryptionProfile = fieldLevelEncryptionProfileDecoded
    }
}

public struct UpdateFunctionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionOutputError>
}

extension UpdateFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionInput(functionCode: \(String(describing: functionCode)), functionConfig: \(String(describing: functionConfig)), ifMatch: \(String(describing: ifMatch)), name: \(String(describing: name)))"}
}

extension UpdateFunctionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let functionCode = functionCode {
            try container.encode(functionCode, forKey: Key("functionCode"))
        }
        if let functionConfig = functionConfig {
            try container.encode(functionConfig, forKey: Key("functionConfig"))
        }
    }
}

public struct UpdateFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionInput>
    public typealias MOutput = OperationOutput<UpdateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionOutputError>
}

public struct UpdateFunctionInput: Equatable {
    /// <p>The function code. For more information about writing a CloudFront function, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html">Writing function
    /// 			code for CloudFront Functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public let functionCode: Data?
    /// <p>Configuration information about the function.</p>
    public let functionConfig: FunctionConfig?
    /// <p>The current version (<code>ETag</code> value) of the function that you are updating, which
    /// 			you can get using <code>DescribeFunction</code>.</p>
    public let ifMatch: String?
    /// <p>The name of the function that you are updating.</p>
    public let name: String?

    public init (
        functionCode: Data? = nil,
        functionConfig: FunctionConfig? = nil,
        ifMatch: String? = nil,
        name: String? = nil
    )
    {
        self.functionCode = functionCode
        self.functionConfig = functionConfig
        self.ifMatch = ifMatch
        self.name = name
    }
}

struct UpdateFunctionInputBody: Equatable {
    public let functionConfig: FunctionConfig?
    public let functionCode: Data?
}

extension UpdateFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionCode = "FunctionCode"
        case functionConfig = "FunctionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionConfigDecoded = try containerValues.decodeIfPresent(FunctionConfig.self, forKey: .functionConfig)
        functionConfig = functionConfigDecoded
        if containerValues.contains(.functionCode) {
            do {
                let functionCodeDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .functionCode)
                functionCode = functionCodeDecoded
            } catch {
                functionCode = "".data(using: .utf8)
            }
        } else {
            functionCode = nil
        }
    }
}

extension UpdateFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "FunctionSizeLimitExceeded" : self = .functionSizeLimitExceeded(try FunctionSizeLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchFunctionExists" : self = .noSuchFunctionExists(try NoSuchFunctionExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionOutputError: Equatable {
    case functionSizeLimitExceeded(FunctionSizeLimitExceeded)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchFunctionExists(NoSuchFunctionExists)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionOutputResponse(eTag: \(String(describing: eTag)), functionSummary: \(String(describing: functionSummary)))"}
}

extension UpdateFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETtag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: FunctionSummary = try responseDecoder.decode(responseBody: unwrappedData)
                self.functionSummary = output
            } else {
                self.functionSummary = nil
            }
        } else {
            self.functionSummary = nil
        }
    }
}

public struct UpdateFunctionOutputResponse: Equatable {
    /// <p>The version identifier for the current version of the CloudFront function.</p>
    public let eTag: String?
    /// <p>Contains configuration information and metadata about a CloudFront function.</p>
    public let functionSummary: FunctionSummary?

    public init (
        eTag: String? = nil,
        functionSummary: FunctionSummary? = nil
    )
    {
        self.eTag = eTag
        self.functionSummary = functionSummary
    }
}

struct UpdateFunctionOutputResponseBody: Equatable {
    public let functionSummary: FunctionSummary?
}

extension UpdateFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionSummary = "FunctionSummary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionSummaryDecoded = try containerValues.decodeIfPresent(FunctionSummary.self, forKey: .functionSummary)
        functionSummary = functionSummaryDecoded
    }
}

public struct UpdateKeyGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateKeyGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let keyGroupConfig = input.operationInput.keyGroupConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(keyGroupConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateKeyGroupOutputError>
}

extension UpdateKeyGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateKeyGroupInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)), keyGroupConfig: \(String(describing: keyGroupConfig)))"}
}

extension UpdateKeyGroupInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateKeyGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let keyGroupConfig = keyGroupConfig {
            try container.encode(keyGroupConfig, forKey: Key("KeyGroupConfig"))
        }
    }
}

public struct UpdateKeyGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateKeyGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateKeyGroupOutputError>
}

public struct UpdateKeyGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateKeyGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateKeyGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateKeyGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateKeyGroupInput>
    public typealias MOutput = OperationOutput<UpdateKeyGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateKeyGroupOutputError>
}

public struct UpdateKeyGroupInput: Equatable {
    /// <p>The identifier of the key group that you are updating.</p>
    public let id: String?
    /// <p>The version of the key group that you are updating. The version is the key group’s
    /// 			<code>ETag</code> value.</p>
    public let ifMatch: String?
    /// <p>The key group configuration.</p>
    public let keyGroupConfig: KeyGroupConfig?

    public init (
        id: String? = nil,
        ifMatch: String? = nil,
        keyGroupConfig: KeyGroupConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.keyGroupConfig = keyGroupConfig
    }
}

struct UpdateKeyGroupInputBody: Equatable {
    public let keyGroupConfig: KeyGroupConfig?
}

extension UpdateKeyGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyGroupConfig = "KeyGroupConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupConfigDecoded = try containerValues.decodeIfPresent(KeyGroupConfig.self, forKey: .keyGroupConfig)
        keyGroupConfig = keyGroupConfigDecoded
    }
}

extension UpdateKeyGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateKeyGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KeyGroupAlreadyExists" : self = .keyGroupAlreadyExists(try KeyGroupAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchResource" : self = .noSuchResource(try NoSuchResource(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyPublicKeysInKeyGroup" : self = .tooManyPublicKeysInKeyGroup(try TooManyPublicKeysInKeyGroup(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateKeyGroupOutputError: Equatable {
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case keyGroupAlreadyExists(KeyGroupAlreadyExists)
    case noSuchResource(NoSuchResource)
    case preconditionFailed(PreconditionFailed)
    case tooManyPublicKeysInKeyGroup(TooManyPublicKeysInKeyGroup)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateKeyGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateKeyGroupOutputResponse(eTag: \(String(describing: eTag)), keyGroup: \(String(describing: keyGroup)))"}
}

extension UpdateKeyGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: KeyGroup = try responseDecoder.decode(responseBody: unwrappedData)
                self.keyGroup = output
            } else {
                self.keyGroup = nil
            }
        } else {
            self.keyGroup = nil
        }
    }
}

public struct UpdateKeyGroupOutputResponse: Equatable {
    /// <p>The identifier for this version of the key group.</p>
    public let eTag: String?
    /// <p>The key group that was just updated.</p>
    public let keyGroup: KeyGroup?

    public init (
        eTag: String? = nil,
        keyGroup: KeyGroup? = nil
    )
    {
        self.eTag = eTag
        self.keyGroup = keyGroup
    }
}

struct UpdateKeyGroupOutputResponseBody: Equatable {
    public let keyGroup: KeyGroup?
}

extension UpdateKeyGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyGroup = "KeyGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyGroupDecoded = try containerValues.decodeIfPresent(KeyGroup.self, forKey: .keyGroup)
        keyGroup = keyGroupDecoded
    }
}

public struct UpdateOriginRequestPolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateOriginRequestPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let originRequestPolicyConfig = input.operationInput.originRequestPolicyConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(originRequestPolicyConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOriginRequestPolicyOutputError>
}

extension UpdateOriginRequestPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOriginRequestPolicyInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)), originRequestPolicyConfig: \(String(describing: originRequestPolicyConfig)))"}
}

extension UpdateOriginRequestPolicyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateOriginRequestPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let originRequestPolicyConfig = originRequestPolicyConfig {
            try container.encode(originRequestPolicyConfig, forKey: Key("OriginRequestPolicyConfig"))
        }
    }
}

public struct UpdateOriginRequestPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateOriginRequestPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOriginRequestPolicyOutputError>
}

public struct UpdateOriginRequestPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateOriginRequestPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOriginRequestPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOriginRequestPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOriginRequestPolicyInput>
    public typealias MOutput = OperationOutput<UpdateOriginRequestPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOriginRequestPolicyOutputError>
}

public struct UpdateOriginRequestPolicyInput: Equatable {
    /// <p>The unique identifier for the origin request policy that you are updating. The identifier is
    /// 			returned in a cache behavior’s <code>OriginRequestPolicyId</code> field in the response
    /// 			to <code>GetDistributionConfig</code>.</p>
    public let id: String?
    /// <p>The version of the origin request policy that you are updating. The version is returned in
    /// 			the origin request policy’s <code>ETag</code> field in the response to
    /// 			<code>GetOriginRequestPolicyConfig</code>.</p>
    public let ifMatch: String?
    /// <p>An origin request policy configuration.</p>
    public let originRequestPolicyConfig: OriginRequestPolicyConfig?

    public init (
        id: String? = nil,
        ifMatch: String? = nil,
        originRequestPolicyConfig: OriginRequestPolicyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.originRequestPolicyConfig = originRequestPolicyConfig
    }
}

struct UpdateOriginRequestPolicyInputBody: Equatable {
    public let originRequestPolicyConfig: OriginRequestPolicyConfig?
}

extension UpdateOriginRequestPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicyConfig = "OriginRequestPolicyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyConfigDecoded = try containerValues.decodeIfPresent(OriginRequestPolicyConfig.self, forKey: .originRequestPolicyConfig)
        originRequestPolicyConfig = originRequestPolicyConfigDecoded
    }
}

extension UpdateOriginRequestPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateOriginRequestPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchOriginRequestPolicy" : self = .noSuchOriginRequestPolicy(try NoSuchOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OriginRequestPolicyAlreadyExists" : self = .originRequestPolicyAlreadyExists(try OriginRequestPolicyAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCookiesInOriginRequestPolicy" : self = .tooManyCookiesInOriginRequestPolicy(try TooManyCookiesInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyHeadersInOriginRequestPolicy" : self = .tooManyHeadersInOriginRequestPolicy(try TooManyHeadersInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyQueryStringsInOriginRequestPolicy" : self = .tooManyQueryStringsInOriginRequestPolicy(try TooManyQueryStringsInOriginRequestPolicy(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOriginRequestPolicyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchOriginRequestPolicy(NoSuchOriginRequestPolicy)
    case originRequestPolicyAlreadyExists(OriginRequestPolicyAlreadyExists)
    case preconditionFailed(PreconditionFailed)
    case tooManyCookiesInOriginRequestPolicy(TooManyCookiesInOriginRequestPolicy)
    case tooManyHeadersInOriginRequestPolicy(TooManyHeadersInOriginRequestPolicy)
    case tooManyQueryStringsInOriginRequestPolicy(TooManyQueryStringsInOriginRequestPolicy)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOriginRequestPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOriginRequestPolicyOutputResponse(eTag: \(String(describing: eTag)), originRequestPolicy: \(String(describing: originRequestPolicy)))"}
}

extension UpdateOriginRequestPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: OriginRequestPolicy = try responseDecoder.decode(responseBody: unwrappedData)
                self.originRequestPolicy = output
            } else {
                self.originRequestPolicy = nil
            }
        } else {
            self.originRequestPolicy = nil
        }
    }
}

public struct UpdateOriginRequestPolicyOutputResponse: Equatable {
    /// <p>The current version of the origin request policy.</p>
    public let eTag: String?
    /// <p>An origin request policy.</p>
    public let originRequestPolicy: OriginRequestPolicy?

    public init (
        eTag: String? = nil,
        originRequestPolicy: OriginRequestPolicy? = nil
    )
    {
        self.eTag = eTag
        self.originRequestPolicy = originRequestPolicy
    }
}

struct UpdateOriginRequestPolicyOutputResponseBody: Equatable {
    public let originRequestPolicy: OriginRequestPolicy?
}

extension UpdateOriginRequestPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case originRequestPolicy = "OriginRequestPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originRequestPolicyDecoded = try containerValues.decodeIfPresent(OriginRequestPolicy.self, forKey: .originRequestPolicy)
        originRequestPolicy = originRequestPolicyDecoded
    }
}

public struct UpdatePublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let publicKeyConfig = input.operationInput.publicKeyConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(publicKeyConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePublicKeyOutputError>
}

extension UpdatePublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePublicKeyInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)), publicKeyConfig: \(String(describing: publicKeyConfig)))"}
}

extension UpdatePublicKeyInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdatePublicKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let publicKeyConfig = publicKeyConfig {
            try container.encode(publicKeyConfig, forKey: Key("PublicKeyConfig"))
        }
    }
}

public struct UpdatePublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePublicKeyOutputError>
}

public struct UpdatePublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePublicKeyInput>
    public typealias MOutput = OperationOutput<UpdatePublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePublicKeyOutputError>
}

public struct UpdatePublicKeyInput: Equatable {
    /// <p>The identifier of the public key that you are updating.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the public key to update.
    /// 			For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?
    /// <p>A public key configuration.</p>
    public let publicKeyConfig: PublicKeyConfig?

    public init (
        id: String? = nil,
        ifMatch: String? = nil,
        publicKeyConfig: PublicKeyConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.publicKeyConfig = publicKeyConfig
    }
}

struct UpdatePublicKeyInputBody: Equatable {
    public let publicKeyConfig: PublicKeyConfig?
}

extension UpdatePublicKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicKeyConfig = "PublicKeyConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyConfigDecoded = try containerValues.decodeIfPresent(PublicKeyConfig.self, forKey: .publicKeyConfig)
        publicKeyConfig = publicKeyConfigDecoded
    }
}

extension UpdatePublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdatePublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CannotChangeImmutablePublicKeyFields" : self = .cannotChangeImmutablePublicKeyFields(try CannotChangeImmutablePublicKeyFields(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchPublicKey" : self = .noSuchPublicKey(try NoSuchPublicKey(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePublicKeyOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cannotChangeImmutablePublicKeyFields(CannotChangeImmutablePublicKeyFields)
    case illegalUpdate(IllegalUpdate)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case noSuchPublicKey(NoSuchPublicKey)
    case preconditionFailed(PreconditionFailed)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePublicKeyOutputResponse(eTag: \(String(describing: eTag)), publicKey: \(String(describing: publicKey)))"}
}

extension UpdatePublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PublicKey = try responseDecoder.decode(responseBody: unwrappedData)
                self.publicKey = output
            } else {
                self.publicKey = nil
            }
        } else {
            self.publicKey = nil
        }
    }
}

public struct UpdatePublicKeyOutputResponse: Equatable {
    /// <p>The identifier of the current version of the public key.</p>
    public let eTag: String?
    /// <p>The public key.</p>
    public let publicKey: PublicKey?

    public init (
        eTag: String? = nil,
        publicKey: PublicKey? = nil
    )
    {
        self.eTag = eTag
        self.publicKey = publicKey
    }
}

struct UpdatePublicKeyOutputResponseBody: Equatable {
    public let publicKey: PublicKey?
}

extension UpdatePublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case publicKey = "PublicKey"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyDecoded = try containerValues.decodeIfPresent(PublicKey.self, forKey: .publicKey)
        publicKey = publicKeyDecoded
    }
}

public struct UpdateRealtimeLogConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRealtimeLogConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRealtimeLogConfigOutputError>
}

extension UpdateRealtimeLogConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRealtimeLogConfigInput(aRN: \(String(describing: aRN)), endPoints: \(String(describing: endPoints)), fields: \(String(describing: fields)), name: \(String(describing: name)), samplingRate: \(String(describing: samplingRate)))"}
}

extension UpdateRealtimeLogConfigInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateRealtimeLogConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aRN = aRN {
            try container.encode(aRN, forKey: Key("aRN"))
        }
        if let endPoints = endPoints {
            var endPointsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("endPoints"))
            for endpoint0 in endPoints {
                try endPointsContainer.encode(endpoint0, forKey: Key("member"))
            }
        }
        if let fields = fields {
            var fieldsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("fields"))
            for string0 in fields {
                try fieldsContainer.encode(string0, forKey: Key("Field"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("name"))
        }
        if let samplingRate = samplingRate {
            try container.encode(samplingRate, forKey: Key("samplingRate"))
        }
    }
}

public struct UpdateRealtimeLogConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRealtimeLogConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRealtimeLogConfigOutputError>
}

public struct UpdateRealtimeLogConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRealtimeLogConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRealtimeLogConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRealtimeLogConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRealtimeLogConfigInput>
    public typealias MOutput = OperationOutput<UpdateRealtimeLogConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRealtimeLogConfigOutputError>
}

public struct UpdateRealtimeLogConfigInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for this real-time log configuration.</p>
    public let aRN: String?
    /// <p>Contains information about the Amazon Kinesis data stream where you are sending real-time
    /// 			log data.</p>
    public let endPoints: [EndPoint]?
    /// <p>A list of fields to include in each real-time log record.</p>
    /// 		       <p>For more information about fields, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html#understand-real-time-log-config-fields">Real-time log configuration fields</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public let fields: [String]?
    /// <p>The name for this real-time log configuration.</p>
    public let name: String?
    /// <p>The sampling rate for this real-time log configuration. The sampling rate determines the
    /// 			percentage of viewer requests that are represented in the real-time log data. You must
    /// 			provide an integer between 1 and 100, inclusive.</p>
    public let samplingRate: Int?

    public init (
        aRN: String? = nil,
        endPoints: [EndPoint]? = nil,
        fields: [String]? = nil,
        name: String? = nil,
        samplingRate: Int? = nil
    )
    {
        self.aRN = aRN
        self.endPoints = endPoints
        self.fields = fields
        self.name = name
        self.samplingRate = samplingRate
    }
}

struct UpdateRealtimeLogConfigInputBody: Equatable {
    public let endPoints: [EndPoint]?
    public let fields: [String]?
    public let name: String?
    public let aRN: String?
    public let samplingRate: Int?
}

extension UpdateRealtimeLogConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case endPoints = "EndPoints"
        case fields = "Fields"
        case name = "Name"
        case samplingRate = "SamplingRate"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.endPoints) {
            struct KeyVal0{struct member{}}
            let endPointsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .endPoints)
            if let endPointsWrappedContainer = endPointsWrappedContainer {
                let endPointsContainer = try endPointsWrappedContainer.decodeIfPresent([EndPoint].self, forKey: .member)
                var endPointsBuffer:[EndPoint]? = nil
                if let endPointsContainer = endPointsContainer {
                    endPointsBuffer = [EndPoint]()
                    for structureContainer0 in endPointsContainer {
                        endPointsBuffer?.append(structureContainer0)
                    }
                }
                endPoints = endPointsBuffer
            } else {
                endPoints = []
            }
        } else {
            endPoints = nil
        }
        if containerValues.contains(.fields) {
            struct KeyVal0{struct Field{}}
            let fieldsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.Field>.CodingKeys.self, forKey: .fields)
            if let fieldsWrappedContainer = fieldsWrappedContainer {
                let fieldsContainer = try fieldsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var fieldsBuffer:[String]? = nil
                if let fieldsContainer = fieldsContainer {
                    fieldsBuffer = [String]()
                    for stringContainer0 in fieldsContainer {
                        fieldsBuffer?.append(stringContainer0)
                    }
                }
                fields = fieldsBuffer
            } else {
                fields = []
            }
        } else {
            fields = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
        let samplingRateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .samplingRate)
        samplingRate = samplingRateDecoded
    }
}

extension UpdateRealtimeLogConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateRealtimeLogConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchRealtimeLogConfig" : self = .noSuchRealtimeLogConfig(try NoSuchRealtimeLogConfig(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRealtimeLogConfigOutputError: Equatable {
    case accessDenied(AccessDenied)
    case invalidArgument(InvalidArgument)
    case noSuchRealtimeLogConfig(NoSuchRealtimeLogConfig)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRealtimeLogConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRealtimeLogConfigOutputResponse(realtimeLogConfig: \(String(describing: realtimeLogConfig)))"}
}

extension UpdateRealtimeLogConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRealtimeLogConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.realtimeLogConfig = output.realtimeLogConfig
        } else {
            self.realtimeLogConfig = nil
        }
    }
}

public struct UpdateRealtimeLogConfigOutputResponse: Equatable {
    /// <p>A real-time log configuration.</p>
    public let realtimeLogConfig: RealtimeLogConfig?

    public init (
        realtimeLogConfig: RealtimeLogConfig? = nil
    )
    {
        self.realtimeLogConfig = realtimeLogConfig
    }
}

struct UpdateRealtimeLogConfigOutputResponseBody: Equatable {
    public let realtimeLogConfig: RealtimeLogConfig?
}

extension UpdateRealtimeLogConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case realtimeLogConfig = "RealtimeLogConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let realtimeLogConfigDecoded = try containerValues.decodeIfPresent(RealtimeLogConfig.self, forKey: .realtimeLogConfig)
        realtimeLogConfig = realtimeLogConfigDecoded
    }
}

public struct UpdateStreamingDistributionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateStreamingDistributionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let streamingDistributionConfig = input.operationInput.streamingDistributionConfig {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(streamingDistributionConfig)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamingDistributionOutputError>
}

extension UpdateStreamingDistributionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStreamingDistributionInput(id: \(String(describing: id)), ifMatch: \(String(describing: ifMatch)), streamingDistributionConfig: \(String(describing: streamingDistributionConfig)))"}
}

extension UpdateStreamingDistributionInput: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

extension UpdateStreamingDistributionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let streamingDistributionConfig = streamingDistributionConfig {
            try container.encode(streamingDistributionConfig, forKey: Key("StreamingDistributionConfig"))
        }
    }
}

public struct UpdateStreamingDistributionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateStreamingDistributionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let ifMatch = input.operationInput.ifMatch {
            input.builder.withHeader(name: "If-Match", value: String(ifMatch))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamingDistributionOutputError>
}

public struct UpdateStreamingDistributionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateStreamingDistributionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateStreamingDistributionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateStreamingDistributionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateStreamingDistributionInput>
    public typealias MOutput = OperationOutput<UpdateStreamingDistributionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateStreamingDistributionOutputError>
}

/// <p>The request to update a streaming distribution.</p>
public struct UpdateStreamingDistributionInput: Equatable {
    /// <p>The streaming distribution's id.</p>
    public let id: String?
    /// <p>The value of the <code>ETag</code> header that you received when retrieving the
    /// 			streaming distribution's configuration. For example: <code>E2QWRUHAPOMQZL</code>.</p>
    public let ifMatch: String?
    /// <p>The streaming distribution's configuration information.</p>
    public let streamingDistributionConfig: StreamingDistributionConfig?

    public init (
        id: String? = nil,
        ifMatch: String? = nil,
        streamingDistributionConfig: StreamingDistributionConfig? = nil
    )
    {
        self.id = id
        self.ifMatch = ifMatch
        self.streamingDistributionConfig = streamingDistributionConfig
    }
}

struct UpdateStreamingDistributionInputBody: Equatable {
    public let streamingDistributionConfig: StreamingDistributionConfig?
}

extension UpdateStreamingDistributionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistributionConfig = "StreamingDistributionConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionConfigDecoded = try containerValues.decodeIfPresent(StreamingDistributionConfig.self, forKey: .streamingDistributionConfig)
        streamingDistributionConfig = streamingDistributionConfigDecoded
    }
}

extension UpdateStreamingDistributionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension UpdateStreamingDistributionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDenied" : self = .accessDenied(try AccessDenied(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CNAMEAlreadyExists" : self = .cNAMEAlreadyExists(try CNAMEAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUpdate" : self = .illegalUpdate(try IllegalUpdate(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InconsistentQuantities" : self = .inconsistentQuantities(try InconsistentQuantities(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgument" : self = .invalidArgument(try InvalidArgument(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIfMatchVersion" : self = .invalidIfMatchVersion(try InvalidIfMatchVersion(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOriginAccessIdentity" : self = .invalidOriginAccessIdentity(try InvalidOriginAccessIdentity(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MissingBody" : self = .missingBody(try MissingBody(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchStreamingDistribution" : self = .noSuchStreamingDistribution(try NoSuchStreamingDistribution(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailed" : self = .preconditionFailed(try PreconditionFailed(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyStreamingDistributionCNAMEs" : self = .tooManyStreamingDistributionCNAMEs(try TooManyStreamingDistributionCNAMEs(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTrustedSigners" : self = .tooManyTrustedSigners(try TooManyTrustedSigners(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrustedSignerDoesNotExist" : self = .trustedSignerDoesNotExist(try TrustedSignerDoesNotExist(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStreamingDistributionOutputError: Equatable {
    case accessDenied(AccessDenied)
    case cNAMEAlreadyExists(CNAMEAlreadyExists)
    case illegalUpdate(IllegalUpdate)
    case inconsistentQuantities(InconsistentQuantities)
    case invalidArgument(InvalidArgument)
    case invalidIfMatchVersion(InvalidIfMatchVersion)
    case invalidOriginAccessIdentity(InvalidOriginAccessIdentity)
    case missingBody(MissingBody)
    case noSuchStreamingDistribution(NoSuchStreamingDistribution)
    case preconditionFailed(PreconditionFailed)
    case tooManyStreamingDistributionCNAMEs(TooManyStreamingDistributionCNAMEs)
    case tooManyTrustedSigners(TooManyTrustedSigners)
    case trustedSignerDoesNotExist(TrustedSignerDoesNotExist)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamingDistributionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateStreamingDistributionOutputResponse(eTag: \(String(describing: eTag)), streamingDistribution: \(String(describing: streamingDistribution)))"}
}

extension UpdateStreamingDistributionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: StreamingDistribution = try responseDecoder.decode(responseBody: unwrappedData)
                self.streamingDistribution = output
            } else {
                self.streamingDistribution = nil
            }
        } else {
            self.streamingDistribution = nil
        }
    }
}

/// <p>The returned result of the corresponding request.</p>
public struct UpdateStreamingDistributionOutputResponse: Equatable {
    /// <p>The current version of the configuration. For example:
    /// 			<code>E2QWRUHAPOMQZL</code>.</p>
    public let eTag: String?
    /// <p>The streaming distribution's information.</p>
    public let streamingDistribution: StreamingDistribution?

    public init (
        eTag: String? = nil,
        streamingDistribution: StreamingDistribution? = nil
    )
    {
        self.eTag = eTag
        self.streamingDistribution = streamingDistribution
    }
}

struct UpdateStreamingDistributionOutputResponseBody: Equatable {
    public let streamingDistribution: StreamingDistribution?
}

extension UpdateStreamingDistributionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamingDistribution = "StreamingDistribution"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingDistributionDecoded = try containerValues.decodeIfPresent(StreamingDistribution.self, forKey: .streamingDistribution)
        streamingDistribution = streamingDistributionDecoded
    }
}

extension ViewerCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aCMCertificateArn = "ACMCertificateArn"
        case certificate = "Certificate"
        case certificateSource = "CertificateSource"
        case cloudFrontDefaultCertificate = "CloudFrontDefaultCertificate"
        case iAMCertificateId = "IAMCertificateId"
        case minimumProtocolVersion = "MinimumProtocolVersion"
        case sSLSupportMethod = "SSLSupportMethod"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if encoder.codingPath.isEmpty {
            try container.encode("http://cloudfront.amazonaws.com/doc/2020-05-31/", forKey: Key("xmlns"))
        }
        if let aCMCertificateArn = aCMCertificateArn {
            try container.encode(aCMCertificateArn, forKey: Key("aCMCertificateArn"))
        }
        if let certificate = certificate {
            try container.encode(certificate, forKey: Key("certificate"))
        }
        if let certificateSource = certificateSource {
            try container.encode(certificateSource, forKey: Key("certificateSource"))
        }
        if let cloudFrontDefaultCertificate = cloudFrontDefaultCertificate {
            try container.encode(cloudFrontDefaultCertificate, forKey: Key("cloudFrontDefaultCertificate"))
        }
        if let iAMCertificateId = iAMCertificateId {
            try container.encode(iAMCertificateId, forKey: Key("iAMCertificateId"))
        }
        if let minimumProtocolVersion = minimumProtocolVersion {
            try container.encode(minimumProtocolVersion, forKey: Key("minimumProtocolVersion"))
        }
        if let sSLSupportMethod = sSLSupportMethod {
            try container.encode(sSLSupportMethod, forKey: Key("sSLSupportMethod"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudFrontDefaultCertificateDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cloudFrontDefaultCertificate)
        cloudFrontDefaultCertificate = cloudFrontDefaultCertificateDecoded
        let iAMCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iAMCertificateId)
        iAMCertificateId = iAMCertificateIdDecoded
        let aCMCertificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aCMCertificateArn)
        aCMCertificateArn = aCMCertificateArnDecoded
        let sSLSupportMethodDecoded = try containerValues.decodeIfPresent(SSLSupportMethod.self, forKey: .sSLSupportMethod)
        sSLSupportMethod = sSLSupportMethodDecoded
        let minimumProtocolVersionDecoded = try containerValues.decodeIfPresent(MinimumProtocolVersion.self, forKey: .minimumProtocolVersion)
        minimumProtocolVersion = minimumProtocolVersionDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let certificateSourceDecoded = try containerValues.decodeIfPresent(CertificateSource.self, forKey: .certificateSource)
        certificateSource = certificateSourceDecoded
    }
}

extension ViewerCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ViewerCertificate(aCMCertificateArn: \(String(describing: aCMCertificateArn)), certificate: \(String(describing: certificate)), certificateSource: \(String(describing: certificateSource)), cloudFrontDefaultCertificate: \(String(describing: cloudFrontDefaultCertificate)), iAMCertificateId: \(String(describing: iAMCertificateId)), minimumProtocolVersion: \(String(describing: minimumProtocolVersion)), sSLSupportMethod: \(String(describing: sSLSupportMethod)))"}
}

extension ViewerCertificate: DynamicNodeEncoding {
    public static func nodeEncoding(for key: CodingKey) -> NodeEncoding {
        let xmlNamespaceValues = [
            "xmlns"
        ]
        if let key = key as? Key {
            if xmlNamespaceValues.contains(key.stringValue) {
                return .attribute
            }
        }
        return .element
    }
}

/// <p>A complex type that determines the distribution’s SSL/TLS configuration for communicating
/// 			with viewers.</p>
/// 		       <p>If the distribution doesn’t use <code>Aliases</code> (also known as alternate domain
/// 			names or CNAMEs)—that is, if the distribution uses the CloudFront domain name such as
/// 			<code>d111111abcdef8.cloudfront.net</code>—set <code>CloudFrontDefaultCertificate</code>
/// 			to <code>true</code> and leave all other fields empty.</p>
/// 		       <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), use
/// 			the fields in this type to specify the following settings:</p>
/// 		       <ul>
///             <li>
/// 				           <p>Which viewers the distribution accepts HTTPS connections from: only viewers that support
/// 					<a href="https://en.wikipedia.org/wiki/Server_Name_Indication">server name
/// 					indication (SNI)</a> (recommended), or all viewers including those that
/// 					don’t support SNI.</p>
/// 				           <ul>
///                   <li>
/// 						               <p>To accept HTTPS connections from only viewers that support SNI, set
/// 							<code>SSLSupportMethod</code> to <code>sni-only</code>. This is
/// 							recommended. Most browsers and clients support
///                             SNI.
///
///                   </p>
/// 					             </li>
///                   <li>
/// 						               <p>To accept HTTPS connections from all viewers, including those that don’t support SNI,
/// 							set <code>SSLSupportMethod</code> to <code>vip</code>. This is not
/// 							recommended, and results in additional monthly charges from
/// 							CloudFront.
///                   </p>
/// 					             </li>
///                </ul>
/// 			         </li>
///             <li>
/// 				           <p>The minimum SSL/TLS protocol version that the distribution can use to
/// 					communicate with viewers. To specify a minimum version, choose a value for
/// 					<code>MinimumProtocolVersion</code>. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy">Security Policy</a> in the
/// 					<i>Amazon CloudFront Developer Guide</i>.</p>
/// 			         </li>
///             <li>
/// 				           <p>The location of the SSL/TLS certificate, <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html">AWS
/// 					Certificate Manager (ACM)</a> (recommended) or <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html">AWS Identity and Access Management (AWS IAM)</a>. You specify the location
/// 					by setting a value in one of the following fields (not both):</p>
/// 				           <ul>
///                   <li>
/// 						               <p>
///                         <code>ACMCertificateArn</code>
///
///                      </p>
/// 					             </li>
///                   <li>
/// 						               <p>
///                         <code>IAMCertificateId</code>
///
///                      </p>
/// 					             </li>
///                </ul>
/// 			         </li>
///          </ul>
/// 		       <p>All distributions support HTTPS connections from viewers. To require viewers to use
/// 			HTTPS only, or to redirect them from HTTP to HTTPS, use
/// 			<code>ViewerProtocolPolicy</code> in the <code>CacheBehavior</code> or
/// 			<code>DefaultCacheBehavior</code>. To specify how CloudFront should use SSL/TLS to
/// 			communicate with your custom origin, use <code>CustomOriginConfig</code>.</p>
/// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https.html">Using
/// 			HTTPS with CloudFront</a> and <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-https-alternate-domain-names.html">
/// 			Using Alternate Domain Names and HTTPS</a> in the
/// 			<i>Amazon CloudFront Developer Guide</i>.</p>
public struct ViewerCertificate: Equatable {
    /// <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs) and
    /// 			the SSL/TLS certificate is stored in <a href="https://docs.aws.amazon.com/acm/latest/userguide/acm-overview.html">AWS Certificate Manager (ACM)</a>, provide the Amazon Resource
    /// 			Name (ARN) of the ACM certificate. CloudFront only supports ACM certificates in the US
    /// 			East (N. Virginia) Region (<code>us-east-1</code>).</p>
    /// 		       <p>If you specify an ACM certificate ARN, you must also specify values for
    /// 			<code>MinimumProtocolVersion</code> and <code>SSLSupportMethod</code>.
    ///       </p>
    public let aCMCertificateArn: String?
    /// <p>This field is deprecated. Use one of the following fields instead:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>ACMCertificateArn</code>
    ///
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>IAMCertificateId</code>
    ///
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>CloudFrontDefaultCertificate</code>
    ///                </p>
    /// 			         </li>
    ///          </ul>
    @available(*, deprecated)
    public let certificate: String?
    /// <p>This field is deprecated. Use one of the following fields instead:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>ACMCertificateArn</code>
    ///
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>IAMCertificateId</code>
    ///
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>CloudFrontDefaultCertificate</code>
    ///                </p>
    /// 			         </li>
    ///          </ul>
    @available(*, deprecated)
    public let certificateSource: CertificateSource?
    /// <p>If the distribution uses the CloudFront domain name such as
    /// 			<code>d111111abcdef8.cloudfront.net</code>, set this field to <code>true</code>.</p>
    /// 		       <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), set
    /// 			this field to <code>false</code> and specify values for the following fields:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>ACMCertificateArn</code> or <code>IAMCertificateId</code> (specify a value for one,
    /// 					not both)</p>
    /// 				
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>MinimumProtocolVersion</code>
    ///                </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>SSLSupportMethod</code>
    ///
    ///                </p>
    /// 			         </li>
    ///          </ul>
    public let cloudFrontDefaultCertificate: Bool?
    /// <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs) and
    /// 			the SSL/TLS certificate is stored in <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_server-certs.html">AWS
    /// 			Identity and Access Management (AWS IAM)</a>, provide the ID of the IAM
    /// 			certificate.</p>
    /// 		       <p>If you specify an IAM certificate ID, you must also specify values for
    /// 			<code>MinimumProtocolVersion</code> and <code>SSLSupportMethod</code>.
    ///       </p>
    public let iAMCertificateId: String?
    /// <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs),
    /// 			specify the security policy that you want CloudFront to use for HTTPS connections with
    /// 			viewers. The security policy determines two settings:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The minimum SSL/TLS protocol that CloudFront can use to communicate with
    /// 					viewers.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The ciphers that CloudFront can use to encrypt the content that it returns to
    /// 					viewers.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-values-specify.html#DownloadDistValues-security-policy">Security Policy</a> and <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/secure-connections-supported-viewer-protocols-ciphers.html#secure-connections-supported-ciphers">Supported Protocols and Ciphers Between Viewers and
    /// 			CloudFront</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <note>
    /// 			         <p>On the CloudFront console, this setting is called <b>Security
    /// 				Policy</b>.</p>
    /// 		       </note>
    /// 		       <p>When you’re using SNI only (you set <code>SSLSupportMethod</code> to <code>sni-only</code>),
    /// 			you must specify <code>TLSv1</code> or higher.
    ///       </p>
    /// 		       <p>If the distribution uses the CloudFront domain name such as
    /// 			<code>d111111abcdef8.cloudfront.net</code> (you set
    /// 			<code>CloudFrontDefaultCertificate</code> to <code>true</code>), CloudFront automatically sets
    /// 			the security policy to <code>TLSv1</code> regardless of the value that you set
    /// 			here.</p>
    public let minimumProtocolVersion: MinimumProtocolVersion?
    /// <p>If the distribution uses <code>Aliases</code> (alternate domain names or CNAMEs), specify
    /// 			which viewers the distribution accepts HTTPS connections from.</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>
    ///                   <code>sni-only</code> – The distribution accepts HTTPS connections from only viewers that
    /// 					support <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">server
    /// 					name indication (SNI)</a>. This is recommended. Most browsers and clients support SNI.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>vip</code> – The distribution accepts HTTPS connections from all viewers including
    /// 					those that don’t support SNI. This is not recommended, and results in additional
    /// 					monthly charges from CloudFront.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>
    ///                   <code>static-ip</code> - Do not specify this value unless your distribution
    /// 					has been enabled for this feature by the CloudFront team. If you have a use case
    /// 					that requires static IP addresses for a distribution, contact CloudFront through
    /// 					the <a href="https://console.aws.amazon.com/support/home">AWS Support Center</a>.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>If the distribution uses the CloudFront domain name such as
    /// 			<code>d111111abcdef8.cloudfront.net</code>, don’t set a value for this field.</p>
    public let sSLSupportMethod: SSLSupportMethod?

    public init (
        aCMCertificateArn: String? = nil,
        certificate: String? = nil,
        certificateSource: CertificateSource? = nil,
        cloudFrontDefaultCertificate: Bool? = nil,
        iAMCertificateId: String? = nil,
        minimumProtocolVersion: MinimumProtocolVersion? = nil,
        sSLSupportMethod: SSLSupportMethod? = nil
    )
    {
        self.aCMCertificateArn = aCMCertificateArn
        self.certificate = certificate
        self.certificateSource = certificateSource
        self.cloudFrontDefaultCertificate = cloudFrontDefaultCertificate
        self.iAMCertificateId = iAMCertificateId
        self.minimumProtocolVersion = minimumProtocolVersion
        self.sSLSupportMethod = sSLSupportMethod
    }
}

public enum ViewerProtocolPolicy {
    case allowAll
    case httpsOnly
    case redirectToHttps
    case sdkUnknown(String)
}

extension ViewerProtocolPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ViewerProtocolPolicy] {
        return [
            .allowAll,
            .httpsOnly,
            .redirectToHttps,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allowAll: return "allow-all"
        case .httpsOnly: return "https-only"
        case .redirectToHttps: return "redirect-to-https"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ViewerProtocolPolicy(rawValue: rawValue) ?? ViewerProtocolPolicy.sdkUnknown(rawValue)
    }
}
