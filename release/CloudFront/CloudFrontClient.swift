// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class CloudFrontClient {
    let client: SdkHttpClient
    let config: CloudFrontClientConfiguration
    let serviceName = "CloudFront"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: CloudFrontClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = XMLEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = XMLDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class CloudFrontClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> CloudFrontClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try CloudFrontClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension CloudFrontClient: CloudFrontClientProtocol {
    /// <p>Creates a cache policy.</p>
    /// 		       <p>After you create a cache policy, you can attach it to one or more cache behaviors. When it’s
    /// 			attached to a cache behavior, the cache policy determines the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The values that CloudFront includes in the <i>cache key</i>. These values can
    /// 					include HTTP headers, cookies, and URL query strings. CloudFront uses the cache key to
    /// 					find an object in its cache that it can return to the viewer.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The default, minimum, and maximum time to live (TTL) values that you want objects to stay
    /// 					in the CloudFront cache.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>The headers, cookies, and query strings that are included in the cache key are automatically
    /// 			included in requests that CloudFront sends to the origin. CloudFront sends a request when it can’t
    /// 			find an object in its cache that matches the request’s cache key. If you want to send
    /// 			values to the origin but <i>not</i> include them in the cache key, use
    /// 			<code>OriginRequestPolicy</code>.</p>
    /// 		       <p>For more information about cache policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-the-cache-key.html">Controlling the cache key</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public func createCachePolicy(input: CreateCachePolicyInput, completion: @escaping (SdkResult<CreateCachePolicyOutputResponse, CreateCachePolicyOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/cache-policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCachePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCachePolicyInput, CreateCachePolicyOutputResponse, CreateCachePolicyOutputError>(id: "createCachePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCachePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCachePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCachePolicyInput, CreateCachePolicyOutputResponse, CreateCachePolicyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCachePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new origin access identity. If you're using Amazon S3 for your origin, you can
    /// 			use an origin access identity to require users to access your content using a CloudFront URL instead
    /// 			of the Amazon S3 URL. For more information about how to use origin access identities, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving Private Content through CloudFront</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public func createCloudFrontOriginAccessIdentity(input: CreateCloudFrontOriginAccessIdentityInput, completion: @escaping (SdkResult<CreateCloudFrontOriginAccessIdentityOutputResponse, CreateCloudFrontOriginAccessIdentityOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/origin-access-identity/cloudfront"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCloudFrontOriginAccessIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateCloudFrontOriginAccessIdentityInput, CreateCloudFrontOriginAccessIdentityOutputResponse, CreateCloudFrontOriginAccessIdentityOutputError>(id: "createCloudFrontOriginAccessIdentity")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateCloudFrontOriginAccessIdentityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateCloudFrontOriginAccessIdentityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateCloudFrontOriginAccessIdentityInput, CreateCloudFrontOriginAccessIdentityOutputResponse, CreateCloudFrontOriginAccessIdentityOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateCloudFrontOriginAccessIdentityInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new web distribution. You create a CloudFront distribution to tell CloudFront where you
    /// 			want content to be delivered from, and the details about how to track and manage content delivery. Send a <code>POST</code> request to the
    /// 			<code>/<i>CloudFront API version</i>/distribution</code>/<code>distribution ID</code> resource.</p>
    /// 		       <important>
    ///             <p>When you update a distribution, there are more required fields than when you create a distribution.
    /// 			When you update your distribution by using
    /// 			<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_UpdateDistribution.html">UpdateDistribution</a>,
    /// 			follow the steps included
    /// 			in the documentation to get the current configuration
    /// 			and then make your updates. This helps to make sure that you include all of the required fields. To view a summary,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
    /// 				Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    ///          </important>
    public func createDistribution(input: CreateDistributionInput, completion: @escaping (SdkResult<CreateDistributionOutputResponse, CreateDistributionOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/distribution"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDistribution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDistributionInput, CreateDistributionOutputResponse, CreateDistributionOutputError>(id: "createDistribution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDistributionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDistributionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDistributionInput, CreateDistributionOutputResponse, CreateDistributionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDistributionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a new distribution with tags.</p>
    public func createDistributionWithTags(input: CreateDistributionWithTagsInput, completion: @escaping (SdkResult<CreateDistributionWithTagsOutputResponse, CreateDistributionWithTagsOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/distribution"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createDistributionWithTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateDistributionWithTagsInput, CreateDistributionWithTagsOutputResponse, CreateDistributionWithTagsOutputError>(id: "createDistributionWithTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateDistributionWithTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateDistributionWithTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateDistributionWithTagsInput, CreateDistributionWithTagsOutputResponse, CreateDistributionWithTagsOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateDistributionWithTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a new field-level encryption configuration.</p>
    public func createFieldLevelEncryptionConfig(input: CreateFieldLevelEncryptionConfigInput, completion: @escaping (SdkResult<CreateFieldLevelEncryptionConfigOutputResponse, CreateFieldLevelEncryptionConfigOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/field-level-encryption"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFieldLevelEncryptionConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFieldLevelEncryptionConfigInput, CreateFieldLevelEncryptionConfigOutputResponse, CreateFieldLevelEncryptionConfigOutputError>(id: "createFieldLevelEncryptionConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateFieldLevelEncryptionConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFieldLevelEncryptionConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFieldLevelEncryptionConfigInput, CreateFieldLevelEncryptionConfigOutputResponse, CreateFieldLevelEncryptionConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFieldLevelEncryptionConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a field-level encryption profile.</p>
    public func createFieldLevelEncryptionProfile(input: CreateFieldLevelEncryptionProfileInput, completion: @escaping (SdkResult<CreateFieldLevelEncryptionProfileOutputResponse, CreateFieldLevelEncryptionProfileOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/field-level-encryption-profile"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFieldLevelEncryptionProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFieldLevelEncryptionProfileInput, CreateFieldLevelEncryptionProfileOutputResponse, CreateFieldLevelEncryptionProfileOutputError>(id: "createFieldLevelEncryptionProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateFieldLevelEncryptionProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFieldLevelEncryptionProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFieldLevelEncryptionProfileInput, CreateFieldLevelEncryptionProfileOutputResponse, CreateFieldLevelEncryptionProfileOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFieldLevelEncryptionProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a CloudFront function.</p>
    /// 		       <p>To create a function, you provide the function code and some configuration information
    /// 			about the function. The response contains an Amazon Resource Name (ARN) that uniquely
    /// 			identifies the function.</p>
    /// 		       <p>When you create a function, it’s in the <code>DEVELOPMENT</code> stage. In this stage, you
    /// 			can test the function with <code>TestFunction</code>, and update it with
    /// 			<code>UpdateFunction</code>.</p>
    /// 		       <p>When you’re ready to use your function with a CloudFront distribution, use
    /// 			<code>PublishFunction</code> to copy the function from the <code>DEVELOPMENT</code>
    /// 			stage to <code>LIVE</code>. When it’s live, you can attach the function to a
    /// 			distribution’s cache behavior, using the function’s ARN.</p>
    public func createFunction(input: CreateFunctionInput, completion: @escaping (SdkResult<CreateFunctionOutputResponse, CreateFunctionOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/function"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateFunctionInput, CreateFunctionOutputResponse, CreateFunctionOutputError>(id: "createFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateFunctionInput, CreateFunctionOutputResponse, CreateFunctionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateFunctionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Create a new invalidation. </p>
    public func createInvalidation(input: CreateInvalidationInput, completion: @escaping (SdkResult<CreateInvalidationOutputResponse, CreateInvalidationOutputError>) -> Void)
    {
        guard let distributionId = input.distributionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component distributionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distribution/\(distributionId)/invalidation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createInvalidation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateInvalidationInput, CreateInvalidationOutputResponse, CreateInvalidationOutputError>(id: "createInvalidation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateInvalidationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateInvalidationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateInvalidationInput, CreateInvalidationOutputResponse, CreateInvalidationOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateInvalidationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a key group that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">CloudFront signed URLs and signed cookies</a>.</p>
    /// 		       <p>To create a key group, you must specify at least one public key for the key group. After you
    /// 			create a key group, you can reference it from one or more cache behaviors. When you
    /// 			reference a key group in a cache behavior, CloudFront requires signed URLs or signed cookies
    /// 			for all requests that match the cache behavior. The URLs or cookies must be signed with
    /// 			a private key whose corresponding public key is in the key group. The signed URL or
    /// 			cookie contains information about which public key CloudFront should use to verify the
    /// 			signature. For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">Serving private content</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public func createKeyGroup(input: CreateKeyGroupInput, completion: @escaping (SdkResult<CreateKeyGroupOutputResponse, CreateKeyGroupOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/key-group"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createKeyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateKeyGroupInput, CreateKeyGroupOutputResponse, CreateKeyGroupOutputError>(id: "createKeyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateKeyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateKeyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateKeyGroupInput, CreateKeyGroupOutputResponse, CreateKeyGroupOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateKeyGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Enables additional CloudWatch metrics for the specified CloudFront distribution. The
    /// 			additional metrics incur an additional cost.</p>
    /// 		       <p>For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional">Viewing additional CloudFront distribution metrics</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public func createMonitoringSubscription(input: CreateMonitoringSubscriptionInput, completion: @escaping (SdkResult<CreateMonitoringSubscriptionOutputResponse, CreateMonitoringSubscriptionOutputError>) -> Void)
    {
        guard let distributionId = input.distributionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component distributionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distributions/\(distributionId)/monitoring-subscription"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createMonitoringSubscription")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateMonitoringSubscriptionInput, CreateMonitoringSubscriptionOutputResponse, CreateMonitoringSubscriptionOutputError>(id: "createMonitoringSubscription")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateMonitoringSubscriptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateMonitoringSubscriptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateMonitoringSubscriptionInput, CreateMonitoringSubscriptionOutputResponse, CreateMonitoringSubscriptionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateMonitoringSubscriptionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an origin request policy.</p>
    /// 		       <p>After you create an origin request policy, you can attach it to one or more cache behaviors.
    /// 			When it’s attached to a cache behavior, the origin request policy determines the values
    /// 			that CloudFront includes in requests that it sends to the origin. Each request that CloudFront sends
    /// 			to the origin includes the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The request body and the URL path (without the domain name) from the viewer
    /// 					request.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The headers that CloudFront automatically includes in every origin request, including
    /// 					<code>Host</code>, <code>User-Agent</code>, and <code>X-Amz-Cf-Id</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>All HTTP headers, cookies, and URL query strings that are specified in the cache policy or
    /// 					the origin request policy. These can include items from the viewer request and,
    /// 					in the case of headers, additional ones that are added by CloudFront.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>CloudFront sends a request when it can’t find a valid object in its cache that matches the
    /// 			request. If you want to send values to the origin and also include them in the cache
    /// 			key, use <code>CachePolicy</code>.</p>
    /// 		       <p>For more information about origin request policies, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html">Controlling origin requests</a> in the
    /// 			<i>Amazon CloudFront Developer Guide</i>.</p>
    public func createOriginRequestPolicy(input: CreateOriginRequestPolicyInput, completion: @escaping (SdkResult<CreateOriginRequestPolicyOutputResponse, CreateOriginRequestPolicyOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/origin-request-policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createOriginRequestPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateOriginRequestPolicyInput, CreateOriginRequestPolicyOutputResponse, CreateOriginRequestPolicyOutputError>(id: "createOriginRequestPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateOriginRequestPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateOriginRequestPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateOriginRequestPolicyInput, CreateOriginRequestPolicyOutputResponse, CreateOriginRequestPolicyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateOriginRequestPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Uploads a public key to CloudFront that you can use with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/PrivateContent.html">signed URLs and signed cookies</a>, or with <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/field-level-encryption.html">field-level encryption</a>.</p>
    public func createPublicKey(input: CreatePublicKeyInput, completion: @escaping (SdkResult<CreatePublicKeyOutputResponse, CreatePublicKeyOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/public-key"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createPublicKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreatePublicKeyInput, CreatePublicKeyOutputResponse, CreatePublicKeyOutputError>(id: "createPublicKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreatePublicKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreatePublicKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreatePublicKeyInput, CreatePublicKeyOutputResponse, CreatePublicKeyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreatePublicKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a real-time log configuration.</p>
    /// 		       <p>After you create a real-time log configuration, you can attach it to one or more cache
    /// 			behaviors to send real-time log data to the specified Amazon Kinesis data stream.</p>
    /// 		       <p>For more information about real-time log configurations, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/real-time-logs.html">Real-time logs</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    public func createRealtimeLogConfig(input: CreateRealtimeLogConfigInput, completion: @escaping (SdkResult<CreateRealtimeLogConfigOutputResponse, CreateRealtimeLogConfigOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/realtime-log-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRealtimeLogConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRealtimeLogConfigInput, CreateRealtimeLogConfigOutputResponse, CreateRealtimeLogConfigOutputError>(id: "createRealtimeLogConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateRealtimeLogConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRealtimeLogConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateRealtimeLogConfigInput, CreateRealtimeLogConfigOutputResponse, CreateRealtimeLogConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRealtimeLogConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is deprecated.
    ///             Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
    ///             For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
    public func createStreamingDistribution(input: CreateStreamingDistributionInput, completion: @escaping (SdkResult<CreateStreamingDistributionOutputResponse, CreateStreamingDistributionOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/streaming-distribution"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createStreamingDistribution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateStreamingDistributionInput, CreateStreamingDistributionOutputResponse, CreateStreamingDistributionOutputError>(id: "createStreamingDistribution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamingDistributionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamingDistributionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateStreamingDistributionInput, CreateStreamingDistributionOutputResponse, CreateStreamingDistributionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamingDistributionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This API is deprecated.
    ///             Amazon CloudFront is deprecating real-time messaging protocol (RTMP) distributions on December 31, 2020.
    ///             For more information, <a href="http://forums.aws.amazon.com/ann.jspa?annID=7356">read the announcement</a> on the Amazon CloudFront discussion forum.</p>
    public func createStreamingDistributionWithTags(input: CreateStreamingDistributionWithTagsInput, completion: @escaping (SdkResult<CreateStreamingDistributionWithTagsOutputResponse, CreateStreamingDistributionWithTagsOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/streaming-distribution"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createStreamingDistributionWithTags")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateStreamingDistributionWithTagsInput, CreateStreamingDistributionWithTagsOutputResponse, CreateStreamingDistributionWithTagsOutputError>(id: "createStreamingDistributionWithTags")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamingDistributionWithTagsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamingDistributionWithTagsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateStreamingDistributionWithTagsInput, CreateStreamingDistributionWithTagsOutputResponse, CreateStreamingDistributionWithTagsOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: CreateStreamingDistributionWithTagsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a cache policy.</p>
    /// 		       <p>You cannot delete a cache policy if it’s attached to a cache behavior. First update your
    /// 			distributions to remove the cache policy from all cache behaviors, then delete the cache
    /// 			policy.</p>
    /// 		       <p>To delete a cache policy, you must provide the policy’s identifier and version. To get these
    /// 			values, you can use <code>ListCachePolicies</code> or
    /// 			<code>GetCachePolicy</code>.</p>
    public func deleteCachePolicy(input: DeleteCachePolicyInput, completion: @escaping (SdkResult<DeleteCachePolicyOutputResponse, DeleteCachePolicyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/cache-policy/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCachePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCachePolicyInput, DeleteCachePolicyOutputResponse, DeleteCachePolicyOutputError>(id: "deleteCachePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCachePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCachePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCachePolicyInput, DeleteCachePolicyOutputResponse, DeleteCachePolicyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete an origin access identity. </p>
    public func deleteCloudFrontOriginAccessIdentity(input: DeleteCloudFrontOriginAccessIdentityInput, completion: @escaping (SdkResult<DeleteCloudFrontOriginAccessIdentityOutputResponse, DeleteCloudFrontOriginAccessIdentityOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/origin-access-identity/cloudfront/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteCloudFrontOriginAccessIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteCloudFrontOriginAccessIdentityInput, DeleteCloudFrontOriginAccessIdentityOutputResponse, DeleteCloudFrontOriginAccessIdentityOutputError>(id: "deleteCloudFrontOriginAccessIdentity")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteCloudFrontOriginAccessIdentityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteCloudFrontOriginAccessIdentityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteCloudFrontOriginAccessIdentityInput, DeleteCloudFrontOriginAccessIdentityOutputResponse, DeleteCloudFrontOriginAccessIdentityOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete a distribution. </p>
    public func deleteDistribution(input: DeleteDistributionInput, completion: @escaping (SdkResult<DeleteDistributionOutputResponse, DeleteDistributionOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distribution/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteDistribution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteDistributionInput, DeleteDistributionOutputResponse, DeleteDistributionOutputError>(id: "deleteDistribution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteDistributionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteDistributionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteDistributionInput, DeleteDistributionOutputResponse, DeleteDistributionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Remove a field-level encryption configuration.</p>
    public func deleteFieldLevelEncryptionConfig(input: DeleteFieldLevelEncryptionConfigInput, completion: @escaping (SdkResult<DeleteFieldLevelEncryptionConfigOutputResponse, DeleteFieldLevelEncryptionConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/field-level-encryption/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFieldLevelEncryptionConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFieldLevelEncryptionConfigInput, DeleteFieldLevelEncryptionConfigOutputResponse, DeleteFieldLevelEncryptionConfigOutputError>(id: "deleteFieldLevelEncryptionConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFieldLevelEncryptionConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFieldLevelEncryptionConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFieldLevelEncryptionConfigInput, DeleteFieldLevelEncryptionConfigOutputResponse, DeleteFieldLevelEncryptionConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Remove a field-level encryption profile.</p>
    public func deleteFieldLevelEncryptionProfile(input: DeleteFieldLevelEncryptionProfileInput, completion: @escaping (SdkResult<DeleteFieldLevelEncryptionProfileOutputResponse, DeleteFieldLevelEncryptionProfileOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/field-level-encryption-profile/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFieldLevelEncryptionProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFieldLevelEncryptionProfileInput, DeleteFieldLevelEncryptionProfileOutputResponse, DeleteFieldLevelEncryptionProfileOutputError>(id: "deleteFieldLevelEncryptionProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFieldLevelEncryptionProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFieldLevelEncryptionProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFieldLevelEncryptionProfileInput, DeleteFieldLevelEncryptionProfileOutputResponse, DeleteFieldLevelEncryptionProfileOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a CloudFront function.</p>
    /// 		       <p>You cannot delete a function if it’s associated with a cache behavior. First, update your
    /// 			distributions to remove the function association from all cache behaviors, then delete
    /// 			the function.</p>
    /// 		       <p>To delete a function, you must provide the function’s name and version
    /// 			(<code>ETag</code> value). To get these values, you can use <code>ListFunctions</code>
    /// 			and <code>DescribeFunction</code>.</p>
    public func deleteFunction(input: DeleteFunctionInput, completion: @escaping (SdkResult<DeleteFunctionOutputResponse, DeleteFunctionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/function/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteFunctionInput, DeleteFunctionOutputResponse, DeleteFunctionOutputError>(id: "deleteFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteFunctionInput, DeleteFunctionOutputResponse, DeleteFunctionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a key group.</p>
    /// 		       <p>You cannot delete a key group that is referenced in a cache behavior. First update
    /// 			your distributions to remove the key group from all cache behaviors, then delete the key
    /// 			group.</p>
    /// 		       <p>To delete a key group, you must provide the key group’s identifier and version. To get
    /// 			these values, use <code>ListKeyGroups</code> followed by <code>GetKeyGroup</code> or
    /// 			<code>GetKeyGroupConfig</code>.</p>
    public func deleteKeyGroup(input: DeleteKeyGroupInput, completion: @escaping (SdkResult<DeleteKeyGroupOutputResponse, DeleteKeyGroupOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/key-group/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteKeyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteKeyGroupInput, DeleteKeyGroupOutputResponse, DeleteKeyGroupOutputError>(id: "deleteKeyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteKeyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteKeyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteKeyGroupInput, DeleteKeyGroupOutputResponse, DeleteKeyGroupOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Disables additional CloudWatch metrics for the specified CloudFront distribution.</p>
    public func deleteMonitoringSubscription(input: DeleteMonitoringSubscriptionInput, completion: @escaping (SdkResult<DeleteMonitoringSubscriptionOutputResponse, DeleteMonitoringSubscriptionOutputError>) -> Void)
    {
        guard let distributionId = input.distributionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component distributionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distributions/\(distributionId)/monitoring-subscription"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMonitoringSubscription")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMonitoringSubscriptionInput, DeleteMonitoringSubscriptionOutputResponse, DeleteMonitoringSubscriptionOutputError>(id: "deleteMonitoringSubscription")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMonitoringSubscriptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMonitoringSubscriptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteMonitoringSubscriptionInput, DeleteMonitoringSubscriptionOutputResponse, DeleteMonitoringSubscriptionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an origin request policy.</p>
    /// 		       <p>You cannot delete an origin request policy if it’s attached to any cache behaviors. First
    /// 			update your distributions to remove the origin request policy from all cache behaviors,
    /// 			then delete the origin request policy.</p>
    /// 		       <p>To delete an origin request policy, you must provide the policy’s identifier and version. To
    /// 			get the identifier, you can use <code>ListOriginRequestPolicies</code> or
    /// 			<code>GetOriginRequestPolicy</code>.</p>
    public func deleteOriginRequestPolicy(input: DeleteOriginRequestPolicyInput, completion: @escaping (SdkResult<DeleteOriginRequestPolicyOutputResponse, DeleteOriginRequestPolicyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/origin-request-policy/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteOriginRequestPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteOriginRequestPolicyInput, DeleteOriginRequestPolicyOutputResponse, DeleteOriginRequestPolicyOutputError>(id: "deleteOriginRequestPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteOriginRequestPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteOriginRequestPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteOriginRequestPolicyInput, DeleteOriginRequestPolicyOutputResponse, DeleteOriginRequestPolicyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Remove a public key you previously added to CloudFront.</p>
    public func deletePublicKey(input: DeletePublicKeyInput, completion: @escaping (SdkResult<DeletePublicKeyOutputResponse, DeletePublicKeyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/public-key/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deletePublicKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeletePublicKeyInput, DeletePublicKeyOutputResponse, DeletePublicKeyOutputError>(id: "deletePublicKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeletePublicKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeletePublicKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeletePublicKeyInput, DeletePublicKeyOutputResponse, DeletePublicKeyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a real-time log configuration.</p>
    /// 		       <p>You cannot delete a real-time log configuration if it’s attached to a cache behavior.
    /// 			First update your distributions to remove the real-time log configuration from all cache
    /// 			behaviors, then delete the real-time log configuration.</p>
    /// 		       <p>To delete a real-time log configuration, you can provide the configuration’s name or its
    /// 			Amazon Resource Name (ARN). You must provide at least one. If you provide both, CloudFront
    /// 			uses the name to identify the real-time log configuration to delete.</p>
    public func deleteRealtimeLogConfig(input: DeleteRealtimeLogConfigInput, completion: @escaping (SdkResult<DeleteRealtimeLogConfigOutputResponse, DeleteRealtimeLogConfigOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/delete-realtime-log-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRealtimeLogConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRealtimeLogConfigInput, DeleteRealtimeLogConfigOutputResponse, DeleteRealtimeLogConfigOutputError>(id: "deleteRealtimeLogConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRealtimeLogConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRealtimeLogConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRealtimeLogConfigInput, DeleteRealtimeLogConfigOutputResponse, DeleteRealtimeLogConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: DeleteRealtimeLogConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Delete a streaming distribution. To delete an RTMP distribution using the CloudFront API,
    /// 			perform the following steps.</p>
    ///
    /// 		       <p>
    ///             <b>To delete an RTMP distribution using the CloudFront
    /// 			API</b>:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Disable the RTMP distribution.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Submit a <code>GET Streaming Distribution Config</code> request to get the current
    /// 					configuration and the <code>Etag</code> header for the distribution. </p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Update the XML document that was returned in the response to your <code>GET
    /// 						Streaming Distribution Config</code> request to change the value of <code>Enabled</code>
    /// 					to <code>false</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Submit a <code>PUT Streaming Distribution Config</code> request to update the
    /// 					configuration for your distribution. In the request body, include the XML document that
    /// 					you updated in Step 3. Then set the value of the HTTP <code>If-Match</code> header to the
    /// 					value of the <code>ETag</code> header that CloudFront returned when you submitted the <code>GET
    /// 						Streaming Distribution Config</code> request in Step 2.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Review the response to the <code>PUT Streaming Distribution Config</code> request
    /// 					to confirm that the distribution was successfully disabled.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Submit a <code>GET Streaming Distribution Config</code> request to confirm that
    /// 					your changes have propagated. When propagation is complete, the value of
    /// 						<code>Status</code> is <code>Deployed</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Submit a <code>DELETE Streaming Distribution</code> request. Set the value of the
    /// 					HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront
    /// 					returned when you submitted the <code>GET Streaming Distribution Config</code> request in
    /// 					Step 2.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Review the response to your <code>DELETE Streaming Distribution</code> request to
    /// 					confirm that the distribution was successfully deleted.</p>
    /// 			         </li>
    ///          </ol>
    /// 		       <p>For information about deleting a distribution using the CloudFront console, see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/HowToDeleteDistribution.html">Deleting a Distribution</a> in the
    /// 				<i>Amazon CloudFront Developer Guide</i>.</p>
    public func deleteStreamingDistribution(input: DeleteStreamingDistributionInput, completion: @escaping (SdkResult<DeleteStreamingDistributionOutputResponse, DeleteStreamingDistributionOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/streaming-distribution/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteStreamingDistribution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteStreamingDistributionInput, DeleteStreamingDistributionOutputResponse, DeleteStreamingDistributionOutputError>(id: "deleteStreamingDistribution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteStreamingDistributionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteStreamingDistributionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteStreamingDistributionInput, DeleteStreamingDistributionOutputResponse, DeleteStreamingDistributionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets configuration information and metadata about a CloudFront function, but not the function’s
    /// 			code. To get a function’s code, use <code>GetFunction</code>.</p>
    /// 		       <p>To get configuration information and metadata about a function, you must provide the
    /// 			function’s name and stage. To get these values, you can use
    /// 			<code>ListFunctions</code>.</p>
    public func describeFunction(input: DescribeFunctionInput, completion: @escaping (SdkResult<DescribeFunctionOutputResponse, DescribeFunctionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/function/\(name)/describe"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeFunctionInput, DescribeFunctionOutputResponse, DescribeFunctionOutputError>(id: "describeFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeFunctionInput, DescribeFunctionOutputResponse, DescribeFunctionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a cache policy, including the following metadata:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The policy’s identifier.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The date and time when the policy was last modified.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>To get a cache policy, you must provide the policy’s identifier. If the cache policy is
    /// 			attached to a distribution’s cache behavior, you can get the policy’s identifier using
    /// 			<code>ListDistributions</code> or <code>GetDistribution</code>. If the cache policy is
    /// 			not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListCachePolicies</code>.</p>
    public func getCachePolicy(input: GetCachePolicyInput, completion: @escaping (SdkResult<GetCachePolicyOutputResponse, GetCachePolicyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/cache-policy/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCachePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCachePolicyInput, GetCachePolicyOutputResponse, GetCachePolicyOutputError>(id: "getCachePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCachePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCachePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCachePolicyInput, GetCachePolicyOutputResponse, GetCachePolicyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a cache policy configuration.</p>
    /// 		       <p>To get a cache policy configuration, you must provide the policy’s identifier. If the cache
    /// 			policy is attached to a distribution’s cache behavior, you can get the policy’s
    /// 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
    /// 			cache policy is not attached to a cache behavior, you can get the identifier using
    /// 			<code>ListCachePolicies</code>.</p>
    public func getCachePolicyConfig(input: GetCachePolicyConfigInput, completion: @escaping (SdkResult<GetCachePolicyConfigOutputResponse, GetCachePolicyConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/cache-policy/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCachePolicyConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCachePolicyConfigInput, GetCachePolicyConfigOutputResponse, GetCachePolicyConfigOutputError>(id: "getCachePolicyConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCachePolicyConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCachePolicyConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCachePolicyConfigInput, GetCachePolicyConfigOutputResponse, GetCachePolicyConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the information about an origin access identity. </p>
    public func getCloudFrontOriginAccessIdentity(input: GetCloudFrontOriginAccessIdentityInput, completion: @escaping (SdkResult<GetCloudFrontOriginAccessIdentityOutputResponse, GetCloudFrontOriginAccessIdentityOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/origin-access-identity/cloudfront/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCloudFrontOriginAccessIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCloudFrontOriginAccessIdentityInput, GetCloudFrontOriginAccessIdentityOutputResponse, GetCloudFrontOriginAccessIdentityOutputError>(id: "getCloudFrontOriginAccessIdentity")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCloudFrontOriginAccessIdentityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCloudFrontOriginAccessIdentityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCloudFrontOriginAccessIdentityInput, GetCloudFrontOriginAccessIdentityOutputResponse, GetCloudFrontOriginAccessIdentityOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the configuration information about an origin access identity. </p>
    public func getCloudFrontOriginAccessIdentityConfig(input: GetCloudFrontOriginAccessIdentityConfigInput, completion: @escaping (SdkResult<GetCloudFrontOriginAccessIdentityConfigOutputResponse, GetCloudFrontOriginAccessIdentityConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/origin-access-identity/cloudfront/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getCloudFrontOriginAccessIdentityConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetCloudFrontOriginAccessIdentityConfigInput, GetCloudFrontOriginAccessIdentityConfigOutputResponse, GetCloudFrontOriginAccessIdentityConfigOutputError>(id: "getCloudFrontOriginAccessIdentityConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetCloudFrontOriginAccessIdentityConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetCloudFrontOriginAccessIdentityConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetCloudFrontOriginAccessIdentityConfigInput, GetCloudFrontOriginAccessIdentityConfigOutputResponse, GetCloudFrontOriginAccessIdentityConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the information about a distribution.</p>
    public func getDistribution(input: GetDistributionInput, completion: @escaping (SdkResult<GetDistributionOutputResponse, GetDistributionOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distribution/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDistribution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDistributionInput, GetDistributionOutputResponse, GetDistributionOutputError>(id: "getDistribution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDistributionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDistributionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDistributionInput, GetDistributionOutputResponse, GetDistributionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the configuration information about a distribution. </p>
    public func getDistributionConfig(input: GetDistributionConfigInput, completion: @escaping (SdkResult<GetDistributionConfigOutputResponse, GetDistributionConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distribution/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getDistributionConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetDistributionConfigInput, GetDistributionConfigOutputResponse, GetDistributionConfigOutputError>(id: "getDistributionConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetDistributionConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetDistributionConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetDistributionConfigInput, GetDistributionConfigOutputResponse, GetDistributionConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the field-level encryption configuration information.</p>
    public func getFieldLevelEncryption(input: GetFieldLevelEncryptionInput, completion: @escaping (SdkResult<GetFieldLevelEncryptionOutputResponse, GetFieldLevelEncryptionOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/field-level-encryption/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFieldLevelEncryption")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFieldLevelEncryptionInput, GetFieldLevelEncryptionOutputResponse, GetFieldLevelEncryptionOutputError>(id: "getFieldLevelEncryption")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFieldLevelEncryptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFieldLevelEncryptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFieldLevelEncryptionInput, GetFieldLevelEncryptionOutputResponse, GetFieldLevelEncryptionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the field-level encryption configuration information.</p>
    public func getFieldLevelEncryptionConfig(input: GetFieldLevelEncryptionConfigInput, completion: @escaping (SdkResult<GetFieldLevelEncryptionConfigOutputResponse, GetFieldLevelEncryptionConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/field-level-encryption/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFieldLevelEncryptionConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFieldLevelEncryptionConfigInput, GetFieldLevelEncryptionConfigOutputResponse, GetFieldLevelEncryptionConfigOutputError>(id: "getFieldLevelEncryptionConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFieldLevelEncryptionConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFieldLevelEncryptionConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFieldLevelEncryptionConfigInput, GetFieldLevelEncryptionConfigOutputResponse, GetFieldLevelEncryptionConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the field-level encryption profile information.</p>
    public func getFieldLevelEncryptionProfile(input: GetFieldLevelEncryptionProfileInput, completion: @escaping (SdkResult<GetFieldLevelEncryptionProfileOutputResponse, GetFieldLevelEncryptionProfileOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/field-level-encryption-profile/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFieldLevelEncryptionProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFieldLevelEncryptionProfileInput, GetFieldLevelEncryptionProfileOutputResponse, GetFieldLevelEncryptionProfileOutputError>(id: "getFieldLevelEncryptionProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFieldLevelEncryptionProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFieldLevelEncryptionProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFieldLevelEncryptionProfileInput, GetFieldLevelEncryptionProfileOutputResponse, GetFieldLevelEncryptionProfileOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the field-level encryption profile configuration information.</p>
    public func getFieldLevelEncryptionProfileConfig(input: GetFieldLevelEncryptionProfileConfigInput, completion: @escaping (SdkResult<GetFieldLevelEncryptionProfileConfigOutputResponse, GetFieldLevelEncryptionProfileConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/field-level-encryption-profile/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFieldLevelEncryptionProfileConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFieldLevelEncryptionProfileConfigInput, GetFieldLevelEncryptionProfileConfigOutputResponse, GetFieldLevelEncryptionProfileConfigOutputError>(id: "getFieldLevelEncryptionProfileConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFieldLevelEncryptionProfileConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFieldLevelEncryptionProfileConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFieldLevelEncryptionProfileConfigInput, GetFieldLevelEncryptionProfileConfigOutputResponse, GetFieldLevelEncryptionProfileConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets the code of a CloudFront function. To get configuration information and metadata about
    /// 			a function, use <code>DescribeFunction</code>.</p>
    /// 		       <p>To get a function’s code, you must provide the function’s name and stage. To get these
    /// 			values, you can use <code>ListFunctions</code>.</p>
    public func getFunction(input: GetFunctionInput, completion: @escaping (SdkResult<GetFunctionOutputResponse, GetFunctionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/function/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFunctionInput, GetFunctionOutputResponse, GetFunctionOutputError>(id: "getFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFunctionInput, GetFunctionOutputResponse, GetFunctionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the information about an invalidation. </p>
    public func getInvalidation(input: GetInvalidationInput, completion: @escaping (SdkResult<GetInvalidationOutputResponse, GetInvalidationOutputError>) -> Void)
    {
        guard let distributionId = input.distributionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component distributionId unexpectedly nil"))))
            return
        }
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distribution/\(distributionId)/invalidation/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getInvalidation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetInvalidationInput, GetInvalidationOutputResponse, GetInvalidationOutputError>(id: "getInvalidation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetInvalidationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetInvalidationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetInvalidationInput, GetInvalidationOutputResponse, GetInvalidationOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a key group, including the date and time when the key group was last modified.</p>
    /// 		       <p>To get a key group, you must provide the key group’s identifier. If the key group is
    /// 			referenced in a distribution’s cache behavior, you can get the key group’s identifier
    /// 			using <code>ListDistributions</code> or <code>GetDistribution</code>. If the key group
    /// 			is not referenced in a cache behavior, you can get the identifier using
    /// 			<code>ListKeyGroups</code>.</p>
    public func getKeyGroup(input: GetKeyGroupInput, completion: @escaping (SdkResult<GetKeyGroupOutputResponse, GetKeyGroupOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/key-group/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getKeyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetKeyGroupInput, GetKeyGroupOutputResponse, GetKeyGroupOutputError>(id: "getKeyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetKeyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetKeyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetKeyGroupInput, GetKeyGroupOutputResponse, GetKeyGroupOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a key group configuration.</p>
    /// 		       <p>To get a key group configuration, you must provide the key group’s identifier. If the
    /// 			key group is referenced in a distribution’s cache behavior, you can get the key group’s
    /// 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
    /// 			key group is not referenced in a cache behavior, you can get the identifier using
    /// 			<code>ListKeyGroups</code>.</p>
    public func getKeyGroupConfig(input: GetKeyGroupConfigInput, completion: @escaping (SdkResult<GetKeyGroupConfigOutputResponse, GetKeyGroupConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/key-group/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getKeyGroupConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetKeyGroupConfigInput, GetKeyGroupConfigOutputResponse, GetKeyGroupConfigOutputError>(id: "getKeyGroupConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetKeyGroupConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetKeyGroupConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetKeyGroupConfigInput, GetKeyGroupConfigOutputResponse, GetKeyGroupConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about whether additional CloudWatch metrics are enabled for the specified
    /// 			CloudFront distribution.</p>
    public func getMonitoringSubscription(input: GetMonitoringSubscriptionInput, completion: @escaping (SdkResult<GetMonitoringSubscriptionOutputResponse, GetMonitoringSubscriptionOutputError>) -> Void)
    {
        guard let distributionId = input.distributionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component distributionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distributions/\(distributionId)/monitoring-subscription"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getMonitoringSubscription")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetMonitoringSubscriptionInput, GetMonitoringSubscriptionOutputResponse, GetMonitoringSubscriptionOutputError>(id: "getMonitoringSubscription")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetMonitoringSubscriptionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetMonitoringSubscriptionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetMonitoringSubscriptionInput, GetMonitoringSubscriptionOutputResponse, GetMonitoringSubscriptionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets an origin request policy, including the following metadata:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>The policy’s identifier.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>The date and time when the policy was last modified.</p>
    /// 			         </li>
    ///          </ul>
    /// 		       <p>To get an origin request policy, you must provide the policy’s identifier. If the origin
    /// 			request policy is attached to a distribution’s cache behavior, you can get the policy’s
    /// 			identifier using <code>ListDistributions</code> or <code>GetDistribution</code>. If the
    /// 			origin request policy is not attached to a cache behavior, you can get the identifier
    /// 			using <code>ListOriginRequestPolicies</code>.</p>
    public func getOriginRequestPolicy(input: GetOriginRequestPolicyInput, completion: @escaping (SdkResult<GetOriginRequestPolicyOutputResponse, GetOriginRequestPolicyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/origin-request-policy/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getOriginRequestPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetOriginRequestPolicyInput, GetOriginRequestPolicyOutputResponse, GetOriginRequestPolicyOutputError>(id: "getOriginRequestPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetOriginRequestPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetOriginRequestPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetOriginRequestPolicyInput, GetOriginRequestPolicyOutputResponse, GetOriginRequestPolicyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets an origin request policy configuration.</p>
    /// 		       <p>To get an origin request policy configuration, you must provide the policy’s identifier. If
    /// 			the origin request policy is attached to a distribution’s cache behavior, you can get
    /// 			the policy’s identifier using <code>ListDistributions</code> or
    /// 			<code>GetDistribution</code>. If the origin request policy is not attached to a cache
    /// 			behavior, you can get the identifier using
    /// 			<code>ListOriginRequestPolicies</code>.</p>
    public func getOriginRequestPolicyConfig(input: GetOriginRequestPolicyConfigInput, completion: @escaping (SdkResult<GetOriginRequestPolicyConfigOutputResponse, GetOriginRequestPolicyConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/origin-request-policy/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getOriginRequestPolicyConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetOriginRequestPolicyConfigInput, GetOriginRequestPolicyConfigOutputResponse, GetOriginRequestPolicyConfigOutputError>(id: "getOriginRequestPolicyConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetOriginRequestPolicyConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetOriginRequestPolicyConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetOriginRequestPolicyConfigInput, GetOriginRequestPolicyConfigOutputResponse, GetOriginRequestPolicyConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a public key.</p>
    public func getPublicKey(input: GetPublicKeyInput, completion: @escaping (SdkResult<GetPublicKeyOutputResponse, GetPublicKeyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/public-key/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getPublicKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetPublicKeyInput, GetPublicKeyOutputResponse, GetPublicKeyOutputError>(id: "getPublicKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetPublicKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetPublicKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetPublicKeyInput, GetPublicKeyOutputResponse, GetPublicKeyOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a public key configuration.</p>
    public func getPublicKeyConfig(input: GetPublicKeyConfigInput, completion: @escaping (SdkResult<GetPublicKeyConfigOutputResponse, GetPublicKeyConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/public-key/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getPublicKeyConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetPublicKeyConfigInput, GetPublicKeyConfigOutputResponse, GetPublicKeyConfigOutputError>(id: "getPublicKeyConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetPublicKeyConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetPublicKeyConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetPublicKeyConfigInput, GetPublicKeyConfigOutputResponse, GetPublicKeyConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a real-time log configuration.</p>
    /// 		       <p>To get a real-time log configuration, you can provide the configuration’s name or its Amazon
    /// 			Resource Name (ARN). You must provide at least one. If you provide both, CloudFront uses the
    /// 			name to identify the real-time log configuration to get.</p>
    public func getRealtimeLogConfig(input: GetRealtimeLogConfigInput, completion: @escaping (SdkResult<GetRealtimeLogConfigOutputResponse, GetRealtimeLogConfigOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/get-realtime-log-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getRealtimeLogConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetRealtimeLogConfigInput, GetRealtimeLogConfigOutputResponse, GetRealtimeLogConfigOutputError>(id: "getRealtimeLogConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetRealtimeLogConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetRealtimeLogConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetRealtimeLogConfigInput, GetRealtimeLogConfigOutputResponse, GetRealtimeLogConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: GetRealtimeLogConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about a specified RTMP distribution, including the distribution configuration.</p>
    public func getStreamingDistribution(input: GetStreamingDistributionInput, completion: @escaping (SdkResult<GetStreamingDistributionOutputResponse, GetStreamingDistributionOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/streaming-distribution/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getStreamingDistribution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetStreamingDistributionInput, GetStreamingDistributionOutputResponse, GetStreamingDistributionOutputError>(id: "getStreamingDistribution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetStreamingDistributionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetStreamingDistributionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetStreamingDistributionInput, GetStreamingDistributionOutputResponse, GetStreamingDistributionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Get the configuration information about a streaming distribution. </p>
    public func getStreamingDistributionConfig(input: GetStreamingDistributionConfigInput, completion: @escaping (SdkResult<GetStreamingDistributionConfigOutputResponse, GetStreamingDistributionConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/streaming-distribution/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getStreamingDistributionConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetStreamingDistributionConfigInput, GetStreamingDistributionConfigOutputResponse, GetStreamingDistributionConfigOutputError>(id: "getStreamingDistributionConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetStreamingDistributionConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetStreamingDistributionConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetStreamingDistributionConfigInput, GetStreamingDistributionConfigOutputResponse, GetStreamingDistributionConfigOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of cache policies.</p>
    /// 		       <p>You can optionally apply a filter to return only the managed policies created by AWS, or
    /// 			only the custom policies created in your AWS account.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    public func listCachePolicies(input: ListCachePoliciesInput, completion: @escaping (SdkResult<ListCachePoliciesOutputResponse, ListCachePoliciesOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/cache-policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCachePolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCachePoliciesInput, ListCachePoliciesOutputResponse, ListCachePoliciesOutputError>(id: "listCachePolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCachePoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCachePoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCachePoliciesInput, ListCachePoliciesOutputResponse, ListCachePoliciesOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists origin access identities.</p>
    public func listCloudFrontOriginAccessIdentities(input: ListCloudFrontOriginAccessIdentitiesInput, completion: @escaping (SdkResult<ListCloudFrontOriginAccessIdentitiesOutputResponse, ListCloudFrontOriginAccessIdentitiesOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/origin-access-identity/cloudfront"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCloudFrontOriginAccessIdentities")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCloudFrontOriginAccessIdentitiesInput, ListCloudFrontOriginAccessIdentitiesOutputResponse, ListCloudFrontOriginAccessIdentitiesOutputError>(id: "listCloudFrontOriginAccessIdentities")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCloudFrontOriginAccessIdentitiesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCloudFrontOriginAccessIdentitiesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCloudFrontOriginAccessIdentitiesInput, ListCloudFrontOriginAccessIdentitiesOutputResponse, ListCloudFrontOriginAccessIdentitiesOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List CloudFront distributions.</p>
    public func listDistributions(input: ListDistributionsInput, completion: @escaping (SdkResult<ListDistributionsOutputResponse, ListDistributionsOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/distribution"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDistributions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDistributionsInput, ListDistributionsOutputResponse, ListDistributionsOutputError>(id: "listDistributions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDistributionsInput, ListDistributionsOutputResponse, ListDistributionsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
    /// 			associated with the specified cache policy.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    public func listDistributionsByCachePolicyId(input: ListDistributionsByCachePolicyIdInput, completion: @escaping (SdkResult<ListDistributionsByCachePolicyIdOutputResponse, ListDistributionsByCachePolicyIdOutputError>) -> Void)
    {
        guard let cachePolicyId = input.cachePolicyId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component cachePolicyId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distributionsByCachePolicyId/\(cachePolicyId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDistributionsByCachePolicyId")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDistributionsByCachePolicyIdInput, ListDistributionsByCachePolicyIdOutputResponse, ListDistributionsByCachePolicyIdOutputError>(id: "listDistributionsByCachePolicyId")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByCachePolicyIdInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByCachePolicyIdInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDistributionsByCachePolicyIdInput, ListDistributionsByCachePolicyIdOutputResponse, ListDistributionsByCachePolicyIdOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of distribution IDs for distributions that have a cache behavior that references
    /// 			the specified key group.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    public func listDistributionsByKeyGroup(input: ListDistributionsByKeyGroupInput, completion: @escaping (SdkResult<ListDistributionsByKeyGroupOutputResponse, ListDistributionsByKeyGroupOutputError>) -> Void)
    {
        guard let keyGroupId = input.keyGroupId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component keyGroupId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distributionsByKeyGroupId/\(keyGroupId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDistributionsByKeyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDistributionsByKeyGroupInput, ListDistributionsByKeyGroupOutputResponse, ListDistributionsByKeyGroupOutputError>(id: "listDistributionsByKeyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByKeyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByKeyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDistributionsByKeyGroupInput, ListDistributionsByKeyGroupOutputResponse, ListDistributionsByKeyGroupOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of distribution IDs for distributions that have a cache behavior that’s
    /// 			associated with the specified origin request policy.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    public func listDistributionsByOriginRequestPolicyId(input: ListDistributionsByOriginRequestPolicyIdInput, completion: @escaping (SdkResult<ListDistributionsByOriginRequestPolicyIdOutputResponse, ListDistributionsByOriginRequestPolicyIdOutputError>) -> Void)
    {
        guard let originRequestPolicyId = input.originRequestPolicyId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component originRequestPolicyId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distributionsByOriginRequestPolicyId/\(originRequestPolicyId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDistributionsByOriginRequestPolicyId")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDistributionsByOriginRequestPolicyIdInput, ListDistributionsByOriginRequestPolicyIdOutputResponse, ListDistributionsByOriginRequestPolicyIdOutputError>(id: "listDistributionsByOriginRequestPolicyId")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByOriginRequestPolicyIdInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByOriginRequestPolicyIdInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDistributionsByOriginRequestPolicyIdInput, ListDistributionsByOriginRequestPolicyIdOutputResponse, ListDistributionsByOriginRequestPolicyIdOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of distributions that have a cache behavior that’s associated with the specified
    /// 			real-time log configuration.</p>
    /// 		       <p>You can specify the real-time log configuration by its name or its Amazon Resource Name
    /// 			(ARN). You must provide at least one. If you provide both, CloudFront uses the name to
    /// 			identify the real-time log configuration to list distributions for.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request. </p>
    public func listDistributionsByRealtimeLogConfig(input: ListDistributionsByRealtimeLogConfigInput, completion: @escaping (SdkResult<ListDistributionsByRealtimeLogConfigOutputResponse, ListDistributionsByRealtimeLogConfigOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/distributionsByRealtimeLogConfig"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDistributionsByRealtimeLogConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDistributionsByRealtimeLogConfigInput, ListDistributionsByRealtimeLogConfigOutputResponse, ListDistributionsByRealtimeLogConfigOutputError>(id: "listDistributionsByRealtimeLogConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByRealtimeLogConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByRealtimeLogConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDistributionsByRealtimeLogConfigInput, ListDistributionsByRealtimeLogConfigOutputResponse, ListDistributionsByRealtimeLogConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByRealtimeLogConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the distributions that are associated with a specified AWS WAF web ACL. </p>
    public func listDistributionsByWebACLId(input: ListDistributionsByWebACLIdInput, completion: @escaping (SdkResult<ListDistributionsByWebACLIdOutputResponse, ListDistributionsByWebACLIdOutputError>) -> Void)
    {
        guard let webACLId = input.webACLId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component webACLId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distributionsByWebACLId/\(webACLId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listDistributionsByWebACLId")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListDistributionsByWebACLIdInput, ListDistributionsByWebACLIdOutputResponse, ListDistributionsByWebACLIdOutputError>(id: "listDistributionsByWebACLId")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByWebACLIdInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListDistributionsByWebACLIdInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListDistributionsByWebACLIdInput, ListDistributionsByWebACLIdOutputResponse, ListDistributionsByWebACLIdOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List all field-level encryption configurations that have been created in CloudFront for this account.</p>
    public func listFieldLevelEncryptionConfigs(input: ListFieldLevelEncryptionConfigsInput, completion: @escaping (SdkResult<ListFieldLevelEncryptionConfigsOutputResponse, ListFieldLevelEncryptionConfigsOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/field-level-encryption"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFieldLevelEncryptionConfigs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFieldLevelEncryptionConfigsInput, ListFieldLevelEncryptionConfigsOutputResponse, ListFieldLevelEncryptionConfigsOutputError>(id: "listFieldLevelEncryptionConfigs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFieldLevelEncryptionConfigsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFieldLevelEncryptionConfigsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFieldLevelEncryptionConfigsInput, ListFieldLevelEncryptionConfigsOutputResponse, ListFieldLevelEncryptionConfigsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Request a list of field-level encryption profiles that have been created in CloudFront for this account.</p>
    public func listFieldLevelEncryptionProfiles(input: ListFieldLevelEncryptionProfilesInput, completion: @escaping (SdkResult<ListFieldLevelEncryptionProfilesOutputResponse, ListFieldLevelEncryptionProfilesOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/field-level-encryption-profile"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFieldLevelEncryptionProfiles")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFieldLevelEncryptionProfilesInput, ListFieldLevelEncryptionProfilesOutputResponse, ListFieldLevelEncryptionProfilesOutputError>(id: "listFieldLevelEncryptionProfiles")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFieldLevelEncryptionProfilesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFieldLevelEncryptionProfilesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFieldLevelEncryptionProfilesInput, ListFieldLevelEncryptionProfilesOutputResponse, ListFieldLevelEncryptionProfilesOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of all CloudFront functions in your AWS account.</p>
    /// 		       <p>You can optionally apply a filter to return only the functions that are in the
    /// 			specified stage, either <code>DEVELOPMENT</code> or <code>LIVE</code>.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    public func listFunctions(input: ListFunctionsInput, completion: @escaping (SdkResult<ListFunctionsOutputResponse, ListFunctionsOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/function"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFunctions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFunctionsInput, ListFunctionsOutputResponse, ListFunctionsOutputError>(id: "listFunctions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFunctionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFunctionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFunctionsInput, ListFunctionsOutputResponse, ListFunctionsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists invalidation batches. </p>
    public func listInvalidations(input: ListInvalidationsInput, completion: @escaping (SdkResult<ListInvalidationsOutputResponse, ListInvalidationsOutputError>) -> Void)
    {
        guard let distributionId = input.distributionId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component distributionId unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distribution/\(distributionId)/invalidation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listInvalidations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListInvalidationsInput, ListInvalidationsOutputResponse, ListInvalidationsOutputError>(id: "listInvalidations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListInvalidationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListInvalidationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListInvalidationsInput, ListInvalidationsOutputResponse, ListInvalidationsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of key groups.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    public func listKeyGroups(input: ListKeyGroupsInput, completion: @escaping (SdkResult<ListKeyGroupsOutputResponse, ListKeyGroupsOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/key-group"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listKeyGroups")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListKeyGroupsInput, ListKeyGroupsOutputResponse, ListKeyGroupsOutputError>(id: "listKeyGroups")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListKeyGroupsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListKeyGroupsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListKeyGroupsInput, ListKeyGroupsOutputResponse, ListKeyGroupsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of origin request policies.</p>
    /// 		       <p>You can optionally apply a filter to return only the managed policies created by AWS, or
    /// 			only the custom policies created in your AWS account.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request.</p>
    public func listOriginRequestPolicies(input: ListOriginRequestPoliciesInput, completion: @escaping (SdkResult<ListOriginRequestPoliciesOutputResponse, ListOriginRequestPoliciesOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/origin-request-policy"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listOriginRequestPolicies")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListOriginRequestPoliciesInput, ListOriginRequestPoliciesOutputResponse, ListOriginRequestPoliciesOutputError>(id: "listOriginRequestPolicies")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListOriginRequestPoliciesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListOriginRequestPoliciesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListOriginRequestPoliciesInput, ListOriginRequestPoliciesOutputResponse, ListOriginRequestPoliciesOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List all public keys that have been added to CloudFront for this account.</p>
    public func listPublicKeys(input: ListPublicKeysInput, completion: @escaping (SdkResult<ListPublicKeysOutputResponse, ListPublicKeysOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/public-key"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPublicKeys")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPublicKeysInput, ListPublicKeysOutputResponse, ListPublicKeysOutputError>(id: "listPublicKeys")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPublicKeysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPublicKeysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPublicKeysInput, ListPublicKeysOutputResponse, ListPublicKeysOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of real-time log configurations.</p>
    /// 		       <p>You can optionally specify the maximum number of items to receive in the response. If
    /// 			the total number of items in the list exceeds the maximum that you specify, or the
    /// 			default maximum, the response is paginated. To get the next page of items, send a
    /// 			subsequent request that specifies the <code>NextMarker</code> value from the current
    /// 			response as the <code>Marker</code> value in the subsequent request. </p>
    public func listRealtimeLogConfigs(input: ListRealtimeLogConfigsInput, completion: @escaping (SdkResult<ListRealtimeLogConfigsOutputResponse, ListRealtimeLogConfigsOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/realtime-log-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRealtimeLogConfigs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRealtimeLogConfigsInput, ListRealtimeLogConfigsOutputResponse, ListRealtimeLogConfigsOutputError>(id: "listRealtimeLogConfigs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRealtimeLogConfigsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRealtimeLogConfigsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRealtimeLogConfigsInput, ListRealtimeLogConfigsOutputResponse, ListRealtimeLogConfigsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List streaming distributions. </p>
    public func listStreamingDistributions(input: ListStreamingDistributionsInput, completion: @escaping (SdkResult<ListStreamingDistributionsOutputResponse, ListStreamingDistributionsOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/streaming-distribution"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listStreamingDistributions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListStreamingDistributionsInput, ListStreamingDistributionsOutputResponse, ListStreamingDistributionsOutputError>(id: "listStreamingDistributions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListStreamingDistributionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListStreamingDistributionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListStreamingDistributionsInput, ListStreamingDistributionsOutputResponse, ListStreamingDistributionsOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List tags for a CloudFront resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/tagging"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Publishes a CloudFront function by copying the function code from the <code>DEVELOPMENT</code>
    /// 			stage to <code>LIVE</code>. This automatically updates all cache behaviors that are
    /// 			using this function to use the newly published copy in the <code>LIVE</code>
    /// 			stage.</p>
    /// 		       <p>When a function is published to the <code>LIVE</code> stage, you can attach the function to
    /// 			a distribution’s cache behavior, using the function’s Amazon Resource Name (ARN).</p>
    /// 		       <p>To publish a function, you must provide the function’s name and version (<code>ETag</code>
    /// 			value). To get these values, you can use <code>ListFunctions</code> and
    /// 			<code>DescribeFunction</code>.</p>
    public func publishFunction(input: PublishFunctionInput, completion: @escaping (SdkResult<PublishFunctionOutputResponse, PublishFunctionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/function/\(name)/publish"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "publishFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PublishFunctionInput, PublishFunctionOutputResponse, PublishFunctionOutputError>(id: "publishFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PublishFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PublishFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PublishFunctionInput, PublishFunctionOutputResponse, PublishFunctionOutputError>(contentType: "application/xml"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Add tags to a CloudFront resource.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/tagging"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Tests a CloudFront function.</p>
    /// 		       <p>To test a function, you provide an <i>event object</i> that represents an HTTP
    /// 			request or response that your CloudFront distribution could receive in production. CloudFront runs
    /// 			the function, passing it the event object that you provided, and returns the function’s
    /// 			result (the modified event object) in the response. The response also contains function
    /// 			logs and error messages, if any exist. For more information about testing functions, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/managing-functions.html#test-function">Testing functions</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		       <p>To test a function, you provide the function’s name and version (<code>ETag</code> value)
    /// 			along with the event object. To get the function’s name and version, you can use
    /// 			<code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
    public func testFunction(input: TestFunctionInput, completion: @escaping (SdkResult<TestFunctionOutputResponse, TestFunctionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/function/\(name)/test"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "testFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TestFunctionInput, TestFunctionOutputResponse, TestFunctionOutputError>(id: "testFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TestFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TestFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TestFunctionInput, TestFunctionOutputResponse, TestFunctionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: TestFunctionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Remove tags from a CloudFront resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/tagging"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a cache policy configuration.</p>
    /// 		       <p>When you update a cache policy configuration, all the fields are updated with the
    /// 			values provided in the request. You cannot update some fields independent of others. To
    /// 			update a cache policy configuration:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Use <code>GetCachePolicyConfig</code> to get the current configuration.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Locally modify the fields in the cache policy configuration that you want to
    /// 					update.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Call <code>UpdateCachePolicy</code> by providing the entire cache policy
    /// 					configuration, including the fields that you modified and those that you
    /// 					didn’t.</p>
    /// 			         </li>
    ///          </ol>
    public func updateCachePolicy(input: UpdateCachePolicyInput, completion: @escaping (SdkResult<UpdateCachePolicyOutputResponse, UpdateCachePolicyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/cache-policy/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCachePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateCachePolicyInput, UpdateCachePolicyOutputResponse, UpdateCachePolicyOutputError>(id: "updateCachePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateCachePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateCachePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateCachePolicyInput, UpdateCachePolicyOutputResponse, UpdateCachePolicyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateCachePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update an origin access identity. </p>
    public func updateCloudFrontOriginAccessIdentity(input: UpdateCloudFrontOriginAccessIdentityInput, completion: @escaping (SdkResult<UpdateCloudFrontOriginAccessIdentityOutputResponse, UpdateCloudFrontOriginAccessIdentityOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/origin-access-identity/cloudfront/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCloudFrontOriginAccessIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateCloudFrontOriginAccessIdentityInput, UpdateCloudFrontOriginAccessIdentityOutputResponse, UpdateCloudFrontOriginAccessIdentityOutputError>(id: "updateCloudFrontOriginAccessIdentity")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateCloudFrontOriginAccessIdentityInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateCloudFrontOriginAccessIdentityInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateCloudFrontOriginAccessIdentityInput, UpdateCloudFrontOriginAccessIdentityOutputResponse, UpdateCloudFrontOriginAccessIdentityOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateCloudFrontOriginAccessIdentityInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the configuration for a web distribution. </p>
    /// 		       <important>
    ///             <p>When you update a distribution, there are more required fields than when you create a distribution.
    /// 			When you update your distribution by using this API action, follow the steps here to get the current configuration
    /// 			and then make your updates, to make sure that you include all of the required fields. To view a summary,
    /// 			see <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-overview-required-fields.html">Required
    /// 				Fields for Create Distribution and Update Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    ///          </important>
    /// 		       <p>The update process includes getting the current distribution configuration, updating the XML document that is
    /// 			returned to make your changes, and then submitting an <code>UpdateDistribution</code> request to make the updates.</p>
    /// 		       <p>For information about updating a distribution using the CloudFront console instead, see
    /// 			<a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-web-creating-console.html">Creating a
    /// 				Distribution</a> in the <i>Amazon CloudFront Developer Guide</i>.</p>
    /// 		
    /// 		       <p>
    ///             <b>To update a web distribution using the CloudFront API</b>
    ///          </p>
    /// 		       <ol>
    ///             <li>
    ///                <p>Submit a
    /// 				<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistributionConfig.html">GetDistributionConfig</a>
    /// 				request to get the current configuration and an <code>Etag</code> header
    /// 				for the distribution.</p>
    /// 				           <note>
    ///                   <p>If you update the distribution again, you must get a new <code>Etag</code> header.</p>
    ///                </note>
    /// 			         </li>
    ///             <li>
    ///                <p>Update the XML document that was returned in the response to your <code>GetDistributionConfig</code> request to include
    /// 				your changes. </p>
    /// 				           <important>
    /// 					             <p>When you edit the XML file, be aware of the following:</p>
    /// 					             <ul>
    ///                      <li>
    ///                         <p>You must strip out the ETag parameter that is returned.</p>
    ///                      </li>
    ///                      <li>
    ///                         <p>Additional fields are required when you update a distribution. There may be fields included in the
    /// 							XML file for features that you haven't configured for your distribution. This is expected and required to
    /// 							successfully update the distribution.</p>
    ///                      </li>
    ///                      <li>
    ///                         <p>You can't change the value of <code>CallerReference</code>. If you try to change this value, CloudFront returns an
    /// 							<code>IllegalUpdate</code> error. </p>
    ///                      </li>
    ///                      <li>
    ///                         <p>The new configuration replaces the existing configuration; the values that you specify in an
    /// 							<code>UpdateDistribution</code> request are not merged into your existing configuration. When you add, delete, or
    /// 							replace values in an element that allows multiple values (for example, <code>CNAME</code>), you must specify all of the
    /// 							values that you want to appear in the updated distribution. In addition,
    /// 							you must update the corresponding <code>Quantity</code> element.</p>
    ///                      </li>
    ///                   </ul>
    ///                </important>
    /// 			         </li>
    ///             <li>
    ///                <p>Submit an <code>UpdateDistribution</code> request to update the configuration for your distribution:</p>
    /// 				           <ul>
    ///                   <li>
    ///                      <p>In the request body, include the XML document that you updated in Step 2. The request body must include an
    /// 						XML document with a <code>DistributionConfig</code> element.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Set the value of the HTTP <code>If-Match</code> header to the value of the <code>ETag</code> header that CloudFront returned
    /// 						when you submitted the <code>GetDistributionConfig</code> request in Step 1.</p>
    ///                   </li>
    ///                </ul>
    /// 			         </li>
    ///             <li>
    ///                <p>Review the response to the <code>UpdateDistribution</code> request to confirm that the configuration was
    /// 				successfully updated.</p>
    ///             </li>
    ///             <li>
    ///                <p>Optional: Submit a
    /// 				<a href="https://docs.aws.amazon.com/cloudfront/latest/APIReference/API_GetDistribution.html">GetDistribution</a>
    /// 				request to confirm that your changes have propagated.
    /// 				When propagation is complete, the value of <code>Status</code> is <code>Deployed</code>.</p>
    /// 			         </li>
    ///          </ol>
    public func updateDistribution(input: UpdateDistributionInput, completion: @escaping (SdkResult<UpdateDistributionOutputResponse, UpdateDistributionOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/distribution/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateDistribution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateDistributionInput, UpdateDistributionOutputResponse, UpdateDistributionOutputError>(id: "updateDistribution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateDistributionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateDistributionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateDistributionInput, UpdateDistributionOutputResponse, UpdateDistributionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateDistributionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update a field-level encryption configuration. </p>
    public func updateFieldLevelEncryptionConfig(input: UpdateFieldLevelEncryptionConfigInput, completion: @escaping (SdkResult<UpdateFieldLevelEncryptionConfigOutputResponse, UpdateFieldLevelEncryptionConfigOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/field-level-encryption/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFieldLevelEncryptionConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFieldLevelEncryptionConfigInput, UpdateFieldLevelEncryptionConfigOutputResponse, UpdateFieldLevelEncryptionConfigOutputError>(id: "updateFieldLevelEncryptionConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateFieldLevelEncryptionConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFieldLevelEncryptionConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFieldLevelEncryptionConfigInput, UpdateFieldLevelEncryptionConfigOutputResponse, UpdateFieldLevelEncryptionConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFieldLevelEncryptionConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update a field-level encryption profile. </p>
    public func updateFieldLevelEncryptionProfile(input: UpdateFieldLevelEncryptionProfileInput, completion: @escaping (SdkResult<UpdateFieldLevelEncryptionProfileOutputResponse, UpdateFieldLevelEncryptionProfileOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/field-level-encryption-profile/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFieldLevelEncryptionProfile")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFieldLevelEncryptionProfileInput, UpdateFieldLevelEncryptionProfileOutputResponse, UpdateFieldLevelEncryptionProfileOutputError>(id: "updateFieldLevelEncryptionProfile")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateFieldLevelEncryptionProfileInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFieldLevelEncryptionProfileInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFieldLevelEncryptionProfileInput, UpdateFieldLevelEncryptionProfileOutputResponse, UpdateFieldLevelEncryptionProfileOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFieldLevelEncryptionProfileInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a CloudFront function.</p>
    /// 		       <p>You can update a function’s code or the comment that describes the function. You
    /// 			cannot update a function’s name.</p>
    /// 		       <p>To update a function, you provide the function’s name and version (<code>ETag</code> value)
    /// 			along with the updated function code. To get the name and version, you can use
    /// 			<code>ListFunctions</code> and <code>DescribeFunction</code>.</p>
    public func updateFunction(input: UpdateFunctionInput, completion: @escaping (SdkResult<UpdateFunctionOutputResponse, UpdateFunctionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/function/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFunction")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFunctionInput, UpdateFunctionOutputResponse, UpdateFunctionOutputError>(id: "updateFunction")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFunctionInput, UpdateFunctionOutputResponse, UpdateFunctionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFunctionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a key group.</p>
    /// 		       <p>When you update a key group, all the fields are updated with the values provided in
    /// 			the request. You cannot update some fields independent of others. To update a key
    /// 			group:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Get the current key group with <code>GetKeyGroup</code> or
    /// 					<code>GetKeyGroupConfig</code>.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Locally modify the fields in the key group that you want to update. For
    /// 					example, add or remove public key IDs.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Call <code>UpdateKeyGroup</code> with the entire key group object, including
    /// 					the fields that you modified and those that you didn’t.</p>
    /// 			         </li>
    ///          </ol>
    public func updateKeyGroup(input: UpdateKeyGroupInput, completion: @escaping (SdkResult<UpdateKeyGroupOutputResponse, UpdateKeyGroupOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/key-group/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateKeyGroup")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateKeyGroupInput, UpdateKeyGroupOutputResponse, UpdateKeyGroupOutputError>(id: "updateKeyGroup")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateKeyGroupInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateKeyGroupInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateKeyGroupInput, UpdateKeyGroupOutputResponse, UpdateKeyGroupOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateKeyGroupInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an origin request policy configuration.</p>
    /// 		       <p>When you update an origin request policy configuration, all the fields are updated
    /// 			with the values provided in the request. You cannot update some fields independent of
    /// 			others. To update an origin request policy configuration:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Use <code>GetOriginRequestPolicyConfig</code> to get the current configuration.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Locally modify the fields in the origin request policy configuration that you
    /// 					want to update.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Call <code>UpdateOriginRequestPolicy</code> by providing the entire origin
    /// 					request policy configuration, including the fields that you modified and those
    /// 					that you didn’t.</p>
    /// 			         </li>
    ///          </ol>
    public func updateOriginRequestPolicy(input: UpdateOriginRequestPolicyInput, completion: @escaping (SdkResult<UpdateOriginRequestPolicyOutputResponse, UpdateOriginRequestPolicyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/origin-request-policy/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateOriginRequestPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateOriginRequestPolicyInput, UpdateOriginRequestPolicyOutputResponse, UpdateOriginRequestPolicyOutputError>(id: "updateOriginRequestPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateOriginRequestPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateOriginRequestPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateOriginRequestPolicyInput, UpdateOriginRequestPolicyOutputResponse, UpdateOriginRequestPolicyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateOriginRequestPolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update public key information. Note that the only value you can change is the comment.</p>
    public func updatePublicKey(input: UpdatePublicKeyInput, completion: @escaping (SdkResult<UpdatePublicKeyOutputResponse, UpdatePublicKeyOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/public-key/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updatePublicKey")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdatePublicKeyInput, UpdatePublicKeyOutputResponse, UpdatePublicKeyOutputError>(id: "updatePublicKey")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdatePublicKeyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdatePublicKeyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdatePublicKeyInput, UpdatePublicKeyOutputResponse, UpdatePublicKeyOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdatePublicKeyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates a real-time log configuration.</p>
    /// 		       <p>When you update a real-time log configuration, all the parameters are updated with the
    /// 			values provided in the request. You cannot update some parameters independent of others.
    /// 			To update a real-time log configuration:</p>
    /// 		       <ol>
    ///             <li>
    /// 				           <p>Call <code>GetRealtimeLogConfig</code> to get the current real-time log
    /// 					configuration.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Locally modify the parameters in the real-time log configuration that you want
    /// 					to update.</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>Call this API (<code>UpdateRealtimeLogConfig</code>) by providing the entire
    /// 					real-time log configuration, including the parameters that you modified and
    /// 					those that you didn’t.</p>
    /// 			         </li>
    ///          </ol>
    /// 		       <p>You cannot update a real-time log configuration’s <code>Name</code> or
    /// 			<code>ARN</code>.</p>
    public func updateRealtimeLogConfig(input: UpdateRealtimeLogConfigInput, completion: @escaping (SdkResult<UpdateRealtimeLogConfigOutputResponse, UpdateRealtimeLogConfigOutputError>) -> Void)
    {
        let urlPath = "/2020-05-31/realtime-log-config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRealtimeLogConfig")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRealtimeLogConfigInput, UpdateRealtimeLogConfigOutputResponse, UpdateRealtimeLogConfigOutputError>(id: "updateRealtimeLogConfig")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateRealtimeLogConfigInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRealtimeLogConfigInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRealtimeLogConfigInput, UpdateRealtimeLogConfigOutputResponse, UpdateRealtimeLogConfigOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRealtimeLogConfigInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Update a streaming distribution. </p>
    public func updateStreamingDistribution(input: UpdateStreamingDistributionInput, completion: @escaping (SdkResult<UpdateStreamingDistributionOutputResponse, UpdateStreamingDistributionOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/2020-05-31/streaming-distribution/\(id)/config"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateStreamingDistribution")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "cloudfront.\(config.region).amazonaws.com")
                      .withSigningName(value: "cloudfront")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateStreamingDistributionInput, UpdateStreamingDistributionOutputResponse, UpdateStreamingDistributionOutputError>(id: "updateStreamingDistribution")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateStreamingDistributionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateStreamingDistributionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateStreamingDistributionInput, UpdateStreamingDistributionOutputResponse, UpdateStreamingDistributionOutputError>(contentType: "application/xml"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateStreamingDistributionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
