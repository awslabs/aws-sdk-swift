// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AuthorizationData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationToken
        case expiresAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationToken = authorizationToken {
            try encodeContainer.encode(authorizationToken, forKey: .authorizationToken)
        }
        if let expiresAt = expiresAt {
            try encodeContainer.encode(expiresAt.timeIntervalSince1970, forKey: .expiresAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expiresAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
    }
}

extension AuthorizationData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthorizationData(authorizationToken: \(String(describing: authorizationToken)), expiresAt: \(String(describing: expiresAt)))"}
}

/// <p>An authorization token data object that corresponds to a public registry.</p>
public struct AuthorizationData: Equatable {
    /// <p>A base64-encoded string that contains authorization data for a public Amazon ECR registry.
    ///          When the string is decoded, it is presented in the format <code>user:password</code> for
    ///          public registry authentication using <code>docker login</code>.</p>
    public let authorizationToken: String?
    /// <p>The Unix time in seconds and milliseconds when the authorization token expires.
    ///          Authorization tokens are valid for 12 hours.</p>
    public let expiresAt: Date?

    public init (
        authorizationToken: String? = nil,
        expiresAt: Date? = nil
    )
    {
        self.authorizationToken = authorizationToken
        self.expiresAt = expiresAt
    }
}

public struct BatchCheckLayerAvailabilityInputBodyMiddleware: Middleware {
    public let id: String = "BatchCheckLayerAvailabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCheckLayerAvailabilityOutputError>
}

extension BatchCheckLayerAvailabilityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCheckLayerAvailabilityInput(layerDigests: \(String(describing: layerDigests)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension BatchCheckLayerAvailabilityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for batchedoperationlayerdigestlist0 in layerDigests {
                try layerDigestsContainer.encode(batchedoperationlayerdigestlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchCheckLayerAvailabilityInputHeadersMiddleware: Middleware {
    public let id: String = "BatchCheckLayerAvailabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchCheckLayerAvailabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInput: Equatable {
    /// <p>The digests of the image layers to check.</p>
    public let layerDigests: [String]?
    /// <p>The AWS account ID associated with the public registry that contains the image layers to
    ///          check. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository that is associated with the image layers to check.</p>
    public let repositoryName: String?

    public init (
        layerDigests: [String]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchCheckLayerAvailabilityInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let layerDigests: [String]?
}

extension BatchCheckLayerAvailabilityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension BatchCheckLayerAvailabilityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCheckLayerAvailabilityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCheckLayerAvailabilityOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCheckLayerAvailabilityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCheckLayerAvailabilityOutputResponse(failures: \(String(describing: failures)), layers: \(String(describing: layers)))"}
}

extension BatchCheckLayerAvailabilityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchCheckLayerAvailabilityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failures = output.failures
            self.layers = output.layers
        } else {
            self.failures = nil
            self.layers = nil
        }
    }
}

public struct BatchCheckLayerAvailabilityOutputResponse: Equatable {
    /// <p>Any failures associated with the call.</p>
    public let failures: [LayerFailure]?
    /// <p>A list of image layer objects corresponding to the image layer references in the
    ///          request.</p>
    public let layers: [Layer]?

    public init (
        failures: [LayerFailure]? = nil,
        layers: [Layer]? = nil
    )
    {
        self.failures = failures
        self.layers = layers
    }
}

struct BatchCheckLayerAvailabilityOutputResponseBody: Equatable {
    public let layers: [Layer]?
    public let failures: [LayerFailure]?
}

extension BatchCheckLayerAvailabilityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures
        case layers
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([LayerFailure?].self, forKey: .failures)
        var failuresDecoded0:[LayerFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [LayerFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct BatchDeleteImageInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImageOutputError>
}

extension BatchDeleteImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteImageInput(imageIds: \(String(describing: imageIds)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension BatchDeleteImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchDeleteImageInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImageOutputError>
}

public struct BatchDeleteImageInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteImageOutputError>
}

public struct BatchDeleteImageInput: Equatable {
    /// <p>A list of image ID references that correspond to images to delete. The format of the
    ///             <code>imageIds</code> reference is <code>imageTag=tag</code> or
    ///             <code>imageDigest=digest</code>.</p>
    public let imageIds: [ImageIdentifier]?
    /// <p>The AWS account ID associated with the registry that contains the image to delete.
    ///          If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The repository in a public registry that contains the image to delete.</p>
    public let repositoryName: String?

    public init (
        imageIds: [ImageIdentifier]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchDeleteImageInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageIds: [ImageIdentifier]?
}

extension BatchDeleteImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
    }
}

extension BatchDeleteImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteImageOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteImageOutputResponse(failures: \(String(describing: failures)), imageIds: \(String(describing: imageIds)))"}
}

extension BatchDeleteImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failures = output.failures
            self.imageIds = output.imageIds
        } else {
            self.failures = nil
            self.imageIds = nil
        }
    }
}

public struct BatchDeleteImageOutputResponse: Equatable {
    /// <p>Any failures associated with the call.</p>
    public let failures: [ImageFailure]?
    /// <p>The image IDs of the deleted images.</p>
    public let imageIds: [ImageIdentifier]?

    public init (
        failures: [ImageFailure]? = nil,
        imageIds: [ImageIdentifier]? = nil
    )
    {
        self.failures = failures
        self.imageIds = imageIds
    }
}

struct BatchDeleteImageOutputResponseBody: Equatable {
    public let imageIds: [ImageIdentifier]?
    public let failures: [ImageFailure]?
}

extension BatchDeleteImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failures
        case imageIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct CompleteLayerUploadInputBodyMiddleware: Middleware {
    public let id: String = "CompleteLayerUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteLayerUploadOutputError>
}

extension CompleteLayerUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteLayerUploadInput(layerDigests: \(String(describing: layerDigests)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension CompleteLayerUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for layerdigestlist0 in layerDigests {
                try layerDigestsContainer.encode(layerdigestlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct CompleteLayerUploadInputHeadersMiddleware: Middleware {
    public let id: String = "CompleteLayerUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "CompleteLayerUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInput: Equatable {
    /// <p>The <code>sha256</code> digest of the image layer.</p>
    public let layerDigests: [String]?
    /// <p>The AWS account ID associated with the registry to which to upload layers.
    ///          If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository in a public registry to associate with the image
    ///          layer.</p>
    public let repositoryName: String?
    /// <p>The upload ID from a previous <a>InitiateLayerUpload</a> operation to
    ///          associate with the image layer.</p>
    public let uploadId: String?

    public init (
        layerDigests: [String]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let layerDigests: [String]?
}

extension CompleteLayerUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension CompleteLayerUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteLayerUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EmptyUploadException" : self = .emptyUploadException(try EmptyUploadException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLayerException" : self = .invalidLayerException(try InvalidLayerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerAlreadyExistsException" : self = .layerAlreadyExistsException(try LayerAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerPartTooSmallException" : self = .layerPartTooSmallException(try LayerPartTooSmallException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteLayerUploadOutputError: Equatable {
    case emptyUploadException(EmptyUploadException)
    case invalidLayerException(InvalidLayerException)
    case invalidParameterException(InvalidParameterException)
    case layerAlreadyExistsException(LayerAlreadyExistsException)
    case layerPartTooSmallException(LayerPartTooSmallException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteLayerUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompleteLayerUploadOutputResponse(layerDigest: \(String(describing: layerDigest)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension CompleteLayerUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CompleteLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.layerDigest = output.layerDigest
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.layerDigest = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct CompleteLayerUploadOutputResponse: Equatable {
    /// <p>The <code>sha256</code> digest of the image layer.</p>
    public let layerDigest: String?
    /// <p>The public registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?
    /// <p>The upload ID associated with the layer.</p>
    public let uploadId: String?

    public init (
        layerDigest: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let layerDigest: String?
}

extension CompleteLayerUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerDigest
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

public struct CreateRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

extension CreateRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRepositoryInput(catalogData: \(String(describing: catalogData)), repositoryName: \(String(describing: repositoryName)), tags: \(String(describing: tags)))"}
}

extension CreateRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogData
        case repositoryName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogData = catalogData {
            try encodeContainer.encode(catalogData, forKey: .catalogData)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInput: Equatable {
    /// <p>The details about the repository that are publicly visible in the
    ///          Amazon ECR Public Gallery.</p>
    public let catalogData: RepositoryCatalogDataInput?
    /// <p>The name to use for the repository. This appears publicly in the Amazon ECR Public Gallery.
    ///          The repository name may be specified on its own (such as <code>nginx-web-app</code>) or it
    ///          can be prepended with a namespace to group the repository into a category (such as
    ///             <code>project-a/nginx-web-app</code>).</p>
    public let repositoryName: String?
    /// <p>The metadata that you apply to the repository to help you categorize and organize them.
    ///          Each tag consists of a key and an optional value, both of which you define.
    ///          Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
    public let tags: [Tag]?

    public init (
        catalogData: RepositoryCatalogDataInput? = nil,
        repositoryName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.catalogData = catalogData
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Equatable {
    public let repositoryName: String?
    public let catalogData: RepositoryCatalogDataInput?
    public let tags: [Tag]?
}

extension CreateRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogData
        case repositoryName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(RepositoryCatalogDataInput.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryAlreadyExistsException" : self = .repositoryAlreadyExistsException(try RepositoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case limitExceededException(LimitExceededException)
    case repositoryAlreadyExistsException(RepositoryAlreadyExistsException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRepositoryOutputResponse(catalogData: \(String(describing: catalogData)), repository: \(String(describing: repository)))"}
}

extension CreateRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.catalogData = output.catalogData
            self.repository = output.repository
        } else {
            self.catalogData = nil
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Equatable {
    /// <p>The catalog data for a repository. This data is publicly visible in the
    ///          Amazon ECR Public Gallery.</p>
    public let catalogData: RepositoryCatalogData?
    /// <p>The repository that was created.</p>
    public let repository: Repository?

    public init (
        catalogData: RepositoryCatalogData? = nil,
        repository: Repository? = nil
    )
    {
        self.catalogData = catalogData
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Equatable {
    public let repository: Repository?
    public let catalogData: RepositoryCatalogData?
}

extension CreateRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogData
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Repository.self, forKey: .repository)
        repository = repositoryDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

public struct DeleteRepositoryInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

extension DeleteRepositoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryInput(force: \(String(describing: force)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteRepositoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInput: Equatable {
    /// <p> If a repository contains images, forces the deletion.</p>
    public let force: Bool
    /// <p>The AWS account ID associated with the public registry that contains the repository to
    ///          delete. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to delete.</p>
    public let repositoryName: String?

    public init (
        force: Bool = false,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.force = force
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let force: Bool
}

extension DeleteRepositoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let forceDecoded = try containerValues.decode(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteRepositoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotEmptyException" : self = .repositoryNotEmptyException(try RepositoryNotEmptyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotEmptyException(RepositoryNotEmptyException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryOutputResponse(repository: \(String(describing: repository)))"}
}

extension DeleteRepositoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Equatable {
    /// <p>The repository that was deleted.</p>
    public let repository: Repository?

    public init (
        repository: Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Equatable {
    public let repository: Repository?
}

extension DeleteRepositoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case repository
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DeleteRepositoryPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryPolicyOutputError>
}

extension DeleteRepositoryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryPolicyInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteRepositoryPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInput: Equatable {
    /// <p>The AWS account ID associated with the public registry that contains the repository
    ///          policy to delete. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository that is associated with the repository policy to
    ///          delete.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension DeleteRepositoryPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRepositoryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DeleteRepositoryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteRepositoryPolicyOutputResponse: Equatable {
    /// <p>The JSON repository policy that was deleted from the repository.</p>
    public let policyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let policyText: String?
}

extension DeleteRepositoryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct DescribeImageTagsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeImageTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageTagsInput>
    public typealias MOutput = OperationOutput<DescribeImageTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageTagsOutputError>
}

extension DescribeImageTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImageTagsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DescribeImageTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DescribeImageTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImageTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageTagsInput>
    public typealias MOutput = OperationOutput<DescribeImageTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageTagsOutputError>
}

public struct DescribeImageTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImageTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImageTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImageTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImageTagsInput>
    public typealias MOutput = OperationOutput<DescribeImageTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImageTagsOutputError>
}

public struct DescribeImageTagsInput: Equatable {
    /// <p>The maximum number of repository results returned by <code>DescribeImageTags</code> in
    ///          paginated output. When this parameter is used, <code>DescribeImageTags</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>DescribeImageTags</code> request with the returned <code>nextToken</code>
    ///          value. This value can be between 1 and 1000. If this parameter
    ///          is not used, then <code>DescribeImageTags</code> returns up to 100
    ///          results and a <code>nextToken</code> value, if applicable. This option cannot be used when
    ///          you specify images with <code>imageIds</code>.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>DescribeImageTags</code> request where <code>maxResults</code> was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the <code>nextToken</code> value. This value is
    ///             <code>null</code> when there are no more results to return. This option cannot be used
    ///          when you specify images with <code>imageIds</code>.</p>
    public let nextToken: String?
    /// <p>The AWS account ID associated with the public registry that contains the repository in
    ///          which to describe images. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository that contains the image tag details to describe.</p>
    public let repositoryName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageTagsInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeImageTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImageTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImageTagsOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImageTagsOutputResponse(imageTagDetails: \(String(describing: imageTagDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeImageTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImageTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageTagDetails = output.imageTagDetails
            self.nextToken = output.nextToken
        } else {
            self.imageTagDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImageTagsOutputResponse: Equatable {
    /// <p>The image tag details for the images in the requested repository.</p>
    public let imageTagDetails: [ImageTagDetail]?
    /// <p>The <code>nextToken</code> value to include in a future <code>DescribeImageTags</code>
    ///          request. When the results of a <code>DescribeImageTags</code> request exceed
    ///             <code>maxResults</code>, this value can be used to retrieve the next page of results.
    ///          This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?

    public init (
        imageTagDetails: [ImageTagDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.imageTagDetails = imageTagDetails
        self.nextToken = nextToken
    }
}

struct DescribeImageTagsOutputResponseBody: Equatable {
    public let imageTagDetails: [ImageTagDetail]?
    public let nextToken: String?
}

extension DescribeImageTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageTagDetails
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagDetailsContainer = try containerValues.decodeIfPresent([ImageTagDetail?].self, forKey: .imageTagDetails)
        var imageTagDetailsDecoded0:[ImageTagDetail]? = nil
        if let imageTagDetailsContainer = imageTagDetailsContainer {
            imageTagDetailsDecoded0 = [ImageTagDetail]()
            for structure0 in imageTagDetailsContainer {
                if let structure0 = structure0 {
                    imageTagDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageTagDetails = imageTagDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeImagesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

extension DescribeImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagesInput(imageIds: \(String(describing: imageIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension DescribeImagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DescribeImagesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInput: Equatable {
    /// <p>The list of image IDs for the requested repository.</p>
    public let imageIds: [ImageIdentifier]?
    /// <p>The maximum number of repository results returned by <code>DescribeImages</code> in
    ///          paginated output. When this parameter is used, <code>DescribeImages</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>DescribeImages</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 1000. If this parameter is not
    ///          used, then <code>DescribeImages</code> returns up to 100 results and a
    ///             <code>nextToken</code> value, if applicable. This option cannot be used when you specify
    ///          images with <code>imageIds</code>.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>DescribeImages</code> request where <code>maxResults</code> was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the <code>nextToken</code> value. This value is
    ///             <code>null</code> when there are no more results to return. This option cannot be used
    ///          when you specify images with <code>imageIds</code>.</p>
    public let nextToken: String?
    /// <p>The AWS account ID associated with the public registry that contains the repository in
    ///          which to describe images. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The repository that contains the images to describe.</p>
    public let repositoryName: String?

    public init (
        imageIds: [ImageIdentifier]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImagesInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageIds: [ImageIdentifier]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeImagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagesOutputError: Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeImagesOutputResponse(imageDetails: \(String(describing: imageDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeImagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.imageDetails = output.imageDetails
            self.nextToken = output.nextToken
        } else {
            self.imageDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutputResponse: Equatable {
    /// <p>A list of <a>ImageDetail</a> objects that contain data about the
    ///          image.</p>
    public let imageDetails: [ImageDetail]?
    /// <p>The <code>nextToken</code> value to include in a future <code>DescribeImages</code>
    ///          request. When the results of a <code>DescribeImages</code> request exceed
    ///             <code>maxResults</code>, this value can be used to retrieve the next page of results.
    ///          This value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?

    public init (
        imageDetails: [ImageDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.imageDetails = imageDetails
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputResponseBody: Equatable {
    public let imageDetails: [ImageDetail]?
    public let nextToken: String?
}

extension DescribeImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageDetails
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDetailsContainer = try containerValues.decodeIfPresent([ImageDetail?].self, forKey: .imageDetails)
        var imageDetailsDecoded0:[ImageDetail]? = nil
        if let imageDetailsContainer = imageDetailsContainer {
            imageDetailsDecoded0 = [ImageDetail]()
            for structure0 in imageDetailsContainer {
                if let structure0 = structure0 {
                    imageDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageDetails = imageDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRegistriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRegistriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegistriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegistriesInput>
    public typealias MOutput = OperationOutput<DescribeRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegistriesOutputError>
}

extension DescribeRegistriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegistriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeRegistriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeRegistriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRegistriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegistriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegistriesInput>
    public typealias MOutput = OperationOutput<DescribeRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegistriesOutputError>
}

public struct DescribeRegistriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRegistriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRegistriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRegistriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRegistriesInput>
    public typealias MOutput = OperationOutput<DescribeRegistriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRegistriesOutputError>
}

public struct DescribeRegistriesInput: Equatable {
    /// <p>The maximum number of repository results returned by <code>DescribeRegistries</code> in
    ///          paginated output. When this parameter is used, <code>DescribeRegistries</code> only returns
    ///             <code>maxResults</code> results in a single page along with a <code>nextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>DescribeRegistries</code> request with the returned <code>nextToken</code>
    ///          value. This value can be between 1 and 1000. If this parameter
    ///          is not used, then <code>DescribeRegistries</code> returns up to 100
    ///          results and a <code>nextToken</code> value, if applicable.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>DescribeRegistries</code> request where <code>maxResults</code> was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the <code>nextToken</code> value. This value is
    ///             <code>null</code> when there are no more results to return.</p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeRegistriesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeRegistriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRegistriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegistriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegistriesOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegistriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRegistriesOutputResponse(nextToken: \(String(describing: nextToken)), registries: \(String(describing: registries)))"}
}

extension DescribeRegistriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRegistriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.registries = output.registries
        } else {
            self.nextToken = nil
            self.registries = nil
        }
    }
}

public struct DescribeRegistriesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future
    ///             <code>DescribeRepositories</code> request. When the results of a
    ///             <code>DescribeRepositories</code> request exceed <code>maxResults</code>, this value can
    ///          be used to retrieve the next page of results. This value is <code>null</code> when there
    ///          are no more results to return.</p>
    public let nextToken: String?
    /// <p>An object containing the details for a public registry.</p>
    public let registries: [Registry]?

    public init (
        nextToken: String? = nil,
        registries: [Registry]? = nil
    )
    {
        self.nextToken = nextToken
        self.registries = registries
    }
}

struct DescribeRegistriesOutputResponseBody: Equatable {
    public let registries: [Registry]?
    public let nextToken: String?
}

extension DescribeRegistriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case registries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registriesContainer = try containerValues.decodeIfPresent([Registry?].self, forKey: .registries)
        var registriesDecoded0:[Registry]? = nil
        if let registriesContainer = registriesContainer {
            registriesDecoded0 = [Registry]()
            for structure0 in registriesContainer {
                if let structure0 = structure0 {
                    registriesDecoded0?.append(structure0)
                }
            }
        }
        registries = registriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeRepositoriesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoriesOutputError>
}

extension DescribeRepositoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRepositoriesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), registryId: \(String(describing: registryId)), repositoryNames: \(String(describing: repositoryNames)))"}
}

extension DescribeRepositoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositorynamelist0 in repositoryNames {
                try repositoryNamesContainer.encode(repositorynamelist0)
            }
        }
    }
}

public struct DescribeRepositoriesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInput: Equatable {
    /// <p>The maximum number of repository results returned by <code>DescribeRepositories</code>
    ///          in paginated output. When this parameter is used, <code>DescribeRepositories</code> only
    ///          returns <code>maxResults</code> results in a single page along with a
    ///             <code>nextToken</code> response element. The remaining results of the initial request
    ///          can be seen by sending another <code>DescribeRepositories</code> request with the returned
    ///             <code>nextToken</code> value. This value can be between 1 and
    ///          1000. If this parameter is not used, then <code>DescribeRepositories</code>
    ///          returns up to 100 results and a <code>nextToken</code> value, if
    ///          applicable. This option cannot be used when you specify repositories with
    ///             <code>repositoryNames</code>.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>DescribeRepositories</code> request where <code>maxResults</code> was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the <code>nextToken</code> value. This value is
    ///             <code>null</code> when there are no more results to return. This option cannot be used
    ///          when you specify repositories with <code>repositoryNames</code>.</p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: String?
    /// <p>The AWS account ID associated with the registry that contains the repositories to be
    ///          described. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>A list of repositories to describe. If this parameter is omitted, then all repositories
    ///          in a registry are described.</p>
    public let repositoryNames: [String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        registryId: String? = nil,
        repositoryNames: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryNames = repositoryNames
    }
}

struct DescribeRepositoriesInputBody: Equatable {
    public let registryId: String?
    public let repositoryNames: [String]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeRepositoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRepositoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoriesOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRepositoriesOutputResponse(nextToken: \(String(describing: nextToken)), repositories: \(String(describing: repositories)))"}
}

extension DescribeRepositoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct DescribeRepositoriesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future
    ///             <code>DescribeRepositories</code> request. When the results of a
    ///             <code>DescribeRepositories</code> request exceed <code>maxResults</code>, this value can
    ///          be used to retrieve the next page of results. This value is <code>null</code> when there
    ///          are no more results to return.</p>
    public let nextToken: String?
    /// <p>A list of repository objects corresponding to valid repositories.</p>
    public let repositories: [Repository]?

    public init (
        nextToken: String? = nil,
        repositories: [Repository]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct DescribeRepositoriesOutputResponseBody: Equatable {
    public let repositories: [Repository]?
    public let nextToken: String?
}

extension DescribeRepositoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([Repository?].self, forKey: .repositories)
        var repositoriesDecoded0:[Repository]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [Repository]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EmptyUploadException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmptyUploadException(message: \(String(describing: message)))"}
}

extension EmptyUploadException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EmptyUploadExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified layer upload does not contain any layer parts.</p>
public struct EmptyUploadException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EmptyUploadExceptionBody: Equatable {
    public let message: String?
}

extension EmptyUploadExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAuthorizationTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizationTokenInput()"}
}

extension GetAuthorizationTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAuthorizationTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetAuthorizationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAuthorizationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInput: Equatable {

    public init() {}
}

struct GetAuthorizationTokenInputBody: Equatable {
}

extension GetAuthorizationTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAuthorizationTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizationTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizationTokenOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizationTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAuthorizationTokenOutputResponse(authorizationData: \(String(describing: authorizationData)))"}
}

extension GetAuthorizationTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAuthorizationTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authorizationData = output.authorizationData
        } else {
            self.authorizationData = nil
        }
    }
}

public struct GetAuthorizationTokenOutputResponse: Equatable {
    /// <p>An authorization token data object that corresponds to a public registry.</p>
    public let authorizationData: AuthorizationData?

    public init (
        authorizationData: AuthorizationData? = nil
    )
    {
        self.authorizationData = authorizationData
    }
}

struct GetAuthorizationTokenOutputResponseBody: Equatable {
    public let authorizationData: AuthorizationData?
}

extension GetAuthorizationTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorizationData
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDataDecoded = try containerValues.decodeIfPresent(AuthorizationData.self, forKey: .authorizationData)
        authorizationData = authorizationDataDecoded
    }
}

extension GetRegistryCatalogDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegistryCatalogDataInput()"}
}

extension GetRegistryCatalogDataInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRegistryCatalogDataInputHeadersMiddleware: Middleware {
    public let id: String = "GetRegistryCatalogDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistryCatalogDataInput>
    public typealias MOutput = OperationOutput<GetRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistryCatalogDataOutputError>
}

public struct GetRegistryCatalogDataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRegistryCatalogDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegistryCatalogDataInput>
    public typealias MOutput = OperationOutput<GetRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegistryCatalogDataOutputError>
}

public struct GetRegistryCatalogDataInput: Equatable {

    public init() {}
}

struct GetRegistryCatalogDataInputBody: Equatable {
}

extension GetRegistryCatalogDataInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRegistryCatalogDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegistryCatalogDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegistryCatalogDataOutputError: Equatable {
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegistryCatalogDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegistryCatalogDataOutputResponse(registryCatalogData: \(String(describing: registryCatalogData)))"}
}

extension GetRegistryCatalogDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRegistryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registryCatalogData = output.registryCatalogData
        } else {
            self.registryCatalogData = nil
        }
    }
}

public struct GetRegistryCatalogDataOutputResponse: Equatable {
    /// <p>The catalog metadata for the public registry.</p>
    public let registryCatalogData: RegistryCatalogData?

    public init (
        registryCatalogData: RegistryCatalogData? = nil
    )
    {
        self.registryCatalogData = registryCatalogData
    }
}

struct GetRegistryCatalogDataOutputResponseBody: Equatable {
    public let registryCatalogData: RegistryCatalogData?
}

extension GetRegistryCatalogDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryCatalogData
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryCatalogDataDecoded = try containerValues.decodeIfPresent(RegistryCatalogData.self, forKey: .registryCatalogData)
        registryCatalogData = registryCatalogDataDecoded
    }
}

public struct GetRepositoryCatalogDataInputBodyMiddleware: Middleware {
    public let id: String = "GetRepositoryCatalogDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryCatalogDataInput>
    public typealias MOutput = OperationOutput<GetRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryCatalogDataOutputError>
}

extension GetRepositoryCatalogDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryCatalogDataInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetRepositoryCatalogDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetRepositoryCatalogDataInputHeadersMiddleware: Middleware {
    public let id: String = "GetRepositoryCatalogDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryCatalogDataInput>
    public typealias MOutput = OperationOutput<GetRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryCatalogDataOutputError>
}

public struct GetRepositoryCatalogDataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRepositoryCatalogDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryCatalogDataInput>
    public typealias MOutput = OperationOutput<GetRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryCatalogDataOutputError>
}

public struct GetRepositoryCatalogDataInput: Equatable {
    /// <p>The AWS account ID associated with the registry that contains the repositories to be
    ///          described. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to retrieve the catalog metadata for.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryCatalogDataInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension GetRepositoryCatalogDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryCatalogDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryCatalogDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryCatalogDataOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryCatalogDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryCatalogDataOutputResponse(catalogData: \(String(describing: catalogData)))"}
}

extension GetRepositoryCatalogDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRepositoryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.catalogData = output.catalogData
        } else {
            self.catalogData = nil
        }
    }
}

public struct GetRepositoryCatalogDataOutputResponse: Equatable {
    /// <p>The catalog metadata for the repository.</p>
    public let catalogData: RepositoryCatalogData?

    public init (
        catalogData: RepositoryCatalogData? = nil
    )
    {
        self.catalogData = catalogData
    }
}

struct GetRepositoryCatalogDataOutputResponseBody: Equatable {
    public let catalogData: RepositoryCatalogData?
}

extension GetRepositoryCatalogDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogData
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDataDecoded = try containerValues.decodeIfPresent(RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

public struct GetRepositoryPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryPolicyOutputError>
}

extension GetRepositoryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryPolicyInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetRepositoryPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetRepositoryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInput: Equatable {
    /// <p>The AWS account ID associated with the public registry that contains the repository.
    ///          If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository with the policy to retrieve.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension GetRepositoryPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRepositoryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension GetRepositoryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetRepositoryPolicyOutputResponse: Equatable {
    /// <p>The repository policy text associated with the repository. The policy text will be in
    ///          JSON format.</p>
    public let policyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let policyText: String?
}

extension GetRepositoryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension Image: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageId
        case imageManifest
        case imageManifestMediaType
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let imageManifest = imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
    }
}

extension Image: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Image(imageId: \(String(describing: imageId)), imageManifest: \(String(describing: imageManifest)), imageManifestMediaType: \(String(describing: imageManifestMediaType)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>An object representing an Amazon ECR image.</p>
public struct Image: Equatable {
    /// <p>An object containing the image tag and image digest associated with an image.</p>
    public let imageId: ImageIdentifier?
    /// <p>The image manifest associated with the image.</p>
    public let imageManifest: String?
    /// <p>The manifest media type of the image.</p>
    public let imageManifestMediaType: String?
    /// <p>The AWS account ID associated with the registry containing the image.</p>
    public let registryId: String?
    /// <p>The name of the repository associated with the image.</p>
    public let repositoryName: String?

    public init (
        imageId: ImageIdentifier? = nil,
        imageManifest: String? = nil,
        imageManifestMediaType: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageId = imageId
        self.imageManifest = imageManifest
        self.imageManifestMediaType = imageManifestMediaType
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

extension ImageAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ImageAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImageAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified image has already been pushed, and there were no changes to the manifest
///          or image tag after the last push.</p>
public struct ImageAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ImageAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ImageAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageSizeInBytes
        case imageTags
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = imagePushedAt {
            try encodeContainer.encode(imagePushedAt.timeIntervalSince1970, forKey: .imagePushedAt)
        }
        if let imageSizeInBytes = imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetaglist0 in imageTags {
                try imageTagsContainer.encode(imagetaglist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
    }
}

extension ImageDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageDetail(artifactMediaType: \(String(describing: artifactMediaType)), imageDigest: \(String(describing: imageDigest)), imageManifestMediaType: \(String(describing: imageManifestMediaType)), imagePushedAt: \(String(describing: imagePushedAt)), imageSizeInBytes: \(String(describing: imageSizeInBytes)), imageTags: \(String(describing: imageTags)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

/// <p>An object that describes an image returned by a <a>DescribeImages</a>
///          operation.</p>
public struct ImageDetail: Equatable {
    /// <p>The artifact media type of the image.</p>
    public let artifactMediaType: String?
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    public let imageDigest: String?
    /// <p>The media type of the image manifest.</p>
    public let imageManifestMediaType: String?
    /// <p>The date and time, expressed in standard JavaScript date format, at which the current
    ///          image was pushed to the repository. </p>
    public let imagePushedAt: Date?
    /// <p>The size, in bytes, of the image in the repository.</p>
    ///          <p>If the image is a manifest list, this will be the max size of all manifests in the
    ///          list.</p>
    ///          <note>
    ///             <p>Beginning with Docker version 1.9, the Docker client compresses image layers before
    ///             pushing them to a V2 Docker registry. The output of the <code>docker images</code>
    ///             command shows the uncompressed image size, so it may return a larger image size than the
    ///             image sizes returned by <a>DescribeImages</a>.</p>
    ///          </note>
    public let imageSizeInBytes: Int?
    /// <p>The list of tags associated with this image.</p>
    public let imageTags: [String]?
    /// <p>The AWS account ID associated with the public registry to which this image
    ///          belongs.</p>
    public let registryId: String?
    /// <p>The name of the repository to which this image belongs.</p>
    public let repositoryName: String?

    public init (
        artifactMediaType: String? = nil,
        imageDigest: String? = nil,
        imageManifestMediaType: String? = nil,
        imagePushedAt: Date? = nil,
        imageSizeInBytes: Int? = nil,
        imageTags: [String]? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.artifactMediaType = artifactMediaType
        self.imageDigest = imageDigest
        self.imageManifestMediaType = imageManifestMediaType
        self.imagePushedAt = imagePushedAt
        self.imageSizeInBytes = imageSizeInBytes
        self.imageTags = imageTags
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

extension ImageDigestDoesNotMatchException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageDigestDoesNotMatchException(message: \(String(describing: message)))"}
}

extension ImageDigestDoesNotMatchException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImageDigestDoesNotMatchExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified image digest does not match the digest that Amazon ECR calculated for the
///          image.</p>
public struct ImageDigestDoesNotMatchException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ImageDigestDoesNotMatchExceptionBody: Equatable {
    public let message: String?
}

extension ImageDigestDoesNotMatchExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureCode
        case failureReason
        case imageId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ImageFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ImageFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageFailure(failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), imageId: \(String(describing: imageId)))"}
}

/// <p>An object representing an Amazon ECR image failure.</p>
public struct ImageFailure: Equatable {
    /// <p>The code associated with the failure.</p>
    public let failureCode: ImageFailureCode?
    /// <p>The reason for the failure.</p>
    public let failureReason: String?
    /// <p>The image ID associated with the failure.</p>
    public let imageId: ImageIdentifier?

    public init (
        failureCode: ImageFailureCode? = nil,
        failureReason: String? = nil,
        imageId: ImageIdentifier? = nil
    )
    {
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.imageId = imageId
    }
}

public enum ImageFailureCode {
    case imagenotfound
    case imagereferencedbymanifestlist
    case imagetagdoesnotmatchdigest
    case invalidimagedigest
    case invalidimagetag
    case kmserror
    case missingdigestandtag
    case sdkUnknown(String)
}

extension ImageFailureCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImageFailureCode] {
        return [
            .imagenotfound,
            .imagereferencedbymanifestlist,
            .imagetagdoesnotmatchdigest,
            .invalidimagedigest,
            .invalidimagetag,
            .kmserror,
            .missingdigestandtag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .imagenotfound: return "ImageNotFound"
        case .imagereferencedbymanifestlist: return "ImageReferencedByManifestList"
        case .imagetagdoesnotmatchdigest: return "ImageTagDoesNotMatchDigest"
        case .invalidimagedigest: return "InvalidImageDigest"
        case .invalidimagetag: return "InvalidImageTag"
        case .kmserror: return "KmsError"
        case .missingdigestandtag: return "MissingDigestAndTag"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImageFailureCode(rawValue: rawValue) ?? ImageFailureCode.sdkUnknown(rawValue)
    }
}

extension ImageIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageDigest
        case imageTag
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
    }
}

extension ImageIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageIdentifier(imageDigest: \(String(describing: imageDigest)), imageTag: \(String(describing: imageTag)))"}
}

/// <p>An object with identifying information for an Amazon ECR image.</p>
public struct ImageIdentifier: Equatable {
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    public let imageDigest: String?
    /// <p>The tag used for the image.</p>
    public let imageTag: String?

    public init (
        imageDigest: String? = nil,
        imageTag: String? = nil
    )
    {
        self.imageDigest = imageDigest
        self.imageTag = imageTag
    }
}

extension ImageNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageNotFoundException(message: \(String(describing: message)))"}
}

extension ImageNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImageNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The image requested does not exist in the specified repository.</p>
public struct ImageNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ImageNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ImageNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageTagAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageTagAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ImageTagAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImageTagAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified image is tagged with a tag that already exists. The repository is
///          configured for tag immutability.</p>
public struct ImageTagAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ImageTagAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ImageTagAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageTagDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case imageDetail
        case imageTag
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let imageDetail = imageDetail {
            try encodeContainer.encode(imageDetail, forKey: .imageDetail)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let imageDetailDecoded = try containerValues.decodeIfPresent(ReferencedImageDetail.self, forKey: .imageDetail)
        imageDetail = imageDetailDecoded
    }
}

extension ImageTagDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageTagDetail(createdAt: \(String(describing: createdAt)), imageDetail: \(String(describing: imageDetail)), imageTag: \(String(describing: imageTag)))"}
}

/// <p>An object representing the image tag details for an image.</p>
public struct ImageTagDetail: Equatable {
    /// <p>The time stamp indicating when the image tag was created.</p>
    public let createdAt: Date?
    /// <p>An object that describes the details of an image.</p>
    public let imageDetail: ReferencedImageDetail?
    /// <p>The tag associated with the image.</p>
    public let imageTag: String?

    public init (
        createdAt: Date? = nil,
        imageDetail: ReferencedImageDetail? = nil,
        imageTag: String? = nil
    )
    {
        self.createdAt = createdAt
        self.imageDetail = imageDetail
        self.imageTag = imageTag
    }
}

public struct InitiateLayerUploadInputBodyMiddleware: Middleware {
    public let id: String = "InitiateLayerUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateLayerUploadOutputError>
}

extension InitiateLayerUploadInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateLayerUploadInput(registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension InitiateLayerUploadInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct InitiateLayerUploadInputHeadersMiddleware: Middleware {
    public let id: String = "InitiateLayerUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInputQueryItemMiddleware: Middleware {
    public let id: String = "InitiateLayerUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInput: Equatable {
    /// <p>The AWS account ID associated with the registry to which you intend to upload layers.
    ///          If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to which you intend to upload layers.</p>
    public let repositoryName: String?

    public init (
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct InitiateLayerUploadInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
}

extension InitiateLayerUploadInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension InitiateLayerUploadOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateLayerUploadOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateLayerUploadOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateLayerUploadOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InitiateLayerUploadOutputResponse(partSize: \(String(describing: partSize)), uploadId: \(String(describing: uploadId)))"}
}

extension InitiateLayerUploadOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InitiateLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.partSize = output.partSize
            self.uploadId = output.uploadId
        } else {
            self.partSize = nil
            self.uploadId = nil
        }
    }
}

public struct InitiateLayerUploadOutputResponse: Equatable {
    /// <p>The size, in bytes, that Amazon ECR expects future layer part uploads to be.</p>
    public let partSize: Int?
    /// <p>The upload ID for the layer upload. This parameter is passed to further <a>UploadLayerPart</a> and <a>CompleteLayerUpload</a> operations.</p>
    public let uploadId: String?

    public init (
        partSize: Int? = nil,
        uploadId: String? = nil
    )
    {
        self.partSize = partSize
        self.uploadId = uploadId
    }
}

struct InitiateLayerUploadOutputResponseBody: Equatable {
    public let uploadId: String?
    public let partSize: Int?
}

extension InitiateLayerUploadOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case partSize
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .partSize)
        partSize = partSizeDecoded
    }
}

extension InvalidLayerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLayerException(message: \(String(describing: message)))"}
}

extension InvalidLayerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLayerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The layer digest calculation performed by Amazon ECR upon receipt of the image layer does not
///          match the digest specified.</p>
public struct InvalidLayerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLayerExceptionBody: Equatable {
    public let message: String?
}

extension InvalidLayerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLayerPartException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLayerPartException(lastValidByteReceived: \(String(describing: lastValidByteReceived)), message: \(String(describing: message)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension InvalidLayerPartException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLayerPartExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastValidByteReceived = output.lastValidByteReceived
            self.message = output.message
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastValidByteReceived = nil
            self.message = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The layer part size is not valid, or the first byte specified is not consecutive to the
///          last byte of a previous layer part upload.</p>
public struct InvalidLayerPartException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The position of the last byte of the layer part.</p>
    public var lastValidByteReceived: Int?
    public var message: String?
    /// <p>The AWS account ID associated with the layer part.</p>
    public var registryId: String?
    /// <p>The name of the repository.</p>
    public var repositoryName: String?
    /// <p>The upload ID associated with the layer part.</p>
    public var uploadId: String?

    public init (
        lastValidByteReceived: Int? = nil,
        message: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.lastValidByteReceived = lastValidByteReceived
        self.message = message
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct InvalidLayerPartExceptionBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let lastValidByteReceived: Int?
    public let message: String?
}

extension InvalidLayerPartExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastValidByteReceived
        case message
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastValidByteReceivedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .lastValidByteReceived)
        lastValidByteReceived = lastValidByteReceivedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified parameter is invalid. Review the available parameters for the API
///          request.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagParameterException(message: \(String(describing: message)))"}
}

extension InvalidTagParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
public struct InvalidTagParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Layer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerAvailability
        case layerDigest
        case layerSize
        case mediaType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerAvailability = layerAvailability {
            try encodeContainer.encode(layerAvailability.rawValue, forKey: .layerAvailability)
        }
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let layerSize = layerSize {
            try encodeContainer.encode(layerSize, forKey: .layerSize)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let layerAvailabilityDecoded = try containerValues.decodeIfPresent(LayerAvailability.self, forKey: .layerAvailability)
        layerAvailability = layerAvailabilityDecoded
        let layerSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .layerSize)
        layerSize = layerSizeDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension Layer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Layer(layerAvailability: \(String(describing: layerAvailability)), layerDigest: \(String(describing: layerDigest)), layerSize: \(String(describing: layerSize)), mediaType: \(String(describing: mediaType)))"}
}

/// <p>An object representing an Amazon ECR image layer.</p>
public struct Layer: Equatable {
    /// <p>The availability status of the image layer.</p>
    public let layerAvailability: LayerAvailability?
    /// <p>The <code>sha256</code> digest of the image layer.</p>
    public let layerDigest: String?
    /// <p>The size, in bytes, of the image layer.</p>
    public let layerSize: Int?
    /// <p>The media type of the layer, such as
    ///             <code>application/vnd.docker.image.rootfs.diff.tar.gzip</code> or
    ///             <code>application/vnd.oci.image.layer.v1.tar+gzip</code>.</p>
    public let mediaType: String?

    public init (
        layerAvailability: LayerAvailability? = nil,
        layerDigest: String? = nil,
        layerSize: Int? = nil,
        mediaType: String? = nil
    )
    {
        self.layerAvailability = layerAvailability
        self.layerDigest = layerDigest
        self.layerSize = layerSize
        self.mediaType = mediaType
    }
}

extension LayerAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerAlreadyExistsException(message: \(String(describing: message)))"}
}

extension LayerAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LayerAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The image layer already exists in the associated repository.</p>
public struct LayerAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LayerAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension LayerAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LayerAvailability {
    case available
    case unavailable
    case sdkUnknown(String)
}

extension LayerAvailability : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LayerAvailability] {
        return [
            .available,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .unavailable: return "UNAVAILABLE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LayerAvailability(rawValue: rawValue) ?? LayerAvailability.sdkUnknown(rawValue)
    }
}

extension LayerFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureCode
        case failureReason
        case layerDigest
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(LayerFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension LayerFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerFailure(failureCode: \(String(describing: failureCode)), failureReason: \(String(describing: failureReason)), layerDigest: \(String(describing: layerDigest)))"}
}

/// <p>An object representing an Amazon ECR image layer failure.</p>
public struct LayerFailure: Equatable {
    /// <p>The failure code associated with the failure.</p>
    public let failureCode: LayerFailureCode?
    /// <p>The reason for the failure.</p>
    public let failureReason: String?
    /// <p>The layer digest associated with the failure.</p>
    public let layerDigest: String?

    public init (
        failureCode: LayerFailureCode? = nil,
        failureReason: String? = nil,
        layerDigest: String? = nil
    )
    {
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.layerDigest = layerDigest
    }
}

public enum LayerFailureCode {
    case invalidlayerdigest
    case missinglayerdigest
    case sdkUnknown(String)
}

extension LayerFailureCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LayerFailureCode] {
        return [
            .invalidlayerdigest,
            .missinglayerdigest,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .invalidlayerdigest: return "InvalidLayerDigest"
        case .missinglayerdigest: return "MissingLayerDigest"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LayerFailureCode(rawValue: rawValue) ?? LayerFailureCode.sdkUnknown(rawValue)
    }
}

extension LayerPartTooSmallException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerPartTooSmallException(message: \(String(describing: message)))"}
}

extension LayerPartTooSmallException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LayerPartTooSmallExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Layer parts must be at least 5 MiB in size.</p>
public struct LayerPartTooSmallException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LayerPartTooSmallExceptionBody: Equatable {
    public let message: String?
}

extension LayerPartTooSmallExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayersNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayersNotFoundException(message: \(String(describing: message)))"}
}

extension LayersNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LayersNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified layers could not be found, or the specified layer is not valid for this
///          repository.</p>
public struct LayersNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LayersNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension LayersNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation did not succeed because it would have exceeded a service limit for your
///          account. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html">Amazon ECR Service Quotas</a> in the
///          Amazon Elastic Container Registry User Guide.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
    ///          supported resource is an Amazon ECR Public repository.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct PutImageInputBodyMiddleware: Middleware {
    public let id: String = "PutImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageInput>
    public typealias MOutput = OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageOutputError>
}

extension PutImageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageInput(imageDigest: \(String(describing: imageDigest)), imageManifest: \(String(describing: imageManifest)), imageManifestMediaType: \(String(describing: imageManifestMediaType)), imageTag: \(String(describing: imageTag)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutImageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifest = imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutImageInputHeadersMiddleware: Middleware {
    public let id: String = "PutImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageInput>
    public typealias MOutput = OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageOutputError>
}

public struct PutImageInputQueryItemMiddleware: Middleware {
    public let id: String = "PutImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutImageInput>
    public typealias MOutput = OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutImageOutputError>
}

public struct PutImageInput: Equatable {
    /// <p>The image digest of the image manifest corresponding to the image.</p>
    public let imageDigest: String?
    /// <p>The image manifest corresponding to the image to be uploaded.</p>
    public let imageManifest: String?
    /// <p>The media type of the image manifest. If you push an image manifest that does not
    ///          contain the <code>mediaType</code> field, you must specify the
    ///             <code>imageManifestMediaType</code> in the request.</p>
    public let imageManifestMediaType: String?
    /// <p>The tag to associate with the image. This parameter is required for images that use the
    ///          Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.</p>
    public let imageTag: String?
    /// <p>The AWS account ID associated with the public registry that contains the repository in
    ///          which to put the image. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository in which to put the image.</p>
    public let repositoryName: String?

    public init (
        imageDigest: String? = nil,
        imageManifest: String? = nil,
        imageManifestMediaType: String? = nil,
        imageTag: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.imageDigest = imageDigest
        self.imageManifest = imageManifest
        self.imageManifestMediaType = imageManifestMediaType
        self.imageTag = imageTag
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let imageManifest: String?
    public let imageManifestMediaType: String?
    public let imageTag: String?
    public let imageDigest: String?
}

extension PutImageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension PutImageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ImageAlreadyExistsException" : self = .imageAlreadyExistsException(try ImageAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageDigestDoesNotMatchException" : self = .imageDigestDoesNotMatchException(try ImageDigestDoesNotMatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageTagAlreadyExistsException" : self = .imageTagAlreadyExistsException(try ImageTagAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayersNotFoundException" : self = .layersNotFoundException(try LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferencedImagesNotFoundException" : self = .referencedImagesNotFoundException(try ReferencedImagesNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageOutputError: Equatable {
    case imageAlreadyExistsException(ImageAlreadyExistsException)
    case imageDigestDoesNotMatchException(ImageDigestDoesNotMatchException)
    case imageTagAlreadyExistsException(ImageTagAlreadyExistsException)
    case invalidParameterException(InvalidParameterException)
    case layersNotFoundException(LayersNotFoundException)
    case limitExceededException(LimitExceededException)
    case referencedImagesNotFoundException(ReferencedImagesNotFoundException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutImageOutputResponse(image: \(String(describing: image)))"}
}

extension PutImageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutImageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct PutImageOutputResponse: Equatable {
    /// <p>Details of the image uploaded.</p>
    public let image: Image?

    public init (
        image: Image? = nil
    )
    {
        self.image = image
    }
}

struct PutImageOutputResponseBody: Equatable {
    public let image: Image?
}

extension PutImageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case image
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(Image.self, forKey: .image)
        image = imageDecoded
    }
}

public struct PutRegistryCatalogDataInputBodyMiddleware: Middleware {
    public let id: String = "PutRegistryCatalogDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRegistryCatalogDataInput>
    public typealias MOutput = OperationOutput<PutRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRegistryCatalogDataOutputError>
}

extension PutRegistryCatalogDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRegistryCatalogDataInput(displayName: \(String(describing: displayName)))"}
}

extension PutRegistryCatalogDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }
}

public struct PutRegistryCatalogDataInputHeadersMiddleware: Middleware {
    public let id: String = "PutRegistryCatalogDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRegistryCatalogDataInput>
    public typealias MOutput = OperationOutput<PutRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRegistryCatalogDataOutputError>
}

public struct PutRegistryCatalogDataInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRegistryCatalogDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRegistryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRegistryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRegistryCatalogDataInput>
    public typealias MOutput = OperationOutput<PutRegistryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRegistryCatalogDataOutputError>
}

public struct PutRegistryCatalogDataInput: Equatable {
    /// <p>The display name for a public registry. The display name is shown as the repository
    ///          author in the Amazon ECR Public Gallery.</p>
    ///          <note>
    ///             <p>The registry display name is only publicly visible in the Amazon ECR Public Gallery for
    ///             verified accounts.</p>
    ///          </note>
    public let displayName: String?

    public init (
        displayName: String? = nil
    )
    {
        self.displayName = displayName
    }
}

struct PutRegistryCatalogDataInputBody: Equatable {
    public let displayName: String?
}

extension PutRegistryCatalogDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case displayName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension PutRegistryCatalogDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRegistryCatalogDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRegistryCatalogDataOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRegistryCatalogDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRegistryCatalogDataOutputResponse(registryCatalogData: \(String(describing: registryCatalogData)))"}
}

extension PutRegistryCatalogDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRegistryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registryCatalogData = output.registryCatalogData
        } else {
            self.registryCatalogData = nil
        }
    }
}

public struct PutRegistryCatalogDataOutputResponse: Equatable {
    /// <p>The catalog data for the public registry.</p>
    public let registryCatalogData: RegistryCatalogData?

    public init (
        registryCatalogData: RegistryCatalogData? = nil
    )
    {
        self.registryCatalogData = registryCatalogData
    }
}

struct PutRegistryCatalogDataOutputResponseBody: Equatable {
    public let registryCatalogData: RegistryCatalogData?
}

extension PutRegistryCatalogDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registryCatalogData
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryCatalogDataDecoded = try containerValues.decodeIfPresent(RegistryCatalogData.self, forKey: .registryCatalogData)
        registryCatalogData = registryCatalogDataDecoded
    }
}

public struct PutRepositoryCatalogDataInputBodyMiddleware: Middleware {
    public let id: String = "PutRepositoryCatalogDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryCatalogDataInput>
    public typealias MOutput = OperationOutput<PutRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryCatalogDataOutputError>
}

extension PutRepositoryCatalogDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRepositoryCatalogDataInput(catalogData: \(String(describing: catalogData)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension PutRepositoryCatalogDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case catalogData
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogData = catalogData {
            try encodeContainer.encode(catalogData, forKey: .catalogData)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutRepositoryCatalogDataInputHeadersMiddleware: Middleware {
    public let id: String = "PutRepositoryCatalogDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryCatalogDataInput>
    public typealias MOutput = OperationOutput<PutRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryCatalogDataOutputError>
}

public struct PutRepositoryCatalogDataInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRepositoryCatalogDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRepositoryCatalogDataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRepositoryCatalogDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRepositoryCatalogDataInput>
    public typealias MOutput = OperationOutput<PutRepositoryCatalogDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRepositoryCatalogDataOutputError>
}

public struct PutRepositoryCatalogDataInput: Equatable {
    /// <p>An object containing the catalog data for a repository. This data is publicly visible in
    ///          the Amazon ECR Public Gallery.</p>
    public let catalogData: RepositoryCatalogDataInput?
    /// <p>The AWS account ID associated with the public registry the repository is in.
    ///          If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to create or update the catalog data for.</p>
    public let repositoryName: String?

    public init (
        catalogData: RepositoryCatalogDataInput? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.catalogData = catalogData
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutRepositoryCatalogDataInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let catalogData: RepositoryCatalogDataInput?
}

extension PutRepositoryCatalogDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogData
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let catalogDataDecoded = try containerValues.decodeIfPresent(RepositoryCatalogDataInput.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

extension PutRepositoryCatalogDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRepositoryCatalogDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRepositoryCatalogDataOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRepositoryCatalogDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRepositoryCatalogDataOutputResponse(catalogData: \(String(describing: catalogData)))"}
}

extension PutRepositoryCatalogDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRepositoryCatalogDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.catalogData = output.catalogData
        } else {
            self.catalogData = nil
        }
    }
}

public struct PutRepositoryCatalogDataOutputResponse: Equatable {
    /// <p>The catalog data for the repository.</p>
    public let catalogData: RepositoryCatalogData?

    public init (
        catalogData: RepositoryCatalogData? = nil
    )
    {
        self.catalogData = catalogData
    }
}

struct PutRepositoryCatalogDataOutputResponseBody: Equatable {
    public let catalogData: RepositoryCatalogData?
}

extension PutRepositoryCatalogDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case catalogData
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogDataDecoded = try containerValues.decodeIfPresent(RepositoryCatalogData.self, forKey: .catalogData)
        catalogData = catalogDataDecoded
    }
}

extension ReferencedImageDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageSizeInBytes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = imagePushedAt {
            try encodeContainer.encode(imagePushedAt.timeIntervalSince1970, forKey: .imagePushedAt)
        }
        if let imageSizeInBytes = imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
    }
}

extension ReferencedImageDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferencedImageDetail(artifactMediaType: \(String(describing: artifactMediaType)), imageDigest: \(String(describing: imageDigest)), imageManifestMediaType: \(String(describing: imageManifestMediaType)), imagePushedAt: \(String(describing: imagePushedAt)), imageSizeInBytes: \(String(describing: imageSizeInBytes)))"}
}

/// <p>An object that describes the image tag details returned by a <a>DescribeImageTags</a> action.</p>
public struct ReferencedImageDetail: Equatable {
    /// <p>The artifact media type of the image.</p>
    public let artifactMediaType: String?
    /// <p>The <code>sha256</code> digest of the image manifest.</p>
    public let imageDigest: String?
    /// <p>The media type of the image manifest.</p>
    public let imageManifestMediaType: String?
    /// <p>The date and time, expressed in standard JavaScript date format, at which the current
    ///          image tag was pushed to the repository.</p>
    public let imagePushedAt: Date?
    /// <p>The size, in bytes, of the image in the repository.</p>
    ///          <p>If the image is a manifest list, this will be the max size of all manifests in the
    ///          list.</p>
    ///          <note>
    ///             <p>Beginning with Docker version 1.9, the Docker client compresses image layers before
    ///             pushing them to a V2 Docker registry. The output of the <code>docker images</code>
    ///             command shows the uncompressed image size, so it may return a larger image size than the
    ///             image sizes returned by <a>DescribeImages</a>.</p>
    ///          </note>
    public let imageSizeInBytes: Int?

    public init (
        artifactMediaType: String? = nil,
        imageDigest: String? = nil,
        imageManifestMediaType: String? = nil,
        imagePushedAt: Date? = nil,
        imageSizeInBytes: Int? = nil
    )
    {
        self.artifactMediaType = artifactMediaType
        self.imageDigest = imageDigest
        self.imageManifestMediaType = imageManifestMediaType
        self.imagePushedAt = imagePushedAt
        self.imageSizeInBytes = imageSizeInBytes
    }
}

extension ReferencedImagesNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReferencedImagesNotFoundException(message: \(String(describing: message)))"}
}

extension ReferencedImagesNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReferencedImagesNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The manifest list is referencing an image that does not exist.</p>
public struct ReferencedImagesNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReferencedImagesNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ReferencedImagesNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Registry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliases
        case registryArn
        case registryId
        case registryUri
        case verified
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliases = aliases {
            var aliasesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aliases)
            for registryaliaslist0 in aliases {
                try aliasesContainer.encode(registryaliaslist0)
            }
        }
        if let registryArn = registryArn {
            try encodeContainer.encode(registryArn, forKey: .registryArn)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let registryUri = registryUri {
            try encodeContainer.encode(registryUri, forKey: .registryUri)
        }
        if let verified = verified {
            try encodeContainer.encode(verified, forKey: .verified)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let registryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryArn)
        registryArn = registryArnDecoded
        let registryUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryUri)
        registryUri = registryUriDecoded
        let verifiedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .verified)
        verified = verifiedDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([RegistryAlias?].self, forKey: .aliases)
        var aliasesDecoded0:[RegistryAlias]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [RegistryAlias]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension Registry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Registry(aliases: \(String(describing: aliases)), registryArn: \(String(describing: registryArn)), registryId: \(String(describing: registryId)), registryUri: \(String(describing: registryUri)), verified: \(String(describing: verified)))"}
}

/// <p>The details of a public registry.</p>
public struct Registry: Equatable {
    /// <p>An array of objects representing the aliases for a public registry.</p>
    public let aliases: [RegistryAlias]?
    /// <p>The Amazon Resource Name (ARN) of the public registry.</p>
    public let registryArn: String?
    /// <p>The AWS account ID associated with the registry. If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The URI of a public registry. The URI contains a universal prefix and the registry
    ///          alias.</p>
    public let registryUri: String?
    /// <p>Whether the account is verified. This indicates whether the account is an AWS
    ///          Marketplace vendor. If an account is verified, each public repository will received a
    ///          verified account badge on the Amazon ECR Public Gallery.</p>
    public let verified: Bool?

    public init (
        aliases: [RegistryAlias]? = nil,
        registryArn: String? = nil,
        registryId: String? = nil,
        registryUri: String? = nil,
        verified: Bool? = nil
    )
    {
        self.aliases = aliases
        self.registryArn = registryArn
        self.registryId = registryId
        self.registryUri = registryUri
        self.verified = verified
    }
}

extension RegistryAlias: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultRegistryAlias
        case name
        case primaryRegistryAlias
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultRegistryAlias != false {
            try encodeContainer.encode(defaultRegistryAlias, forKey: .defaultRegistryAlias)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if primaryRegistryAlias != false {
            try encodeContainer.encode(primaryRegistryAlias, forKey: .primaryRegistryAlias)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RegistryAliasStatus.self, forKey: .status)
        status = statusDecoded
        let primaryRegistryAliasDecoded = try containerValues.decode(Bool.self, forKey: .primaryRegistryAlias)
        primaryRegistryAlias = primaryRegistryAliasDecoded
        let defaultRegistryAliasDecoded = try containerValues.decode(Bool.self, forKey: .defaultRegistryAlias)
        defaultRegistryAlias = defaultRegistryAliasDecoded
    }
}

extension RegistryAlias: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistryAlias(defaultRegistryAlias: \(String(describing: defaultRegistryAlias)), name: \(String(describing: name)), primaryRegistryAlias: \(String(describing: primaryRegistryAlias)), status: \(String(describing: status)))"}
}

/// <p>An object representing the aliases for a public registry. A public registry is given an
///          alias upon creation but a custom alias can be set using the Amazon ECR console. For more
///          information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html">Registries</a> in the
///             <i>Amazon Elastic Container Registry User Guide</i>.</p>
public struct RegistryAlias: Equatable {
    /// <p>Whether or not the registry alias is the default alias for the registry. When the first
    ///          public repository is created, your public registry is assigned a default registry
    ///          alias.</p>
    public let defaultRegistryAlias: Bool
    /// <p>The name of the registry alias.</p>
    public let name: String?
    /// <p>Whether or not the registry alias is the primary alias for the registry. If true, the
    ///          alias is the primary registry alias and is displayed in both the repository URL and the
    ///          image URI used in the <code>docker pull</code> commands on the Amazon ECR Public Gallery.</p>
    ///          <note>
    ///             <p>A registry alias that is not the primary registry alias can be used in the repository
    ///             URI in a <code>docker pull</code> command.</p>
    ///          </note>
    public let primaryRegistryAlias: Bool
    /// <p>The status of the registry alias.</p>
    public let status: RegistryAliasStatus?

    public init (
        defaultRegistryAlias: Bool = false,
        name: String? = nil,
        primaryRegistryAlias: Bool = false,
        status: RegistryAliasStatus? = nil
    )
    {
        self.defaultRegistryAlias = defaultRegistryAlias
        self.name = name
        self.primaryRegistryAlias = primaryRegistryAlias
        self.status = status
    }
}

public enum RegistryAliasStatus {
    case active
    case pending
    case rejected
    case sdkUnknown(String)
}

extension RegistryAliasStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RegistryAliasStatus] {
        return [
            .active,
            .pending,
            .rejected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .pending: return "PENDING"
        case .rejected: return "REJECTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RegistryAliasStatus(rawValue: rawValue) ?? RegistryAliasStatus.sdkUnknown(rawValue)
    }
}

extension RegistryCatalogData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension RegistryCatalogData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistryCatalogData(displayName: \(String(describing: displayName)))"}
}

/// <p>The metadata for a public registry.</p>
public struct RegistryCatalogData: Equatable {
    /// <p>The display name for a public registry. This appears on the Amazon ECR Public Gallery.</p>
    ///          <important>
    ///             <p>Only accounts that have the verified account badge can have a registry display
    ///             name.</p>
    ///          </important>
    public let displayName: String?

    public init (
        displayName: String? = nil
    )
    {
        self.displayName = displayName
    }
}

extension RegistryNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegistryNotFoundException(message: \(String(describing: message)))"}
}

extension RegistryNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegistryNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The registry does not exist.</p>
public struct RegistryNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RegistryNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension RegistryNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Repository: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case registryId
        case repositoryArn
        case repositoryName
        case repositoryUri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryArn = repositoryArn {
            try encodeContainer.encode(repositoryArn, forKey: .repositoryArn)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryUri = repositoryUri {
            try encodeContainer.encode(repositoryUri, forKey: .repositoryUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryArn)
        repositoryArn = repositoryArnDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryUri)
        repositoryUri = repositoryUriDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension Repository: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Repository(createdAt: \(String(describing: createdAt)), registryId: \(String(describing: registryId)), repositoryArn: \(String(describing: repositoryArn)), repositoryName: \(String(describing: repositoryName)), repositoryUri: \(String(describing: repositoryUri)))"}
}

/// <p>An object representing a repository.</p>
public struct Repository: Equatable {
    /// <p>The date and time, in JavaScript date format, when the repository was created.</p>
    public let createdAt: Date?
    /// <p>The AWS account ID associated with the public registry that contains the
    ///          repository.</p>
    public let registryId: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the <code>arn:aws:ecr</code> namespace, followed by the region of the repository, AWS account ID of the repository owner, repository namespace, and repository name. For example, <code>arn:aws:ecr:region:012345678910:repository/test</code>.</p>
    public let repositoryArn: String?
    /// <p>The name of the repository.</p>
    public let repositoryName: String?
    /// <p>The URI for the repository. You can use this URI for container image <code>push</code>
    ///          and <code>pull</code> operations.</p>
    public let repositoryUri: String?

    public init (
        createdAt: Date? = nil,
        registryId: String? = nil,
        repositoryArn: String? = nil,
        repositoryName: String? = nil,
        repositoryUri: String? = nil
    )
    {
        self.createdAt = createdAt
        self.registryId = registryId
        self.repositoryArn = repositoryArn
        self.repositoryName = repositoryName
        self.repositoryUri = repositoryUri
    }
}

extension RepositoryAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryAlreadyExistsException(message: \(String(describing: message)))"}
}

extension RepositoryAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository already exists in the specified registry.</p>
public struct RepositoryAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryCatalogData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aboutText
        case architectures
        case description
        case logoUrl
        case marketplaceCertified
        case operatingSystems
        case usageText
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aboutText = aboutText {
            try encodeContainer.encode(aboutText, forKey: .aboutText)
        }
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecturelist0 in architectures {
                try architecturesContainer.encode(architecturelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logoUrl = logoUrl {
            try encodeContainer.encode(logoUrl, forKey: .logoUrl)
        }
        if let marketplaceCertified = marketplaceCertified {
            try encodeContainer.encode(marketplaceCertified, forKey: .marketplaceCertified)
        }
        if let operatingSystems = operatingSystems {
            var operatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystems)
            for operatingsystemlist0 in operatingSystems {
                try operatingSystemsContainer.encode(operatingsystemlist0)
            }
        }
        if let usageText = usageText {
            try encodeContainer.encode(usageText, forKey: .usageText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .architectures)
        var architecturesDecoded0:[String]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [String]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
        let operatingSystemsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[String]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [String]()
            for string0 in operatingSystemsContainer {
                if let string0 = string0 {
                    operatingSystemsDecoded0?.append(string0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
        let logoUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logoUrl)
        logoUrl = logoUrlDecoded
        let aboutTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aboutText)
        aboutText = aboutTextDecoded
        let usageTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageText)
        usageText = usageTextDecoded
        let marketplaceCertifiedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .marketplaceCertified)
        marketplaceCertified = marketplaceCertifiedDecoded
    }
}

extension RepositoryCatalogData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryCatalogData(aboutText: \(String(describing: aboutText)), architectures: \(String(describing: architectures)), description: \(String(describing: description)), logoUrl: \(String(describing: logoUrl)), marketplaceCertified: \(String(describing: marketplaceCertified)), operatingSystems: \(String(describing: operatingSystems)), usageText: \(String(describing: usageText)))"}
}

/// <p>The catalog data for a repository. This data is publicly visible in the
///          Amazon ECR Public Gallery.</p>
public struct RepositoryCatalogData: Equatable {
    /// <p>The longform description of the contents of the repository. This text appears in the
    ///          repository details on the Amazon ECR Public Gallery.</p>
    public let aboutText: String?
    /// <p>The architecture tags that are associated with the repository.</p>
    ///          <note>
    ///             <p>Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For
    ///             more information, see <a>RepositoryCatalogDataInput</a>.</p>
    ///          </note>
    public let architectures: [String]?
    /// <p>The short description of the repository.</p>
    public let description: String?
    /// <p>The URL containing the logo associated with the repository.</p>
    public let logoUrl: String?
    /// <p>Whether or not the repository is certified by AWS Marketplace.</p>
    public let marketplaceCertified: Bool?
    /// <p>The operating system tags that are associated with the repository.</p>
    ///          <note>
    ///             <p>Only supported operating system tags appear publicly in the Amazon ECR Public Gallery. For
    ///             more information, see <a>RepositoryCatalogDataInput</a>.</p>
    ///          </note>
    public let operatingSystems: [String]?
    /// <p>The longform usage details of the contents of the repository. The usage text provides
    ///          context for users of the repository.</p>
    public let usageText: String?

    public init (
        aboutText: String? = nil,
        architectures: [String]? = nil,
        description: String? = nil,
        logoUrl: String? = nil,
        marketplaceCertified: Bool? = nil,
        operatingSystems: [String]? = nil,
        usageText: String? = nil
    )
    {
        self.aboutText = aboutText
        self.architectures = architectures
        self.description = description
        self.logoUrl = logoUrl
        self.marketplaceCertified = marketplaceCertified
        self.operatingSystems = operatingSystems
        self.usageText = usageText
    }
}

extension RepositoryCatalogDataInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aboutText
        case architectures
        case description
        case logoImageBlob
        case operatingSystems
        case usageText
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aboutText = aboutText {
            try encodeContainer.encode(aboutText, forKey: .aboutText)
        }
        if let architectures = architectures {
            var architecturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .architectures)
            for architecturelist0 in architectures {
                try architecturesContainer.encode(architecturelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logoImageBlob = logoImageBlob {
            try encodeContainer.encode(logoImageBlob.base64EncodedString(), forKey: .logoImageBlob)
        }
        if let operatingSystems = operatingSystems {
            var operatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operatingSystems)
            for operatingsystemlist0 in operatingSystems {
                try operatingSystemsContainer.encode(operatingsystemlist0)
            }
        }
        if let usageText = usageText {
            try encodeContainer.encode(usageText, forKey: .usageText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let architecturesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .architectures)
        var architecturesDecoded0:[String]? = nil
        if let architecturesContainer = architecturesContainer {
            architecturesDecoded0 = [String]()
            for string0 in architecturesContainer {
                if let string0 = string0 {
                    architecturesDecoded0?.append(string0)
                }
            }
        }
        architectures = architecturesDecoded0
        let operatingSystemsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .operatingSystems)
        var operatingSystemsDecoded0:[String]? = nil
        if let operatingSystemsContainer = operatingSystemsContainer {
            operatingSystemsDecoded0 = [String]()
            for string0 in operatingSystemsContainer {
                if let string0 = string0 {
                    operatingSystemsDecoded0?.append(string0)
                }
            }
        }
        operatingSystems = operatingSystemsDecoded0
        let logoImageBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .logoImageBlob)
        logoImageBlob = logoImageBlobDecoded
        let aboutTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aboutText)
        aboutText = aboutTextDecoded
        let usageTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageText)
        usageText = usageTextDecoded
    }
}

extension RepositoryCatalogDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryCatalogDataInput(aboutText: \(String(describing: aboutText)), architectures: \(String(describing: architectures)), description: \(String(describing: description)), logoImageBlob: \(String(describing: logoImageBlob)), operatingSystems: \(String(describing: operatingSystems)), usageText: \(String(describing: usageText)))"}
}

/// <p>An object containing the catalog data for a repository. This data is publicly visible in
///          the Amazon ECR Public Gallery.</p>
public struct RepositoryCatalogDataInput: Equatable {
    /// <p>A detailed description of the contents of the repository. It is publicly visible in the
    ///          Amazon ECR Public Gallery. The text must be in markdown format.</p>
    public let aboutText: String?
    /// <p>The system architecture that the images in the repository are compatible with. On the
    ///          Amazon ECR Public Gallery, the following supported architectures will appear as badges on the
    ///          repository and are used as search filters.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Linux</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Windows</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>If an unsupported tag is added to your repository catalog data, it will be associated
    ///             with the repository and can be retrieved using the API but will not be discoverable in
    ///             the Amazon ECR Public Gallery.</p>
    ///          </note>
    public let architectures: [String]?
    /// <p>A short description of the contents of the repository. This text appears in both the
    ///          image details and also when searching for repositories on the Amazon ECR Public Gallery.</p>
    public let description: String?
    /// <p>The base64-encoded repository logo payload.</p>
    ///          <note>
    ///             <p>The repository logo is only publicly visible in the Amazon ECR Public Gallery for verified
    ///             accounts.</p>
    ///          </note>
    public let logoImageBlob: Data?
    /// <p>The operating systems that the images in the repository are compatible with. On the
    ///          Amazon ECR Public Gallery, the following supported operating systems will appear as badges on
    ///          the repository and are used as search filters.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ARM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ARM 64</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>x86</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>x86-64</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>If an unsupported tag is added to your repository catalog data, it will be associated
    ///             with the repository and can be retrieved using the API but will not be discoverable in
    ///             the Amazon ECR Public Gallery.</p>
    ///          </note>
    public let operatingSystems: [String]?
    /// <p>Detailed information on how to use the contents of the repository. It is publicly
    ///          visible in the Amazon ECR Public Gallery. The usage text provides context, support information,
    ///          and additional usage details for users of the repository. The text must be in markdown
    ///          format.</p>
    public let usageText: String?

    public init (
        aboutText: String? = nil,
        architectures: [String]? = nil,
        description: String? = nil,
        logoImageBlob: Data? = nil,
        operatingSystems: [String]? = nil,
        usageText: String? = nil
    )
    {
        self.aboutText = aboutText
        self.architectures = architectures
        self.description = description
        self.logoImageBlob = logoImageBlob
        self.operatingSystems = operatingSystems
        self.usageText = usageText
    }
}

extension RepositoryNotEmptyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNotEmptyException(message: \(String(describing: message)))"}
}

extension RepositoryNotEmptyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryNotEmptyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository contains images. To delete a repository that contains images,
///          you must force the deletion with the <code>force</code> parameter.</p>
public struct RepositoryNotEmptyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotEmptyExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryNotEmptyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryNotFoundException(message: \(String(describing: message)))"}
}

extension RepositoryNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository could not be found. Check the spelling of the specified
///          repository and ensure that you are performing operations on the correct registry.</p>
public struct RepositoryNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryPolicyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RepositoryPolicyNotFoundException(message: \(String(describing: message)))"}
}

extension RepositoryPolicyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RepositoryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified repository and registry combination does not have an associated repository
///          policy.</p>
public struct RepositoryPolicyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryPolicyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension RepositoryPolicyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerException(message: \(String(describing: message)))"}
}

extension ServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>These errors are usually caused by a server-side issue.</p>
public struct ServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServerExceptionBody: Equatable {
    public let message: String?
}

extension ServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetRepositoryPolicyInputBodyMiddleware: Middleware {
    public let id: String = "SetRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRepositoryPolicyOutputError>
}

extension SetRepositoryPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetRepositoryPolicyInput(force: \(String(describing: force)), policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension SetRepositoryPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct SetRepositoryPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "SetRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "SetRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInput: Equatable {
    /// <p>If the policy you are attempting to set on a repository policy would prevent you from
    ///          setting another policy in the future, you must force the <a>SetRepositoryPolicy</a> operation. This is intended to prevent accidental
    ///          repository lock outs.</p>
    public let force: Bool
    /// <p>The JSON repository policy text to apply to the repository. For more information, see
    ///             <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html">Amazon ECR Repository
    ///             Policies</a> in the <i>Amazon Elastic Container Registry User Guide</i>.</p>
    public let policyText: String?
    /// <p>The AWS account ID associated with the registry that contains the repository.
    ///          If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to receive the policy.</p>
    public let repositoryName: String?

    public init (
        force: Bool = false,
        policyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.force = force
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let policyText: String?
    public let force: Bool
}

extension SetRepositoryPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let forceDecoded = try containerValues.decode(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension SetRepositoryPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetRepositoryPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetRepositoryPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetRepositoryPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetRepositoryPolicyOutputResponse(policyText: \(String(describing: policyText)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)))"}
}

extension SetRepositoryPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct SetRepositoryPolicyOutputResponse: Equatable {
    /// <p>The JSON repository policy text applied to the repository.</p>
    public let policyText: String?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?

    public init (
        policyText: String? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let policyText: String?
}

extension SetRepositoryPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The metadata that you apply to a resource to help you categorize and organize them. Each
///          tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that make up a tag. A <code>key</code> is a general label
    ///          that acts like a category for more specific tag values.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that make up a tag. A <code>value</code> acts as a
    ///          descriptor within a tag category (key).</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to which to add tags. Currently, the
    ///          supported resource is an Amazon ECR Public repository.</p>
    public let resourceArn: String?
    /// <p>The tags to add to the resource. A tag is an array of key-value pairs.
    ///          Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The list of tags on the repository is over the limit. The maximum number of tags that
///          can be applied to a repository is 50.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedCommandException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedCommandException(message: \(String(describing: message)))"}
}

extension UnsupportedCommandException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedCommandExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action is not supported in this Region.</p>
public struct UnsupportedCommandException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedCommandExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedCommandExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource from which to delete tags. Currently, the supported
    ///          resource is an Amazon ECR Public repository.</p>
    public let resourceArn: String?
    /// <p>The keys of the tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UploadLayerPartInputBodyMiddleware: Middleware {
    public let id: String = "UploadLayerPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadLayerPartOutputError>
}

extension UploadLayerPartInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadLayerPartInput(layerPartBlob: \(String(describing: layerPartBlob)), partFirstByte: \(String(describing: partFirstByte)), partLastByte: \(String(describing: partLastByte)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension UploadLayerPartInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerPartBlob = layerPartBlob {
            try encodeContainer.encode(layerPartBlob.base64EncodedString(), forKey: .layerPartBlob)
        }
        if let partFirstByte = partFirstByte {
            try encodeContainer.encode(partFirstByte, forKey: .partFirstByte)
        }
        if let partLastByte = partLastByte {
            try encodeContainer.encode(partLastByte, forKey: .partLastByte)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct UploadLayerPartInputHeadersMiddleware: Middleware {
    public let id: String = "UploadLayerPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInputQueryItemMiddleware: Middleware {
    public let id: String = "UploadLayerPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInput: Equatable {
    /// <p>The base64-encoded layer part payload.</p>
    public let layerPartBlob: Data?
    /// <p>The position of the first byte of the layer part witin the overall image layer.</p>
    public let partFirstByte: Int?
    /// <p>The position of the last byte of the layer part within the overall image layer.</p>
    public let partLastByte: Int?
    /// <p>The AWS account ID associated with the registry to which you are uploading layer parts.
    ///          If you do not specify a registry, the default public registry is assumed.</p>
    public let registryId: String?
    /// <p>The name of the repository to which you are uploading layer parts.</p>
    public let repositoryName: String?
    /// <p>The upload ID from a previous <a>InitiateLayerUpload</a> operation to
    ///          associate with the layer part upload.</p>
    public let uploadId: String?

    public init (
        layerPartBlob: Data? = nil,
        partFirstByte: Int? = nil,
        partLastByte: Int? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.layerPartBlob = layerPartBlob
        self.partFirstByte = partFirstByte
        self.partLastByte = partLastByte
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartInputBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let partFirstByte: Int?
    public let partLastByte: Int?
    public let layerPartBlob: Data?
}

extension UploadLayerPartInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partFirstByteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .partFirstByte)
        partFirstByte = partFirstByteDecoded
        let partLastByteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .partLastByte)
        partLastByte = partLastByteDecoded
        let layerPartBlobDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .layerPartBlob)
        layerPartBlob = layerPartBlobDecoded
    }
}

extension UploadLayerPartOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadLayerPartOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidLayerPartException" : self = .invalidLayerPartException(try InvalidLayerPartException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryNotFoundException" : self = .registryNotFoundException(try RegistryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedCommandException" : self = .unsupportedCommandException(try UnsupportedCommandException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadLayerPartOutputError: Equatable {
    case invalidLayerPartException(InvalidLayerPartException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case registryNotFoundException(RegistryNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedCommandException(UnsupportedCommandException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadLayerPartOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadLayerPartOutputResponse(lastByteReceived: \(String(describing: lastByteReceived)), registryId: \(String(describing: registryId)), repositoryName: \(String(describing: repositoryName)), uploadId: \(String(describing: uploadId)))"}
}

extension UploadLayerPartOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UploadLayerPartOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastByteReceived = output.lastByteReceived
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastByteReceived = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct UploadLayerPartOutputResponse: Equatable {
    /// <p>The integer value of the last byte received in the request.</p>
    public let lastByteReceived: Int?
    /// <p>The registry ID associated with the request.</p>
    public let registryId: String?
    /// <p>The repository name associated with the request.</p>
    public let repositoryName: String?
    /// <p>The upload ID associated with the request.</p>
    public let uploadId: String?

    public init (
        lastByteReceived: Int? = nil,
        registryId: String? = nil,
        repositoryName: String? = nil,
        uploadId: String? = nil
    )
    {
        self.lastByteReceived = lastByteReceived
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartOutputResponseBody: Equatable {
    public let registryId: String?
    public let repositoryName: String?
    public let uploadId: String?
    public let lastByteReceived: Int?
}

extension UploadLayerPartOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastByteReceived
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastByteReceivedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .lastByteReceived)
        lastByteReceived = lastByteReceivedDecoded
    }
}

extension UploadNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UploadNotFoundException(message: \(String(describing: message)))"}
}

extension UploadNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UploadNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The upload could not be found, or the specified upload ID is not valid for this
///          repository.</p>
public struct UploadNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UploadNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension UploadNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
