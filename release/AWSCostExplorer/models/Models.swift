// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CostExplorerClientTypes {
    public enum AccountScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linked
        case payer
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountScope] {
            return [
                .linked,
                .payer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linked: return "LINKED"
            case .payer: return "PAYER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountScope(rawValue: rawValue) ?? AccountScope.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.Anomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyEndDate = "AnomalyEndDate"
        case anomalyId = "AnomalyId"
        case anomalyScore = "AnomalyScore"
        case anomalyStartDate = "AnomalyStartDate"
        case dimensionValue = "DimensionValue"
        case feedback = "Feedback"
        case impact = "Impact"
        case monitorArn = "MonitorArn"
        case rootCauses = "RootCauses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyEndDate = anomalyEndDate {
            try encodeContainer.encode(anomalyEndDate, forKey: .anomalyEndDate)
        }
        if let anomalyId = anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let anomalyScore = anomalyScore {
            try encodeContainer.encode(anomalyScore, forKey: .anomalyScore)
        }
        if let anomalyStartDate = anomalyStartDate {
            try encodeContainer.encode(anomalyStartDate, forKey: .anomalyStartDate)
        }
        if let dimensionValue = dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let impact = impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let rootCauses = rootCauses {
            var rootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rootCauses)
            for rootcauses0 in rootCauses {
                try rootCausesContainer.encode(rootcauses0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
        let anomalyStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyStartDate)
        anomalyStartDate = anomalyStartDateDecoded
        let anomalyEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyEndDate)
        anomalyEndDate = anomalyEndDateDecoded
        let dimensionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
        let rootCausesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.RootCause?].self, forKey: .rootCauses)
        var rootCausesDecoded0:[CostExplorerClientTypes.RootCause]? = nil
        if let rootCausesContainer = rootCausesContainer {
            rootCausesDecoded0 = [CostExplorerClientTypes.RootCause]()
            for structure0 in rootCausesContainer {
                if let structure0 = structure0 {
                    rootCausesDecoded0?.append(structure0)
                }
            }
        }
        rootCauses = rootCausesDecoded0
        let anomalyScoreDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyScore.self, forKey: .anomalyScore)
        anomalyScore = anomalyScoreDecoded
        let impactDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Impact.self, forKey: .impact)
        impact = impactDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension CostExplorerClientTypes {
    /// An unusual cost pattern. This consists of the detailed metadata and the current status of the anomaly object.
    public struct Anomaly: Swift.Equatable {
        /// The last day the anomaly is detected.
        public var anomalyEndDate: Swift.String?
        /// The unique identifier for the anomaly.
        /// This member is required.
        public var anomalyId: Swift.String?
        /// The latest and maximum score for the anomaly.
        /// This member is required.
        public var anomalyScore: CostExplorerClientTypes.AnomalyScore?
        /// The first day the anomaly is detected.
        public var anomalyStartDate: Swift.String?
        /// The dimension for the anomaly (for example, an Amazon Web Services service in a service monitor).
        public var dimensionValue: Swift.String?
        /// The feedback value.
        public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?
        /// The dollar impact for the anomaly.
        /// This member is required.
        public var impact: CostExplorerClientTypes.Impact?
        /// The Amazon Resource Name (ARN) for the cost monitor that generated this anomaly.
        /// This member is required.
        public var monitorArn: Swift.String?
        /// The list of identified root causes for the anomaly.
        public var rootCauses: [CostExplorerClientTypes.RootCause]?

        public init (
            anomalyEndDate: Swift.String? = nil,
            anomalyId: Swift.String? = nil,
            anomalyScore: CostExplorerClientTypes.AnomalyScore? = nil,
            anomalyStartDate: Swift.String? = nil,
            dimensionValue: Swift.String? = nil,
            feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil,
            impact: CostExplorerClientTypes.Impact? = nil,
            monitorArn: Swift.String? = nil,
            rootCauses: [CostExplorerClientTypes.RootCause]? = nil
        )
        {
            self.anomalyEndDate = anomalyEndDate
            self.anomalyId = anomalyId
            self.anomalyScore = anomalyScore
            self.anomalyStartDate = anomalyStartDate
            self.dimensionValue = dimensionValue
            self.feedback = feedback
            self.impact = impact
            self.monitorArn = monitorArn
            self.rootCauses = rootCauses
        }
    }

}

extension CostExplorerClientTypes.AnomalyDateInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate = "EndDate"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
    }
}

extension CostExplorerClientTypes {
    /// The time period for an anomaly.
    public struct AnomalyDateInterval: Swift.Equatable {
        /// The last date an anomaly was observed.
        public var endDate: Swift.String?
        /// The first date an anomaly was observed.
        /// This member is required.
        public var startDate: Swift.String?

        public init (
            endDate: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.endDate = endDate
            self.startDate = startDate
        }
    }

}

extension CostExplorerClientTypes {
    public enum AnomalyFeedbackType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case plannedActivity
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyFeedbackType] {
            return [
                .no,
                .plannedActivity,
                .yes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .plannedActivity: return "PLANNED_ACTIVITY"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyFeedbackType(rawValue: rawValue) ?? AnomalyFeedbackType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.AnomalyMonitor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case dimensionalValueCount = "DimensionalValueCount"
        case lastEvaluatedDate = "LastEvaluatedDate"
        case lastUpdatedDate = "LastUpdatedDate"
        case monitorArn = "MonitorArn"
        case monitorDimension = "MonitorDimension"
        case monitorName = "MonitorName"
        case monitorSpecification = "MonitorSpecification"
        case monitorType = "MonitorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if dimensionalValueCount != 0 {
            try encodeContainer.encode(dimensionalValueCount, forKey: .dimensionalValueCount)
        }
        if let lastEvaluatedDate = lastEvaluatedDate {
            try encodeContainer.encode(lastEvaluatedDate, forKey: .lastEvaluatedDate)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate, forKey: .lastUpdatedDate)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorDimension = monitorDimension {
            try encodeContainer.encode(monitorDimension.rawValue, forKey: .monitorDimension)
        }
        if let monitorName = monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let monitorSpecification = monitorSpecification {
            try encodeContainer.encode(monitorSpecification, forKey: .monitorSpecification)
        }
        if let monitorType = monitorType {
            try encodeContainer.encode(monitorType.rawValue, forKey: .monitorType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let lastEvaluatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastEvaluatedDate)
        lastEvaluatedDate = lastEvaluatedDateDecoded
        let monitorTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.MonitorType.self, forKey: .monitorType)
        monitorType = monitorTypeDecoded
        let monitorDimensionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.MonitorDimension.self, forKey: .monitorDimension)
        monitorDimension = monitorDimensionDecoded
        let monitorSpecificationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .monitorSpecification)
        monitorSpecification = monitorSpecificationDecoded
        let dimensionalValueCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .dimensionalValueCount)
        dimensionalValueCount = dimensionalValueCountDecoded
    }
}

extension CostExplorerClientTypes {
    /// This object continuously inspects your account's cost data for anomalies. It's based on MonitorType and MonitorSpecification. The content consists of detailed metadata and the current status of the monitor object.
    public struct AnomalyMonitor: Swift.Equatable {
        /// The date when the monitor was created.
        public var creationDate: Swift.String?
        /// The value for evaluated dimensions.
        public var dimensionalValueCount: Swift.Int
        /// The date when the monitor last evaluated for anomalies.
        public var lastEvaluatedDate: Swift.String?
        /// The date when the monitor was last updated.
        public var lastUpdatedDate: Swift.String?
        /// The Amazon Resource Name (ARN) value.
        public var monitorArn: Swift.String?
        /// The dimensions to evaluate.
        public var monitorDimension: CostExplorerClientTypes.MonitorDimension?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// Use Expression to filter by cost or by usage. There are two patterns:
        ///
        /// * Simple dimension values - You can set the dimension name and values for the filters that you plan to use. For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia). The Expression example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } } The list of dimension values are OR'd together to retrieve cost or usage data. You can create Expression and DimensionValues objects using either with* methods or set* methods in multiple lines.
        ///
        /// * Compound dimension values with logical operations - You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter on more advanced options. For example, you can filter on ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer). The Expression for that is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }  Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error.  { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }
        ///
        ///
        /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
        public var monitorSpecification: CostExplorerClientTypes.Expression?
        /// The possible type values.
        /// This member is required.
        public var monitorType: CostExplorerClientTypes.MonitorType?

        public init (
            creationDate: Swift.String? = nil,
            dimensionalValueCount: Swift.Int = 0,
            lastEvaluatedDate: Swift.String? = nil,
            lastUpdatedDate: Swift.String? = nil,
            monitorArn: Swift.String? = nil,
            monitorDimension: CostExplorerClientTypes.MonitorDimension? = nil,
            monitorName: Swift.String? = nil,
            monitorSpecification: CostExplorerClientTypes.Expression? = nil,
            monitorType: CostExplorerClientTypes.MonitorType? = nil
        )
        {
            self.creationDate = creationDate
            self.dimensionalValueCount = dimensionalValueCount
            self.lastEvaluatedDate = lastEvaluatedDate
            self.lastUpdatedDate = lastUpdatedDate
            self.monitorArn = monitorArn
            self.monitorDimension = monitorDimension
            self.monitorName = monitorName
            self.monitorSpecification = monitorSpecification
            self.monitorType = monitorType
        }
    }

}

extension CostExplorerClientTypes.AnomalyScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentScore = "CurrentScore"
        case maxScore = "MaxScore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentScore != 0.0 {
            try encodeContainer.encode(currentScore, forKey: .currentScore)
        }
        if maxScore != 0.0 {
            try encodeContainer.encode(maxScore, forKey: .maxScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .maxScore)
        maxScore = maxScoreDecoded
        let currentScoreDecoded = try containerValues.decode(Swift.Double.self, forKey: .currentScore)
        currentScore = currentScoreDecoded
    }
}

extension CostExplorerClientTypes {
    /// Quantifies the anomaly. The higher score means that it's more anomalous.
    public struct AnomalyScore: Swift.Equatable {
        /// The last observed score.
        /// This member is required.
        public var currentScore: Swift.Double
        /// The maximum score that's observed during the AnomalyDateInterval.
        /// This member is required.
        public var maxScore: Swift.Double

        public init (
            currentScore: Swift.Double = 0.0,
            maxScore: Swift.Double = 0.0
        )
        {
            self.currentScore = currentScore
            self.maxScore = maxScore
        }
    }

}

extension CostExplorerClientTypes.AnomalySubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for monitorarnlist0 in monitorArnList {
                try monitorArnListContainer.encode(monitorarnlist0)
            }
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
        if let subscriptionArn = subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let monitorArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[Swift.String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [Swift.String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let subscribersContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[CostExplorerClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [CostExplorerClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalySubscriptionFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension CostExplorerClientTypes {
    /// The association between a monitor, threshold, and list of subscribers used to deliver notifications about anomalies detected by a monitor that exceeds a threshold. The content consists of the detailed metadata and the current status of the AnomalySubscription object.
    public struct AnomalySubscription: Swift.Equatable {
        /// Your unique account identifier.
        public var accountId: Swift.String?
        /// The frequency that anomaly reports are sent over email.
        /// This member is required.
        public var frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency?
        /// A list of cost anomaly monitors.
        /// This member is required.
        public var monitorArnList: [Swift.String]?
        /// A list of subscribers to notify.
        /// This member is required.
        public var subscribers: [CostExplorerClientTypes.Subscriber]?
        /// The AnomalySubscription Amazon Resource Name (ARN).
        public var subscriptionArn: Swift.String?
        /// The name for the subscription.
        /// This member is required.
        public var subscriptionName: Swift.String?
        /// The dollar value that triggers a notification if the threshold is exceeded.
        /// This member is required.
        public var threshold: Swift.Double?

        public init (
            accountId: Swift.String? = nil,
            frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency? = nil,
            monitorArnList: [Swift.String]? = nil,
            subscribers: [CostExplorerClientTypes.Subscriber]? = nil,
            subscriptionArn: Swift.String? = nil,
            subscriptionName: Swift.String? = nil,
            threshold: Swift.Double? = nil
        )
        {
            self.accountId = accountId
            self.frequency = frequency
            self.monitorArnList = monitorArnList
            self.subscribers = subscribers
            self.subscriptionArn = subscriptionArn
            self.subscriptionName = subscriptionName
            self.threshold = threshold
        }
    }

}

extension CostExplorerClientTypes {
    public enum AnomalySubscriptionFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case immediate
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalySubscriptionFrequency] {
            return [
                .daily,
                .immediate,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .immediate: return "IMMEDIATE"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalySubscriptionFrequency(rawValue: rawValue) ?? AnomalySubscriptionFrequency.sdkUnknown(rawValue)
        }
    }
}

extension BillExpirationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BillExpirationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested report expired. Update the date interval and try again.
public struct BillExpirationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BillExpirationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BillExpirationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes {
    public enum Context: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costAndUsage
        case reservations
        case savingsPlans
        case sdkUnknown(Swift.String)

        public static var allCases: [Context] {
            return [
                .costAndUsage,
                .reservations,
                .savingsPlans,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costAndUsage: return "COST_AND_USAGE"
            case .reservations: return "RESERVATIONS"
            case .savingsPlans: return "SAVINGS_PLANS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Context(rawValue: rawValue) ?? Context.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostCategory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case effectiveEnd = "EffectiveEnd"
        case effectiveStart = "EffectiveStart"
        case name = "Name"
        case processingStatus = "ProcessingStatus"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let effectiveEnd = effectiveEnd {
            try encodeContainer.encode(effectiveEnd, forKey: .effectiveEnd)
        }
        if let effectiveStart = effectiveStart {
            try encodeContainer.encode(effectiveStart, forKey: .effectiveStart)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processingStatus = processingStatus {
            var processingStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processingStatus)
            for costcategoryprocessingstatuslist0 in processingStatus {
                try processingStatusContainer.encode(costcategoryprocessingstatuslist0)
            }
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryruleslist0 in rules {
                try rulesContainer.encode(costcategoryruleslist0)
            }
        }
        if let splitChargeRules = splitChargeRules {
            var splitChargeRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .splitChargeRules)
            for costcategorysplitchargeruleslist0 in splitChargeRules {
                try splitChargeRulesContainer.encode(costcategorysplitchargeruleslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostExplorerClientTypes.CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostExplorerClientTypes.CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let splitChargeRulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategorySplitChargeRule?].self, forKey: .splitChargeRules)
        var splitChargeRulesDecoded0:[CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        if let splitChargeRulesContainer = splitChargeRulesContainer {
            splitChargeRulesDecoded0 = [CostExplorerClientTypes.CostCategorySplitChargeRule]()
            for structure0 in splitChargeRulesContainer {
                if let structure0 = structure0 {
                    splitChargeRulesDecoded0?.append(structure0)
                }
            }
        }
        splitChargeRules = splitChargeRulesDecoded0
        let processingStatusContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryProcessingStatus?].self, forKey: .processingStatus)
        var processingStatusDecoded0:[CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil
        if let processingStatusContainer = processingStatusContainer {
            processingStatusDecoded0 = [CostExplorerClientTypes.CostCategoryProcessingStatus]()
            for structure0 in processingStatusContainer {
                if let structure0 = structure0 {
                    processingStatusDecoded0?.append(structure0)
                }
            }
        }
        processingStatus = processingStatusDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension CostExplorerClientTypes {
    /// The structure of Cost Categories. This includes detailed metadata and the set of rules for the CostCategory object.
    public struct CostCategory: Swift.Equatable {
        /// The unique identifier for your Cost Category.
        /// This member is required.
        public var costCategoryArn: Swift.String?
        /// The default value for the cost category.
        public var defaultValue: Swift.String?
        /// The effective end data of your Cost Category.
        public var effectiveEnd: Swift.String?
        /// The effective state data of your Cost Category.
        /// This member is required.
        public var effectiveStart: Swift.String?
        /// The unique name of the Cost Category.
        /// This member is required.
        public var name: Swift.String?
        /// The list of processing statuses for Cost Management products for a specific cost category.
        public var processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]?
        /// The rule schema version in this particular Cost Category.
        /// This member is required.
        public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
        /// The rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
        /// This member is required.
        public var rules: [CostExplorerClientTypes.CostCategoryRule]?
        /// The split charge rules that are used to allocate your charges between your Cost Category values.
        public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

        public init (
            costCategoryArn: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            effectiveEnd: Swift.String? = nil,
            effectiveStart: Swift.String? = nil,
            name: Swift.String? = nil,
            processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil,
            ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
            rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
            splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        )
        {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.name = name
            self.processingStatus = processingStatus
            self.ruleVersion = ruleVersion
            self.rules = rules
            self.splitChargeRules = splitChargeRules
        }
    }

}

extension CostExplorerClientTypes.CostCategoryInheritedValueDimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionKey = "DimensionKey"
        case dimensionName = "DimensionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionKey = dimensionKey {
            try encodeContainer.encode(dimensionKey, forKey: .dimensionKey)
        }
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName.rawValue, forKey: .dimensionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryInheritedValueDimensionName.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionKey)
        dimensionKey = dimensionKeyDecoded
    }
}

extension CostExplorerClientTypes {
    /// When creating or updating a cost category, you can define the CostCategoryRule rule type as INHERITED_VALUE. This rule type adds the flexibility of defining a rule that dynamically inherits the cost category value from the dimension value defined by CostCategoryInheritedValueDimension. For example, if you want to dynamically group costs that are based on the value of a specific tag key, first choose an inherited value rule type, then choose the tag dimension and specify the tag key to use.
    public struct CostCategoryInheritedValueDimension: Swift.Equatable {
        /// The key to extract cost category values.
        public var dimensionKey: Swift.String?
        /// The name of the dimension that's used to group costs. If you specify LINKED_ACCOUNT_NAME, the cost category value is based on account name. If you specify TAG, the cost category value will be based on the value of the specified tag key.
        public var dimensionName: CostExplorerClientTypes.CostCategoryInheritedValueDimensionName?

        public init (
            dimensionKey: Swift.String? = nil,
            dimensionName: CostExplorerClientTypes.CostCategoryInheritedValueDimensionName? = nil
        )
        {
            self.dimensionKey = dimensionKey
            self.dimensionName = dimensionName
        }
    }

}

extension CostExplorerClientTypes {
    public enum CostCategoryInheritedValueDimensionName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linkedAccountName
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryInheritedValueDimensionName] {
            return [
                .linkedAccountName,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linkedAccountName: return "LINKED_ACCOUNT_NAME"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryInheritedValueDimensionName(rawValue: rawValue) ?? CostCategoryInheritedValueDimensionName.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostCategoryProcessingStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component = "Component"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let component = component {
            try encodeContainer.encode(component.rawValue, forKey: .component)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryStatusComponent.self, forKey: .component)
        component = componentDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CostExplorerClientTypes {
    /// The list of processing statuses for Cost Management products for a specific cost category.
    public struct CostCategoryProcessingStatus: Swift.Equatable {
        /// The Cost Management product name of the applied status.
        public var component: CostExplorerClientTypes.CostCategoryStatusComponent?
        /// The process status for a specific cost category.
        public var status: CostExplorerClientTypes.CostCategoryStatus?

        public init (
            component: CostExplorerClientTypes.CostCategoryStatusComponent? = nil,
            status: CostExplorerClientTypes.CostCategoryStatus? = nil
        )
        {
            self.component = component
            self.status = status
        }
    }

}

extension CostExplorerClientTypes.CostCategoryReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case effectiveEnd = "EffectiveEnd"
        case effectiveStart = "EffectiveStart"
        case name = "Name"
        case numberOfRules = "NumberOfRules"
        case processingStatus = "ProcessingStatus"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let effectiveEnd = effectiveEnd {
            try encodeContainer.encode(effectiveEnd, forKey: .effectiveEnd)
        }
        if let effectiveStart = effectiveStart {
            try encodeContainer.encode(effectiveStart, forKey: .effectiveStart)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if numberOfRules != 0 {
            try encodeContainer.encode(numberOfRules, forKey: .numberOfRules)
        }
        if let processingStatus = processingStatus {
            var processingStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processingStatus)
            for costcategoryprocessingstatuslist0 in processingStatus {
                try processingStatusContainer.encode(costcategoryprocessingstatuslist0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for costcategoryvalueslist0 in values {
                try valuesContainer.encode(costcategoryvalueslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
        let numberOfRulesDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfRules)
        numberOfRules = numberOfRulesDecoded
        let processingStatusContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryProcessingStatus?].self, forKey: .processingStatus)
        var processingStatusDecoded0:[CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil
        if let processingStatusContainer = processingStatusContainer {
            processingStatusDecoded0 = [CostExplorerClientTypes.CostCategoryProcessingStatus]()
            for structure0 in processingStatusContainer {
                if let structure0 = structure0 {
                    processingStatusDecoded0?.append(structure0)
                }
            }
        }
        processingStatus = processingStatusDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension CostExplorerClientTypes {
    /// A reference to a Cost Category containing only enough information to identify the Cost Category. You can use this information to retrieve the full Cost Category information using DescribeCostCategory.
    public struct CostCategoryReference: Swift.Equatable {
        /// The unique identifier for your Cost Category.
        public var costCategoryArn: Swift.String?
        /// The default value for the cost category.
        public var defaultValue: Swift.String?
        /// The Cost Category's effective end date.
        public var effectiveEnd: Swift.String?
        /// The Cost Category's effective start date.
        public var effectiveStart: Swift.String?
        /// The unique name of the Cost Category.
        public var name: Swift.String?
        /// The number of rules that are associated with a specific Cost Category.
        public var numberOfRules: Swift.Int
        /// The list of processing statuses for Cost Management products for a specific cost category.
        public var processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]?
        /// A list of unique cost category values in a specific cost category.
        public var values: [Swift.String]?

        public init (
            costCategoryArn: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            effectiveEnd: Swift.String? = nil,
            effectiveStart: Swift.String? = nil,
            name: Swift.String? = nil,
            numberOfRules: Swift.Int = 0,
            processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.name = name
            self.numberOfRules = numberOfRules
            self.processingStatus = processingStatus
            self.values = values
        }
    }

}

extension CostExplorerClientTypes.CostCategoryRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inheritedValue = "InheritedValue"
        case rule = "Rule"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inheritedValue = inheritedValue {
            try encodeContainer.encode(inheritedValue, forKey: .inheritedValue)
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let ruleDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .rule)
        rule = ruleDecoded
        let inheritedValueDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryInheritedValueDimension.self, forKey: .inheritedValue)
        inheritedValue = inheritedValueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryRuleType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CostExplorerClientTypes {
    /// Rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
    public struct CostCategoryRule: Swift.Equatable {
        /// The value the line item is categorized as if the line item contains the matched dimension.
        public var inheritedValue: CostExplorerClientTypes.CostCategoryInheritedValueDimension?
        /// An [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object used to categorize costs. This supports dimensions, tags, and nested expressions. Currently the only dimensions supported are LINKED_ACCOUNT, SERVICE_CODE, RECORD_TYPE, and LINKED_ACCOUNT_NAME. Root level OR isn't supported. We recommend that you create a separate rule instead. RECORD_TYPE is a dimension used for Cost Explorer APIs, and is also supported for Cost Category expressions. This dimension uses different terms, depending on whether you're using the console or API/JSON editor. For a detailed comparison, see [Term Comparisons](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/manage-cost-categories.html#cost-categories-terms) in the Billing and Cost Management User Guide.
        public var rule: CostExplorerClientTypes.Expression?
        /// You can define the CostCategoryRule rule type as either REGULAR or INHERITED_VALUE. The INHERITED_VALUE rule type adds the flexibility of defining a rule that dynamically inherits the cost category value from the dimension value defined by CostCategoryInheritedValueDimension. For example, if you want to dynamically group costs based on the value of a specific tag key, first choose an inherited value rule type, then choose the tag dimension and specify the tag key to use.
        public var type: CostExplorerClientTypes.CostCategoryRuleType?
        /// The default value for the cost category.
        public var value: Swift.String?

        public init (
            inheritedValue: CostExplorerClientTypes.CostCategoryInheritedValueDimension? = nil,
            rule: CostExplorerClientTypes.Expression? = nil,
            type: CostExplorerClientTypes.CostCategoryRuleType? = nil,
            value: Swift.String? = nil
        )
        {
            self.inheritedValue = inheritedValue
            self.rule = rule
            self.type = type
            self.value = value
        }
    }

}

extension CostExplorerClientTypes {
    public enum CostCategoryRuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inheritedValue
        case regular
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryRuleType] {
            return [
                .inheritedValue,
                .regular,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inheritedValue: return "INHERITED_VALUE"
            case .regular: return "REGULAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryRuleType(rawValue: rawValue) ?? CostCategoryRuleType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    /// The rule schema version in this particular Cost Category.
    public enum CostCategoryRuleVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costcategoryexpressionv1
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryRuleVersion] {
            return [
                .costcategoryexpressionv1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costcategoryexpressionv1: return "CostCategoryExpression.v1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryRuleVersion(rawValue: rawValue) ?? CostCategoryRuleVersion.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum CostCategorySplitChargeMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case even
        case fixed
        case proportional
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategorySplitChargeMethod] {
            return [
                .even,
                .fixed,
                .proportional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .even: return "EVEN"
            case .fixed: return "FIXED"
            case .proportional: return "PROPORTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategorySplitChargeMethod(rawValue: rawValue) ?? CostCategorySplitChargeMethod.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostCategorySplitChargeRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case method = "Method"
        case parameters = "Parameters"
        case source = "Source"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let method = method {
            try encodeContainer.encode(method.rawValue, forKey: .method)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for costcategorysplitchargeruleparameterslist0 in parameters {
                try parametersContainer.encode(costcategorysplitchargeruleparameterslist0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for costcategorysplitchargeruletargetslist0 in targets {
                try targetsContainer.encode(costcategorysplitchargeruletargetslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let methodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategorySplitChargeMethod.self, forKey: .method)
        method = methodDecoded
        let parametersContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategorySplitChargeRuleParameter?].self, forKey: .parameters)
        var parametersDecoded0:[CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension CostExplorerClientTypes {
    /// Use the split charge rule to split the cost of one Cost Category value across several other target values.
    public struct CostCategorySplitChargeRule: Swift.Equatable {
        /// The method that's used to define how to split your source costs across your targets. Proportional - Allocates charges across your targets based on the proportional weighted cost of each target. Fixed - Allocates charges across your targets based on your defined allocation percentage. >Even - Allocates costs evenly across all targets.
        /// This member is required.
        public var method: CostExplorerClientTypes.CostCategorySplitChargeMethod?
        /// The parameters for a split charge method. This is only required for the FIXED method.
        public var parameters: [CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]?
        /// The Cost Category value that you want to split. That value can't be used as a source or a target in other split charge rules. To indicate uncategorized costs, you can use an empty string as the source.
        /// This member is required.
        public var source: Swift.String?
        /// The Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        /// This member is required.
        public var targets: [Swift.String]?

        public init (
            method: CostExplorerClientTypes.CostCategorySplitChargeMethod? = nil,
            parameters: [CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]? = nil,
            source: Swift.String? = nil,
            targets: [Swift.String]? = nil
        )
        {
            self.method = method
            self.parameters = parameters
            self.source = source
            self.targets = targets
        }
    }

}

extension CostExplorerClientTypes.CostCategorySplitChargeRuleParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for costcategorysplitchargeruleparametervalueslist0 in values {
                try valuesContainer.encode(costcategorysplitchargeruleparametervalueslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategorySplitChargeRuleParameterType.self, forKey: .type)
        type = typeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The parameters for a split charge method.
    public struct CostCategorySplitChargeRuleParameter: Swift.Equatable {
        /// The parameter type.
        /// This member is required.
        public var type: CostExplorerClientTypes.CostCategorySplitChargeRuleParameterType?
        /// The parameter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            type: CostExplorerClientTypes.CostCategorySplitChargeRuleParameterType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.type = type
            self.values = values
        }
    }

}

extension CostExplorerClientTypes {
    public enum CostCategorySplitChargeRuleParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allocationPercentages
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategorySplitChargeRuleParameterType] {
            return [
                .allocationPercentages,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allocationPercentages: return "ALLOCATION_PERCENTAGES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategorySplitChargeRuleParameterType(rawValue: rawValue) ?? CostCategorySplitChargeRuleParameterType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum CostCategoryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applied
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryStatus] {
            return [
                .applied,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryStatus(rawValue: rawValue) ?? CostCategoryStatus.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum CostCategoryStatusComponent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costExplorer
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryStatusComponent] {
            return [
                .costExplorer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costExplorer: return "COST_EXPLORER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryStatusComponent(rawValue: rawValue) ?? CostCategoryStatusComponent.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostCategoryValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoptions0 in matchOptions {
                try matchOptionsContainer.encode(matchoptions0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[CostExplorerClientTypes.MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [CostExplorerClientTypes.MatchOption]()
            for string0 in matchOptionsContainer {
                if let string0 = string0 {
                    matchOptionsDecoded0?.append(string0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The Cost Categories values used for filtering the costs. If Values and Key are not specified, the ABSENTMatchOption is applied to all Cost Categories. That is, it filters on resources that aren't mapped to any Cost Categories. If Values is provided and Key isn't specified, the ABSENTMatchOption is applied to the Cost Categories Key only. That is, it filters on resources without the given Cost Categories key.
    public struct CostCategoryValues: Swift.Equatable {
        /// The unique name of the Cost Category.
        public var key: Swift.String?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The specific value of the Cost Category.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }

}

extension CostExplorerClientTypes.Coverage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coverageCost = "CoverageCost"
        case coverageHours = "CoverageHours"
        case coverageNormalizedUnits = "CoverageNormalizedUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageCost = coverageCost {
            try encodeContainer.encode(coverageCost, forKey: .coverageCost)
        }
        if let coverageHours = coverageHours {
            try encodeContainer.encode(coverageHours, forKey: .coverageHours)
        }
        if let coverageNormalizedUnits = coverageNormalizedUnits {
            try encodeContainer.encode(coverageNormalizedUnits, forKey: .coverageNormalizedUnits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coverageHoursDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CoverageHours.self, forKey: .coverageHours)
        coverageHours = coverageHoursDecoded
        let coverageNormalizedUnitsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CoverageNormalizedUnits.self, forKey: .coverageNormalizedUnits)
        coverageNormalizedUnits = coverageNormalizedUnitsDecoded
        let coverageCostDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CoverageCost.self, forKey: .coverageCost)
        coverageCost = coverageCostDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of instance usage that a reservation covered.
    public struct Coverage: Swift.Equatable {
        /// The amount of cost that the reservation covered.
        public var coverageCost: CostExplorerClientTypes.CoverageCost?
        /// The amount of instance usage that the reservation covered, in hours.
        public var coverageHours: CostExplorerClientTypes.CoverageHours?
        /// The amount of instance usage that the reservation covered, in normalized units.
        public var coverageNormalizedUnits: CostExplorerClientTypes.CoverageNormalizedUnits?

        public init (
            coverageCost: CostExplorerClientTypes.CoverageCost? = nil,
            coverageHours: CostExplorerClientTypes.CoverageHours? = nil,
            coverageNormalizedUnits: CostExplorerClientTypes.CoverageNormalizedUnits? = nil
        )
        {
            self.coverageCost = coverageCost
            self.coverageHours = coverageHours
            self.coverageNormalizedUnits = coverageNormalizedUnits
        }
    }

}

extension CostExplorerClientTypes.CoverageByTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for reservationcoveragegroups0 in groups {
                try groupsContainer.encode(reservationcoveragegroups0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ReservationCoverageGroup?].self, forKey: .groups)
        var groupsDecoded0:[CostExplorerClientTypes.ReservationCoverageGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [CostExplorerClientTypes.ReservationCoverageGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Coverage.self, forKey: .total)
        total = totalDecoded
    }
}

extension CostExplorerClientTypes {
    /// Reservation coverage for a specified period, in hours.
    public struct CoverageByTime: Swift.Equatable {
        /// The groups of instances that the reservation covered.
        public var groups: [CostExplorerClientTypes.ReservationCoverageGroup]?
        /// The period that this coverage was used over.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total reservation coverage, in hours.
        public var total: CostExplorerClientTypes.Coverage?

        public init (
            groups: [CostExplorerClientTypes.ReservationCoverageGroup]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: CostExplorerClientTypes.Coverage? = nil
        )
        {
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }

}

extension CostExplorerClientTypes.CoverageCost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onDemandCost = "OnDemandCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onDemandCost = onDemandCost {
            try encodeContainer.encode(onDemandCost, forKey: .onDemandCost)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandCost)
        onDemandCost = onDemandCostDecoded
    }
}

extension CostExplorerClientTypes {
    /// How much it costs to run an instance.
    public struct CoverageCost: Swift.Equatable {
        /// How much an On-Demand Instance costs.
        public var onDemandCost: Swift.String?

        public init (
            onDemandCost: Swift.String? = nil
        )
        {
            self.onDemandCost = onDemandCost
        }
    }

}

extension CostExplorerClientTypes.CoverageHours: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coverageHoursPercentage = "CoverageHoursPercentage"
        case onDemandHours = "OnDemandHours"
        case reservedHours = "ReservedHours"
        case totalRunningHours = "TotalRunningHours"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageHoursPercentage = coverageHoursPercentage {
            try encodeContainer.encode(coverageHoursPercentage, forKey: .coverageHoursPercentage)
        }
        if let onDemandHours = onDemandHours {
            try encodeContainer.encode(onDemandHours, forKey: .onDemandHours)
        }
        if let reservedHours = reservedHours {
            try encodeContainer.encode(reservedHours, forKey: .reservedHours)
        }
        if let totalRunningHours = totalRunningHours {
            try encodeContainer.encode(totalRunningHours, forKey: .totalRunningHours)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandHours)
        onDemandHours = onDemandHoursDecoded
        let reservedHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedHours)
        reservedHours = reservedHoursDecoded
        let totalRunningHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRunningHours)
        totalRunningHours = totalRunningHoursDecoded
        let coverageHoursPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coverageHoursPercentage)
        coverageHoursPercentage = coverageHoursPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// How long a running instance either used a reservation or was On-Demand.
    public struct CoverageHours: Swift.Equatable {
        /// The percentage of instance hours that a reservation covered.
        public var coverageHoursPercentage: Swift.String?
        /// The number of instance running hours that On-Demand Instances covered.
        public var onDemandHours: Swift.String?
        /// The number of instance running hours that reservations covered.
        public var reservedHours: Swift.String?
        /// The total instance usage, in hours.
        public var totalRunningHours: Swift.String?

        public init (
            coverageHoursPercentage: Swift.String? = nil,
            onDemandHours: Swift.String? = nil,
            reservedHours: Swift.String? = nil,
            totalRunningHours: Swift.String? = nil
        )
        {
            self.coverageHoursPercentage = coverageHoursPercentage
            self.onDemandHours = onDemandHours
            self.reservedHours = reservedHours
            self.totalRunningHours = totalRunningHours
        }
    }

}

extension CostExplorerClientTypes.CoverageNormalizedUnits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coverageNormalizedUnitsPercentage = "CoverageNormalizedUnitsPercentage"
        case onDemandNormalizedUnits = "OnDemandNormalizedUnits"
        case reservedNormalizedUnits = "ReservedNormalizedUnits"
        case totalRunningNormalizedUnits = "TotalRunningNormalizedUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentage {
            try encodeContainer.encode(coverageNormalizedUnitsPercentage, forKey: .coverageNormalizedUnitsPercentage)
        }
        if let onDemandNormalizedUnits = onDemandNormalizedUnits {
            try encodeContainer.encode(onDemandNormalizedUnits, forKey: .onDemandNormalizedUnits)
        }
        if let reservedNormalizedUnits = reservedNormalizedUnits {
            try encodeContainer.encode(reservedNormalizedUnits, forKey: .reservedNormalizedUnits)
        }
        if let totalRunningNormalizedUnits = totalRunningNormalizedUnits {
            try encodeContainer.encode(totalRunningNormalizedUnits, forKey: .totalRunningNormalizedUnits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandNormalizedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandNormalizedUnits)
        onDemandNormalizedUnits = onDemandNormalizedUnitsDecoded
        let reservedNormalizedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNormalizedUnits)
        reservedNormalizedUnits = reservedNormalizedUnitsDecoded
        let totalRunningNormalizedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRunningNormalizedUnits)
        totalRunningNormalizedUnits = totalRunningNormalizedUnitsDecoded
        let coverageNormalizedUnitsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coverageNormalizedUnitsPercentage)
        coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of instance usage, in normalized units. You can use normalized units to see your EC2 usage for multiple sizes of instances in a uniform way. For example, suppose that you run an xlarge instance and a 2xlarge instance. If you run both instances for the same amount of time, the 2xlarge instance uses twice as much of your reservation as the xlarge instance, even though both instances show only one instance-hour. When you use normalized units instead of instance-hours, the xlarge instance used 8 normalized units, and the 2xlarge instance used 16 normalized units. For more information, see [Modifying Reserved Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html) in the Amazon Elastic Compute Cloud User Guide for Linux Instances.
    public struct CoverageNormalizedUnits: Swift.Equatable {
        /// The percentage of your used instance normalized units that a reservation covers.
        public var coverageNormalizedUnitsPercentage: Swift.String?
        /// The number of normalized units that are covered by On-Demand Instances instead of a reservation.
        public var onDemandNormalizedUnits: Swift.String?
        /// The number of normalized units that a reservation covers.
        public var reservedNormalizedUnits: Swift.String?
        /// The total number of normalized units that you used.
        public var totalRunningNormalizedUnits: Swift.String?

        public init (
            coverageNormalizedUnitsPercentage: Swift.String? = nil,
            onDemandNormalizedUnits: Swift.String? = nil,
            reservedNormalizedUnits: Swift.String? = nil,
            totalRunningNormalizedUnits: Swift.String? = nil
        )
        {
            self.coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentage
            self.onDemandNormalizedUnits = onDemandNormalizedUnits
            self.reservedNormalizedUnits = reservedNormalizedUnits
            self.totalRunningNormalizedUnits = totalRunningNormalizedUnits
        }
    }

}

extension CreateAnomalyMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyMonitor = "AnomalyMonitor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyMonitor = anomalyMonitor {
            try encodeContainer.encode(anomalyMonitor, forKey: .anomalyMonitor)
        }
    }
}

extension CreateAnomalyMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAnomalyMonitorInput: Swift.Equatable {
    /// The cost anomaly detection monitor object that you want to create.
    /// This member is required.
    public var anomalyMonitor: CostExplorerClientTypes.AnomalyMonitor?

    public init (
        anomalyMonitor: CostExplorerClientTypes.AnomalyMonitor? = nil
    )
    {
        self.anomalyMonitor = anomalyMonitor
    }
}

struct CreateAnomalyMonitorInputBody: Swift.Equatable {
    let anomalyMonitor: CostExplorerClientTypes.AnomalyMonitor?
}

extension CreateAnomalyMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyMonitor = "AnomalyMonitor"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyMonitorDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyMonitor.self, forKey: .anomalyMonitor)
        anomalyMonitor = anomalyMonitorDecoded
    }
}

extension CreateAnomalyMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnomalyMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnomalyMonitorOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnomalyMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAnomalyMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.monitorArn = output.monitorArn
        } else {
            self.monitorArn = nil
        }
    }
}

public struct CreateAnomalyMonitorOutputResponse: Swift.Equatable {
    /// The unique identifier of your newly created cost anomaly detection monitor.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init (
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct CreateAnomalyMonitorOutputResponseBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension CreateAnomalyMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension CreateAnomalySubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalySubscription = "AnomalySubscription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalySubscription = anomalySubscription {
            try encodeContainer.encode(anomalySubscription, forKey: .anomalySubscription)
        }
    }
}

extension CreateAnomalySubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAnomalySubscriptionInput: Swift.Equatable {
    /// The cost anomaly subscription object that you want to create.
    /// This member is required.
    public var anomalySubscription: CostExplorerClientTypes.AnomalySubscription?

    public init (
        anomalySubscription: CostExplorerClientTypes.AnomalySubscription? = nil
    )
    {
        self.anomalySubscription = anomalySubscription
    }
}

struct CreateAnomalySubscriptionInputBody: Swift.Equatable {
    let anomalySubscription: CostExplorerClientTypes.AnomalySubscription?
}

extension CreateAnomalySubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalySubscription = "AnomalySubscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalySubscriptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalySubscription.self, forKey: .anomalySubscription)
        anomalySubscription = anomalySubscriptionDecoded
    }
}

extension CreateAnomalySubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnomalySubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnomalySubscriptionOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnomalySubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAnomalySubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

public struct CreateAnomalySubscriptionOutputResponse: Swift.Equatable {
    /// The unique identifier of your newly created cost anomaly subscription.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct CreateAnomalySubscriptionOutputResponseBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension CreateAnomalySubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension CreateCostCategoryDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case name = "Name"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryruleslist0 in rules {
                try rulesContainer.encode(costcategoryruleslist0)
            }
        }
        if let splitChargeRules = splitChargeRules {
            var splitChargeRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .splitChargeRules)
            for costcategorysplitchargeruleslist0 in splitChargeRules {
                try splitChargeRulesContainer.encode(costcategorysplitchargeruleslist0)
            }
        }
    }
}

extension CreateCostCategoryDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCostCategoryDefinitionInput: Swift.Equatable {
    /// The default value for the cost category.
    public var defaultValue: Swift.String?
    /// The unique name of the Cost Category.
    /// This member is required.
    public var name: Swift.String?
    /// The rule schema version in this particular Cost Category.
    /// This member is required.
    public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    /// The Cost Category rules used to categorize costs. For more information, see [CostCategoryRule](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html).
    /// This member is required.
    public var rules: [CostExplorerClientTypes.CostCategoryRule]?
    /// The split charge rules used to allocate your charges between your Cost Category values.
    public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

    public init (
        defaultValue: Swift.String? = nil,
        name: Swift.String? = nil,
        ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
        rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
        splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
    )
    {
        self.defaultValue = defaultValue
        self.name = name
        self.ruleVersion = ruleVersion
        self.rules = rules
        self.splitChargeRules = splitChargeRules
    }
}

struct CreateCostCategoryDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
    let ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    let rules: [CostExplorerClientTypes.CostCategoryRule]?
    let defaultValue: Swift.String?
    let splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?
}

extension CreateCostCategoryDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case name = "Name"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostExplorerClientTypes.CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostExplorerClientTypes.CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let splitChargeRulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategorySplitChargeRule?].self, forKey: .splitChargeRules)
        var splitChargeRulesDecoded0:[CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        if let splitChargeRulesContainer = splitChargeRulesContainer {
            splitChargeRulesDecoded0 = [CostExplorerClientTypes.CostCategorySplitChargeRule]()
            for structure0 in splitChargeRulesContainer {
                if let structure0 = structure0 {
                    splitChargeRulesDecoded0?.append(structure0)
                }
            }
        }
        splitChargeRules = splitChargeRulesDecoded0
    }
}

extension CreateCostCategoryDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCostCategoryDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCostCategoryDefinitionOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCostCategoryDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCostCategoryDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveStart = output.effectiveStart
        } else {
            self.costCategoryArn = nil
            self.effectiveStart = nil
        }
    }
}

public struct CreateCostCategoryDefinitionOutputResponse: Swift.Equatable {
    /// The unique identifier for your newly created Cost Category.
    public var costCategoryArn: Swift.String?
    /// The Cost Category's effective start date.
    public var effectiveStart: Swift.String?

    public init (
        costCategoryArn: Swift.String? = nil,
        effectiveStart: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveStart = effectiveStart
    }
}

struct CreateCostCategoryDefinitionOutputResponseBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveStart: Swift.String?
}

extension CreateCostCategoryDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveStart = "EffectiveStart"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
    }
}

extension CostExplorerClientTypes.CurrentInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case instanceName = "InstanceName"
        case monthlyCost = "MonthlyCost"
        case onDemandHoursInLookbackPeriod = "OnDemandHoursInLookbackPeriod"
        case reservationCoveredHoursInLookbackPeriod = "ReservationCoveredHoursInLookbackPeriod"
        case resourceDetails = "ResourceDetails"
        case resourceId = "ResourceId"
        case resourceUtilization = "ResourceUtilization"
        case savingsPlansCoveredHoursInLookbackPeriod = "SavingsPlansCoveredHoursInLookbackPeriod"
        case tags = "Tags"
        case totalRunningHoursInLookbackPeriod = "TotalRunningHoursInLookbackPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let instanceName = instanceName {
            try encodeContainer.encode(instanceName, forKey: .instanceName)
        }
        if let monthlyCost = monthlyCost {
            try encodeContainer.encode(monthlyCost, forKey: .monthlyCost)
        }
        if let onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriod {
            try encodeContainer.encode(onDemandHoursInLookbackPeriod, forKey: .onDemandHoursInLookbackPeriod)
        }
        if let reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriod {
            try encodeContainer.encode(reservationCoveredHoursInLookbackPeriod, forKey: .reservationCoveredHoursInLookbackPeriod)
        }
        if let resourceDetails = resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceUtilization = resourceUtilization {
            try encodeContainer.encode(resourceUtilization, forKey: .resourceUtilization)
        }
        if let savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriod {
            try encodeContainer.encode(savingsPlansCoveredHoursInLookbackPeriod, forKey: .savingsPlansCoveredHoursInLookbackPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagvalueslist0 in tags {
                try tagsContainer.encode(tagvalueslist0)
            }
        }
        if let totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriod {
            try encodeContainer.encode(totalRunningHoursInLookbackPeriod, forKey: .totalRunningHoursInLookbackPeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let instanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceName)
        instanceName = instanceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.TagValues?].self, forKey: .tags)
        var tagsDecoded0:[CostExplorerClientTypes.TagValues]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CostExplorerClientTypes.TagValues]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let resourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ResourceUtilization.self, forKey: .resourceUtilization)
        resourceUtilization = resourceUtilizationDecoded
        let reservationCoveredHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationCoveredHoursInLookbackPeriod)
        reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriodDecoded
        let savingsPlansCoveredHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlansCoveredHoursInLookbackPeriod)
        savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriodDecoded
        let onDemandHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandHoursInLookbackPeriod)
        onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriodDecoded
        let totalRunningHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRunningHoursInLookbackPeriod)
        totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriodDecoded
        let monthlyCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyCost)
        monthlyCost = monthlyCostDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension CostExplorerClientTypes {
    /// Context about the current instance.
    public struct CurrentInstance: Swift.Equatable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// The name that you given an instance. This field shows as blank if you haven't given the instance a name.
        public var instanceName: Swift.String?
        /// The current On-Demand cost of operating this instance on a monthly basis.
        public var monthlyCost: Swift.String?
        /// The number of hours during the lookback period that's billed at On-Demand rates.
        public var onDemandHoursInLookbackPeriod: Swift.String?
        /// The number of hours during the lookback period that's covered by reservations.
        public var reservationCoveredHoursInLookbackPeriod: Swift.String?
        /// Details about the resource and utilization.
        public var resourceDetails: CostExplorerClientTypes.ResourceDetails?
        /// Resource ID of the current instance.
        public var resourceId: Swift.String?
        /// Utilization information of the current instance during the lookback period.
        public var resourceUtilization: CostExplorerClientTypes.ResourceUtilization?
        /// The number of hours during the lookback period that's covered by Savings Plans.
        public var savingsPlansCoveredHoursInLookbackPeriod: Swift.String?
        /// Cost allocation resource tags that are applied to the instance.
        public var tags: [CostExplorerClientTypes.TagValues]?
        /// The total number of hours that the instance ran during the lookback period.
        public var totalRunningHoursInLookbackPeriod: Swift.String?

        public init (
            currencyCode: Swift.String? = nil,
            instanceName: Swift.String? = nil,
            monthlyCost: Swift.String? = nil,
            onDemandHoursInLookbackPeriod: Swift.String? = nil,
            reservationCoveredHoursInLookbackPeriod: Swift.String? = nil,
            resourceDetails: CostExplorerClientTypes.ResourceDetails? = nil,
            resourceId: Swift.String? = nil,
            resourceUtilization: CostExplorerClientTypes.ResourceUtilization? = nil,
            savingsPlansCoveredHoursInLookbackPeriod: Swift.String? = nil,
            tags: [CostExplorerClientTypes.TagValues]? = nil,
            totalRunningHoursInLookbackPeriod: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.instanceName = instanceName
            self.monthlyCost = monthlyCost
            self.onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriod
            self.reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriod
            self.resourceDetails = resourceDetails
            self.resourceId = resourceId
            self.resourceUtilization = resourceUtilization
            self.savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriod
            self.tags = tags
            self.totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriod
        }
    }

}

extension DataUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DataUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested data is unavailable.
public struct DataUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DataUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DataUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes.DateInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .end)
        end = endDecoded
    }
}

extension CostExplorerClientTypes {
    /// The time period of the request.
    public struct DateInterval: Swift.Equatable {
        /// The end of the time period. The end date is exclusive. For example, if end is 2017-05-01, Amazon Web Services retrieves cost and usage data from the start date up to, but not including, 2017-05-01.
        /// This member is required.
        public var end: Swift.String?
        /// The beginning of the time period. The start date is inclusive. For example, if start is 2017-01-01, Amazon Web Services retrieves cost and usage data starting at 2017-01-01 up to the end date. The start date must be equal to or no later than the current date to avoid a validation error.
        /// This member is required.
        public var start: Swift.String?

        public init (
            end: Swift.String? = nil,
            start: Swift.String? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension DeleteAnomalyMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
    }
}

extension DeleteAnomalyMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAnomalyMonitorInput: Swift.Equatable {
    /// The unique identifier of the cost anomaly monitor that you want to delete.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init (
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct DeleteAnomalyMonitorInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension DeleteAnomalyMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension DeleteAnomalyMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnomalyMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnomalyMonitorOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnomalyMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnomalyMonitorOutputResponse: Swift.Equatable {

}

extension DeleteAnomalySubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptionArn = subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
    }
}

extension DeleteAnomalySubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAnomalySubscriptionInput: Swift.Equatable {
    /// The unique identifier of the cost anomaly subscription that you want to delete.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct DeleteAnomalySubscriptionInputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension DeleteAnomalySubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension DeleteAnomalySubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnomalySubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownSubscriptionException" : self = .unknownSubscriptionException(try UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnomalySubscriptionOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknownSubscriptionException(UnknownSubscriptionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnomalySubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnomalySubscriptionOutputResponse: Swift.Equatable {

}

extension DeleteCostCategoryDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
    }
}

extension DeleteCostCategoryDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCostCategoryDefinitionInput: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?

    public init (
        costCategoryArn: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
    }
}

struct DeleteCostCategoryDefinitionInputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
}

extension DeleteCostCategoryDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
    }
}

extension DeleteCostCategoryDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCostCategoryDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCostCategoryDefinitionOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCostCategoryDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteCostCategoryDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveEnd = output.effectiveEnd
        } else {
            self.costCategoryArn = nil
            self.effectiveEnd = nil
        }
    }
}

public struct DeleteCostCategoryDefinitionOutputResponse: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    public var costCategoryArn: Swift.String?
    /// The effective end date of the Cost Category as a result of deleting it. No costs after this date will be categorized by the deleted Cost Category.
    public var effectiveEnd: Swift.String?

    public init (
        costCategoryArn: Swift.String? = nil,
        effectiveEnd: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveEnd = effectiveEnd
    }
}

struct DeleteCostCategoryDefinitionOutputResponseBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveEnd: Swift.String?
}

extension DeleteCostCategoryDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveEnd = "EffectiveEnd"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
    }
}

extension DescribeCostCategoryDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveOn = "EffectiveOn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let effectiveOn = effectiveOn {
            try encodeContainer.encode(effectiveOn, forKey: .effectiveOn)
        }
    }
}

extension DescribeCostCategoryDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCostCategoryDefinitionInput: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?
    /// The date when the Cost Category was effective.
    public var effectiveOn: Swift.String?

    public init (
        costCategoryArn: Swift.String? = nil,
        effectiveOn: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveOn = effectiveOn
    }
}

struct DescribeCostCategoryDefinitionInputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveOn: Swift.String?
}

extension DescribeCostCategoryDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveOn = "EffectiveOn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveOnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
    }
}

extension DescribeCostCategoryDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCostCategoryDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCostCategoryDefinitionOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCostCategoryDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCostCategoryDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.costCategory = output.costCategory
        } else {
            self.costCategory = nil
        }
    }
}

public struct DescribeCostCategoryDefinitionOutputResponse: Swift.Equatable {
    /// The structure of Cost Categories. This includes detailed metadata and the set of rules for the CostCategory object.
    public var costCategory: CostExplorerClientTypes.CostCategory?

    public init (
        costCategory: CostExplorerClientTypes.CostCategory? = nil
    )
    {
        self.costCategory = costCategory
    }
}

struct DescribeCostCategoryDefinitionOutputResponseBody: Swift.Equatable {
    let costCategory: CostExplorerClientTypes.CostCategory?
}

extension DescribeCostCategoryDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategory = "CostCategory"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategory.self, forKey: .costCategory)
        costCategory = costCategoryDecoded
    }
}

extension CostExplorerClientTypes {
    public enum Dimension: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agreementEndDateTimeAfter
        case agreementEndDateTimeBefore
        case az
        case billingEntity
        case cacheEngine
        case databaseEngine
        case deploymentOption
        case instanceType
        case instanceTypeFamily
        case legalEntityName
        case linkedAccount
        case linkedAccountName
        case operatingSystem
        case operation
        case paymentOption
        case platform
        case purchaseType
        case recordType
        case region
        case reservationId
        case resourceId
        case rightsizingType
        case savingsPlansType
        case savingsPlanArn
        case scope
        case service
        case serviceCode
        case subscriptionId
        case tenancy
        case usageType
        case usageTypeGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .agreementEndDateTimeAfter,
                .agreementEndDateTimeBefore,
                .az,
                .billingEntity,
                .cacheEngine,
                .databaseEngine,
                .deploymentOption,
                .instanceType,
                .instanceTypeFamily,
                .legalEntityName,
                .linkedAccount,
                .linkedAccountName,
                .operatingSystem,
                .operation,
                .paymentOption,
                .platform,
                .purchaseType,
                .recordType,
                .region,
                .reservationId,
                .resourceId,
                .rightsizingType,
                .savingsPlansType,
                .savingsPlanArn,
                .scope,
                .service,
                .serviceCode,
                .subscriptionId,
                .tenancy,
                .usageType,
                .usageTypeGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agreementEndDateTimeAfter: return "AGREEMENT_END_DATE_TIME_AFTER"
            case .agreementEndDateTimeBefore: return "AGREEMENT_END_DATE_TIME_BEFORE"
            case .az: return "AZ"
            case .billingEntity: return "BILLING_ENTITY"
            case .cacheEngine: return "CACHE_ENGINE"
            case .databaseEngine: return "DATABASE_ENGINE"
            case .deploymentOption: return "DEPLOYMENT_OPTION"
            case .instanceType: return "INSTANCE_TYPE"
            case .instanceTypeFamily: return "INSTANCE_TYPE_FAMILY"
            case .legalEntityName: return "LEGAL_ENTITY_NAME"
            case .linkedAccount: return "LINKED_ACCOUNT"
            case .linkedAccountName: return "LINKED_ACCOUNT_NAME"
            case .operatingSystem: return "OPERATING_SYSTEM"
            case .operation: return "OPERATION"
            case .paymentOption: return "PAYMENT_OPTION"
            case .platform: return "PLATFORM"
            case .purchaseType: return "PURCHASE_TYPE"
            case .recordType: return "RECORD_TYPE"
            case .region: return "REGION"
            case .reservationId: return "RESERVATION_ID"
            case .resourceId: return "RESOURCE_ID"
            case .rightsizingType: return "RIGHTSIZING_TYPE"
            case .savingsPlansType: return "SAVINGS_PLANS_TYPE"
            case .savingsPlanArn: return "SAVINGS_PLAN_ARN"
            case .scope: return "SCOPE"
            case .service: return "SERVICE"
            case .serviceCode: return "SERVICE_CODE"
            case .subscriptionId: return "SUBSCRIPTION_ID"
            case .tenancy: return "TENANCY"
            case .usageType: return "USAGE_TYPE"
            case .usageTypeGroup: return "USAGE_TYPE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Dimension(rawValue: rawValue) ?? Dimension.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.DimensionValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoptions0 in matchOptions {
                try matchOptionsContainer.encode(matchoptions0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Dimension.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[CostExplorerClientTypes.MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [CostExplorerClientTypes.MatchOption]()
            for string0 in matchOptionsContainer {
                if let string0 = string0 {
                    matchOptionsDecoded0?.append(string0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The metadata that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
    public struct DimensionValues: Swift.Equatable {
        /// The names of the metadata types that you can use to filter and group your results. For example, AZ returns a list of Availability Zones.
        public var key: CostExplorerClientTypes.Dimension?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to Cost Category. The default values for MatchOptions are EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The metadata values that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
        public var values: [Swift.String]?

        public init (
            key: CostExplorerClientTypes.Dimension? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }

}

extension CostExplorerClientTypes.DimensionValuesWithAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The metadata of a specific type that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
    public struct DimensionValuesWithAttributes: Swift.Equatable {
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String:Swift.String]?
        /// The value of a dimension with a specific attribute.
        public var value: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.value = value
        }
    }

}

extension CostExplorerClientTypes.DiskResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskReadBytesPerSecond = "DiskReadBytesPerSecond"
        case diskReadOpsPerSecond = "DiskReadOpsPerSecond"
        case diskWriteBytesPerSecond = "DiskWriteBytesPerSecond"
        case diskWriteOpsPerSecond = "DiskWriteOpsPerSecond"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskReadBytesPerSecond = diskReadBytesPerSecond {
            try encodeContainer.encode(diskReadBytesPerSecond, forKey: .diskReadBytesPerSecond)
        }
        if let diskReadOpsPerSecond = diskReadOpsPerSecond {
            try encodeContainer.encode(diskReadOpsPerSecond, forKey: .diskReadOpsPerSecond)
        }
        if let diskWriteBytesPerSecond = diskWriteBytesPerSecond {
            try encodeContainer.encode(diskWriteBytesPerSecond, forKey: .diskWriteBytesPerSecond)
        }
        if let diskWriteOpsPerSecond = diskWriteOpsPerSecond {
            try encodeContainer.encode(diskWriteOpsPerSecond, forKey: .diskWriteOpsPerSecond)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let diskReadOpsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskReadOpsPerSecond)
        diskReadOpsPerSecond = diskReadOpsPerSecondDecoded
        let diskWriteOpsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskWriteOpsPerSecond)
        diskWriteOpsPerSecond = diskWriteOpsPerSecondDecoded
        let diskReadBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskReadBytesPerSecond)
        diskReadBytesPerSecond = diskReadBytesPerSecondDecoded
        let diskWriteBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskWriteBytesPerSecond)
        diskWriteBytesPerSecond = diskWriteBytesPerSecondDecoded
    }
}

extension CostExplorerClientTypes {
    /// The field that contains a list of disk (local storage) metrics that are associated with the current instance.
    public struct DiskResourceUtilization: Swift.Equatable {
        /// The maximum read throughput operations per second.
        public var diskReadBytesPerSecond: Swift.String?
        /// The maximum number of read operations per second.
        public var diskReadOpsPerSecond: Swift.String?
        /// The maximum write throughput operations per second.
        public var diskWriteBytesPerSecond: Swift.String?
        /// The maximum number of write operations per second.
        public var diskWriteOpsPerSecond: Swift.String?

        public init (
            diskReadBytesPerSecond: Swift.String? = nil,
            diskReadOpsPerSecond: Swift.String? = nil,
            diskWriteBytesPerSecond: Swift.String? = nil,
            diskWriteOpsPerSecond: Swift.String? = nil
        )
        {
            self.diskReadBytesPerSecond = diskReadBytesPerSecond
            self.diskReadOpsPerSecond = diskReadOpsPerSecond
            self.diskWriteBytesPerSecond = diskWriteBytesPerSecond
            self.diskWriteOpsPerSecond = diskWriteOpsPerSecond
        }
    }

}

extension CostExplorerClientTypes.EBSResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsReadBytesPerSecond = "EbsReadBytesPerSecond"
        case ebsReadOpsPerSecond = "EbsReadOpsPerSecond"
        case ebsWriteBytesPerSecond = "EbsWriteBytesPerSecond"
        case ebsWriteOpsPerSecond = "EbsWriteOpsPerSecond"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsReadBytesPerSecond = ebsReadBytesPerSecond {
            try encodeContainer.encode(ebsReadBytesPerSecond, forKey: .ebsReadBytesPerSecond)
        }
        if let ebsReadOpsPerSecond = ebsReadOpsPerSecond {
            try encodeContainer.encode(ebsReadOpsPerSecond, forKey: .ebsReadOpsPerSecond)
        }
        if let ebsWriteBytesPerSecond = ebsWriteBytesPerSecond {
            try encodeContainer.encode(ebsWriteBytesPerSecond, forKey: .ebsWriteBytesPerSecond)
        }
        if let ebsWriteOpsPerSecond = ebsWriteOpsPerSecond {
            try encodeContainer.encode(ebsWriteOpsPerSecond, forKey: .ebsWriteOpsPerSecond)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsReadOpsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsReadOpsPerSecond)
        ebsReadOpsPerSecond = ebsReadOpsPerSecondDecoded
        let ebsWriteOpsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsWriteOpsPerSecond)
        ebsWriteOpsPerSecond = ebsWriteOpsPerSecondDecoded
        let ebsReadBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsReadBytesPerSecond)
        ebsReadBytesPerSecond = ebsReadBytesPerSecondDecoded
        let ebsWriteBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsWriteBytesPerSecond)
        ebsWriteBytesPerSecond = ebsWriteBytesPerSecondDecoded
    }
}

extension CostExplorerClientTypes {
    /// The EBS field that contains a list of EBS metrics that are associated with the current instance.
    public struct EBSResourceUtilization: Swift.Equatable {
        /// The maximum size of read operations per second
        public var ebsReadBytesPerSecond: Swift.String?
        /// The maximum number of read operations per second.
        public var ebsReadOpsPerSecond: Swift.String?
        /// The maximum size of write operations per second.
        public var ebsWriteBytesPerSecond: Swift.String?
        /// The maximum number of write operations per second.
        public var ebsWriteOpsPerSecond: Swift.String?

        public init (
            ebsReadBytesPerSecond: Swift.String? = nil,
            ebsReadOpsPerSecond: Swift.String? = nil,
            ebsWriteBytesPerSecond: Swift.String? = nil,
            ebsWriteOpsPerSecond: Swift.String? = nil
        )
        {
            self.ebsReadBytesPerSecond = ebsReadBytesPerSecond
            self.ebsReadOpsPerSecond = ebsReadOpsPerSecond
            self.ebsWriteBytesPerSecond = ebsWriteBytesPerSecond
            self.ebsWriteOpsPerSecond = ebsWriteOpsPerSecond
        }
    }

}

extension CostExplorerClientTypes.EC2InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case instanceType = "InstanceType"
        case platform = "Platform"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
        case tenancy = "Tenancy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let currentGenerationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon EC2 instances that Amazon Web Services recommends that you purchase.
    public struct EC2InstanceDetails: Swift.Equatable {
        /// The Availability Zone of the recommended reservation.
        public var availabilityZone: Swift.String?
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// The platform of the recommended reservation. The platform is the specific combination of operating system, license model, and software on an instance.
        public var platform: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool
        /// Determines whether the recommended reservation is dedicated or shared.
        public var tenancy: Swift.String?

        public init (
            availabilityZone: Swift.String? = nil,
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            platform: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false,
            tenancy: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.currentGeneration = currentGeneration
            self.family = family
            self.instanceType = instanceType
            self.platform = platform
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
            self.tenancy = tenancy
        }
    }

}

extension CostExplorerClientTypes.EC2ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hourlyOnDemandRate = "HourlyOnDemandRate"
        case instanceType = "InstanceType"
        case memory = "Memory"
        case networkPerformance = "NetworkPerformance"
        case platform = "Platform"
        case region = "Region"
        case sku = "Sku"
        case storage = "Storage"
        case vcpu = "Vcpu"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hourlyOnDemandRate = hourlyOnDemandRate {
            try encodeContainer.encode(hourlyOnDemandRate, forKey: .hourlyOnDemandRate)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let networkPerformance = networkPerformance {
            try encodeContainer.encode(networkPerformance, forKey: .networkPerformance)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let sku = sku {
            try encodeContainer.encode(sku, forKey: .sku)
        }
        if let storage = storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
        if let vcpu = vcpu {
            try encodeContainer.encode(vcpu, forKey: .vcpu)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hourlyOnDemandRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyOnDemandRate)
        hourlyOnDemandRate = hourlyOnDemandRateDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let skuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sku)
        sku = skuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let networkPerformanceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkPerformance)
        networkPerformance = networkPerformanceDecoded
        let storageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storage)
        storage = storageDecoded
        let vcpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcpu)
        vcpu = vcpuDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details on the Amazon EC2 Resource.
    public struct EC2ResourceDetails: Swift.Equatable {
        /// The hourly public On-Demand rate for the instance type.
        public var hourlyOnDemandRate: Swift.String?
        /// The type of Amazon Web Services instance.
        public var instanceType: Swift.String?
        /// The memory capacity of the Amazon Web Services instance.
        public var memory: Swift.String?
        /// The network performance capacity of the Amazon Web Services instance.
        public var networkPerformance: Swift.String?
        /// The platform of the Amazon Web Services instance. The platform is the specific combination of operating system, license model, and software on an instance.
        public var platform: Swift.String?
        /// The Amazon Web Services Region of the instance.
        public var region: Swift.String?
        /// The SKU of the product.
        public var sku: Swift.String?
        /// The disk storage of the Amazon Web Services instance. This doesn't include EBS storage.
        public var storage: Swift.String?
        /// The number of VCPU cores in the Amazon Web Services instance type.
        public var vcpu: Swift.String?

        public init (
            hourlyOnDemandRate: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            memory: Swift.String? = nil,
            networkPerformance: Swift.String? = nil,
            platform: Swift.String? = nil,
            region: Swift.String? = nil,
            sku: Swift.String? = nil,
            storage: Swift.String? = nil,
            vcpu: Swift.String? = nil
        )
        {
            self.hourlyOnDemandRate = hourlyOnDemandRate
            self.instanceType = instanceType
            self.memory = memory
            self.networkPerformance = networkPerformance
            self.platform = platform
            self.region = region
            self.sku = sku
            self.storage = storage
            self.vcpu = vcpu
        }
    }

}

extension CostExplorerClientTypes.EC2ResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskResourceUtilization = "DiskResourceUtilization"
        case eBSResourceUtilization = "EBSResourceUtilization"
        case maxCpuUtilizationPercentage = "MaxCpuUtilizationPercentage"
        case maxMemoryUtilizationPercentage = "MaxMemoryUtilizationPercentage"
        case maxStorageUtilizationPercentage = "MaxStorageUtilizationPercentage"
        case networkResourceUtilization = "NetworkResourceUtilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskResourceUtilization = diskResourceUtilization {
            try encodeContainer.encode(diskResourceUtilization, forKey: .diskResourceUtilization)
        }
        if let eBSResourceUtilization = eBSResourceUtilization {
            try encodeContainer.encode(eBSResourceUtilization, forKey: .eBSResourceUtilization)
        }
        if let maxCpuUtilizationPercentage = maxCpuUtilizationPercentage {
            try encodeContainer.encode(maxCpuUtilizationPercentage, forKey: .maxCpuUtilizationPercentage)
        }
        if let maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentage {
            try encodeContainer.encode(maxMemoryUtilizationPercentage, forKey: .maxMemoryUtilizationPercentage)
        }
        if let maxStorageUtilizationPercentage = maxStorageUtilizationPercentage {
            try encodeContainer.encode(maxStorageUtilizationPercentage, forKey: .maxStorageUtilizationPercentage)
        }
        if let networkResourceUtilization = networkResourceUtilization {
            try encodeContainer.encode(networkResourceUtilization, forKey: .networkResourceUtilization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxCpuUtilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxCpuUtilizationPercentage)
        maxCpuUtilizationPercentage = maxCpuUtilizationPercentageDecoded
        let maxMemoryUtilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxMemoryUtilizationPercentage)
        maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentageDecoded
        let maxStorageUtilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxStorageUtilizationPercentage)
        maxStorageUtilizationPercentage = maxStorageUtilizationPercentageDecoded
        let eBSResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EBSResourceUtilization.self, forKey: .eBSResourceUtilization)
        eBSResourceUtilization = eBSResourceUtilizationDecoded
        let diskResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DiskResourceUtilization.self, forKey: .diskResourceUtilization)
        diskResourceUtilization = diskResourceUtilizationDecoded
        let networkResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.NetworkResourceUtilization.self, forKey: .networkResourceUtilization)
        networkResourceUtilization = networkResourceUtilizationDecoded
    }
}

extension CostExplorerClientTypes {
    /// Utilization metrics of the instance.
    public struct EC2ResourceUtilization: Swift.Equatable {
        /// The field that contains a list of disk (local storage) metrics that are associated with the current instance.
        public var diskResourceUtilization: CostExplorerClientTypes.DiskResourceUtilization?
        /// The EBS field that contains a list of EBS metrics that are associated with the current instance.
        public var eBSResourceUtilization: CostExplorerClientTypes.EBSResourceUtilization?
        /// The maximum observed or expected CPU utilization of the instance.
        public var maxCpuUtilizationPercentage: Swift.String?
        /// The maximum observed or expected memory utilization of the instance.
        public var maxMemoryUtilizationPercentage: Swift.String?
        /// The maximum observed or expected storage utilization of the instance. This doesn't include EBS storage.
        public var maxStorageUtilizationPercentage: Swift.String?
        /// The network field that contains a list of network metrics that are associated with the current instance.
        public var networkResourceUtilization: CostExplorerClientTypes.NetworkResourceUtilization?

        public init (
            diskResourceUtilization: CostExplorerClientTypes.DiskResourceUtilization? = nil,
            eBSResourceUtilization: CostExplorerClientTypes.EBSResourceUtilization? = nil,
            maxCpuUtilizationPercentage: Swift.String? = nil,
            maxMemoryUtilizationPercentage: Swift.String? = nil,
            maxStorageUtilizationPercentage: Swift.String? = nil,
            networkResourceUtilization: CostExplorerClientTypes.NetworkResourceUtilization? = nil
        )
        {
            self.diskResourceUtilization = diskResourceUtilization
            self.eBSResourceUtilization = eBSResourceUtilization
            self.maxCpuUtilizationPercentage = maxCpuUtilizationPercentage
            self.maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentage
            self.maxStorageUtilizationPercentage = maxStorageUtilizationPercentage
            self.networkResourceUtilization = networkResourceUtilization
        }
    }

}

extension CostExplorerClientTypes.EC2Specification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringClass = "OfferingClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringClass = offeringClass {
            try encodeContainer.encode(offeringClass.rawValue, forKey: .offeringClass)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringClassDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.OfferingClass.self, forKey: .offeringClass)
        offeringClass = offeringClassDecoded
    }
}

extension CostExplorerClientTypes {
    /// The Amazon EC2 hardware specifications that you want Amazon Web Services to provide recommendations for.
    public struct EC2Specification: Swift.Equatable {
        /// Indicates whether you want a recommendation for standard or convertible reservations.
        public var offeringClass: CostExplorerClientTypes.OfferingClass?

        public init (
            offeringClass: CostExplorerClientTypes.OfferingClass? = nil
        )
        {
            self.offeringClass = offeringClass
        }
    }

}

extension CostExplorerClientTypes.ESInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentGeneration = "CurrentGeneration"
        case instanceClass = "InstanceClass"
        case instanceSize = "InstanceSize"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let instanceClass = instanceClass {
            try encodeContainer.encode(instanceClass, forKey: .instanceClass)
        }
        if let instanceSize = instanceSize {
            try encodeContainer.encode(instanceSize, forKey: .instanceSize)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceClass)
        instanceClass = instanceClassDecoded
        let instanceSizeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceSize)
        instanceSize = instanceSizeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let currentGenerationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon ES instances that Amazon Web Services recommends that you purchase.
    public struct ESInstanceDetails: Swift.Equatable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The class of instance that Amazon Web Services recommends.
        public var instanceClass: Swift.String?
        /// The size of instance that Amazon Web Services recommends.
        public var instanceSize: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init (
            currentGeneration: Swift.Bool = false,
            instanceClass: Swift.String? = nil,
            instanceSize: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.instanceClass = instanceClass
            self.instanceSize = instanceSize
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }

}

extension CostExplorerClientTypes.ElastiCacheInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case nodeType = "NodeType"
        case productDescription = "ProductDescription"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let productDescription = productDescription {
            try encodeContainer.encode(productDescription, forKey: .productDescription)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let currentGenerationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon ElastiCache instances that Amazon Web Services recommends that you purchase.
    public struct ElastiCacheInstanceDetails: Swift.Equatable {
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of node that Amazon Web Services recommends.
        public var nodeType: Swift.String?
        /// The description of the recommended reservation.
        public var productDescription: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init (
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            productDescription: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.productDescription = productDescription
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }

}

extension CostExplorerClientTypes.Expression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case costCategories = "CostCategories"
        case dimensions = "Dimensions"
        case not = "Not"
        case or = "Or"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for expressions0 in and {
                try andContainer.encode(expressions0)
            }
        }
        if let costCategories = costCategories {
            try encodeContainer.encode(costCategories, forKey: .costCategories)
        }
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let not = not {
            try encodeContainer.encode(not.value, forKey: .not)
        }
        if let or = or {
            var orContainer = encodeContainer.nestedUnkeyedContainer(forKey: .or)
            for expressions0 in or {
                try orContainer.encode(expressions0)
            }
        }
        if let tags = tags {
            try encodeContainer.encode(tags, forKey: .tags)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Expression?].self, forKey: .or)
        var orDecoded0:[CostExplorerClientTypes.Expression]? = nil
        if let orContainer = orContainer {
            orDecoded0 = [CostExplorerClientTypes.Expression]()
            for structure0 in orContainer {
                if let structure0 = structure0 {
                    orDecoded0?.append(structure0)
                }
            }
        }
        or = orDecoded0
        let andContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Expression?].self, forKey: .and)
        var andDecoded0:[CostExplorerClientTypes.Expression]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [CostExplorerClientTypes.Expression]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
        let notDecoded = try containerValues.decodeIfPresent(Box<CostExplorerClientTypes.Expression>.self, forKey: .not)
        not = notDecoded
        let dimensionsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DimensionValues.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TagValues.self, forKey: .tags)
        tags = tagsDecoded
        let costCategoriesDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryValues.self, forKey: .costCategories)
        costCategories = costCategoriesDecoded
    }
}

extension CostExplorerClientTypes {
    /// Use Expression to filter by cost or by usage. There are two patterns:
    ///
    /// * Simple dimension values - You can set the dimension name and values for the filters that you plan to use. For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia). The Expression example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } } The list of dimension values are OR'd together to retrieve cost or usage data. You can create Expression and DimensionValues objects using either with* methods or set* methods in multiple lines.
    ///
    /// * Compound dimension values with logical operations - You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter on more advanced options. For example, you can filter on ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer). The Expression for that is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }  Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error.  { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public struct Expression: Swift.Equatable {
        /// Return results that match both Dimension objects.
        public var and: [CostExplorerClientTypes.Expression]?
        /// The filter that's based on CostCategory values.
        public var costCategories: CostExplorerClientTypes.CostCategoryValues?
        /// The specific Dimension to use for Expression.
        public var dimensions: CostExplorerClientTypes.DimensionValues?
        /// Return results that don't match a Dimension object.
        public var not: Box<CostExplorerClientTypes.Expression>?
        /// Return results that match either Dimension object.
        public var or: [CostExplorerClientTypes.Expression]?
        /// The specific Tag to use for Expression.
        public var tags: CostExplorerClientTypes.TagValues?

        public init (
            and: [CostExplorerClientTypes.Expression]? = nil,
            costCategories: CostExplorerClientTypes.CostCategoryValues? = nil,
            dimensions: CostExplorerClientTypes.DimensionValues? = nil,
            not: Box<CostExplorerClientTypes.Expression>? = nil,
            or: [CostExplorerClientTypes.Expression]? = nil,
            tags: CostExplorerClientTypes.TagValues? = nil
        )
        {
            self.and = and
            self.costCategories = costCategories
            self.dimensions = dimensions
            self.not = not
            self.or = or
            self.tags = tags
        }
    }

}

extension CostExplorerClientTypes {
    public enum FindingReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cpuOverProvisioned
        case cpuUnderProvisioned
        case diskIopsOverProvisioned
        case diskIopsUnderProvisioned
        case diskThroughputOverProvisioned
        case diskThroughputUnderProvisioned
        case ebsIopsOverProvisioned
        case ebsIopsUnderProvisioned
        case ebsThroughputOverProvisioned
        case ebsThroughputUnderProvisioned
        case memoryOverProvisioned
        case memoryUnderProvisioned
        case networkBandwidthOverProvisioned
        case networkBandwidthUnderProvisioned
        case networkPpsOverProvisioned
        case networkPpsUnderProvisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingReasonCode] {
            return [
                .cpuOverProvisioned,
                .cpuUnderProvisioned,
                .diskIopsOverProvisioned,
                .diskIopsUnderProvisioned,
                .diskThroughputOverProvisioned,
                .diskThroughputUnderProvisioned,
                .ebsIopsOverProvisioned,
                .ebsIopsUnderProvisioned,
                .ebsThroughputOverProvisioned,
                .ebsThroughputUnderProvisioned,
                .memoryOverProvisioned,
                .memoryUnderProvisioned,
                .networkBandwidthOverProvisioned,
                .networkBandwidthUnderProvisioned,
                .networkPpsOverProvisioned,
                .networkPpsUnderProvisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cpuOverProvisioned: return "CPU_OVER_PROVISIONED"
            case .cpuUnderProvisioned: return "CPU_UNDER_PROVISIONED"
            case .diskIopsOverProvisioned: return "DISK_IOPS_OVER_PROVISIONED"
            case .diskIopsUnderProvisioned: return "DISK_IOPS_UNDER_PROVISIONED"
            case .diskThroughputOverProvisioned: return "DISK_THROUGHPUT_OVER_PROVISIONED"
            case .diskThroughputUnderProvisioned: return "DISK_THROUGHPUT_UNDER_PROVISIONED"
            case .ebsIopsOverProvisioned: return "EBS_IOPS_OVER_PROVISIONED"
            case .ebsIopsUnderProvisioned: return "EBS_IOPS_UNDER_PROVISIONED"
            case .ebsThroughputOverProvisioned: return "EBS_THROUGHPUT_OVER_PROVISIONED"
            case .ebsThroughputUnderProvisioned: return "EBS_THROUGHPUT_UNDER_PROVISIONED"
            case .memoryOverProvisioned: return "MEMORY_OVER_PROVISIONED"
            case .memoryUnderProvisioned: return "MEMORY_UNDER_PROVISIONED"
            case .networkBandwidthOverProvisioned: return "NETWORK_BANDWIDTH_OVER_PROVISIONED"
            case .networkBandwidthUnderProvisioned: return "NETWORK_BANDWIDTH_UNDER_PROVISIONED"
            case .networkPpsOverProvisioned: return "NETWORK_PPS_OVER_PROVISIONED"
            case .networkPpsUnderProvisioned: return "NETWORK_PPS_UNDER_PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingReasonCode(rawValue: rawValue) ?? FindingReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.ForecastResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meanValue = "MeanValue"
        case predictionIntervalLowerBound = "PredictionIntervalLowerBound"
        case predictionIntervalUpperBound = "PredictionIntervalUpperBound"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meanValue = meanValue {
            try encodeContainer.encode(meanValue, forKey: .meanValue)
        }
        if let predictionIntervalLowerBound = predictionIntervalLowerBound {
            try encodeContainer.encode(predictionIntervalLowerBound, forKey: .predictionIntervalLowerBound)
        }
        if let predictionIntervalUpperBound = predictionIntervalUpperBound {
            try encodeContainer.encode(predictionIntervalUpperBound, forKey: .predictionIntervalUpperBound)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let meanValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meanValue)
        meanValue = meanValueDecoded
        let predictionIntervalLowerBoundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionIntervalLowerBound)
        predictionIntervalLowerBound = predictionIntervalLowerBoundDecoded
        let predictionIntervalUpperBoundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionIntervalUpperBound)
        predictionIntervalUpperBound = predictionIntervalUpperBoundDecoded
    }
}

extension CostExplorerClientTypes {
    /// The forecast that's created for your query.
    public struct ForecastResult: Swift.Equatable {
        /// The mean value of the forecast.
        public var meanValue: Swift.String?
        /// The lower limit for the prediction interval.
        public var predictionIntervalLowerBound: Swift.String?
        /// The upper limit for the prediction interval.
        public var predictionIntervalUpperBound: Swift.String?
        /// The period of time that the forecast covers.
        public var timePeriod: CostExplorerClientTypes.DateInterval?

        public init (
            meanValue: Swift.String? = nil,
            predictionIntervalLowerBound: Swift.String? = nil,
            predictionIntervalUpperBound: Swift.String? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil
        )
        {
            self.meanValue = meanValue
            self.predictionIntervalLowerBound = predictionIntervalLowerBound
            self.predictionIntervalUpperBound = predictionIntervalUpperBound
            self.timePeriod = timePeriod
        }
    }

}

extension GetAnomaliesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateInterval = "DateInterval"
        case feedback = "Feedback"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case totalImpact = "TotalImpact"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateInterval = dateInterval {
            try encodeContainer.encode(dateInterval, forKey: .dateInterval)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let totalImpact = totalImpact {
            try encodeContainer.encode(totalImpact, forKey: .totalImpact)
        }
    }
}

extension GetAnomaliesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAnomaliesInput: Swift.Equatable {
    /// Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object will have an AnomalyEndDate in the specified time range.
    /// This member is required.
    public var dateInterval: CostExplorerClientTypes.AnomalyDateInterval?
    /// Filters anomaly results by the feedback field on the anomaly object.
    public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon Resource Name (ARN).
    public var monitorArn: Swift.String?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Filters anomaly results by the total impact field on the anomaly object. For example, you can filter anomalies GREATER_THAN 200.00 to retrieve anomalies, with an estimated dollar impact greater than 200.
    public var totalImpact: CostExplorerClientTypes.TotalImpactFilter?

    public init (
        dateInterval: CostExplorerClientTypes.AnomalyDateInterval? = nil,
        feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil,
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextPageToken: Swift.String? = nil,
        totalImpact: CostExplorerClientTypes.TotalImpactFilter? = nil
    )
    {
        self.dateInterval = dateInterval
        self.feedback = feedback
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextPageToken = nextPageToken
        self.totalImpact = totalImpact
    }
}

struct GetAnomaliesInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
    let dateInterval: CostExplorerClientTypes.AnomalyDateInterval?
    let feedback: CostExplorerClientTypes.AnomalyFeedbackType?
    let totalImpact: CostExplorerClientTypes.TotalImpactFilter?
    let nextPageToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetAnomaliesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateInterval = "DateInterval"
        case feedback = "Feedback"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case totalImpact = "TotalImpact"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let dateIntervalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyDateInterval.self, forKey: .dateInterval)
        dateInterval = dateIntervalDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
        let totalImpactDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TotalImpactFilter.self, forKey: .totalImpact)
        totalImpact = totalImpactDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomaliesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomaliesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnomaliesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomaliesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAnomaliesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalies = output.anomalies
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalies = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomaliesOutputResponse: Swift.Equatable {
    /// A list of cost anomalies.
    /// This member is required.
    public var anomalies: [CostExplorerClientTypes.Anomaly]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init (
        anomalies: [CostExplorerClientTypes.Anomaly]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalies = anomalies
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomaliesOutputResponseBody: Swift.Equatable {
    let anomalies: [CostExplorerClientTypes.Anomaly]?
    let nextPageToken: Swift.String?
}

extension GetAnomaliesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalies = "Anomalies"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomaliesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Anomaly?].self, forKey: .anomalies)
        var anomaliesDecoded0:[CostExplorerClientTypes.Anomaly]? = nil
        if let anomaliesContainer = anomaliesContainer {
            anomaliesDecoded0 = [CostExplorerClientTypes.Anomaly]()
            for structure0 in anomaliesContainer {
                if let structure0 = structure0 {
                    anomaliesDecoded0?.append(structure0)
                }
            }
        }
        anomalies = anomaliesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetAnomalyMonitorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case monitorArnList = "MonitorArnList"
        case nextPageToken = "NextPageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for values0 in monitorArnList {
                try monitorArnListContainer.encode(values0)
            }
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
    }
}

extension GetAnomalyMonitorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAnomalyMonitorsInput: Swift.Equatable {
    /// The number of entries that a paginated response contains.
    public var maxResults: Swift.Int?
    /// A list of cost anomaly monitor ARNs.
    public var monitorArnList: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        monitorArnList: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorArnList = monitorArnList
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalyMonitorsInputBody: Swift.Equatable {
    let monitorArnList: [Swift.String]?
    let nextPageToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetAnomalyMonitorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case monitorArnList = "MonitorArnList"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[Swift.String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [Swift.String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomalyMonitorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomalyMonitorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnomalyMonitorsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomalyMonitorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAnomalyMonitorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyMonitors = output.anomalyMonitors
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalyMonitors = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomalyMonitorsOutputResponse: Swift.Equatable {
    /// A list of cost anomaly monitors that includes the detailed metadata for each monitor.
    /// This member is required.
    public var anomalyMonitors: [CostExplorerClientTypes.AnomalyMonitor]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init (
        anomalyMonitors: [CostExplorerClientTypes.AnomalyMonitor]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalyMonitors = anomalyMonitors
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalyMonitorsOutputResponseBody: Swift.Equatable {
    let anomalyMonitors: [CostExplorerClientTypes.AnomalyMonitor]?
    let nextPageToken: Swift.String?
}

extension GetAnomalyMonitorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyMonitors = "AnomalyMonitors"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyMonitorsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.AnomalyMonitor?].self, forKey: .anomalyMonitors)
        var anomalyMonitorsDecoded0:[CostExplorerClientTypes.AnomalyMonitor]? = nil
        if let anomalyMonitorsContainer = anomalyMonitorsContainer {
            anomalyMonitorsDecoded0 = [CostExplorerClientTypes.AnomalyMonitor]()
            for structure0 in anomalyMonitorsContainer {
                if let structure0 = structure0 {
                    anomalyMonitorsDecoded0?.append(structure0)
                }
            }
        }
        anomalyMonitors = anomalyMonitorsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetAnomalySubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case subscriptionArnList = "SubscriptionArnList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let subscriptionArnList = subscriptionArnList {
            var subscriptionArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionArnList)
            for values0 in subscriptionArnList {
                try subscriptionArnListContainer.encode(values0)
            }
        }
    }
}

extension GetAnomalySubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAnomalySubscriptionsInput: Swift.Equatable {
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// Cost anomaly monitor ARNs.
    public var monitorArn: Swift.String?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// A list of cost anomaly subscription ARNs.
    public var subscriptionArnList: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextPageToken: Swift.String? = nil,
        subscriptionArnList: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextPageToken = nextPageToken
        self.subscriptionArnList = subscriptionArnList
    }
}

struct GetAnomalySubscriptionsInputBody: Swift.Equatable {
    let subscriptionArnList: [Swift.String]?
    let monitorArn: Swift.String?
    let nextPageToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetAnomalySubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case subscriptionArnList = "SubscriptionArnList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subscriptionArnList)
        var subscriptionArnListDecoded0:[Swift.String]? = nil
        if let subscriptionArnListContainer = subscriptionArnListContainer {
            subscriptionArnListDecoded0 = [Swift.String]()
            for string0 in subscriptionArnListContainer {
                if let string0 = string0 {
                    subscriptionArnListDecoded0?.append(string0)
                }
            }
        }
        subscriptionArnList = subscriptionArnListDecoded0
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomalySubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomalySubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownSubscriptionException" : self = .unknownSubscriptionException(try UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnomalySubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknownSubscriptionException(UnknownSubscriptionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomalySubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAnomalySubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalySubscriptions = output.anomalySubscriptions
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalySubscriptions = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomalySubscriptionsOutputResponse: Swift.Equatable {
    /// A list of cost anomaly subscriptions that includes the detailed metadata for each one.
    /// This member is required.
    public var anomalySubscriptions: [CostExplorerClientTypes.AnomalySubscription]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init (
        anomalySubscriptions: [CostExplorerClientTypes.AnomalySubscription]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalySubscriptions = anomalySubscriptions
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalySubscriptionsOutputResponseBody: Swift.Equatable {
    let anomalySubscriptions: [CostExplorerClientTypes.AnomalySubscription]?
    let nextPageToken: Swift.String?
}

extension GetAnomalySubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalySubscriptions = "AnomalySubscriptions"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalySubscriptionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.AnomalySubscription?].self, forKey: .anomalySubscriptions)
        var anomalySubscriptionsDecoded0:[CostExplorerClientTypes.AnomalySubscription]? = nil
        if let anomalySubscriptionsContainer = anomalySubscriptionsContainer {
            anomalySubscriptionsDecoded0 = [CostExplorerClientTypes.AnomalySubscription]()
            for structure0 in anomalySubscriptionsContainer {
                if let structure0 = structure0 {
                    anomalySubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        anomalySubscriptions = anomalySubscriptionsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostAndUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricnames0 in metrics {
                try metricsContainer.encode(metricnames0)
            }
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetCostAndUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCostAndUsageInput: Swift.Equatable {
    /// Filters Amazon Web Services costs by different dimensions. For example, you can specify SERVICE and LINKED_ACCOUNT and get the costs that are associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html).
    public var filter: CostExplorerClientTypes.Expression?
    /// Sets the Amazon Web Services cost granularity to MONTHLY or DAILY, or HOURLY. If Granularity isn't set, the response object doesn't include the Granularity, either MONTHLY or DAILY, or HOURLY.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group Amazon Web Services costs using up to two different groups, either dimensions, tag keys, cost categories, or any two group by types. Valid values for the DIMENSION type are AZ, INSTANCE_TYPE, LEGAL_ENTITY_NAME, LINKED_ACCOUNT, OPERATION, PLATFORM, PURCHASE_TYPE, SERVICE, TENANCY, RECORD_TYPE, and USAGE_TYPE. When you group by the TAG type and include a valid tag key, you get all tag values, including empty strings.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// Which metrics are returned in the query. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity. If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours and GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups. Metrics is required for GetCostAndUsage requests.
    /// This member is required.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Sets the start date and end date for retrieving Amazon Web Services costs. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.timePeriod = timePeriod
    }
}

struct GetCostAndUsageInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let metrics: [Swift.String]?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let nextPageToken: Swift.String?
}

extension GetCostAndUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostAndUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostAndUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostAndUsageOutputError: Swift.Error, Swift.Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostAndUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCostAndUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dimensionValueAttributes = output.dimensionValueAttributes
            self.groupDefinitions = output.groupDefinitions
            self.nextPageToken = output.nextPageToken
            self.resultsByTime = output.resultsByTime
        } else {
            self.dimensionValueAttributes = nil
            self.groupDefinitions = nil
            self.nextPageToken = nil
            self.resultsByTime = nil
        }
    }
}

public struct GetCostAndUsageOutputResponse: Swift.Equatable {
    /// The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.
    public var dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The groups that are specified by the Filter or GroupBy parameters in the request.
    public var groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The time period that's covered by the results in the response.
    public var resultsByTime: [CostExplorerClientTypes.ResultByTime]?

    public init (
        dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        groupDefinitions: [CostExplorerClientTypes.GroupDefinition]? = nil,
        nextPageToken: Swift.String? = nil,
        resultsByTime: [CostExplorerClientTypes.ResultByTime]? = nil
    )
    {
        self.dimensionValueAttributes = dimensionValueAttributes
        self.groupDefinitions = groupDefinitions
        self.nextPageToken = nextPageToken
        self.resultsByTime = resultsByTime
    }
}

struct GetCostAndUsageOutputResponseBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    let resultsByTime: [CostExplorerClientTypes.ResultByTime]?
    let dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
}

extension GetCostAndUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValueAttributes = "DimensionValueAttributes"
        case groupDefinitions = "GroupDefinitions"
        case nextPageToken = "NextPageToken"
        case resultsByTime = "ResultsByTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let groupDefinitionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupDefinitions)
        var groupDefinitionsDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupDefinitionsContainer = groupDefinitionsContainer {
            groupDefinitionsDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupDefinitionsContainer {
                if let structure0 = structure0 {
                    groupDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        groupDefinitions = groupDefinitionsDecoded0
        let resultsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResultByTime?].self, forKey: .resultsByTime)
        var resultsByTimeDecoded0:[CostExplorerClientTypes.ResultByTime]? = nil
        if let resultsByTimeContainer = resultsByTimeContainer {
            resultsByTimeDecoded0 = [CostExplorerClientTypes.ResultByTime]()
            for structure0 in resultsByTimeContainer {
                if let structure0 = structure0 {
                    resultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        resultsByTime = resultsByTimeDecoded0
        let dimensionValueAttributesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.DimensionValuesWithAttributes?].self, forKey: .dimensionValueAttributes)
        var dimensionValueAttributesDecoded0:[CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil
        if let dimensionValueAttributesContainer = dimensionValueAttributesContainer {
            dimensionValueAttributesDecoded0 = [CostExplorerClientTypes.DimensionValuesWithAttributes]()
            for structure0 in dimensionValueAttributesContainer {
                if let structure0 = structure0 {
                    dimensionValueAttributesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueAttributes = dimensionValueAttributesDecoded0
    }
}

extension GetCostAndUsageWithResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricnames0 in metrics {
                try metricsContainer.encode(metricnames0)
            }
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetCostAndUsageWithResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCostAndUsageWithResourcesInput: Swift.Equatable {
    /// Filters Amazon Web Services costs by different dimensions. For example, you can specify SERVICE and LINKED_ACCOUNT and get the costs that are associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html). The GetCostAndUsageWithResources operation requires that you either group by or filter by a ResourceId. It requires the [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html)"SERVICE = Amazon Elastic Compute Cloud - Compute" in the filter.
    /// This member is required.
    public var filter: CostExplorerClientTypes.Expression?
    /// Sets the Amazon Web Services cost granularity to MONTHLY, DAILY, or HOURLY. If Granularity isn't set, the response object doesn't include the Granularity, MONTHLY, DAILY, or HOURLY.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group Amazon Web Services costs using up to two different groups: DIMENSION, TAG, COST_CATEGORY.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// Which metrics are returned in the query. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity. If you return the UsageQuantity metric, the service aggregates all usage numbers without taking the units into account. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours vs. GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups. Metrics is required for GetCostAndUsageWithResources requests.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.timePeriod = timePeriod
    }
}

struct GetCostAndUsageWithResourcesInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let metrics: [Swift.String]?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let nextPageToken: Swift.String?
}

extension GetCostAndUsageWithResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostAndUsageWithResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostAndUsageWithResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostAndUsageWithResourcesOutputError: Swift.Error, Swift.Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostAndUsageWithResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCostAndUsageWithResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dimensionValueAttributes = output.dimensionValueAttributes
            self.groupDefinitions = output.groupDefinitions
            self.nextPageToken = output.nextPageToken
            self.resultsByTime = output.resultsByTime
        } else {
            self.dimensionValueAttributes = nil
            self.groupDefinitions = nil
            self.nextPageToken = nil
            self.resultsByTime = nil
        }
    }
}

public struct GetCostAndUsageWithResourcesOutputResponse: Swift.Equatable {
    /// The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.
    public var dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The groups that are specified by the Filter or GroupBy parameters in the request.
    public var groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The time period that is covered by the results in the response.
    public var resultsByTime: [CostExplorerClientTypes.ResultByTime]?

    public init (
        dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        groupDefinitions: [CostExplorerClientTypes.GroupDefinition]? = nil,
        nextPageToken: Swift.String? = nil,
        resultsByTime: [CostExplorerClientTypes.ResultByTime]? = nil
    )
    {
        self.dimensionValueAttributes = dimensionValueAttributes
        self.groupDefinitions = groupDefinitions
        self.nextPageToken = nextPageToken
        self.resultsByTime = resultsByTime
    }
}

struct GetCostAndUsageWithResourcesOutputResponseBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    let resultsByTime: [CostExplorerClientTypes.ResultByTime]?
    let dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
}

extension GetCostAndUsageWithResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValueAttributes = "DimensionValueAttributes"
        case groupDefinitions = "GroupDefinitions"
        case nextPageToken = "NextPageToken"
        case resultsByTime = "ResultsByTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let groupDefinitionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupDefinitions)
        var groupDefinitionsDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupDefinitionsContainer = groupDefinitionsContainer {
            groupDefinitionsDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupDefinitionsContainer {
                if let structure0 = structure0 {
                    groupDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        groupDefinitions = groupDefinitionsDecoded0
        let resultsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResultByTime?].self, forKey: .resultsByTime)
        var resultsByTimeDecoded0:[CostExplorerClientTypes.ResultByTime]? = nil
        if let resultsByTimeContainer = resultsByTimeContainer {
            resultsByTimeDecoded0 = [CostExplorerClientTypes.ResultByTime]()
            for structure0 in resultsByTimeContainer {
                if let structure0 = structure0 {
                    resultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        resultsByTime = resultsByTimeDecoded0
        let dimensionValueAttributesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.DimensionValuesWithAttributes?].self, forKey: .dimensionValueAttributes)
        var dimensionValueAttributesDecoded0:[CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil
        if let dimensionValueAttributesContainer = dimensionValueAttributesContainer {
            dimensionValueAttributesDecoded0 = [CostExplorerClientTypes.DimensionValuesWithAttributes]()
            for structure0 in dimensionValueAttributesContainer {
                if let structure0 = structure0 {
                    dimensionValueAttributesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueAttributes = dimensionValueAttributesDecoded0
    }
}

extension GetCostCategoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryName = "CostCategoryName"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryName = costCategoryName {
            try encodeContainer.encode(costCategoryName, forKey: .costCategoryName)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinitions0 in sortBy {
                try sortByContainer.encode(sortdefinitions0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetCostCategoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCostCategoriesInput: Swift.Equatable {
    /// The unique name of the Cost Category.
    public var costCategoryName: Swift.String?
    /// Use Expression to filter by cost or by usage. There are two patterns:
    ///
    /// * Simple dimension values - You can set the dimension name and values for the filters that you plan to use. For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia). The Expression example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } } The list of dimension values are OR'd together to retrieve cost or usage data. You can create Expression and DimensionValues objects using either with* methods or set* methods in multiple lines.
    ///
    /// * Compound dimension values with logical operations - You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter on more advanced options. For example, you can filter on ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer). The Expression for that is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }  Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error.  { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when SortBy is provided in the request. The maximum number of objects that to be returned for this request. If MaxResults is not specified with SortBy, the request will return 1000 results as the default value for this parameter. For GetCostCategories, MaxResults has an upper limit of 1000.
    public var maxResults: Swift.Int
    /// If the number of objects that are still available for retrieval exceeds the limit, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the prior call in your next request.
    public var nextPageToken: Swift.String?
    /// The value that you want to search the filter values for. If you do not specify a CostCategoryName, SearchString will be used to filter Cost Category names that match the SearchString pattern. If you do specifiy a CostCategoryName, SearchString will be used to filter Cost Category values that match the SearchString pattern.
    public var searchString: Swift.String?
    /// The value by which you want to sort the data. The key represents cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING. When using SortBy, NextPageToken and SearchString are not supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The time period of the request.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        costCategoryName: Swift.String? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int = 0,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.costCategoryName = costCategoryName
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetCostCategoriesInputBody: Swift.Equatable {
    let searchString: Swift.String?
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let costCategoryName: Swift.String?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: [CostExplorerClientTypes.SortDefinition]?
    let maxResults: Swift.Int
    let nextPageToken: Swift.String?
}

extension GetCostCategoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryName = "CostCategoryName"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let costCategoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryName)
        costCategoryName = costCategoryNameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[CostExplorerClientTypes.SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [CostExplorerClientTypes.SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostCategoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostCategoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostCategoriesOutputError: Swift.Error, Swift.Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostCategoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCostCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryNames = output.costCategoryNames
            self.costCategoryValues = output.costCategoryValues
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.totalSize = output.totalSize
        } else {
            self.costCategoryNames = nil
            self.costCategoryValues = nil
            self.nextPageToken = nil
            self.returnSize = nil
            self.totalSize = nil
        }
    }
}

public struct GetCostCategoriesOutputResponse: Swift.Equatable {
    /// The names of the Cost Categories.
    public var costCategoryNames: [Swift.String]?
    /// The Cost Category values. CostCategoryValues are not returned if CostCategoryName is not specified in the request.
    public var costCategoryValues: [Swift.String]?
    /// If the number of objects that are still available for retrieval exceeds the limit, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.
    public var nextPageToken: Swift.String?
    /// The number of objects returned.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The total number of objects.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init (
        costCategoryNames: [Swift.String]? = nil,
        costCategoryValues: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.costCategoryNames = costCategoryNames
        self.costCategoryValues = costCategoryValues
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.totalSize = totalSize
    }
}

struct GetCostCategoriesOutputResponseBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let costCategoryNames: [Swift.String]?
    let costCategoryValues: [Swift.String]?
    let returnSize: Swift.Int?
    let totalSize: Swift.Int?
}

extension GetCostCategoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryNames = "CostCategoryNames"
        case costCategoryValues = "CostCategoryValues"
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case totalSize = "TotalSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let costCategoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .costCategoryNames)
        var costCategoryNamesDecoded0:[Swift.String]? = nil
        if let costCategoryNamesContainer = costCategoryNamesContainer {
            costCategoryNamesDecoded0 = [Swift.String]()
            for string0 in costCategoryNamesContainer {
                if let string0 = string0 {
                    costCategoryNamesDecoded0?.append(string0)
                }
            }
        }
        costCategoryNames = costCategoryNamesDecoded0
        let costCategoryValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .costCategoryValues)
        var costCategoryValuesDecoded0:[Swift.String]? = nil
        if let costCategoryValuesContainer = costCategoryValuesContainer {
            costCategoryValuesDecoded0 = [Swift.String]()
            for string0 in costCategoryValuesContainer {
                if let string0 = string0 {
                    costCategoryValuesDecoded0?.append(string0)
                }
            }
        }
        costCategoryValues = costCategoryValuesDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
    }
}

extension GetCostForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let metric = metric {
            try encodeContainer.encode(metric.rawValue, forKey: .metric)
        }
        if let predictionIntervalLevel = predictionIntervalLevel {
            try encodeContainer.encode(predictionIntervalLevel, forKey: .predictionIntervalLevel)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetCostForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCostForecastInput: Swift.Equatable {
    /// The filters that you want to use to filter your forecast. The GetCostForecast API supports filtering by the following dimensions:
    ///
    /// * AZ
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * LINKED_ACCOUNT_NAME
    ///
    /// * OPERATION
    ///
    /// * PURCHASE_TYPE
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * USAGE_TYPE
    ///
    /// * USAGE_TYPE_GROUP
    ///
    /// * RECORD_TYPE
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * TENANCY
    ///
    /// * SCOPE
    ///
    /// * PLATFORM
    ///
    /// * SUBSCRIPTION_ID
    ///
    /// * LEGAL_ENTITY_NAME
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * DATABASE_ENGINE
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    /// * BILLING_ENTITY
    ///
    /// * RESERVATION_ID
    ///
    /// * SAVINGS_PLAN_ARN
    public var filter: CostExplorerClientTypes.Expression?
    /// How granular you want the forecast to be. You can get 3 months of DAILY forecasts or 12 months of MONTHLY forecasts. The GetCostForecast operation supports only DAILY and MONTHLY granularities.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values for a GetCostForecast call are the following:
    ///
    /// * AMORTIZED_COST
    ///
    /// * BLENDED_COST
    ///
    /// * NET_AMORTIZED_COST
    ///
    /// * NET_UNBLENDED_COST
    ///
    /// * UNBLENDED_COST
    /// This member is required.
    public var metric: CostExplorerClientTypes.Metric?
    /// Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.
    public var predictionIntervalLevel: Swift.Int?
    /// The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        metric: CostExplorerClientTypes.Metric? = nil,
        predictionIntervalLevel: Swift.Int? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.metric = metric
        self.predictionIntervalLevel = predictionIntervalLevel
        self.timePeriod = timePeriod
    }
}

struct GetCostForecastInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let metric: CostExplorerClientTypes.Metric?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let predictionIntervalLevel: Swift.Int?
}

extension GetCostForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let metricDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let predictionIntervalLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .predictionIntervalLevel)
        predictionIntervalLevel = predictionIntervalLevelDecoded
    }
}

extension GetCostForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostForecastOutputError: Swift.Error, Swift.Equatable {
    case dataUnavailableException(DataUnavailableException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCostForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastResultsByTime = output.forecastResultsByTime
            self.total = output.total
        } else {
            self.forecastResultsByTime = nil
            self.total = nil
        }
    }
}

public struct GetCostForecastOutputResponse: Swift.Equatable {
    /// The forecasts for your query, in order. For DAILY forecasts, this is a list of days. For MONTHLY forecasts, this is a list of months.
    public var forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
    /// How much you are forecasted to spend over the forecast period, in USD.
    public var total: CostExplorerClientTypes.MetricValue?

    public init (
        forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]? = nil,
        total: CostExplorerClientTypes.MetricValue? = nil
    )
    {
        self.forecastResultsByTime = forecastResultsByTime
        self.total = total
    }
}

struct GetCostForecastOutputResponseBody: Swift.Equatable {
    let total: CostExplorerClientTypes.MetricValue?
    let forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
}

extension GetCostForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastResultsByTime = "ForecastResultsByTime"
        case total = "Total"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.MetricValue.self, forKey: .total)
        total = totalDecoded
        let forecastResultsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ForecastResult?].self, forKey: .forecastResultsByTime)
        var forecastResultsByTimeDecoded0:[CostExplorerClientTypes.ForecastResult]? = nil
        if let forecastResultsByTimeContainer = forecastResultsByTimeContainer {
            forecastResultsByTimeDecoded0 = [CostExplorerClientTypes.ForecastResult]()
            for structure0 in forecastResultsByTimeContainer {
                if let structure0 = structure0 {
                    forecastResultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        forecastResultsByTime = forecastResultsByTimeDecoded0
    }
}

extension GetDimensionValuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context = "Context"
        case dimension = "Dimension"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let context = context {
            try encodeContainer.encode(context.rawValue, forKey: .context)
        }
        if let dimension = dimension {
            try encodeContainer.encode(dimension.rawValue, forKey: .dimension)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinitions0 in sortBy {
                try sortByContainer.encode(sortdefinitions0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetDimensionValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDimensionValuesInput: Swift.Equatable {
    /// The context for the call to GetDimensionValues. This can be RESERVATIONS or COST_AND_USAGE. The default value is COST_AND_USAGE. If the context is set to RESERVATIONS, the resulting dimension values can be used in the GetReservationUtilization operation. If the context is set to COST_AND_USAGE, the resulting dimension values can be used in the GetCostAndUsage operation. If you set the context to COST_AND_USAGE, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.
    ///
    /// * OPERATION - The action performed. Examples include RunInstance and CreateBucket.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * PURCHASE_TYPE - The reservation type of the purchase to which this usage is related. Examples include On-Demand Instances and Standard Reserved Instances.
    ///
    /// * SERVICE - The Amazon Web Services service such as Amazon DynamoDB.
    ///
    /// * USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues operation includes a unit attribute. Examples include GB and Hrs.
    ///
    /// * USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * RECORD_TYPE - The different types of charges such as RI fees, usage costs, tax refunds, and credits.
    ///
    /// * RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.
    ///
    ///
    /// If you set the context to RESERVATIONS, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.
    ///
    /// * DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.
    ///
    /// * TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).
    ///
    /// * TENANCY - The tenancy of a resource. Examples are shared or dedicated.
    ///
    ///
    /// If you set the context to SAVINGS_PLANS, you can use the following dimensions for searching:
    ///
    /// * SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)
    ///
    /// * PAYMENT_OPTION - Payment option for the given Savings Plans (for example, All Upfront)
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * INSTANCE_TYPE_FAMILY - The family of instances (For example, m5)
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * SAVINGS_PLAN_ARN - The unique identifier for your Savings Plan
    public var context: CostExplorerClientTypes.Context?
    /// The name of the dimension. Each Dimension is available for a different Context. For more information, see Context.
    /// This member is required.
    public var dimension: CostExplorerClientTypes.Dimension?
    /// Use Expression to filter by cost or by usage. There are two patterns:
    ///
    /// * Simple dimension values - You can set the dimension name and values for the filters that you plan to use. For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia). The Expression example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } } The list of dimension values are OR'd together to retrieve cost or usage data. You can create Expression and DimensionValues objects using either with* methods or set* methods in multiple lines.
    ///
    /// * Compound dimension values with logical operations - You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter on more advanced options. For example, you can filter on ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer). The Expression for that is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }  Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error.  { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when SortBy is provided in the request. The maximum number of objects that to be returned for this request. If MaxResults is not specified with SortBy, the request will return 1000 results as the default value for this parameter. For GetDimensionValues, MaxResults has an upper limit of 1000.
    public var maxResults: Swift.Int
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value that you want to search the filter values for.
    public var searchString: Swift.String?
    /// The value by which you want to sort the data. The key represents cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING. When you specify a SortBy paramater, the context must be COST_AND_USAGE. Further, when using SortBy, NextPageToken and SearchString are not supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The start date and end date for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        context: CostExplorerClientTypes.Context? = nil,
        dimension: CostExplorerClientTypes.Dimension? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int = 0,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.context = context
        self.dimension = dimension
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetDimensionValuesInputBody: Swift.Equatable {
    let searchString: Swift.String?
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let dimension: CostExplorerClientTypes.Dimension?
    let context: CostExplorerClientTypes.Context?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: [CostExplorerClientTypes.SortDefinition]?
    let maxResults: Swift.Int
    let nextPageToken: Swift.String?
}

extension GetDimensionValuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context = "Context"
        case dimension = "Dimension"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Dimension.self, forKey: .dimension)
        dimension = dimensionDecoded
        let contextDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Context.self, forKey: .context)
        context = contextDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[CostExplorerClientTypes.SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [CostExplorerClientTypes.SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetDimensionValuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDimensionValuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDimensionValuesOutputError: Swift.Error, Swift.Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDimensionValuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDimensionValuesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dimensionValues = output.dimensionValues
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.totalSize = output.totalSize
        } else {
            self.dimensionValues = nil
            self.nextPageToken = nil
            self.returnSize = nil
            self.totalSize = nil
        }
    }
}

public struct GetDimensionValuesOutputResponse: Swift.Equatable {
    /// The filters that you used to filter your request. Some dimensions are available only for a specific context. If you set the context to COST_AND_USAGE, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.
    ///
    /// * OPERATION - The action performed. Examples include RunInstance and CreateBucket.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * PURCHASE_TYPE - The reservation type of the purchase to which this usage is related. Examples include On-Demand Instances and Standard Reserved Instances.
    ///
    /// * SERVICE - The Amazon Web Services service such as Amazon DynamoDB.
    ///
    /// * USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues operation includes a unit attribute. Examples include GB and Hrs.
    ///
    /// * USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.
    ///
    /// * RECORD_TYPE - The different types of charges such as RI fees, usage costs, tax refunds, and credits.
    ///
    /// * RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.
    ///
    ///
    /// If you set the context to RESERVATIONS, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.
    ///
    /// * DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.
    ///
    /// * TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).
    ///
    /// * TENANCY - The tenancy of a resource. Examples are shared or dedicated.
    ///
    ///
    /// If you set the context to SAVINGS_PLANS, you can use the following dimensions for searching:
    ///
    /// * SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)
    ///
    /// * PAYMENT_OPTION - Payment option for the given Savings Plans (for example, All Upfront)
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * INSTANCE_TYPE_FAMILY - The family of instances (For example, m5)
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * SAVINGS_PLAN_ARN - The unique identifier for your Savings Plan
    /// This member is required.
    public var dimensionValues: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of results that Amazon Web Services returned at one time.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The total number of search results.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init (
        dimensionValues: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.dimensionValues = dimensionValues
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.totalSize = totalSize
    }
}

struct GetDimensionValuesOutputResponseBody: Swift.Equatable {
    let dimensionValues: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    let returnSize: Swift.Int?
    let totalSize: Swift.Int?
    let nextPageToken: Swift.String?
}

extension GetDimensionValuesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValues = "DimensionValues"
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case totalSize = "TotalSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionValuesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.DimensionValuesWithAttributes?].self, forKey: .dimensionValues)
        var dimensionValuesDecoded0:[CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil
        if let dimensionValuesContainer = dimensionValuesContainer {
            dimensionValuesDecoded0 = [CostExplorerClientTypes.DimensionValuesWithAttributes]()
            for structure0 in dimensionValuesContainer {
                if let structure0 = structure0 {
                    dimensionValuesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValues = dimensionValuesDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetReservationCoverageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricnames0 in metrics {
                try metricsContainer.encode(metricnames0)
            }
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetReservationCoverageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// You can use the following request parameters to query for how much of your instance usage a reservation covered.
public struct GetReservationCoverageInput: Swift.Equatable {
    /// Filters utilization data by dimensions. You can filter by the following dimensions:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DATABASE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * TAG
    ///
    /// * TENANCY
    ///
    ///
    /// GetReservationCoverage uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension. You can nest only one level deep. If there are multiple values for a dimension, they are OR'd together. If you don't provide a SERVICE filter, Cost Explorer defaults to EC2. Cost category is also supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services cost data for the reservation. Valid values are MONTHLY and DAILY. If GroupBy is set, Granularity can't be set. If Granularity isn't set, the response object doesn't include Granularity, either MONTHLY or DAILY. The GetReservationCoverage operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group the data by the following attributes:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DATABASE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * TENANCY
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int
    /// The measurement that you want your reservation coverage reported in. Valid values are Hour, Unit, and Cost. You can use multiple values in a request.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value by which you want to sort the data. The following values are supported for Key:
    ///
    /// * OnDemandCost
    ///
    /// * CoverageHoursPercentage
    ///
    /// * OnDemandHours
    ///
    /// * ReservedHours
    ///
    /// * TotalRunningHours
    ///
    /// * CoverageNormalizedUnitsPercentage
    ///
    /// * OnDemandNormalizedUnits
    ///
    /// * ReservedNormalizedUnits
    ///
    /// * TotalRunningNormalizedUnits
    ///
    /// * Time
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int = 0,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetReservationCoverageInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let metrics: [Swift.String]?
    let nextPageToken: Swift.String?
    let sortBy: CostExplorerClientTypes.SortDefinition?
    let maxResults: Swift.Int
}

extension GetReservationCoverageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReservationCoverageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReservationCoverageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReservationCoverageOutputError: Swift.Error, Swift.Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReservationCoverageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReservationCoverageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.coveragesByTime = output.coveragesByTime
            self.nextPageToken = output.nextPageToken
            self.total = output.total
        } else {
            self.coveragesByTime = nil
            self.nextPageToken = nil
            self.total = nil
        }
    }
}

public struct GetReservationCoverageOutputResponse: Swift.Equatable {
    /// The amount of time that your reservations covered.
    /// This member is required.
    public var coveragesByTime: [CostExplorerClientTypes.CoverageByTime]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The total amount of instance usage that a reservation covered.
    public var total: CostExplorerClientTypes.Coverage?

    public init (
        coveragesByTime: [CostExplorerClientTypes.CoverageByTime]? = nil,
        nextPageToken: Swift.String? = nil,
        total: CostExplorerClientTypes.Coverage? = nil
    )
    {
        self.coveragesByTime = coveragesByTime
        self.nextPageToken = nextPageToken
        self.total = total
    }
}

struct GetReservationCoverageOutputResponseBody: Swift.Equatable {
    let coveragesByTime: [CostExplorerClientTypes.CoverageByTime]?
    let total: CostExplorerClientTypes.Coverage?
    let nextPageToken: Swift.String?
}

extension GetReservationCoverageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coveragesByTime = "CoveragesByTime"
        case nextPageToken = "NextPageToken"
        case total = "Total"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coveragesByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CoverageByTime?].self, forKey: .coveragesByTime)
        var coveragesByTimeDecoded0:[CostExplorerClientTypes.CoverageByTime]? = nil
        if let coveragesByTimeContainer = coveragesByTimeContainer {
            coveragesByTimeDecoded0 = [CostExplorerClientTypes.CoverageByTime]()
            for structure0 in coveragesByTimeContainer {
                if let structure0 = structure0 {
                    coveragesByTimeDecoded0?.append(structure0)
                }
            }
        }
        coveragesByTime = coveragesByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Coverage.self, forKey: .total)
        total = totalDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetReservationPurchaseRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case service = "Service"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountScope = accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let serviceSpecification = serviceSpecification {
            try encodeContainer.encode(serviceSpecification, forKey: .serviceSpecification)
        }
        if let termInYears = termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }
}

extension GetReservationPurchaseRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetReservationPurchaseRecommendationInput: Swift.Equatable {
    /// The account ID that is associated with the recommendation.
    public var accountId: Swift.String?
    /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
    public var accountScope: CostExplorerClientTypes.AccountScope?
    /// Use Expression to filter by cost or by usage. There are two patterns:
    ///
    /// * Simple dimension values - You can set the dimension name and values for the filters that you plan to use. For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia). The Expression example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } } The list of dimension values are OR'd together to retrieve cost or usage data. You can create Expression and DimensionValues objects using either with* methods or set* methods in multiple lines.
    ///
    /// * Compound dimension values with logical operations - You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter on more advanced options. For example, you can filter on ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer). The Expression for that is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }  Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error.  { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// The number of previous days that you want Amazon Web Services to consider when it calculates your recommendations.
    public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int
    /// The reservation purchase option that you want recommendations for.
    public var paymentOption: CostExplorerClientTypes.PaymentOption?
    /// The specific service that you want recommendations for.
    /// This member is required.
    public var service: Swift.String?
    /// The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.
    public var serviceSpecification: CostExplorerClientTypes.ServiceSpecification?
    /// The reservation term that you want recommendations for.
    public var termInYears: CostExplorerClientTypes.TermInYears?

    public init (
        accountId: Swift.String? = nil,
        accountScope: CostExplorerClientTypes.AccountScope? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
        service: Swift.String? = nil,
        serviceSpecification: CostExplorerClientTypes.ServiceSpecification? = nil,
        termInYears: CostExplorerClientTypes.TermInYears? = nil
    )
    {
        self.accountId = accountId
        self.accountScope = accountScope
        self.filter = filter
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.paymentOption = paymentOption
        self.service = service
        self.serviceSpecification = serviceSpecification
        self.termInYears = termInYears
    }
}

struct GetReservationPurchaseRecommendationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let service: Swift.String?
    let filter: CostExplorerClientTypes.Expression?
    let accountScope: CostExplorerClientTypes.AccountScope?
    let lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    let termInYears: CostExplorerClientTypes.TermInYears?
    let paymentOption: CostExplorerClientTypes.PaymentOption?
    let serviceSpecification: CostExplorerClientTypes.ServiceSpecification?
    let pageSize: Swift.Int
    let nextPageToken: Swift.String?
}

extension GetReservationPurchaseRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case service = "Service"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let serviceSpecificationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ServiceSpecification.self, forKey: .serviceSpecification)
        serviceSpecification = serviceSpecificationDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetReservationPurchaseRecommendationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReservationPurchaseRecommendationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReservationPurchaseRecommendationOutputError: Swift.Error, Swift.Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReservationPurchaseRecommendationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReservationPurchaseRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.recommendations = output.recommendations
        } else {
            self.metadata = nil
            self.nextPageToken = nil
            self.recommendations = nil
        }
    }
}

public struct GetReservationPurchaseRecommendationOutputResponse: Swift.Equatable {
    /// Information about this specific recommendation call, such as the time stamp for when Cost Explorer generated this recommendation.
    public var metadata: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata?
    /// The pagination token for the next set of retrievable results.
    public var nextPageToken: Swift.String?
    /// Recommendations for reservations to purchase.
    public var recommendations: [CostExplorerClientTypes.ReservationPurchaseRecommendation]?

    public init (
        metadata: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        recommendations: [CostExplorerClientTypes.ReservationPurchaseRecommendation]? = nil
    )
    {
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.recommendations = recommendations
    }
}

struct GetReservationPurchaseRecommendationOutputResponseBody: Swift.Equatable {
    let metadata: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata?
    let recommendations: [CostExplorerClientTypes.ReservationPurchaseRecommendation]?
    let nextPageToken: Swift.String?
}

extension GetReservationPurchaseRecommendationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case recommendations = "Recommendations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ReservationPurchaseRecommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[CostExplorerClientTypes.ReservationPurchaseRecommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [CostExplorerClientTypes.ReservationPurchaseRecommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetReservationUtilizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetReservationUtilizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetReservationUtilizationInput: Swift.Equatable {
    /// Filters utilization data by dimensions. You can filter by the following dimensions:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * SCOPE
    ///
    /// * TENANCY
    ///
    ///
    /// GetReservationUtilization uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.
    public var filter: CostExplorerClientTypes.Expression?
    /// If GroupBy is set, Granularity can't be set. If Granularity isn't set, the response object doesn't include Granularity, either MONTHLY or DAILY. If both GroupBy and Granularity aren't set, GetReservationUtilization defaults to DAILY. The GetReservationUtilization operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Groups only by SUBSCRIPTION_ID. Metadata is included.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value by which you want to sort the data. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * UtilizationPercentageInUnits
    ///
    /// * PurchasedHours
    ///
    /// * PurchasedUnits
    ///
    /// * TotalActualHours
    ///
    /// * TotalActualUnits
    ///
    /// * UnusedHours
    ///
    /// * UnusedUnits
    ///
    /// * OnDemandCostOfRIHoursUsed
    ///
    /// * NetRISavings
    ///
    /// * TotalPotentialRISavings
    ///
    /// * AmortizedUpfrontFee
    ///
    /// * AmortizedRecurringFee
    ///
    /// * TotalAmortizedFee
    ///
    /// * RICostForUnusedHours
    ///
    /// * RealizedSavings
    ///
    /// * UnrealizedSavings
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// Sets the start and end dates for retrieving RI utilization. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int = 0,
        nextPageToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetReservationUtilizationInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: CostExplorerClientTypes.SortDefinition?
    let nextPageToken: Swift.String?
    let maxResults: Swift.Int
}

extension GetReservationUtilizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReservationUtilizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReservationUtilizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReservationUtilizationOutputError: Swift.Error, Swift.Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReservationUtilizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReservationUtilizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.total = output.total
            self.utilizationsByTime = output.utilizationsByTime
        } else {
            self.nextPageToken = nil
            self.total = nil
            self.utilizationsByTime = nil
        }
    }
}

public struct GetReservationUtilizationOutputResponse: Swift.Equatable {
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The total amount of time that you used your RIs.
    public var total: CostExplorerClientTypes.ReservationAggregates?
    /// The amount of time that you used your RIs.
    /// This member is required.
    public var utilizationsByTime: [CostExplorerClientTypes.UtilizationByTime]?

    public init (
        nextPageToken: Swift.String? = nil,
        total: CostExplorerClientTypes.ReservationAggregates? = nil,
        utilizationsByTime: [CostExplorerClientTypes.UtilizationByTime]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.total = total
        self.utilizationsByTime = utilizationsByTime
    }
}

struct GetReservationUtilizationOutputResponseBody: Swift.Equatable {
    let utilizationsByTime: [CostExplorerClientTypes.UtilizationByTime]?
    let total: CostExplorerClientTypes.ReservationAggregates?
    let nextPageToken: Swift.String?
}

extension GetReservationUtilizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case total = "Total"
        case utilizationsByTime = "UtilizationsByTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.UtilizationByTime?].self, forKey: .utilizationsByTime)
        var utilizationsByTimeDecoded0:[CostExplorerClientTypes.UtilizationByTime]? = nil
        if let utilizationsByTimeContainer = utilizationsByTimeContainer {
            utilizationsByTimeDecoded0 = [CostExplorerClientTypes.UtilizationByTime]()
            for structure0 in utilizationsByTimeContainer {
                if let structure0 = structure0 {
                    utilizationsByTimeDecoded0?.append(structure0)
                }
            }
        }
        utilizationsByTime = utilizationsByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationAggregates.self, forKey: .total)
        total = totalDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetRightsizingRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case filter = "Filter"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case service = "Service"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }
}

extension GetRightsizingRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRightsizingRecommendationInput: Swift.Equatable {
    /// Enables you to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
    public var configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
    /// Use Expression to filter by cost or by usage. There are two patterns:
    ///
    /// * Simple dimension values - You can set the dimension name and values for the filters that you plan to use. For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia). The Expression example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } } The list of dimension values are OR'd together to retrieve cost or usage data. You can create Expression and DimensionValues objects using either with* methods or set* methods in multiple lines.
    ///
    /// * Compound dimension values with logical operations - You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter on more advanced options. For example, you can filter on ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer). The Expression for that is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }  Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error.  { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int
    /// The specific service that you want recommendations for. The only valid value for GetRightsizingRecommendation is "AmazonEC2".
    /// This member is required.
    public var service: Swift.String?

    public init (
        configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        service: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.filter = filter
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.service = service
    }
}

struct GetRightsizingRecommendationInputBody: Swift.Equatable {
    let filter: CostExplorerClientTypes.Expression?
    let configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
    let service: Swift.String?
    let pageSize: Swift.Int
    let nextPageToken: Swift.String?
}

extension GetRightsizingRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case filter = "Filter"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingRecommendationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetRightsizingRecommendationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRightsizingRecommendationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRightsizingRecommendationOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRightsizingRecommendationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRightsizingRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.rightsizingRecommendations = output.rightsizingRecommendations
            self.summary = output.summary
        } else {
            self.configuration = nil
            self.metadata = nil
            self.nextPageToken = nil
            self.rightsizingRecommendations = nil
            self.summary = nil
        }
    }
}

public struct GetRightsizingRecommendationOutputResponse: Swift.Equatable {
    /// Enables you to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
    public var configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
    /// Information regarding this specific recommendation set.
    public var metadata: CostExplorerClientTypes.RightsizingRecommendationMetadata?
    /// The token to retrieve the next set of results.
    public var nextPageToken: Swift.String?
    /// Recommendations to rightsize resources.
    public var rightsizingRecommendations: [CostExplorerClientTypes.RightsizingRecommendation]?
    /// Summary of this recommendation set.
    public var summary: CostExplorerClientTypes.RightsizingRecommendationSummary?

    public init (
        configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration? = nil,
        metadata: CostExplorerClientTypes.RightsizingRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        rightsizingRecommendations: [CostExplorerClientTypes.RightsizingRecommendation]? = nil,
        summary: CostExplorerClientTypes.RightsizingRecommendationSummary? = nil
    )
    {
        self.configuration = configuration
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.rightsizingRecommendations = rightsizingRecommendations
        self.summary = summary
    }
}

struct GetRightsizingRecommendationOutputResponseBody: Swift.Equatable {
    let metadata: CostExplorerClientTypes.RightsizingRecommendationMetadata?
    let summary: CostExplorerClientTypes.RightsizingRecommendationSummary?
    let rightsizingRecommendations: [CostExplorerClientTypes.RightsizingRecommendation]?
    let nextPageToken: Swift.String?
    let configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
}

extension GetRightsizingRecommendationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case rightsizingRecommendations = "RightsizingRecommendations"
        case summary = "Summary"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingRecommendationSummary.self, forKey: .summary)
        summary = summaryDecoded
        let rightsizingRecommendationsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.RightsizingRecommendation?].self, forKey: .rightsizingRecommendations)
        var rightsizingRecommendationsDecoded0:[CostExplorerClientTypes.RightsizingRecommendation]? = nil
        if let rightsizingRecommendationsContainer = rightsizingRecommendationsContainer {
            rightsizingRecommendationsDecoded0 = [CostExplorerClientTypes.RightsizingRecommendation]()
            for structure0 in rightsizingRecommendationsContainer {
                if let structure0 = structure0 {
                    rightsizingRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        rightsizingRecommendations = rightsizingRecommendationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingRecommendationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension GetSavingsPlansCoverageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricnames0 in metrics {
                try metricsContainer.encode(metricnames0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetSavingsPlansCoverageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlansCoverageInput: Swift.Equatable {
    /// Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * INSTANCE_FAMILY
    ///
    ///
    /// GetSavingsPlansCoverage uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension. If there are multiple values for a dimension, they are OR'd together. Cost category is also supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services cost data for your Savings Plans. Granularity can't be set if GroupBy is set. The GetSavingsPlansCoverage operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group the data using the attributes INSTANCE_FAMILY, REGION, or SERVICE.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The number of items to be returned in a response. The default is 20, with a minimum value of 1.
    public var maxResults: Swift.Int
    /// The measurement that you want your Savings Plans coverage reported in. The only valid value is SpendCoveredBySavingsPlans.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The value by which you want to sort the data. The following values are supported for Key:
    ///
    /// * SpendCoveredBySavingsPlan
    ///
    /// * OnDemandCost
    ///
    /// * CoveragePercentage
    ///
    /// * TotalCost
    ///
    /// * InstanceFamily
    ///
    /// * Region
    ///
    /// * Service
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int = 0,
        metrics: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansCoverageInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let metrics: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let sortBy: CostExplorerClientTypes.SortDefinition?
}

extension GetSavingsPlansCoverageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansCoverageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSavingsPlansCoverageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSavingsPlansCoverageOutputError: Swift.Error, Swift.Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSavingsPlansCoverageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSavingsPlansCoverageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.savingsPlansCoverages = output.savingsPlansCoverages
        } else {
            self.nextToken = nil
            self.savingsPlansCoverages = nil
        }
    }
}

public struct GetSavingsPlansCoverageOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The amount of spend that your Savings Plans covered.
    /// This member is required.
    public var savingsPlansCoverages: [CostExplorerClientTypes.SavingsPlansCoverage]?

    public init (
        nextToken: Swift.String? = nil,
        savingsPlansCoverages: [CostExplorerClientTypes.SavingsPlansCoverage]? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlansCoverages = savingsPlansCoverages
    }
}

struct GetSavingsPlansCoverageOutputResponseBody: Swift.Equatable {
    let savingsPlansCoverages: [CostExplorerClientTypes.SavingsPlansCoverage]?
    let nextToken: Swift.String?
}

extension GetSavingsPlansCoverageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case savingsPlansCoverages = "SavingsPlansCoverages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansCoveragesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansCoverage?].self, forKey: .savingsPlansCoverages)
        var savingsPlansCoveragesDecoded0:[CostExplorerClientTypes.SavingsPlansCoverage]? = nil
        if let savingsPlansCoveragesContainer = savingsPlansCoveragesContainer {
            savingsPlansCoveragesDecoded0 = [CostExplorerClientTypes.SavingsPlansCoverage]()
            for structure0 in savingsPlansCoveragesContainer {
                if let structure0 = structure0 {
                    savingsPlansCoveragesDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansCoverages = savingsPlansCoveragesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSavingsPlansPurchaseRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let savingsPlansType = savingsPlansType {
            try encodeContainer.encode(savingsPlansType.rawValue, forKey: .savingsPlansType)
        }
        if let termInYears = termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }
}

extension GetSavingsPlansPurchaseRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlansPurchaseRecommendationInput: Swift.Equatable {
    /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
    public var accountScope: CostExplorerClientTypes.AccountScope?
    /// You can filter your recommendations by Account ID with the LINKED_ACCOUNT dimension. To filter your recommendations by Account ID, specify Key as LINKED_ACCOUNT and Value as the comma-separated Acount ID(s) for which you want to see Savings Plans purchase recommendations. For GetSavingsPlansPurchaseRecommendation, the Filter does not include CostCategories or Tags. It only includes Dimensions. With Dimensions, Key must be LINKED_ACCOUNT and Value can be a single Account ID or multiple comma-separated Account IDs for which you want to see Savings Plans Purchase Recommendations. AND and OR operators are not supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The lookback period used to generate the recommendation.
    /// This member is required.
    public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int
    /// The payment option used to generate these recommendations.
    /// This member is required.
    public var paymentOption: CostExplorerClientTypes.PaymentOption?
    /// The Savings Plans recommendation type requested.
    /// This member is required.
    public var savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
    /// The savings plan recommendation term used to generate these recommendations.
    /// This member is required.
    public var termInYears: CostExplorerClientTypes.TermInYears?

    public init (
        accountScope: CostExplorerClientTypes.AccountScope? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
        savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType? = nil,
        termInYears: CostExplorerClientTypes.TermInYears? = nil
    )
    {
        self.accountScope = accountScope
        self.filter = filter
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.paymentOption = paymentOption
        self.savingsPlansType = savingsPlansType
        self.termInYears = termInYears
    }
}

struct GetSavingsPlansPurchaseRecommendationInputBody: Swift.Equatable {
    let savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
    let termInYears: CostExplorerClientTypes.TermInYears?
    let paymentOption: CostExplorerClientTypes.PaymentOption?
    let accountScope: CostExplorerClientTypes.AccountScope?
    let nextPageToken: Swift.String?
    let pageSize: Swift.Int
    let lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    let filter: CostExplorerClientTypes.Expression?
}

extension GetSavingsPlansPurchaseRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SupportedSavingsPlansType.self, forKey: .savingsPlansType)
        savingsPlansType = savingsPlansTypeDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension GetSavingsPlansPurchaseRecommendationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSavingsPlansPurchaseRecommendationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSavingsPlansPurchaseRecommendationOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSavingsPlansPurchaseRecommendationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSavingsPlansPurchaseRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.savingsPlansPurchaseRecommendation = output.savingsPlansPurchaseRecommendation
        } else {
            self.metadata = nil
            self.nextPageToken = nil
            self.savingsPlansPurchaseRecommendation = nil
        }
    }
}

public struct GetSavingsPlansPurchaseRecommendationOutputResponse: Swift.Equatable {
    /// Information regarding this specific recommendation set.
    public var metadata: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Contains your request parameters, Savings Plan Recommendations Summary, and Details.
    public var savingsPlansPurchaseRecommendation: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation?

    public init (
        metadata: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        savingsPlansPurchaseRecommendation: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation? = nil
    )
    {
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.savingsPlansPurchaseRecommendation = savingsPlansPurchaseRecommendation
    }
}

struct GetSavingsPlansPurchaseRecommendationOutputResponseBody: Swift.Equatable {
    let metadata: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata?
    let savingsPlansPurchaseRecommendation: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation?
    let nextPageToken: Swift.String?
}

extension GetSavingsPlansPurchaseRecommendationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case savingsPlansPurchaseRecommendation = "SavingsPlansPurchaseRecommendation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let savingsPlansPurchaseRecommendationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansPurchaseRecommendation.self, forKey: .savingsPlansPurchaseRecommendation)
        savingsPlansPurchaseRecommendation = savingsPlansPurchaseRecommendationDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetSavingsPlansUtilizationDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType = "DataType"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            var dataTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataType)
            for savingsplansdatatypes0 in dataType {
                try dataTypeContainer.encode(savingsplansdatatypes0.rawValue)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetSavingsPlansUtilizationDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlansUtilizationDetailsInput: Swift.Equatable {
    /// The data type.
    public var dataType: [CostExplorerClientTypes.SavingsPlansDataType]?
    /// Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * SAVINGS_PLAN_ARN
    ///
    /// * REGION
    ///
    /// * PAYMENT_OPTION
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    ///
    /// GetSavingsPlansUtilizationDetails uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension.
    public var filter: CostExplorerClientTypes.Expression?
    /// The number of items to be returned in a response. The default is 20, with a minimum value of 1.
    public var maxResults: Swift.Int
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The value by which you want to sort the data. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * TotalCommitment
    ///
    /// * UsedCommitment
    ///
    /// * UnusedCommitment
    ///
    /// * NetSavings
    ///
    /// * AmortizedRecurringCommitment
    ///
    /// * AmortizedUpfrontCommitment
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        dataType: [CostExplorerClientTypes.SavingsPlansDataType]? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.dataType = dataType
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansUtilizationDetailsInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let filter: CostExplorerClientTypes.Expression?
    let dataType: [CostExplorerClientTypes.SavingsPlansDataType]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
    let sortBy: CostExplorerClientTypes.SortDefinition?
}

extension GetSavingsPlansUtilizationDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType = "DataType"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let dataTypeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansDataType?].self, forKey: .dataType)
        var dataTypeDecoded0:[CostExplorerClientTypes.SavingsPlansDataType]? = nil
        if let dataTypeContainer = dataTypeContainer {
            dataTypeDecoded0 = [CostExplorerClientTypes.SavingsPlansDataType]()
            for string0 in dataTypeContainer {
                if let string0 = string0 {
                    dataTypeDecoded0?.append(string0)
                }
            }
        }
        dataType = dataTypeDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansUtilizationDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSavingsPlansUtilizationDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSavingsPlansUtilizationDetailsOutputError: Swift.Error, Swift.Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSavingsPlansUtilizationDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSavingsPlansUtilizationDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.savingsPlansUtilizationDetails = output.savingsPlansUtilizationDetails
            self.timePeriod = output.timePeriod
            self.total = output.total
        } else {
            self.nextToken = nil
            self.savingsPlansUtilizationDetails = nil
            self.timePeriod = nil
            self.total = nil
        }
    }
}

public struct GetSavingsPlansUtilizationDetailsOutputResponse: Swift.Equatable {
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// Retrieves a single daily or monthly Savings Plans utilization rate and details for your account.
    /// This member is required.
    public var savingsPlansUtilizationDetails: [CostExplorerClientTypes.SavingsPlansUtilizationDetail]?
    /// The time period of the request.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?
    /// The total Savings Plans utilization, regardless of time period.
    public var total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?

    public init (
        nextToken: Swift.String? = nil,
        savingsPlansUtilizationDetails: [CostExplorerClientTypes.SavingsPlansUtilizationDetail]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil,
        total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlansUtilizationDetails = savingsPlansUtilizationDetails
        self.timePeriod = timePeriod
        self.total = total
    }
}

struct GetSavingsPlansUtilizationDetailsOutputResponseBody: Swift.Equatable {
    let savingsPlansUtilizationDetails: [CostExplorerClientTypes.SavingsPlansUtilizationDetail]?
    let total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let nextToken: Swift.String?
}

extension GetSavingsPlansUtilizationDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case savingsPlansUtilizationDetails = "SavingsPlansUtilizationDetails"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansUtilizationDetailsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansUtilizationDetail?].self, forKey: .savingsPlansUtilizationDetails)
        var savingsPlansUtilizationDetailsDecoded0:[CostExplorerClientTypes.SavingsPlansUtilizationDetail]? = nil
        if let savingsPlansUtilizationDetailsContainer = savingsPlansUtilizationDetailsContainer {
            savingsPlansUtilizationDetailsDecoded0 = [CostExplorerClientTypes.SavingsPlansUtilizationDetail]()
            for structure0 in savingsPlansUtilizationDetailsContainer {
                if let structure0 = structure0 {
                    savingsPlansUtilizationDetailsDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansUtilizationDetails = savingsPlansUtilizationDetailsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilizationAggregates.self, forKey: .total)
        total = totalDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSavingsPlansUtilizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetSavingsPlansUtilizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlansUtilizationInput: Swift.Equatable {
    /// Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * SAVINGS_PLAN_ARN
    ///
    /// * SAVINGS_PLANS_TYPE
    ///
    /// * REGION
    ///
    /// * PAYMENT_OPTION
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    ///
    /// GetSavingsPlansUtilization uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services utillization data for your Savings Plans. The GetSavingsPlansUtilization operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// The value by which you want to sort the data. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * TotalCommitment
    ///
    /// * UsedCommitment
    ///
    /// * UnusedCommitment
    ///
    /// * NetSavings
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansUtilizationInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: CostExplorerClientTypes.SortDefinition?
}

extension GetSavingsPlansUtilizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansUtilizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSavingsPlansUtilizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSavingsPlansUtilizationOutputError: Swift.Error, Swift.Equatable {
    case dataUnavailableException(DataUnavailableException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSavingsPlansUtilizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSavingsPlansUtilizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.savingsPlansUtilizationsByTime = output.savingsPlansUtilizationsByTime
            self.total = output.total
        } else {
            self.savingsPlansUtilizationsByTime = nil
            self.total = nil
        }
    }
}

public struct GetSavingsPlansUtilizationOutputResponse: Swift.Equatable {
    /// The amount of cost/commitment you used your Savings Plans. This allows you to specify date ranges.
    public var savingsPlansUtilizationsByTime: [CostExplorerClientTypes.SavingsPlansUtilizationByTime]?
    /// The total amount of cost/commitment that you used your Savings Plans, regardless of date ranges.
    /// This member is required.
    public var total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?

    public init (
        savingsPlansUtilizationsByTime: [CostExplorerClientTypes.SavingsPlansUtilizationByTime]? = nil,
        total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates? = nil
    )
    {
        self.savingsPlansUtilizationsByTime = savingsPlansUtilizationsByTime
        self.total = total
    }
}

struct GetSavingsPlansUtilizationOutputResponseBody: Swift.Equatable {
    let savingsPlansUtilizationsByTime: [CostExplorerClientTypes.SavingsPlansUtilizationByTime]?
    let total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?
}

extension GetSavingsPlansUtilizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case savingsPlansUtilizationsByTime = "SavingsPlansUtilizationsByTime"
        case total = "Total"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansUtilizationsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansUtilizationByTime?].self, forKey: .savingsPlansUtilizationsByTime)
        var savingsPlansUtilizationsByTimeDecoded0:[CostExplorerClientTypes.SavingsPlansUtilizationByTime]? = nil
        if let savingsPlansUtilizationsByTimeContainer = savingsPlansUtilizationsByTimeContainer {
            savingsPlansUtilizationsByTimeDecoded0 = [CostExplorerClientTypes.SavingsPlansUtilizationByTime]()
            for structure0 in savingsPlansUtilizationsByTimeContainer {
                if let structure0 = structure0 {
                    savingsPlansUtilizationsByTimeDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansUtilizationsByTime = savingsPlansUtilizationsByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilizationAggregates.self, forKey: .total)
        total = totalDecoded
    }
}

extension GetTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case tagKey = "TagKey"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinitions0 in sortBy {
                try sortByContainer.encode(sortdefinitions0)
            }
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTagsInput: Swift.Equatable {
    /// Use Expression to filter by cost or by usage. There are two patterns:
    ///
    /// * Simple dimension values - You can set the dimension name and values for the filters that you plan to use. For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia). The Expression example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", “us-west-1” ] } } The list of dimension values are OR'd together to retrieve cost or usage data. You can create Expression and DimensionValues objects using either with* methods or set* methods in multiple lines.
    ///
    /// * Compound dimension values with logical operations - You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter on more advanced options. For example, you can filter on ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer). The Expression for that is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }  Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error.  { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when SortBy is provided in the request. The maximum number of objects that to be returned for this request. If MaxResults is not specified with SortBy, the request will return 1000 results as the default value for this parameter. For GetTags, MaxResults has an upper limit of 1000.
    public var maxResults: Swift.Int
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value that you want to search for.
    public var searchString: Swift.String?
    /// The value by which you want to sort the data. The key represents cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING. When using SortBy, NextPageToken and SearchString are not supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The key of the tag that you want to return values for.
    public var tagKey: Swift.String?
    /// The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int = 0,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        tagKey: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.tagKey = tagKey
        self.timePeriod = timePeriod
    }
}

struct GetTagsInputBody: Swift.Equatable {
    let searchString: Swift.String?
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let tagKey: Swift.String?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: [CostExplorerClientTypes.SortDefinition]?
    let maxResults: Swift.Int
    let nextPageToken: Swift.String?
}

extension GetTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case tagKey = "TagKey"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[CostExplorerClientTypes.SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [CostExplorerClientTypes.SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagsOutputError: Swift.Error, Swift.Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.tags = output.tags
            self.totalSize = output.totalSize
        } else {
            self.nextPageToken = nil
            self.returnSize = nil
            self.tags = nil
            self.totalSize = nil
        }
    }
}

public struct GetTagsOutputResponse: Swift.Equatable {
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of query results that Amazon Web Services returns at a time.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The tags that match your request.
    /// This member is required.
    public var tags: [Swift.String]?
    /// The total number of query results.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init (
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        tags: [Swift.String]? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.tags = tags
        self.totalSize = totalSize
    }
}

struct GetTagsOutputResponseBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let tags: [Swift.String]?
    let returnSize: Swift.Int?
    let totalSize: Swift.Int?
}

extension GetTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case tags = "Tags"
        case totalSize = "TotalSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tags)
        var tagsDecoded0:[Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
    }
}

extension GetUsageForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let metric = metric {
            try encodeContainer.encode(metric.rawValue, forKey: .metric)
        }
        if let predictionIntervalLevel = predictionIntervalLevel {
            try encodeContainer.encode(predictionIntervalLevel, forKey: .predictionIntervalLevel)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetUsageForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUsageForecastInput: Swift.Equatable {
    /// The filters that you want to use to filter your forecast. The GetUsageForecast API supports filtering by the following dimensions:
    ///
    /// * AZ
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * LINKED_ACCOUNT_NAME
    ///
    /// * OPERATION
    ///
    /// * PURCHASE_TYPE
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * USAGE_TYPE
    ///
    /// * USAGE_TYPE_GROUP
    ///
    /// * RECORD_TYPE
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * TENANCY
    ///
    /// * SCOPE
    ///
    /// * PLATFORM
    ///
    /// * SUBSCRIPTION_ID
    ///
    /// * LEGAL_ENTITY_NAME
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * DATABASE_ENGINE
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    /// * BILLING_ENTITY
    ///
    /// * RESERVATION_ID
    ///
    /// * SAVINGS_PLAN_ARN
    public var filter: CostExplorerClientTypes.Expression?
    /// How granular you want the forecast to be. You can get 3 months of DAILY forecasts or 12 months of MONTHLY forecasts. The GetUsageForecast operation supports only DAILY and MONTHLY granularities.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Which metric Cost Explorer uses to create your forecast. Valid values for a GetUsageForecast call are the following:
    ///
    /// * USAGE_QUANTITY
    ///
    /// * NORMALIZED_USAGE_AMOUNT
    /// This member is required.
    public var metric: CostExplorerClientTypes.Metric?
    /// Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.
    public var predictionIntervalLevel: Swift.Int?
    /// The start and end dates of the period that you want to retrieve usage forecast for. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01. The start date must be equal to or later than the current date to avoid a validation error.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init (
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        metric: CostExplorerClientTypes.Metric? = nil,
        predictionIntervalLevel: Swift.Int? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.metric = metric
        self.predictionIntervalLevel = predictionIntervalLevel
        self.timePeriod = timePeriod
    }
}

struct GetUsageForecastInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let metric: CostExplorerClientTypes.Metric?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let predictionIntervalLevel: Swift.Int?
}

extension GetUsageForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let metricDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let predictionIntervalLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .predictionIntervalLevel)
        predictionIntervalLevel = predictionIntervalLevelDecoded
    }
}

extension GetUsageForecastOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageForecastOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnresolvableUsageUnitException" : self = .unresolvableUsageUnitException(try UnresolvableUsageUnitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsageForecastOutputError: Swift.Error, Swift.Equatable {
    case dataUnavailableException(DataUnavailableException)
    case limitExceededException(LimitExceededException)
    case unresolvableUsageUnitException(UnresolvableUsageUnitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageForecastOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUsageForecastOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.forecastResultsByTime = output.forecastResultsByTime
            self.total = output.total
        } else {
            self.forecastResultsByTime = nil
            self.total = nil
        }
    }
}

public struct GetUsageForecastOutputResponse: Swift.Equatable {
    /// The forecasts for your query, in order. For DAILY forecasts, this is a list of days. For MONTHLY forecasts, this is a list of months.
    public var forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
    /// How much you're forecasted to use over the forecast period.
    public var total: CostExplorerClientTypes.MetricValue?

    public init (
        forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]? = nil,
        total: CostExplorerClientTypes.MetricValue? = nil
    )
    {
        self.forecastResultsByTime = forecastResultsByTime
        self.total = total
    }
}

struct GetUsageForecastOutputResponseBody: Swift.Equatable {
    let total: CostExplorerClientTypes.MetricValue?
    let forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
}

extension GetUsageForecastOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastResultsByTime = "ForecastResultsByTime"
        case total = "Total"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.MetricValue.self, forKey: .total)
        total = totalDecoded
        let forecastResultsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ForecastResult?].self, forKey: .forecastResultsByTime)
        var forecastResultsByTimeDecoded0:[CostExplorerClientTypes.ForecastResult]? = nil
        if let forecastResultsByTimeContainer = forecastResultsByTimeContainer {
            forecastResultsByTimeDecoded0 = [CostExplorerClientTypes.ForecastResult]()
            for structure0 in forecastResultsByTimeContainer {
                if let structure0 = structure0 {
                    forecastResultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        forecastResultsByTime = forecastResultsByTimeDecoded0
    }
}

extension CostExplorerClientTypes {
    public enum Granularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [Granularity] {
            return [
                .daily,
                .hourly,
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Granularity(rawValue: rawValue) ?? Granularity.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keys = "Keys"
        case metrics = "Metrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for keys0 in keys {
                try keysContainer.encode(keys0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metrics)
            for (dictKey0, metrics0) in metrics {
                try metricsContainer.encode(metrics0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keys)
        var keysDecoded0:[Swift.String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String: CostExplorerClientTypes.MetricValue?].self, forKey: .metrics)
        var metricsDecoded0: [Swift.String:CostExplorerClientTypes.MetricValue]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String:CostExplorerClientTypes.MetricValue]()
            for (key0, metricvalue0) in metricsContainer {
                if let metricvalue0 = metricvalue0 {
                    metricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension CostExplorerClientTypes {
    /// One level of grouped data in the results.
    public struct Group: Swift.Equatable {
        /// The keys that are included in this group.
        public var keys: [Swift.String]?
        /// The metrics that are included in this group.
        public var metrics: [Swift.String:CostExplorerClientTypes.MetricValue]?

        public init (
            keys: [Swift.String]? = nil,
            metrics: [Swift.String:CostExplorerClientTypes.MetricValue]? = nil
        )
        {
            self.keys = keys
            self.metrics = metrics
        }
    }

}

extension CostExplorerClientTypes.GroupDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.GroupDefinitionType.self, forKey: .type)
        type = typeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension CostExplorerClientTypes {
    /// Represents a group when you specify a group by criteria or in the response to a query with a specific grouping.
    public struct GroupDefinition: Swift.Equatable {
        /// The string that represents a key for a specified group.
        public var key: Swift.String?
        /// The string that represents the type of group.
        public var type: CostExplorerClientTypes.GroupDefinitionType?

        public init (
            key: Swift.String? = nil,
            type: CostExplorerClientTypes.GroupDefinitionType? = nil
        )
        {
            self.key = key
            self.type = type
        }
    }

}

extension CostExplorerClientTypes {
    public enum GroupDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costCategory
        case dimension
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupDefinitionType] {
            return [
                .costCategory,
                .dimension,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costCategory: return "COST_CATEGORY"
            case .dimension: return "DIMENSION"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupDefinitionType(rawValue: rawValue) ?? GroupDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.Impact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxImpact = "MaxImpact"
        case totalImpact = "TotalImpact"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxImpact != 0.0 {
            try encodeContainer.encode(maxImpact, forKey: .maxImpact)
        }
        if totalImpact != 0.0 {
            try encodeContainer.encode(totalImpact, forKey: .totalImpact)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxImpactDecoded = try containerValues.decode(Swift.Double.self, forKey: .maxImpact)
        maxImpact = maxImpactDecoded
        let totalImpactDecoded = try containerValues.decode(Swift.Double.self, forKey: .totalImpact)
        totalImpact = totalImpactDecoded
    }
}

extension CostExplorerClientTypes {
    /// The dollar value of the anomaly.
    public struct Impact: Swift.Equatable {
        /// The maximum dollar value that's observed for an anomaly.
        /// This member is required.
        public var maxImpact: Swift.Double
        /// The cumulative dollar value that's observed for an anomaly.
        public var totalImpact: Swift.Double

        public init (
            maxImpact: Swift.Double = 0.0,
            totalImpact: Swift.Double = 0.0
        )
        {
            self.maxImpact = maxImpact
            self.totalImpact = totalImpact
        }
    }

}

extension CostExplorerClientTypes.InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2InstanceDetails = "EC2InstanceDetails"
        case eSInstanceDetails = "ESInstanceDetails"
        case elastiCacheInstanceDetails = "ElastiCacheInstanceDetails"
        case rDSInstanceDetails = "RDSInstanceDetails"
        case redshiftInstanceDetails = "RedshiftInstanceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2InstanceDetails = eC2InstanceDetails {
            try encodeContainer.encode(eC2InstanceDetails, forKey: .eC2InstanceDetails)
        }
        if let eSInstanceDetails = eSInstanceDetails {
            try encodeContainer.encode(eSInstanceDetails, forKey: .eSInstanceDetails)
        }
        if let elastiCacheInstanceDetails = elastiCacheInstanceDetails {
            try encodeContainer.encode(elastiCacheInstanceDetails, forKey: .elastiCacheInstanceDetails)
        }
        if let rDSInstanceDetails = rDSInstanceDetails {
            try encodeContainer.encode(rDSInstanceDetails, forKey: .rDSInstanceDetails)
        }
        if let redshiftInstanceDetails = redshiftInstanceDetails {
            try encodeContainer.encode(redshiftInstanceDetails, forKey: .redshiftInstanceDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eC2InstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EC2InstanceDetails.self, forKey: .eC2InstanceDetails)
        eC2InstanceDetails = eC2InstanceDetailsDecoded
        let rDSInstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RDSInstanceDetails.self, forKey: .rDSInstanceDetails)
        rDSInstanceDetails = rDSInstanceDetailsDecoded
        let redshiftInstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RedshiftInstanceDetails.self, forKey: .redshiftInstanceDetails)
        redshiftInstanceDetails = redshiftInstanceDetailsDecoded
        let elastiCacheInstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ElastiCacheInstanceDetails.self, forKey: .elastiCacheInstanceDetails)
        elastiCacheInstanceDetails = elastiCacheInstanceDetailsDecoded
        let eSInstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ESInstanceDetails.self, forKey: .eSInstanceDetails)
        eSInstanceDetails = eSInstanceDetailsDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the instances that Amazon Web Services recommends that you purchase.
    public struct InstanceDetails: Swift.Equatable {
        /// The Amazon EC2 instances that Amazon Web Services recommends that you purchase.
        public var eC2InstanceDetails: CostExplorerClientTypes.EC2InstanceDetails?
        /// The Amazon ES instances that Amazon Web Services recommends that you purchase.
        public var eSInstanceDetails: CostExplorerClientTypes.ESInstanceDetails?
        /// The ElastiCache instances that Amazon Web Services recommends that you purchase.
        public var elastiCacheInstanceDetails: CostExplorerClientTypes.ElastiCacheInstanceDetails?
        /// The Amazon RDS instances that Amazon Web Services recommends that you purchase.
        public var rDSInstanceDetails: CostExplorerClientTypes.RDSInstanceDetails?
        /// The Amazon Redshift instances that Amazon Web Services recommends that you purchase.
        public var redshiftInstanceDetails: CostExplorerClientTypes.RedshiftInstanceDetails?

        public init (
            eC2InstanceDetails: CostExplorerClientTypes.EC2InstanceDetails? = nil,
            eSInstanceDetails: CostExplorerClientTypes.ESInstanceDetails? = nil,
            elastiCacheInstanceDetails: CostExplorerClientTypes.ElastiCacheInstanceDetails? = nil,
            rDSInstanceDetails: CostExplorerClientTypes.RDSInstanceDetails? = nil,
            redshiftInstanceDetails: CostExplorerClientTypes.RedshiftInstanceDetails? = nil
        )
        {
            self.eC2InstanceDetails = eC2InstanceDetails
            self.eSInstanceDetails = eSInstanceDetails
            self.elastiCacheInstanceDetails = elastiCacheInstanceDetails
            self.rDSInstanceDetails = rDSInstanceDetails
            self.redshiftInstanceDetails = redshiftInstanceDetails
        }
    }

}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pagination token is invalid. Try again without a pagination token.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You made too many calls in a short period of time. Try again later.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCostCategoryDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveOn = "EffectiveOn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveOn = effectiveOn {
            try encodeContainer.encode(effectiveOn, forKey: .effectiveOn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCostCategoryDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCostCategoryDefinitionsInput: Swift.Equatable {
    /// The date when the Cost Category was effective.
    public var effectiveOn: Swift.String?
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init (
        effectiveOn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.effectiveOn = effectiveOn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCostCategoryDefinitionsInputBody: Swift.Equatable {
    let effectiveOn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListCostCategoryDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveOn = "EffectiveOn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectiveOnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCostCategoryDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCostCategoryDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCostCategoryDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCostCategoryDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCostCategoryDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryReferences = output.costCategoryReferences
            self.nextToken = output.nextToken
        } else {
            self.costCategoryReferences = nil
            self.nextToken = nil
        }
    }
}

public struct ListCostCategoryDefinitionsOutputResponse: Swift.Equatable {
    /// A reference to a Cost Category containing enough information to identify the Cost Category.
    public var costCategoryReferences: [CostExplorerClientTypes.CostCategoryReference]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init (
        costCategoryReferences: [CostExplorerClientTypes.CostCategoryReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.costCategoryReferences = costCategoryReferences
        self.nextToken = nextToken
    }
}

struct ListCostCategoryDefinitionsOutputResponseBody: Swift.Equatable {
    let costCategoryReferences: [CostExplorerClientTypes.CostCategoryReference]?
    let nextToken: Swift.String?
}

extension ListCostCategoryDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryReferences = "CostCategoryReferences"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryReferencesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryReference?].self, forKey: .costCategoryReferences)
        var costCategoryReferencesDecoded0:[CostExplorerClientTypes.CostCategoryReference]? = nil
        if let costCategoryReferencesContainer = costCategoryReferencesContainer {
            costCategoryReferencesDecoded0 = [CostExplorerClientTypes.CostCategoryReference]()
            for structure0 in costCategoryReferencesContainer {
                if let structure0 = structure0 {
                    costCategoryReferencesDecoded0?.append(structure0)
                }
            }
        }
        costCategoryReferences = costCategoryReferencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CostExplorerClientTypes {
    public enum LookbackPeriodInDays: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sevenDays
        case sixtyDays
        case thirtyDays
        case sdkUnknown(Swift.String)

        public static var allCases: [LookbackPeriodInDays] {
            return [
                .sevenDays,
                .sixtyDays,
                .thirtyDays,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sevenDays: return "SEVEN_DAYS"
            case .sixtyDays: return "SIXTY_DAYS"
            case .thirtyDays: return "THIRTY_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LookbackPeriodInDays(rawValue: rawValue) ?? LookbackPeriodInDays.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum MatchOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case absent
        case caseInsensitive
        case caseSensitive
        case contains
        case endsWith
        case equals
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .absent,
                .caseInsensitive,
                .caseSensitive,
                .contains,
                .endsWith,
                .equals,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .absent: return "ABSENT"
            case .caseInsensitive: return "CASE_INSENSITIVE"
            case .caseSensitive: return "CASE_SENSITIVE"
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MatchOption(rawValue: rawValue) ?? MatchOption.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum Metric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amortizedCost
        case blendedCost
        case netAmortizedCost
        case netUnblendedCost
        case normalizedUsageAmount
        case unblendedCost
        case usageQuantity
        case sdkUnknown(Swift.String)

        public static var allCases: [Metric] {
            return [
                .amortizedCost,
                .blendedCost,
                .netAmortizedCost,
                .netUnblendedCost,
                .normalizedUsageAmount,
                .unblendedCost,
                .usageQuantity,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amortizedCost: return "AMORTIZED_COST"
            case .blendedCost: return "BLENDED_COST"
            case .netAmortizedCost: return "NET_AMORTIZED_COST"
            case .netUnblendedCost: return "NET_UNBLENDED_COST"
            case .normalizedUsageAmount: return "NORMALIZED_USAGE_AMOUNT"
            case .unblendedCost: return "UNBLENDED_COST"
            case .usageQuantity: return "USAGE_QUANTITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Metric(rawValue: rawValue) ?? Metric.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.MetricValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension CostExplorerClientTypes {
    /// The aggregated value for a metric.
    public struct MetricValue: Swift.Equatable {
        /// The actual number that represents the metric.
        public var amount: Swift.String?
        /// The unit that the metric is given in.
        public var unit: Swift.String?

        public init (
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension CostExplorerClientTypes.ModifyRecommendationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetInstances = "TargetInstances"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetInstances = targetInstances {
            var targetInstancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetInstances)
            for targetinstanceslist0 in targetInstances {
                try targetInstancesContainer.encode(targetinstanceslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetInstancesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.TargetInstance?].self, forKey: .targetInstances)
        var targetInstancesDecoded0:[CostExplorerClientTypes.TargetInstance]? = nil
        if let targetInstancesContainer = targetInstancesContainer {
            targetInstancesDecoded0 = [CostExplorerClientTypes.TargetInstance]()
            for structure0 in targetInstancesContainer {
                if let structure0 = structure0 {
                    targetInstancesDecoded0?.append(structure0)
                }
            }
        }
        targetInstances = targetInstancesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// Details on the modification recommendation.
    public struct ModifyRecommendationDetail: Swift.Equatable {
        /// Determines whether this instance type is the Amazon Web Services default recommendation.
        public var targetInstances: [CostExplorerClientTypes.TargetInstance]?

        public init (
            targetInstances: [CostExplorerClientTypes.TargetInstance]? = nil
        )
        {
            self.targetInstances = targetInstances
        }
    }

}

extension CostExplorerClientTypes {
    public enum MonitorDimension: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorDimension] {
            return [
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorDimension(rawValue: rawValue) ?? MonitorDimension.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum MonitorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case dimensional
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorType] {
            return [
                .custom,
                .dimensional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .dimensional: return "DIMENSIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorType(rawValue: rawValue) ?? MonitorType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.NetworkResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInBytesPerSecond = "NetworkInBytesPerSecond"
        case networkOutBytesPerSecond = "NetworkOutBytesPerSecond"
        case networkPacketsInPerSecond = "NetworkPacketsInPerSecond"
        case networkPacketsOutPerSecond = "NetworkPacketsOutPerSecond"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInBytesPerSecond = networkInBytesPerSecond {
            try encodeContainer.encode(networkInBytesPerSecond, forKey: .networkInBytesPerSecond)
        }
        if let networkOutBytesPerSecond = networkOutBytesPerSecond {
            try encodeContainer.encode(networkOutBytesPerSecond, forKey: .networkOutBytesPerSecond)
        }
        if let networkPacketsInPerSecond = networkPacketsInPerSecond {
            try encodeContainer.encode(networkPacketsInPerSecond, forKey: .networkPacketsInPerSecond)
        }
        if let networkPacketsOutPerSecond = networkPacketsOutPerSecond {
            try encodeContainer.encode(networkPacketsOutPerSecond, forKey: .networkPacketsOutPerSecond)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInBytesPerSecond)
        networkInBytesPerSecond = networkInBytesPerSecondDecoded
        let networkOutBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkOutBytesPerSecond)
        networkOutBytesPerSecond = networkOutBytesPerSecondDecoded
        let networkPacketsInPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkPacketsInPerSecond)
        networkPacketsInPerSecond = networkPacketsInPerSecondDecoded
        let networkPacketsOutPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkPacketsOutPerSecond)
        networkPacketsOutPerSecond = networkPacketsOutPerSecondDecoded
    }
}

extension CostExplorerClientTypes {
    /// The network field that contains a list of network metrics that are associated with the current instance.
    public struct NetworkResourceUtilization: Swift.Equatable {
        /// The network inbound throughput utilization measured in Bytes per second.
        public var networkInBytesPerSecond: Swift.String?
        /// The network outbound throughput utilization measured in Bytes per second.
        public var networkOutBytesPerSecond: Swift.String?
        /// The network ingress packets that are measured in packets per second.
        public var networkPacketsInPerSecond: Swift.String?
        /// The network outgress packets that are measured in packets per second.
        public var networkPacketsOutPerSecond: Swift.String?

        public init (
            networkInBytesPerSecond: Swift.String? = nil,
            networkOutBytesPerSecond: Swift.String? = nil,
            networkPacketsInPerSecond: Swift.String? = nil,
            networkPacketsOutPerSecond: Swift.String? = nil
        )
        {
            self.networkInBytesPerSecond = networkInBytesPerSecond
            self.networkOutBytesPerSecond = networkOutBytesPerSecond
            self.networkPacketsInPerSecond = networkPacketsInPerSecond
            self.networkPacketsOutPerSecond = networkPacketsOutPerSecond
        }
    }

}

extension CostExplorerClientTypes {
    public enum NumericOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case equal
        case greaterThan
        case greaterThanOrEqual
        case lessThan
        case lessThanOrEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericOperator] {
            return [
                .between,
                .equal,
                .greaterThan,
                .greaterThanOrEqual,
                .lessThan,
                .lessThanOrEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumericOperator(rawValue: rawValue) ?? NumericOperator.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum OfferingClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case convertible
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingClass] {
            return [
                .convertible,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .convertible: return "CONVERTIBLE"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferingClass(rawValue: rawValue) ?? OfferingClass.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum PaymentOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allUpfront
        case heavyUtilization
        case lightUtilization
        case mediumUtilization
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentOption] {
            return [
                .allUpfront,
                .heavyUtilization,
                .lightUtilization,
                .mediumUtilization,
                .noUpfront,
                .partialUpfront,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .heavyUtilization: return "HEAVY_UTILIZATION"
            case .lightUtilization: return "LIGHT_UTILIZATION"
            case .mediumUtilization: return "MEDIUM_UTILIZATION"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaymentOption(rawValue: rawValue) ?? PaymentOption.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum PlatformDifference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hypervisor
        case instanceStoreAvailability
        case networkInterface
        case storageInterface
        case virtualizationType
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformDifference] {
            return [
                .hypervisor,
                .instanceStoreAvailability,
                .networkInterface,
                .storageInterface,
                .virtualizationType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hypervisor: return "HYPERVISOR"
            case .instanceStoreAvailability: return "INSTANCE_STORE_AVAILABILITY"
            case .networkInterface: return "NETWORK_INTERFACE"
            case .storageInterface: return "STORAGE_INTERFACE"
            case .virtualizationType: return "VIRTUALIZATION_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlatformDifference(rawValue: rawValue) ?? PlatformDifference.sdkUnknown(rawValue)
        }
    }
}

extension ProvideAnomalyFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyId = "AnomalyId"
        case feedback = "Feedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyId = anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
    }
}

extension ProvideAnomalyFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ProvideAnomalyFeedbackInput: Swift.Equatable {
    /// A cost anomaly ID.
    /// This member is required.
    public var anomalyId: Swift.String?
    /// Describes whether the cost anomaly was a planned activity or you considered it an anomaly.
    /// This member is required.
    public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?

    public init (
        anomalyId: Swift.String? = nil,
        feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil
    )
    {
        self.anomalyId = anomalyId
        self.feedback = feedback
    }
}

struct ProvideAnomalyFeedbackInputBody: Swift.Equatable {
    let anomalyId: Swift.String?
    let feedback: CostExplorerClientTypes.AnomalyFeedbackType?
}

extension ProvideAnomalyFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyId = "AnomalyId"
        case feedback = "Feedback"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension ProvideAnomalyFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvideAnomalyFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ProvideAnomalyFeedbackOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvideAnomalyFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProvideAnomalyFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.anomalyId = output.anomalyId
        } else {
            self.anomalyId = nil
        }
    }
}

public struct ProvideAnomalyFeedbackOutputResponse: Swift.Equatable {
    /// The ID of the modified cost anomaly.
    /// This member is required.
    public var anomalyId: Swift.String?

    public init (
        anomalyId: Swift.String? = nil
    )
    {
        self.anomalyId = anomalyId
    }
}

struct ProvideAnomalyFeedbackOutputResponseBody: Swift.Equatable {
    let anomalyId: Swift.String?
}

extension ProvideAnomalyFeedbackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyId = "AnomalyId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
    }
}

extension CostExplorerClientTypes.RDSInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentGeneration = "CurrentGeneration"
        case databaseEdition = "DatabaseEdition"
        case databaseEngine = "DatabaseEngine"
        case deploymentOption = "DeploymentOption"
        case family = "Family"
        case instanceType = "InstanceType"
        case licenseModel = "LicenseModel"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let databaseEdition = databaseEdition {
            try encodeContainer.encode(databaseEdition, forKey: .databaseEdition)
        }
        if let databaseEngine = databaseEngine {
            try encodeContainer.encode(databaseEngine, forKey: .databaseEngine)
        }
        if let deploymentOption = deploymentOption {
            try encodeContainer.encode(deploymentOption, forKey: .deploymentOption)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let licenseModel = licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let databaseEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseEngine)
        databaseEngine = databaseEngineDecoded
        let databaseEditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseEdition)
        databaseEdition = databaseEditionDecoded
        let deploymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentOption)
        deploymentOption = deploymentOptionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let currentGenerationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon RDS instances that Amazon Web Services recommends that you purchase.
    public struct RDSInstanceDetails: Swift.Equatable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The database edition that the recommended reservation supports.
        public var databaseEdition: Swift.String?
        /// The database engine that the recommended reservation supports.
        public var databaseEngine: Swift.String?
        /// Determines whether the recommendation is for a reservation in a single Availability Zone or a reservation with a backup in a second Availability Zone.
        public var deploymentOption: Swift.String?
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// The license model that the recommended reservation supports.
        public var licenseModel: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init (
            currentGeneration: Swift.Bool = false,
            databaseEdition: Swift.String? = nil,
            databaseEngine: Swift.String? = nil,
            deploymentOption: Swift.String? = nil,
            family: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.databaseEdition = databaseEdition
            self.databaseEngine = databaseEngine
            self.deploymentOption = deploymentOption
            self.family = family
            self.instanceType = instanceType
            self.licenseModel = licenseModel
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }

}

extension CostExplorerClientTypes {
    public enum RecommendationTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crossInstanceFamily
        case sameInstanceFamily
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTarget] {
            return [
                .crossInstanceFamily,
                .sameInstanceFamily,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crossInstanceFamily: return "CROSS_INSTANCE_FAMILY"
            case .sameInstanceFamily: return "SAME_INSTANCE_FAMILY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationTarget(rawValue: rawValue) ?? RecommendationTarget.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.RedshiftInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case nodeType = "NodeType"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let currentGenerationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon Redshift instances that Amazon Web Services recommends that you purchase.
    public struct RedshiftInstanceDetails: Swift.Equatable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of node that Amazon Web Services recommends.
        public var nodeType: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init (
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }

}

extension RequestChangedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestChangedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request parameters changed between pages. Try again with the old parameters or without a pagination token.
public struct RequestChangedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestChangedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestChangedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes.ReservationAggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedRecurringFee = "AmortizedRecurringFee"
        case amortizedUpfrontFee = "AmortizedUpfrontFee"
        case netRISavings = "NetRISavings"
        case onDemandCostOfRIHoursUsed = "OnDemandCostOfRIHoursUsed"
        case purchasedHours = "PurchasedHours"
        case purchasedUnits = "PurchasedUnits"
        case rICostForUnusedHours = "RICostForUnusedHours"
        case realizedSavings = "RealizedSavings"
        case totalActualHours = "TotalActualHours"
        case totalActualUnits = "TotalActualUnits"
        case totalAmortizedFee = "TotalAmortizedFee"
        case totalPotentialRISavings = "TotalPotentialRISavings"
        case unrealizedSavings = "UnrealizedSavings"
        case unusedHours = "UnusedHours"
        case unusedUnits = "UnusedUnits"
        case utilizationPercentage = "UtilizationPercentage"
        case utilizationPercentageInUnits = "UtilizationPercentageInUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedRecurringFee = amortizedRecurringFee {
            try encodeContainer.encode(amortizedRecurringFee, forKey: .amortizedRecurringFee)
        }
        if let amortizedUpfrontFee = amortizedUpfrontFee {
            try encodeContainer.encode(amortizedUpfrontFee, forKey: .amortizedUpfrontFee)
        }
        if let netRISavings = netRISavings {
            try encodeContainer.encode(netRISavings, forKey: .netRISavings)
        }
        if let onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsed {
            try encodeContainer.encode(onDemandCostOfRIHoursUsed, forKey: .onDemandCostOfRIHoursUsed)
        }
        if let purchasedHours = purchasedHours {
            try encodeContainer.encode(purchasedHours, forKey: .purchasedHours)
        }
        if let purchasedUnits = purchasedUnits {
            try encodeContainer.encode(purchasedUnits, forKey: .purchasedUnits)
        }
        if let rICostForUnusedHours = rICostForUnusedHours {
            try encodeContainer.encode(rICostForUnusedHours, forKey: .rICostForUnusedHours)
        }
        if let realizedSavings = realizedSavings {
            try encodeContainer.encode(realizedSavings, forKey: .realizedSavings)
        }
        if let totalActualHours = totalActualHours {
            try encodeContainer.encode(totalActualHours, forKey: .totalActualHours)
        }
        if let totalActualUnits = totalActualUnits {
            try encodeContainer.encode(totalActualUnits, forKey: .totalActualUnits)
        }
        if let totalAmortizedFee = totalAmortizedFee {
            try encodeContainer.encode(totalAmortizedFee, forKey: .totalAmortizedFee)
        }
        if let totalPotentialRISavings = totalPotentialRISavings {
            try encodeContainer.encode(totalPotentialRISavings, forKey: .totalPotentialRISavings)
        }
        if let unrealizedSavings = unrealizedSavings {
            try encodeContainer.encode(unrealizedSavings, forKey: .unrealizedSavings)
        }
        if let unusedHours = unusedHours {
            try encodeContainer.encode(unusedHours, forKey: .unusedHours)
        }
        if let unusedUnits = unusedUnits {
            try encodeContainer.encode(unusedUnits, forKey: .unusedUnits)
        }
        if let utilizationPercentage = utilizationPercentage {
            try encodeContainer.encode(utilizationPercentage, forKey: .utilizationPercentage)
        }
        if let utilizationPercentageInUnits = utilizationPercentageInUnits {
            try encodeContainer.encode(utilizationPercentageInUnits, forKey: .utilizationPercentageInUnits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utilizationPercentage)
        utilizationPercentage = utilizationPercentageDecoded
        let utilizationPercentageInUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utilizationPercentageInUnits)
        utilizationPercentageInUnits = utilizationPercentageInUnitsDecoded
        let purchasedHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .purchasedHours)
        purchasedHours = purchasedHoursDecoded
        let purchasedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .purchasedUnits)
        purchasedUnits = purchasedUnitsDecoded
        let totalActualHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalActualHours)
        totalActualHours = totalActualHoursDecoded
        let totalActualUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalActualUnits)
        totalActualUnits = totalActualUnitsDecoded
        let unusedHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unusedHours)
        unusedHours = unusedHoursDecoded
        let unusedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unusedUnits)
        unusedUnits = unusedUnitsDecoded
        let onDemandCostOfRIHoursUsedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandCostOfRIHoursUsed)
        onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsedDecoded
        let netRISavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .netRISavings)
        netRISavings = netRISavingsDecoded
        let totalPotentialRISavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalPotentialRISavings)
        totalPotentialRISavings = totalPotentialRISavingsDecoded
        let amortizedUpfrontFeeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amortizedUpfrontFee)
        amortizedUpfrontFee = amortizedUpfrontFeeDecoded
        let amortizedRecurringFeeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amortizedRecurringFee)
        amortizedRecurringFee = amortizedRecurringFeeDecoded
        let totalAmortizedFeeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalAmortizedFee)
        totalAmortizedFee = totalAmortizedFeeDecoded
        let rICostForUnusedHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rICostForUnusedHours)
        rICostForUnusedHours = rICostForUnusedHoursDecoded
        let realizedSavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realizedSavings)
        realizedSavings = realizedSavingsDecoded
        let unrealizedSavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unrealizedSavings)
        unrealizedSavings = unrealizedSavingsDecoded
    }
}

extension CostExplorerClientTypes {
    /// The aggregated numbers for your reservation usage.
    public struct ReservationAggregates: Swift.Equatable {
        /// The monthly cost of your reservation. It's amortized over the reservation period.
        public var amortizedRecurringFee: Swift.String?
        /// The upfront cost of your reservation. It's amortized over the reservation period.
        public var amortizedUpfrontFee: Swift.String?
        /// How much you saved due to purchasing and utilizing reservation. Amazon Web Services calculates this by subtracting TotalAmortizedFee from OnDemandCostOfRIHoursUsed.
        public var netRISavings: Swift.String?
        /// How much your reservation costs if charged On-Demand rates.
        public var onDemandCostOfRIHoursUsed: Swift.String?
        /// How many reservation hours that you purchased.
        public var purchasedHours: Swift.String?
        /// The number of Amazon EC2 reservation hours that you purchased. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var purchasedUnits: Swift.String?
        /// The cost of unused hours for your reservation.
        public var rICostForUnusedHours: Swift.String?
        /// The realized savings because of purchasing and using a reservation.
        public var realizedSavings: Swift.String?
        /// The total number of reservation hours that you used.
        public var totalActualHours: Swift.String?
        /// The total number of Amazon EC2 reservation hours that you used. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var totalActualUnits: Swift.String?
        /// The total cost of your reservation. It's amortized over the reservation period.
        public var totalAmortizedFee: Swift.String?
        /// How much you might save if you use your entire reservation.
        public var totalPotentialRISavings: Swift.String?
        /// The unrealized savings because of purchasing and using a reservation.
        public var unrealizedSavings: Swift.String?
        /// The number of reservation hours that you didn't use.
        public var unusedHours: Swift.String?
        /// The number of Amazon EC2 reservation hours that you didn't use. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var unusedUnits: Swift.String?
        /// The percentage of reservation time that you used.
        public var utilizationPercentage: Swift.String?
        /// The percentage of Amazon EC2 reservation time that you used. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var utilizationPercentageInUnits: Swift.String?

        public init (
            amortizedRecurringFee: Swift.String? = nil,
            amortizedUpfrontFee: Swift.String? = nil,
            netRISavings: Swift.String? = nil,
            onDemandCostOfRIHoursUsed: Swift.String? = nil,
            purchasedHours: Swift.String? = nil,
            purchasedUnits: Swift.String? = nil,
            rICostForUnusedHours: Swift.String? = nil,
            realizedSavings: Swift.String? = nil,
            totalActualHours: Swift.String? = nil,
            totalActualUnits: Swift.String? = nil,
            totalAmortizedFee: Swift.String? = nil,
            totalPotentialRISavings: Swift.String? = nil,
            unrealizedSavings: Swift.String? = nil,
            unusedHours: Swift.String? = nil,
            unusedUnits: Swift.String? = nil,
            utilizationPercentage: Swift.String? = nil,
            utilizationPercentageInUnits: Swift.String? = nil
        )
        {
            self.amortizedRecurringFee = amortizedRecurringFee
            self.amortizedUpfrontFee = amortizedUpfrontFee
            self.netRISavings = netRISavings
            self.onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsed
            self.purchasedHours = purchasedHours
            self.purchasedUnits = purchasedUnits
            self.rICostForUnusedHours = rICostForUnusedHours
            self.realizedSavings = realizedSavings
            self.totalActualHours = totalActualHours
            self.totalActualUnits = totalActualUnits
            self.totalAmortizedFee = totalAmortizedFee
            self.totalPotentialRISavings = totalPotentialRISavings
            self.unrealizedSavings = unrealizedSavings
            self.unusedHours = unusedHours
            self.unusedUnits = unusedUnits
            self.utilizationPercentage = utilizationPercentage
            self.utilizationPercentageInUnits = utilizationPercentageInUnits
        }
    }

}

extension CostExplorerClientTypes.ReservationCoverageGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case coverage = "Coverage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let coverage = coverage {
            try encodeContainer.encode(coverage, forKey: .coverage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let coverageDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Coverage.self, forKey: .coverage)
        coverage = coverageDecoded
    }
}

extension CostExplorerClientTypes {
    /// A group of reservations that share a set of attributes.
    public struct ReservationCoverageGroup: Swift.Equatable {
        /// The attributes for this group of reservations.
        public var attributes: [Swift.String:Swift.String]?
        /// How much instance usage this group of reservations covered.
        public var coverage: CostExplorerClientTypes.Coverage?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            coverage: CostExplorerClientTypes.Coverage? = nil
        )
        {
            self.attributes = attributes
            self.coverage = coverage
        }
    }

}

extension CostExplorerClientTypes.ReservationPurchaseRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope = "AccountScope"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case paymentOption = "PaymentOption"
        case recommendationDetails = "RecommendationDetails"
        case recommendationSummary = "RecommendationSummary"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let recommendationDetails = recommendationDetails {
            var recommendationDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationDetails)
            for reservationpurchaserecommendationdetails0 in recommendationDetails {
                try recommendationDetailsContainer.encode(reservationpurchaserecommendationdetails0)
            }
        }
        if let recommendationSummary = recommendationSummary {
            try encodeContainer.encode(recommendationSummary, forKey: .recommendationSummary)
        }
        if let serviceSpecification = serviceSpecification {
            try encodeContainer.encode(serviceSpecification, forKey: .serviceSpecification)
        }
        if let termInYears = termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let serviceSpecificationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ServiceSpecification.self, forKey: .serviceSpecification)
        serviceSpecification = serviceSpecificationDecoded
        let recommendationDetailsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ReservationPurchaseRecommendationDetail?].self, forKey: .recommendationDetails)
        var recommendationDetailsDecoded0:[CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]? = nil
        if let recommendationDetailsContainer = recommendationDetailsContainer {
            recommendationDetailsDecoded0 = [CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]()
            for structure0 in recommendationDetailsContainer {
                if let structure0 = structure0 {
                    recommendationDetailsDecoded0?.append(structure0)
                }
            }
        }
        recommendationDetails = recommendationDetailsDecoded0
        let recommendationSummaryDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationPurchaseRecommendationSummary.self, forKey: .recommendationSummary)
        recommendationSummary = recommendationSummaryDecoded
    }
}

extension CostExplorerClientTypes {
    /// A specific reservation that Amazon Web Services recommends for purchase.
    public struct ReservationPurchaseRecommendation: Swift.Equatable {
        /// The account scope that Amazon Web Services recommends that you purchase this instance for. For example, you can purchase this reservation for an entire organization in Amazon Web Services Organizations.
        public var accountScope: CostExplorerClientTypes.AccountScope?
        /// How many days of previous usage that Amazon Web Services considers when making this recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The payment option for the reservation (for example, AllUpfront or NoUpfront).
        public var paymentOption: CostExplorerClientTypes.PaymentOption?
        /// Details about the recommended purchases.
        public var recommendationDetails: [CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]?
        /// A summary about the recommended purchase.
        public var recommendationSummary: CostExplorerClientTypes.ReservationPurchaseRecommendationSummary?
        /// Hardware specifications for the service that you want recommendations for.
        public var serviceSpecification: CostExplorerClientTypes.ServiceSpecification?
        /// The term of the reservation that you want recommendations for, in years.
        public var termInYears: CostExplorerClientTypes.TermInYears?

        public init (
            accountScope: CostExplorerClientTypes.AccountScope? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
            recommendationDetails: [CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]? = nil,
            recommendationSummary: CostExplorerClientTypes.ReservationPurchaseRecommendationSummary? = nil,
            serviceSpecification: CostExplorerClientTypes.ServiceSpecification? = nil,
            termInYears: CostExplorerClientTypes.TermInYears? = nil
        )
        {
            self.accountScope = accountScope
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.paymentOption = paymentOption
            self.recommendationDetails = recommendationDetails
            self.recommendationSummary = recommendationSummary
            self.serviceSpecification = serviceSpecification
            self.termInYears = termInYears
        }
    }

}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case averageNormalizedUnitsUsedPerHour = "AverageNormalizedUnitsUsedPerHour"
        case averageNumberOfInstancesUsedPerHour = "AverageNumberOfInstancesUsedPerHour"
        case averageUtilization = "AverageUtilization"
        case currencyCode = "CurrencyCode"
        case estimatedBreakEvenInMonths = "EstimatedBreakEvenInMonths"
        case estimatedMonthlyOnDemandCost = "EstimatedMonthlyOnDemandCost"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedMonthlySavingsPercentage = "EstimatedMonthlySavingsPercentage"
        case estimatedReservationCostForLookbackPeriod = "EstimatedReservationCostForLookbackPeriod"
        case instanceDetails = "InstanceDetails"
        case maximumNormalizedUnitsUsedPerHour = "MaximumNormalizedUnitsUsedPerHour"
        case maximumNumberOfInstancesUsedPerHour = "MaximumNumberOfInstancesUsedPerHour"
        case minimumNormalizedUnitsUsedPerHour = "MinimumNormalizedUnitsUsedPerHour"
        case minimumNumberOfInstancesUsedPerHour = "MinimumNumberOfInstancesUsedPerHour"
        case recommendedNormalizedUnitsToPurchase = "RecommendedNormalizedUnitsToPurchase"
        case recommendedNumberOfInstancesToPurchase = "RecommendedNumberOfInstancesToPurchase"
        case recurringStandardMonthlyCost = "RecurringStandardMonthlyCost"
        case upfrontCost = "UpfrontCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(averageNormalizedUnitsUsedPerHour, forKey: .averageNormalizedUnitsUsedPerHour)
        }
        if let averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(averageNumberOfInstancesUsedPerHour, forKey: .averageNumberOfInstancesUsedPerHour)
        }
        if let averageUtilization = averageUtilization {
            try encodeContainer.encode(averageUtilization, forKey: .averageUtilization)
        }
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let estimatedBreakEvenInMonths = estimatedBreakEvenInMonths {
            try encodeContainer.encode(estimatedBreakEvenInMonths, forKey: .estimatedBreakEvenInMonths)
        }
        if let estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCost {
            try encodeContainer.encode(estimatedMonthlyOnDemandCost, forKey: .estimatedMonthlyOnDemandCost)
        }
        if let estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentage {
            try encodeContainer.encode(estimatedMonthlySavingsPercentage, forKey: .estimatedMonthlySavingsPercentage)
        }
        if let estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriod {
            try encodeContainer.encode(estimatedReservationCostForLookbackPeriod, forKey: .estimatedReservationCostForLookbackPeriod)
        }
        if let instanceDetails = instanceDetails {
            try encodeContainer.encode(instanceDetails, forKey: .instanceDetails)
        }
        if let maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(maximumNormalizedUnitsUsedPerHour, forKey: .maximumNormalizedUnitsUsedPerHour)
        }
        if let maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(maximumNumberOfInstancesUsedPerHour, forKey: .maximumNumberOfInstancesUsedPerHour)
        }
        if let minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(minimumNormalizedUnitsUsedPerHour, forKey: .minimumNormalizedUnitsUsedPerHour)
        }
        if let minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(minimumNumberOfInstancesUsedPerHour, forKey: .minimumNumberOfInstancesUsedPerHour)
        }
        if let recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchase {
            try encodeContainer.encode(recommendedNormalizedUnitsToPurchase, forKey: .recommendedNormalizedUnitsToPurchase)
        }
        if let recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchase {
            try encodeContainer.encode(recommendedNumberOfInstancesToPurchase, forKey: .recommendedNumberOfInstancesToPurchase)
        }
        if let recurringStandardMonthlyCost = recurringStandardMonthlyCost {
            try encodeContainer.encode(recurringStandardMonthlyCost, forKey: .recurringStandardMonthlyCost)
        }
        if let upfrontCost = upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let instanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.InstanceDetails.self, forKey: .instanceDetails)
        instanceDetails = instanceDetailsDecoded
        let recommendedNumberOfInstancesToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedNumberOfInstancesToPurchase)
        recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchaseDecoded
        let recommendedNormalizedUnitsToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedNormalizedUnitsToPurchase)
        recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchaseDecoded
        let minimumNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumNumberOfInstancesUsedPerHour)
        minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHourDecoded
        let minimumNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumNormalizedUnitsUsedPerHour)
        minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHourDecoded
        let maximumNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maximumNumberOfInstancesUsedPerHour)
        maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHourDecoded
        let maximumNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maximumNormalizedUnitsUsedPerHour)
        maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHourDecoded
        let averageNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .averageNumberOfInstancesUsedPerHour)
        averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHourDecoded
        let averageNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .averageNormalizedUnitsUsedPerHour)
        averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHourDecoded
        let averageUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .averageUtilization)
        averageUtilization = averageUtilizationDecoded
        let estimatedBreakEvenInMonthsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedBreakEvenInMonths)
        estimatedBreakEvenInMonths = estimatedBreakEvenInMonthsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let estimatedMonthlySavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsPercentage)
        estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentageDecoded
        let estimatedMonthlyOnDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlyOnDemandCost)
        estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCostDecoded
        let estimatedReservationCostForLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedReservationCostForLookbackPeriod)
        estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriodDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let recurringStandardMonthlyCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recurringStandardMonthlyCost)
        recurringStandardMonthlyCost = recurringStandardMonthlyCostDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about your recommended reservation purchase.
    public struct ReservationPurchaseRecommendationDetail: Swift.Equatable {
        /// The account that this RI recommendation is for.
        public var accountId: Swift.String?
        /// The average number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageNormalizedUnitsUsedPerHour: Swift.String?
        /// The average number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageNumberOfInstancesUsedPerHour: Swift.String?
        /// The average utilization of your instances. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageUtilization: Swift.String?
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// How long Amazon Web Services estimates that it takes for this instance to start saving you money, in months.
        public var estimatedBreakEvenInMonths: Swift.String?
        /// How much Amazon Web Services estimates that you spend on On-Demand Instances in a month.
        public var estimatedMonthlyOnDemandCost: Swift.String?
        /// How much Amazon Web Services estimates that this specific recommendation could save you in a month.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// How much Amazon Web Services estimates that this specific recommendation could save you in a month, as a percentage of your overall costs.
        public var estimatedMonthlySavingsPercentage: Swift.String?
        /// How much Amazon Web Services estimates that you would have spent for all usage during the specified historical period if you had a reservation.
        public var estimatedReservationCostForLookbackPeriod: Swift.String?
        /// Details about the instances that Amazon Web Services recommends that you purchase.
        public var instanceDetails: CostExplorerClientTypes.InstanceDetails?
        /// The maximum number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var maximumNormalizedUnitsUsedPerHour: Swift.String?
        /// The maximum number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var maximumNumberOfInstancesUsedPerHour: Swift.String?
        /// The minimum number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var minimumNormalizedUnitsUsedPerHour: Swift.String?
        /// The minimum number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var minimumNumberOfInstancesUsedPerHour: Swift.String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public var recommendedNormalizedUnitsToPurchase: Swift.String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public var recommendedNumberOfInstancesToPurchase: Swift.String?
        /// How much purchasing this instance costs you on a monthly basis.
        public var recurringStandardMonthlyCost: Swift.String?
        /// How much purchasing this instance costs you upfront.
        public var upfrontCost: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            averageNormalizedUnitsUsedPerHour: Swift.String? = nil,
            averageNumberOfInstancesUsedPerHour: Swift.String? = nil,
            averageUtilization: Swift.String? = nil,
            currencyCode: Swift.String? = nil,
            estimatedBreakEvenInMonths: Swift.String? = nil,
            estimatedMonthlyOnDemandCost: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedMonthlySavingsPercentage: Swift.String? = nil,
            estimatedReservationCostForLookbackPeriod: Swift.String? = nil,
            instanceDetails: CostExplorerClientTypes.InstanceDetails? = nil,
            maximumNormalizedUnitsUsedPerHour: Swift.String? = nil,
            maximumNumberOfInstancesUsedPerHour: Swift.String? = nil,
            minimumNormalizedUnitsUsedPerHour: Swift.String? = nil,
            minimumNumberOfInstancesUsedPerHour: Swift.String? = nil,
            recommendedNormalizedUnitsToPurchase: Swift.String? = nil,
            recommendedNumberOfInstancesToPurchase: Swift.String? = nil,
            recurringStandardMonthlyCost: Swift.String? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHour
            self.averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHour
            self.averageUtilization = averageUtilization
            self.currencyCode = currencyCode
            self.estimatedBreakEvenInMonths = estimatedBreakEvenInMonths
            self.estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCost
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentage
            self.estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriod
            self.instanceDetails = instanceDetails
            self.maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHour
            self.maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHour
            self.minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHour
            self.minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHour
            self.recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchase
            self.recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchase
            self.recurringStandardMonthlyCost = recurringStandardMonthlyCost
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationTimestamp = "GenerationTimestamp"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationTimestamp = generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
    }
}

extension CostExplorerClientTypes {
    /// Information about this specific recommendation, such as the timestamp for when Amazon Web Services made a specific recommendation.
    public struct ReservationPurchaseRecommendationMetadata: Swift.Equatable {
        /// The timestamp for when Amazon Web Services made this recommendation.
        public var generationTimestamp: Swift.String?
        /// The ID for this specific recommendation.
        public var recommendationId: Swift.String?

        public init (
            generationTimestamp: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.generationTimestamp = generationTimestamp
            self.recommendationId = recommendationId
        }
    }

}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case totalEstimatedMonthlySavingsAmount = "TotalEstimatedMonthlySavingsAmount"
        case totalEstimatedMonthlySavingsPercentage = "TotalEstimatedMonthlySavingsPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmount {
            try encodeContainer.encode(totalEstimatedMonthlySavingsAmount, forKey: .totalEstimatedMonthlySavingsAmount)
        }
        if let totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentage {
            try encodeContainer.encode(totalEstimatedMonthlySavingsPercentage, forKey: .totalEstimatedMonthlySavingsPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalEstimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalEstimatedMonthlySavingsAmount)
        totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmountDecoded
        let totalEstimatedMonthlySavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalEstimatedMonthlySavingsPercentage)
        totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentageDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension CostExplorerClientTypes {
    /// A summary about this recommendation, such as the currency code, the amount that Amazon Web Services estimates that you could save, and the total amount of reservation to purchase.
    public struct ReservationPurchaseRecommendationSummary: Swift.Equatable {
        /// The currency code used for this recommendation.
        public var currencyCode: Swift.String?
        /// The total amount that Amazon Web Services estimates that this recommendation could save you in a month.
        public var totalEstimatedMonthlySavingsAmount: Swift.String?
        /// The total amount that Amazon Web Services estimates that this recommendation could save you in a month, as a percentage of your costs.
        public var totalEstimatedMonthlySavingsPercentage: Swift.String?

        public init (
            currencyCode: Swift.String? = nil,
            totalEstimatedMonthlySavingsAmount: Swift.String? = nil,
            totalEstimatedMonthlySavingsPercentage: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmount
            self.totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentage
        }
    }

}

extension CostExplorerClientTypes.ReservationUtilizationGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case key = "Key"
        case utilization = "Utilization"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let utilization = utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let utilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationAggregates.self, forKey: .utilization)
        utilization = utilizationDecoded
    }
}

extension CostExplorerClientTypes {
    /// A group of reservations that share a set of attributes.
    public struct ReservationUtilizationGroup: Swift.Equatable {
        /// The attributes for this group of reservations.
        public var attributes: [Swift.String:Swift.String]?
        /// The key for a specific reservation attribute.
        public var key: Swift.String?
        /// How much you used this group of reservations.
        public var utilization: CostExplorerClientTypes.ReservationAggregates?
        /// The value of a specific reservation attribute.
        public var value: Swift.String?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            key: Swift.String? = nil,
            utilization: CostExplorerClientTypes.ReservationAggregates? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.key = key
            self.utilization = utilization
            self.value = value
        }
    }

}

extension CostExplorerClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2ResourceDetails = "EC2ResourceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2ResourceDetails = eC2ResourceDetails {
            try encodeContainer.encode(eC2ResourceDetails, forKey: .eC2ResourceDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eC2ResourceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EC2ResourceDetails.self, forKey: .eC2ResourceDetails)
        eC2ResourceDetails = eC2ResourceDetailsDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details on the resource.
    public struct ResourceDetails: Swift.Equatable {
        /// Details on the Amazon EC2 resource.
        public var eC2ResourceDetails: CostExplorerClientTypes.EC2ResourceDetails?

        public init (
            eC2ResourceDetails: CostExplorerClientTypes.EC2ResourceDetails? = nil
        )
        {
            self.eC2ResourceDetails = eC2ResourceDetails
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified ARN in the request doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes.ResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2ResourceUtilization = "EC2ResourceUtilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2ResourceUtilization = eC2ResourceUtilization {
            try encodeContainer.encode(eC2ResourceUtilization, forKey: .eC2ResourceUtilization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eC2ResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EC2ResourceUtilization.self, forKey: .eC2ResourceUtilization)
        eC2ResourceUtilization = eC2ResourceUtilizationDecoded
    }
}

extension CostExplorerClientTypes {
    /// Resource utilization of current resource.
    public struct ResourceUtilization: Swift.Equatable {
        /// The utilization of current Amazon EC2 instance.
        public var eC2ResourceUtilization: CostExplorerClientTypes.EC2ResourceUtilization?

        public init (
            eC2ResourceUtilization: CostExplorerClientTypes.EC2ResourceUtilization? = nil
        )
        {
            self.eC2ResourceUtilization = eC2ResourceUtilization
        }
    }

}

extension CostExplorerClientTypes.ResultByTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimated = "Estimated"
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if estimated != false {
            try encodeContainer.encode(estimated, forKey: .estimated)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groups0 in groups {
                try groupsContainer.encode(groups0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = total {
            var totalContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .total)
            for (dictKey0, metrics0) in total {
                try totalContainer.encode(metrics0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let totalContainer = try containerValues.decodeIfPresent([Swift.String: CostExplorerClientTypes.MetricValue?].self, forKey: .total)
        var totalDecoded0: [Swift.String:CostExplorerClientTypes.MetricValue]? = nil
        if let totalContainer = totalContainer {
            totalDecoded0 = [Swift.String:CostExplorerClientTypes.MetricValue]()
            for (key0, metricvalue0) in totalContainer {
                if let metricvalue0 = metricvalue0 {
                    totalDecoded0?[key0] = metricvalue0
                }
            }
        }
        total = totalDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Group?].self, forKey: .groups)
        var groupsDecoded0:[CostExplorerClientTypes.Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [CostExplorerClientTypes.Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let estimatedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .estimated)
        estimated = estimatedDecoded
    }
}

extension CostExplorerClientTypes {
    /// The result that's associated with a time period.
    public struct ResultByTime: Swift.Equatable {
        /// Determines whether the result is estimated.
        public var estimated: Swift.Bool
        /// The groups that this time period includes.
        public var groups: [CostExplorerClientTypes.Group]?
        /// The time period that the result covers.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total amount of cost or usage accrued during the time period.
        public var total: [Swift.String:CostExplorerClientTypes.MetricValue]?

        public init (
            estimated: Swift.Bool = false,
            groups: [CostExplorerClientTypes.Group]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: [Swift.String:CostExplorerClientTypes.MetricValue]? = nil
        )
        {
            self.estimated = estimated
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }

}

extension CostExplorerClientTypes.RightsizingRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case currentInstance = "CurrentInstance"
        case findingReasonCodes = "FindingReasonCodes"
        case modifyRecommendationDetail = "ModifyRecommendationDetail"
        case rightsizingType = "RightsizingType"
        case terminateRecommendationDetail = "TerminateRecommendationDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let currentInstance = currentInstance {
            try encodeContainer.encode(currentInstance, forKey: .currentInstance)
        }
        if let findingReasonCodes = findingReasonCodes {
            var findingReasonCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingReasonCodes)
            for findingreasoncodes0 in findingReasonCodes {
                try findingReasonCodesContainer.encode(findingreasoncodes0.rawValue)
            }
        }
        if let modifyRecommendationDetail = modifyRecommendationDetail {
            try encodeContainer.encode(modifyRecommendationDetail, forKey: .modifyRecommendationDetail)
        }
        if let rightsizingType = rightsizingType {
            try encodeContainer.encode(rightsizingType.rawValue, forKey: .rightsizingType)
        }
        if let terminateRecommendationDetail = terminateRecommendationDetail {
            try encodeContainer.encode(terminateRecommendationDetail, forKey: .terminateRecommendationDetail)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let currentInstanceDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CurrentInstance.self, forKey: .currentInstance)
        currentInstance = currentInstanceDecoded
        let rightsizingTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingType.self, forKey: .rightsizingType)
        rightsizingType = rightsizingTypeDecoded
        let modifyRecommendationDetailDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ModifyRecommendationDetail.self, forKey: .modifyRecommendationDetail)
        modifyRecommendationDetail = modifyRecommendationDetailDecoded
        let terminateRecommendationDetailDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TerminateRecommendationDetail.self, forKey: .terminateRecommendationDetail)
        terminateRecommendationDetail = terminateRecommendationDetailDecoded
        let findingReasonCodesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.FindingReasonCode?].self, forKey: .findingReasonCodes)
        var findingReasonCodesDecoded0:[CostExplorerClientTypes.FindingReasonCode]? = nil
        if let findingReasonCodesContainer = findingReasonCodesContainer {
            findingReasonCodesDecoded0 = [CostExplorerClientTypes.FindingReasonCode]()
            for string0 in findingReasonCodesContainer {
                if let string0 = string0 {
                    findingReasonCodesDecoded0?.append(string0)
                }
            }
        }
        findingReasonCodes = findingReasonCodesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// Recommendations to rightsize resources.
    public struct RightsizingRecommendation: Swift.Equatable {
        /// The account that this recommendation is for.
        public var accountId: Swift.String?
        /// Context regarding the current instance.
        public var currentInstance: CostExplorerClientTypes.CurrentInstance?
        /// The list of possible reasons why the recommendation is generated such as under or over utilization of specific metrics (for example, CPU, Memory, Network).
        public var findingReasonCodes: [CostExplorerClientTypes.FindingReasonCode]?
        /// The details for the modification recommendations.
        public var modifyRecommendationDetail: CostExplorerClientTypes.ModifyRecommendationDetail?
        /// A recommendation to either terminate or modify the resource.
        public var rightsizingType: CostExplorerClientTypes.RightsizingType?
        /// The details for termination recommendations.
        public var terminateRecommendationDetail: CostExplorerClientTypes.TerminateRecommendationDetail?

        public init (
            accountId: Swift.String? = nil,
            currentInstance: CostExplorerClientTypes.CurrentInstance? = nil,
            findingReasonCodes: [CostExplorerClientTypes.FindingReasonCode]? = nil,
            modifyRecommendationDetail: CostExplorerClientTypes.ModifyRecommendationDetail? = nil,
            rightsizingType: CostExplorerClientTypes.RightsizingType? = nil,
            terminateRecommendationDetail: CostExplorerClientTypes.TerminateRecommendationDetail? = nil
        )
        {
            self.accountId = accountId
            self.currentInstance = currentInstance
            self.findingReasonCodes = findingReasonCodes
            self.modifyRecommendationDetail = modifyRecommendationDetail
            self.rightsizingType = rightsizingType
            self.terminateRecommendationDetail = terminateRecommendationDetail
        }
    }

}

extension CostExplorerClientTypes.RightsizingRecommendationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case benefitsConsidered = "BenefitsConsidered"
        case recommendationTarget = "RecommendationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if benefitsConsidered != false {
            try encodeContainer.encode(benefitsConsidered, forKey: .benefitsConsidered)
        }
        if let recommendationTarget = recommendationTarget {
            try encodeContainer.encode(recommendationTarget.rawValue, forKey: .recommendationTarget)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTargetDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RecommendationTarget.self, forKey: .recommendationTarget)
        recommendationTarget = recommendationTargetDecoded
        let benefitsConsideredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .benefitsConsidered)
        benefitsConsidered = benefitsConsideredDecoded
    }
}

extension CostExplorerClientTypes {
    /// You can use RightsizingRecommendationConfiguration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
    public struct RightsizingRecommendationConfiguration: Swift.Equatable {
        /// The option to consider RI or Savings Plans discount benefits in your savings calculation. The default value is TRUE.
        /// This member is required.
        public var benefitsConsidered: Swift.Bool
        /// The option to see recommendations within the same instance family or recommendations for instances across other families. The default value is SAME_INSTANCE_FAMILY.
        /// This member is required.
        public var recommendationTarget: CostExplorerClientTypes.RecommendationTarget?

        public init (
            benefitsConsidered: Swift.Bool = false,
            recommendationTarget: CostExplorerClientTypes.RecommendationTarget? = nil
        )
        {
            self.benefitsConsidered = benefitsConsidered
            self.recommendationTarget = recommendationTarget
        }
    }

}

extension CostExplorerClientTypes.RightsizingRecommendationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetadata = "AdditionalMetadata"
        case generationTimestamp = "GenerationTimestamp"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetadata = additionalMetadata {
            try encodeContainer.encode(additionalMetadata, forKey: .additionalMetadata)
        }
        if let generationTimestamp = generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let additionalMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalMetadata)
        additionalMetadata = additionalMetadataDecoded
    }
}

extension CostExplorerClientTypes {
    /// Metadata for this recommendation set.
    public struct RightsizingRecommendationMetadata: Swift.Equatable {
        /// Additional metadata that might be applicable to the recommendation.
        public var additionalMetadata: Swift.String?
        /// The timestamp for when Amazon Web Services made this recommendation.
        public var generationTimestamp: Swift.String?
        /// The number of days of previous usage that Amazon Web Services considers when making this recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The ID for this specific recommendation.
        public var recommendationId: Swift.String?

        public init (
            additionalMetadata: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.recommendationId = recommendationId
        }
    }

}

extension CostExplorerClientTypes.RightsizingRecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedTotalMonthlySavingsAmount = "EstimatedTotalMonthlySavingsAmount"
        case savingsCurrencyCode = "SavingsCurrencyCode"
        case savingsPercentage = "SavingsPercentage"
        case totalRecommendationCount = "TotalRecommendationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmount {
            try encodeContainer.encode(estimatedTotalMonthlySavingsAmount, forKey: .estimatedTotalMonthlySavingsAmount)
        }
        if let savingsCurrencyCode = savingsCurrencyCode {
            try encodeContainer.encode(savingsCurrencyCode, forKey: .savingsCurrencyCode)
        }
        if let savingsPercentage = savingsPercentage {
            try encodeContainer.encode(savingsPercentage, forKey: .savingsPercentage)
        }
        if let totalRecommendationCount = totalRecommendationCount {
            try encodeContainer.encode(totalRecommendationCount, forKey: .totalRecommendationCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalRecommendationCountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRecommendationCount)
        totalRecommendationCount = totalRecommendationCountDecoded
        let estimatedTotalMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedTotalMonthlySavingsAmount)
        estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmountDecoded
        let savingsCurrencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsCurrencyCode)
        savingsCurrencyCode = savingsCurrencyCodeDecoded
        let savingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPercentage)
        savingsPercentage = savingsPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// The summary of rightsizing recommendations
    public struct RightsizingRecommendationSummary: Swift.Equatable {
        /// The estimated total savings resulting from modifications, on a monthly basis.
        public var estimatedTotalMonthlySavingsAmount: Swift.String?
        /// The currency code that Amazon Web Services used to calculate the savings.
        public var savingsCurrencyCode: Swift.String?
        /// The savings percentage based on the recommended modifications. It's relative to the total On-Demand costs that are associated with these instances.
        public var savingsPercentage: Swift.String?
        /// The total number of instance recommendations.
        public var totalRecommendationCount: Swift.String?

        public init (
            estimatedTotalMonthlySavingsAmount: Swift.String? = nil,
            savingsCurrencyCode: Swift.String? = nil,
            savingsPercentage: Swift.String? = nil,
            totalRecommendationCount: Swift.String? = nil
        )
        {
            self.estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmount
            self.savingsCurrencyCode = savingsCurrencyCode
            self.savingsPercentage = savingsPercentage
            self.totalRecommendationCount = totalRecommendationCount
        }
    }

}

extension CostExplorerClientTypes {
    public enum RightsizingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case modify
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [RightsizingType] {
            return [
                .modify,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .modify: return "MODIFY"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RightsizingType(rawValue: rawValue) ?? RightsizingType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.RootCause: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkedAccount = "LinkedAccount"
        case region = "Region"
        case service = "Service"
        case usageType = "UsageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkedAccount = linkedAccount {
            try encodeContainer.encode(linkedAccount, forKey: .linkedAccount)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let usageType = usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let linkedAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkedAccount)
        linkedAccount = linkedAccountDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
    }
}

extension CostExplorerClientTypes {
    /// The combination of Amazon Web Services service, linked account, Region, and usage type where a cost anomaly is observed.
    public struct RootCause: Swift.Equatable {
        /// The member account value that's associated with the cost anomaly.
        public var linkedAccount: Swift.String?
        /// The Amazon Web Services Region that's associated with the cost anomaly.
        public var region: Swift.String?
        /// The Amazon Web Services service name that's associated with the cost anomaly.
        public var service: Swift.String?
        /// The UsageType value that's associated with the cost anomaly.
        public var usageType: Swift.String?

        public init (
            linkedAccount: Swift.String? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.linkedAccount = linkedAccount
            self.region = region
            self.service = service
            self.usageType = usageType
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansAmortizedCommitment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedRecurringCommitment = "AmortizedRecurringCommitment"
        case amortizedUpfrontCommitment = "AmortizedUpfrontCommitment"
        case totalAmortizedCommitment = "TotalAmortizedCommitment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedRecurringCommitment = amortizedRecurringCommitment {
            try encodeContainer.encode(amortizedRecurringCommitment, forKey: .amortizedRecurringCommitment)
        }
        if let amortizedUpfrontCommitment = amortizedUpfrontCommitment {
            try encodeContainer.encode(amortizedUpfrontCommitment, forKey: .amortizedUpfrontCommitment)
        }
        if let totalAmortizedCommitment = totalAmortizedCommitment {
            try encodeContainer.encode(totalAmortizedCommitment, forKey: .totalAmortizedCommitment)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amortizedRecurringCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amortizedRecurringCommitment)
        amortizedRecurringCommitment = amortizedRecurringCommitmentDecoded
        let amortizedUpfrontCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amortizedUpfrontCommitment)
        amortizedUpfrontCommitment = amortizedUpfrontCommitmentDecoded
        let totalAmortizedCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalAmortizedCommitment)
        totalAmortizedCommitment = totalAmortizedCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amortized amount of Savings Plans purchased in a specific account during a specific time interval.
    public struct SavingsPlansAmortizedCommitment: Swift.Equatable {
        /// The amortized amount of your Savings Plans commitment that was purchased with either a Partial or a NoUpfront.
        public var amortizedRecurringCommitment: Swift.String?
        /// The amortized amount of your Savings Plans commitment that was purchased with an Upfront or PartialUpfront Savings Plans.
        public var amortizedUpfrontCommitment: Swift.String?
        /// The total amortized amount of your Savings Plans commitment, regardless of your Savings Plans purchase method.
        public var totalAmortizedCommitment: Swift.String?

        public init (
            amortizedRecurringCommitment: Swift.String? = nil,
            amortizedUpfrontCommitment: Swift.String? = nil,
            totalAmortizedCommitment: Swift.String? = nil
        )
        {
            self.amortizedRecurringCommitment = amortizedRecurringCommitment
            self.amortizedUpfrontCommitment = amortizedUpfrontCommitment
            self.totalAmortizedCommitment = totalAmortizedCommitment
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansCoverage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case coverage = "Coverage"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let coverage = coverage {
            try encodeContainer.encode(coverage, forKey: .coverage)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let coverageDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansCoverageData.self, forKey: .coverage)
        coverage = coverageDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of Savings Plans eligible usage that is covered by Savings Plans. All calculations consider the On-Demand equivalent of your Savings Plans usage.
    public struct SavingsPlansCoverage: Swift.Equatable {
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String:Swift.String]?
        /// The amount of Savings Plans eligible usage that the Savings Plans covered.
        public var coverage: CostExplorerClientTypes.SavingsPlansCoverageData?
        /// The time period of the request.
        public var timePeriod: CostExplorerClientTypes.DateInterval?

        public init (
            attributes: [Swift.String:Swift.String]? = nil,
            coverage: CostExplorerClientTypes.SavingsPlansCoverageData? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil
        )
        {
            self.attributes = attributes
            self.coverage = coverage
            self.timePeriod = timePeriod
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansCoverageData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coveragePercentage = "CoveragePercentage"
        case onDemandCost = "OnDemandCost"
        case spendCoveredBySavingsPlans = "SpendCoveredBySavingsPlans"
        case totalCost = "TotalCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coveragePercentage = coveragePercentage {
            try encodeContainer.encode(coveragePercentage, forKey: .coveragePercentage)
        }
        if let onDemandCost = onDemandCost {
            try encodeContainer.encode(onDemandCost, forKey: .onDemandCost)
        }
        if let spendCoveredBySavingsPlans = spendCoveredBySavingsPlans {
            try encodeContainer.encode(spendCoveredBySavingsPlans, forKey: .spendCoveredBySavingsPlans)
        }
        if let totalCost = totalCost {
            try encodeContainer.encode(totalCost, forKey: .totalCost)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spendCoveredBySavingsPlansDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spendCoveredBySavingsPlans)
        spendCoveredBySavingsPlans = spendCoveredBySavingsPlansDecoded
        let onDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandCost)
        onDemandCost = onDemandCostDecoded
        let totalCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalCost)
        totalCost = totalCostDecoded
        let coveragePercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coveragePercentage)
        coveragePercentage = coveragePercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// Specific coverage percentage, On-Demand costs, and spend covered by Savings Plans, and total Savings Plans costs for an account.
    public struct SavingsPlansCoverageData: Swift.Equatable {
        /// The percentage of your existing Savings Plans covered usage, divided by all of your eligible Savings Plans usage in an account (or set of accounts).
        public var coveragePercentage: Swift.String?
        /// The cost of your Amazon Web Services usage at the public On-Demand rate.
        public var onDemandCost: Swift.String?
        /// The amount of your Amazon Web Services usage that is covered by a Savings Plans.
        public var spendCoveredBySavingsPlans: Swift.String?
        /// The total cost of your Amazon Web Services usage, regardless of your purchase option.
        public var totalCost: Swift.String?

        public init (
            coveragePercentage: Swift.String? = nil,
            onDemandCost: Swift.String? = nil,
            spendCoveredBySavingsPlans: Swift.String? = nil,
            totalCost: Swift.String? = nil
        )
        {
            self.coveragePercentage = coveragePercentage
            self.onDemandCost = onDemandCost
            self.spendCoveredBySavingsPlans = spendCoveredBySavingsPlans
            self.totalCost = totalCost
        }
    }

}

extension CostExplorerClientTypes {
    public enum SavingsPlansDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amortizedCommitment
        case attributes
        case savings
        case utilization
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlansDataType] {
            return [
                .amortizedCommitment,
                .attributes,
                .savings,
                .utilization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amortizedCommitment: return "AMORTIZED_COMMITMENT"
            case .attributes: return "ATTRIBUTES"
            case .savings: return "SAVINGS"
            case .utilization: return "UTILIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlansDataType(rawValue: rawValue) ?? SavingsPlansDataType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.SavingsPlansDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceFamily = "InstanceFamily"
        case offeringId = "OfferingId"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceFamily = instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
    }
}

extension CostExplorerClientTypes {
    /// The attribute details on a specific Savings Plan.
    public struct SavingsPlansDetails: Swift.Equatable {
        /// A group of instance types that Savings Plans applies to.
        public var instanceFamily: Swift.String?
        /// The unique ID that's used to distinguish Savings Plans from one another.
        public var offeringId: Swift.String?
        /// A collection of Amazon Web Services resources in a geographic area. Each Amazon Web Services Region is isolated and independent of the other Regions.
        public var region: Swift.String?

        public init (
            instanceFamily: Swift.String? = nil,
            offeringId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.instanceFamily = instanceFamily
            self.offeringId = offeringId
            self.region = region
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope = "AccountScope"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case paymentOption = "PaymentOption"
        case savingsPlansPurchaseRecommendationDetails = "SavingsPlansPurchaseRecommendationDetails"
        case savingsPlansPurchaseRecommendationSummary = "SavingsPlansPurchaseRecommendationSummary"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetails {
            var savingsPlansPurchaseRecommendationDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlansPurchaseRecommendationDetails)
            for savingsplanspurchaserecommendationdetaillist0 in savingsPlansPurchaseRecommendationDetails {
                try savingsPlansPurchaseRecommendationDetailsContainer.encode(savingsplanspurchaserecommendationdetaillist0)
            }
        }
        if let savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummary {
            try encodeContainer.encode(savingsPlansPurchaseRecommendationSummary, forKey: .savingsPlansPurchaseRecommendationSummary)
        }
        if let savingsPlansType = savingsPlansType {
            try encodeContainer.encode(savingsPlansType.rawValue, forKey: .savingsPlansType)
        }
        if let termInYears = termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let savingsPlansTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SupportedSavingsPlansType.self, forKey: .savingsPlansType)
        savingsPlansType = savingsPlansTypeDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let savingsPlansPurchaseRecommendationDetailsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail?].self, forKey: .savingsPlansPurchaseRecommendationDetails)
        var savingsPlansPurchaseRecommendationDetailsDecoded0:[CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]? = nil
        if let savingsPlansPurchaseRecommendationDetailsContainer = savingsPlansPurchaseRecommendationDetailsContainer {
            savingsPlansPurchaseRecommendationDetailsDecoded0 = [CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]()
            for structure0 in savingsPlansPurchaseRecommendationDetailsContainer {
                if let structure0 = structure0 {
                    savingsPlansPurchaseRecommendationDetailsDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetailsDecoded0
        let savingsPlansPurchaseRecommendationSummaryDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary.self, forKey: .savingsPlansPurchaseRecommendationSummary)
        savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummaryDecoded
    }
}

extension CostExplorerClientTypes {
    /// Contains your request parameters, Savings Plan Recommendations Summary, and Details.
    public struct SavingsPlansPurchaseRecommendation: Swift.Equatable {
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations that include the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public var accountScope: CostExplorerClientTypes.AccountScope?
        /// The lookback period in days, used to generate the recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The payment option used to generate the recommendation.
        public var paymentOption: CostExplorerClientTypes.PaymentOption?
        /// Details for the Savings Plans we recommend that you purchase to cover existing Savings Plans eligible workloads.
        public var savingsPlansPurchaseRecommendationDetails: [CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]?
        /// Summary metrics for your Savings Plans Recommendations.
        public var savingsPlansPurchaseRecommendationSummary: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary?
        /// The requested Savings Plans recommendation type.
        public var savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
        /// The Savings Plans recommendation term in years. It's used to generate the recommendation.
        public var termInYears: CostExplorerClientTypes.TermInYears?

        public init (
            accountScope: CostExplorerClientTypes.AccountScope? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
            savingsPlansPurchaseRecommendationDetails: [CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]? = nil,
            savingsPlansPurchaseRecommendationSummary: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary? = nil,
            savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType? = nil,
            termInYears: CostExplorerClientTypes.TermInYears? = nil
        )
        {
            self.accountScope = accountScope
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.paymentOption = paymentOption
            self.savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetails
            self.savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummary
            self.savingsPlansType = savingsPlansType
            self.termInYears = termInYears
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case currencyCode = "CurrencyCode"
        case currentAverageHourlyOnDemandSpend = "CurrentAverageHourlyOnDemandSpend"
        case currentMaximumHourlyOnDemandSpend = "CurrentMaximumHourlyOnDemandSpend"
        case currentMinimumHourlyOnDemandSpend = "CurrentMinimumHourlyOnDemandSpend"
        case estimatedAverageUtilization = "EstimatedAverageUtilization"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedOnDemandCost = "EstimatedOnDemandCost"
        case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
        case estimatedROI = "EstimatedROI"
        case estimatedSPCost = "EstimatedSPCost"
        case estimatedSavingsAmount = "EstimatedSavingsAmount"
        case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
        case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
        case savingsPlansDetails = "SavingsPlansDetails"
        case upfrontCost = "UpfrontCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend {
            try encodeContainer.encode(currentAverageHourlyOnDemandSpend, forKey: .currentAverageHourlyOnDemandSpend)
        }
        if let currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend {
            try encodeContainer.encode(currentMaximumHourlyOnDemandSpend, forKey: .currentMaximumHourlyOnDemandSpend)
        }
        if let currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend {
            try encodeContainer.encode(currentMinimumHourlyOnDemandSpend, forKey: .currentMinimumHourlyOnDemandSpend)
        }
        if let estimatedAverageUtilization = estimatedAverageUtilization {
            try encodeContainer.encode(estimatedAverageUtilization, forKey: .estimatedAverageUtilization)
        }
        if let estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedOnDemandCost = estimatedOnDemandCost {
            try encodeContainer.encode(estimatedOnDemandCost, forKey: .estimatedOnDemandCost)
        }
        if let estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment {
            try encodeContainer.encode(estimatedOnDemandCostWithCurrentCommitment, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        }
        if let estimatedROI = estimatedROI {
            try encodeContainer.encode(estimatedROI, forKey: .estimatedROI)
        }
        if let estimatedSPCost = estimatedSPCost {
            try encodeContainer.encode(estimatedSPCost, forKey: .estimatedSPCost)
        }
        if let estimatedSavingsAmount = estimatedSavingsAmount {
            try encodeContainer.encode(estimatedSavingsAmount, forKey: .estimatedSavingsAmount)
        }
        if let estimatedSavingsPercentage = estimatedSavingsPercentage {
            try encodeContainer.encode(estimatedSavingsPercentage, forKey: .estimatedSavingsPercentage)
        }
        if let hourlyCommitmentToPurchase = hourlyCommitmentToPurchase {
            try encodeContainer.encode(hourlyCommitmentToPurchase, forKey: .hourlyCommitmentToPurchase)
        }
        if let savingsPlansDetails = savingsPlansDetails {
            try encodeContainer.encode(savingsPlansDetails, forKey: .savingsPlansDetails)
        }
        if let upfrontCost = upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansDetails.self, forKey: .savingsPlansDetails)
        savingsPlansDetails = savingsPlansDetailsDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let estimatedROIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedROI)
        estimatedROI = estimatedROIDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedSPCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSPCost)
        estimatedSPCost = estimatedSPCostDecoded
        let estimatedOnDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCost)
        estimatedOnDemandCost = estimatedOnDemandCostDecoded
        let estimatedOnDemandCostWithCurrentCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitmentDecoded
        let estimatedSavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsAmount)
        estimatedSavingsAmount = estimatedSavingsAmountDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let hourlyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyCommitmentToPurchase)
        hourlyCommitmentToPurchase = hourlyCommitmentToPurchaseDecoded
        let estimatedAverageUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedAverageUtilization)
        estimatedAverageUtilization = estimatedAverageUtilizationDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let currentMinimumHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentMinimumHourlyOnDemandSpend)
        currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpendDecoded
        let currentMaximumHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentMaximumHourlyOnDemandSpend)
        currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpendDecoded
        let currentAverageHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentAverageHourlyOnDemandSpend)
        currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpendDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details for your recommended Savings Plans.
    public struct SavingsPlansPurchaseRecommendationDetail: Swift.Equatable {
        /// The AccountID the recommendation is generated for.
        public var accountId: Swift.String?
        /// The currency code that Amazon Web Services used to generate the recommendations and present potential savings.
        public var currencyCode: Swift.String?
        /// The average value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentAverageHourlyOnDemandSpend: Swift.String?
        /// The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMaximumHourlyOnDemandSpend: Swift.String?
        /// The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMinimumHourlyOnDemandSpend: Swift.String?
        /// The estimated utilization of the recommended Savings Plans.
        public var estimatedAverageUtilization: Swift.String?
        /// The estimated monthly savings amount based on the recommended Savings Plans.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// The remaining On-Demand cost estimated to not be covered by the recommended Savings Plans, over the length of the lookback period.
        public var estimatedOnDemandCost: Swift.String?
        /// The estimated On-Demand costs you would expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
        public var estimatedOnDemandCostWithCurrentCommitment: Swift.String?
        /// The estimated return on investment that's based on the recommended Savings Plans that you purchased. This is calculated as estimatedSavingsAmount/ estimatedSPCost*100.
        public var estimatedROI: Swift.String?
        /// The cost of the recommended Savings Plans over the length of the lookback period.
        public var estimatedSPCost: Swift.String?
        /// The estimated savings amount that's based on the recommended Savings Plans over the length of the lookback period.
        public var estimatedSavingsAmount: Swift.String?
        /// The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.
        public var estimatedSavingsPercentage: Swift.String?
        /// The recommended hourly commitment level for the Savings Plans type and the configuration that's based on the usage during the lookback period.
        public var hourlyCommitmentToPurchase: Swift.String?
        /// Details for your recommended Savings Plans.
        public var savingsPlansDetails: CostExplorerClientTypes.SavingsPlansDetails?
        /// The upfront cost of the recommended Savings Plans, based on the selected payment option.
        public var upfrontCost: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            currencyCode: Swift.String? = nil,
            currentAverageHourlyOnDemandSpend: Swift.String? = nil,
            currentMaximumHourlyOnDemandSpend: Swift.String? = nil,
            currentMinimumHourlyOnDemandSpend: Swift.String? = nil,
            estimatedAverageUtilization: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedOnDemandCost: Swift.String? = nil,
            estimatedOnDemandCostWithCurrentCommitment: Swift.String? = nil,
            estimatedROI: Swift.String? = nil,
            estimatedSPCost: Swift.String? = nil,
            estimatedSavingsAmount: Swift.String? = nil,
            estimatedSavingsPercentage: Swift.String? = nil,
            hourlyCommitmentToPurchase: Swift.String? = nil,
            savingsPlansDetails: CostExplorerClientTypes.SavingsPlansDetails? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.currencyCode = currencyCode
            self.currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend
            self.currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend
            self.currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend
            self.estimatedAverageUtilization = estimatedAverageUtilization
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSPCost = estimatedSPCost
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.savingsPlansDetails = savingsPlansDetails
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetadata = "AdditionalMetadata"
        case generationTimestamp = "GenerationTimestamp"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetadata = additionalMetadata {
            try encodeContainer.encode(additionalMetadata, forKey: .additionalMetadata)
        }
        if let generationTimestamp = generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
        let additionalMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalMetadata)
        additionalMetadata = additionalMetadataDecoded
    }
}

extension CostExplorerClientTypes {
    /// Metadata about your Savings Plans Purchase Recommendations.
    public struct SavingsPlansPurchaseRecommendationMetadata: Swift.Equatable {
        /// Additional metadata that might be applicable to the recommendation.
        public var additionalMetadata: Swift.String?
        /// The timestamp showing when the recommendations were generated.
        public var generationTimestamp: Swift.String?
        /// The unique identifier for the recommendation set.
        public var recommendationId: Swift.String?

        public init (
            additionalMetadata: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.recommendationId = recommendationId
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case currentOnDemandSpend = "CurrentOnDemandSpend"
        case dailyCommitmentToPurchase = "DailyCommitmentToPurchase"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
        case estimatedROI = "EstimatedROI"
        case estimatedSavingsAmount = "EstimatedSavingsAmount"
        case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
        case estimatedTotalCost = "EstimatedTotalCost"
        case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
        case totalRecommendationCount = "TotalRecommendationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let currentOnDemandSpend = currentOnDemandSpend {
            try encodeContainer.encode(currentOnDemandSpend, forKey: .currentOnDemandSpend)
        }
        if let dailyCommitmentToPurchase = dailyCommitmentToPurchase {
            try encodeContainer.encode(dailyCommitmentToPurchase, forKey: .dailyCommitmentToPurchase)
        }
        if let estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment {
            try encodeContainer.encode(estimatedOnDemandCostWithCurrentCommitment, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        }
        if let estimatedROI = estimatedROI {
            try encodeContainer.encode(estimatedROI, forKey: .estimatedROI)
        }
        if let estimatedSavingsAmount = estimatedSavingsAmount {
            try encodeContainer.encode(estimatedSavingsAmount, forKey: .estimatedSavingsAmount)
        }
        if let estimatedSavingsPercentage = estimatedSavingsPercentage {
            try encodeContainer.encode(estimatedSavingsPercentage, forKey: .estimatedSavingsPercentage)
        }
        if let estimatedTotalCost = estimatedTotalCost {
            try encodeContainer.encode(estimatedTotalCost, forKey: .estimatedTotalCost)
        }
        if let hourlyCommitmentToPurchase = hourlyCommitmentToPurchase {
            try encodeContainer.encode(hourlyCommitmentToPurchase, forKey: .hourlyCommitmentToPurchase)
        }
        if let totalRecommendationCount = totalRecommendationCount {
            try encodeContainer.encode(totalRecommendationCount, forKey: .totalRecommendationCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedROIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedROI)
        estimatedROI = estimatedROIDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedTotalCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedTotalCost)
        estimatedTotalCost = estimatedTotalCostDecoded
        let currentOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentOnDemandSpend)
        currentOnDemandSpend = currentOnDemandSpendDecoded
        let estimatedSavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsAmount)
        estimatedSavingsAmount = estimatedSavingsAmountDecoded
        let totalRecommendationCountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRecommendationCount)
        totalRecommendationCount = totalRecommendationCountDecoded
        let dailyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dailyCommitmentToPurchase)
        dailyCommitmentToPurchase = dailyCommitmentToPurchaseDecoded
        let hourlyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyCommitmentToPurchase)
        hourlyCommitmentToPurchase = hourlyCommitmentToPurchaseDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let estimatedOnDemandCostWithCurrentCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// Summary metrics for your Savings Plans Purchase Recommendations.
    public struct SavingsPlansPurchaseRecommendationSummary: Swift.Equatable {
        /// The currency code that Amazon Web Services used to generate the recommendations and present potential savings.
        public var currencyCode: Swift.String?
        /// The current total on demand spend of the applicable usage types over the lookback period.
        public var currentOnDemandSpend: Swift.String?
        /// The recommended Savings Plans cost on a daily (24 hourly) basis.
        public var dailyCommitmentToPurchase: Swift.String?
        /// The estimated monthly savings amount that's based on the recommended Savings Plans purchase.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// The estimated On-Demand costs you would expect with no additional commitment. It's based on your usage of the selected time period and the Savings Plans you own.
        public var estimatedOnDemandCostWithCurrentCommitment: Swift.String?
        /// The estimated return on investment that's based on the recommended Savings Plans and estimated savings.
        public var estimatedROI: Swift.String?
        /// The estimated total savings over the lookback period, based on the purchase of the recommended Savings Plans.
        public var estimatedSavingsAmount: Swift.String?
        /// The estimated savings relative to the total cost of On-Demand usage, over the lookback period. This is calculated as estimatedSavingsAmount/ CurrentOnDemandSpend*100.
        public var estimatedSavingsPercentage: Swift.String?
        /// The estimated total cost of the usage after purchasing the recommended Savings Plans. This is a sum of the cost of Savings Plans during this term, and the remaining On-Demand usage.
        public var estimatedTotalCost: Swift.String?
        /// The recommended hourly commitment that's based on the recommendation parameters.
        public var hourlyCommitmentToPurchase: Swift.String?
        /// The aggregate number of Savings Plans recommendations that exist for your account.
        public var totalRecommendationCount: Swift.String?

        public init (
            currencyCode: Swift.String? = nil,
            currentOnDemandSpend: Swift.String? = nil,
            dailyCommitmentToPurchase: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedOnDemandCostWithCurrentCommitment: Swift.String? = nil,
            estimatedROI: Swift.String? = nil,
            estimatedSavingsAmount: Swift.String? = nil,
            estimatedSavingsPercentage: Swift.String? = nil,
            estimatedTotalCost: Swift.String? = nil,
            hourlyCommitmentToPurchase: Swift.String? = nil,
            totalRecommendationCount: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.currentOnDemandSpend = currentOnDemandSpend
            self.dailyCommitmentToPurchase = dailyCommitmentToPurchase
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.estimatedTotalCost = estimatedTotalCost
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.totalRecommendationCount = totalRecommendationCount
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansSavings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case netSavings = "NetSavings"
        case onDemandCostEquivalent = "OnDemandCostEquivalent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let netSavings = netSavings {
            try encodeContainer.encode(netSavings, forKey: .netSavings)
        }
        if let onDemandCostEquivalent = onDemandCostEquivalent {
            try encodeContainer.encode(onDemandCostEquivalent, forKey: .onDemandCostEquivalent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let netSavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .netSavings)
        netSavings = netSavingsDecoded
        let onDemandCostEquivalentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandCostEquivalent)
        onDemandCostEquivalent = onDemandCostEquivalentDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of savings that you're accumulating, against the public On-Demand rate of the usage accrued in an account.
    public struct SavingsPlansSavings: Swift.Equatable {
        /// The savings amount that you're accumulating for the usage that's covered by a Savings Plans, when compared to the On-Demand equivalent of the same usage.
        public var netSavings: Swift.String?
        /// How much the amount that the usage would have cost if it was accrued at the On-Demand rate.
        public var onDemandCostEquivalent: Swift.String?

        public init (
            netSavings: Swift.String? = nil,
            onDemandCostEquivalent: Swift.String? = nil
        )
        {
            self.netSavings = netSavings
            self.onDemandCostEquivalent = onDemandCostEquivalent
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case totalCommitment = "TotalCommitment"
        case unusedCommitment = "UnusedCommitment"
        case usedCommitment = "UsedCommitment"
        case utilizationPercentage = "UtilizationPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let totalCommitment = totalCommitment {
            try encodeContainer.encode(totalCommitment, forKey: .totalCommitment)
        }
        if let unusedCommitment = unusedCommitment {
            try encodeContainer.encode(unusedCommitment, forKey: .unusedCommitment)
        }
        if let usedCommitment = usedCommitment {
            try encodeContainer.encode(usedCommitment, forKey: .usedCommitment)
        }
        if let utilizationPercentage = utilizationPercentage {
            try encodeContainer.encode(utilizationPercentage, forKey: .utilizationPercentage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalCommitment)
        totalCommitment = totalCommitmentDecoded
        let usedCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usedCommitment)
        usedCommitment = usedCommitmentDecoded
        let unusedCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unusedCommitment)
        unusedCommitment = unusedCommitmentDecoded
        let utilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utilizationPercentage)
        utilizationPercentage = utilizationPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// The measurement of how well you're using your existing Savings Plans.
    public struct SavingsPlansUtilization: Swift.Equatable {
        /// The total amount of Savings Plans commitment that's been purchased in an account (or set of accounts).
        public var totalCommitment: Swift.String?
        /// The amount of your Savings Plans commitment that wasn't consumed from Savings Plans eligible usage in a specific period.
        public var unusedCommitment: Swift.String?
        /// The amount of your Savings Plans commitment that was consumed from Savings Plans eligible usage in a specific period.
        public var usedCommitment: Swift.String?
        /// The amount of UsedCommitment divided by the TotalCommitment for your Savings Plans.
        public var utilizationPercentage: Swift.String?

        public init (
            totalCommitment: Swift.String? = nil,
            unusedCommitment: Swift.String? = nil,
            usedCommitment: Swift.String? = nil,
            utilizationPercentage: Swift.String? = nil
        )
        {
            self.totalCommitment = totalCommitment
            self.unusedCommitment = unusedCommitment
            self.usedCommitment = usedCommitment
            self.utilizationPercentage = utilizationPercentage
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansUtilizationAggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case savings = "Savings"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let savings = savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let utilization = utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// The aggregated utilization metrics for your Savings Plans usage.
    public struct SavingsPlansUtilizationAggregates: Swift.Equatable {
        /// The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The amount saved by using existing Savings Plans. Savings returns both net savings from Savings Plans, as well as the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        /// This member is required.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init (
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.savings = savings
            self.utilization = utilization
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansUtilizationByTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case savings = "Savings"
        case timePeriod = "TimePeriod"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let savings = savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let utilization = utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let utilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of Savings Plans utilization, in hours.
    public struct SavingsPlansUtilizationByTime: Swift.Equatable {
        /// The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The amount saved by using existing Savings Plans. Savings returns both net savings from Savings Plans as well as the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// The time period of the request.
        /// This member is required.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        /// This member is required.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init (
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.savings = savings
            self.timePeriod = timePeriod
            self.utilization = utilization
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansUtilizationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case attributes = "Attributes"
        case savings = "Savings"
        case savingsPlanArn = "SavingsPlanArn"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let savings = savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let savingsPlanArn = savingsPlanArn {
            try encodeContainer.encode(savingsPlanArn, forKey: .savingsPlanArn)
        }
        if let utilization = utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanArn)
        savingsPlanArn = savingsPlanArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let utilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// A single daily or monthly Savings Plans utilization rate, and details for your account. A management account in an organization have access to member accounts. You can use GetDimensionValues to determine the possible dimension values.
    public struct SavingsPlansUtilizationDetail: Swift.Equatable {
        /// The total amortized commitment for a Savings Plans. Includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String:Swift.String]?
        /// The amount saved by using existing Savings Plans. Savings returns both net savings from savings plans as well as the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// The unique Amazon Resource Name (ARN) for a particular Savings Plan.
        public var savingsPlanArn: Swift.String?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init (
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            savingsPlanArn: Swift.String? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.attributes = attributes
            self.savings = savings
            self.savingsPlanArn = savingsPlanArn
            self.utilization = utilization
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've reached the limit on the number of resources you can create, or exceeded the size of an individual resource.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes.ServiceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eC2Specification = "EC2Specification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2Specification = eC2Specification {
            try encodeContainer.encode(eC2Specification, forKey: .eC2Specification)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eC2SpecificationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EC2Specification.self, forKey: .eC2Specification)
        eC2Specification = eC2SpecificationDecoded
    }
}

extension CostExplorerClientTypes {
    /// Hardware specifications for the service that you want recommendations for.
    public struct ServiceSpecification: Swift.Equatable {
        /// The Amazon EC2 hardware specifications that you want Amazon Web Services to provide recommendations for.
        public var eC2Specification: CostExplorerClientTypes.EC2Specification?

        public init (
            eC2Specification: CostExplorerClientTypes.EC2Specification? = nil
        )
        {
            self.eC2Specification = eC2Specification
        }
    }

}

extension CostExplorerClientTypes.SortDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension CostExplorerClientTypes {
    /// The details of how to sort the data.
    public struct SortDefinition: Swift.Equatable {
        /// The key that's used to sort the data.
        /// This member is required.
        public var key: Swift.String?
        /// The order that's used to sort the data.
        public var sortOrder: CostExplorerClientTypes.SortOrder?

        public init (
            key: Swift.String? = nil,
            sortOrder: CostExplorerClientTypes.SortOrder? = nil
        )
        {
            self.key = key
            self.sortOrder = sortOrder
        }
    }

}

extension CostExplorerClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.Subscriber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SubscriberType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SubscriberStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CostExplorerClientTypes {
    /// The recipient of AnomalySubscription notifications.
    public struct Subscriber: Swift.Equatable {
        /// The email address or SNS Amazon Resource Name (ARN). This depends on the Type.
        public var address: Swift.String?
        /// Indicates if the subscriber accepts the notifications.
        public var status: CostExplorerClientTypes.SubscriberStatus?
        /// The notification delivery channel.
        public var type: CostExplorerClientTypes.SubscriberType?

        public init (
            address: Swift.String? = nil,
            status: CostExplorerClientTypes.SubscriberStatus? = nil,
            type: CostExplorerClientTypes.SubscriberType? = nil
        )
        {
            self.address = address
            self.status = status
            self.type = type
        }
    }

}

extension CostExplorerClientTypes {
    public enum SubscriberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confirmed
        case declined
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriberStatus] {
            return [
                .confirmed,
                .declined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confirmed: return "CONFIRMED"
            case .declined: return "DECLINED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriberStatus(rawValue: rawValue) ?? SubscriberStatus.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum SubscriberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriberType] {
            return [
                .email,
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriberType(rawValue: rawValue) ?? SubscriberType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum SupportedSavingsPlansType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computeSp
        case ec2InstanceSp
        case sagemakerSp
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedSavingsPlansType] {
            return [
                .computeSp,
                .ec2InstanceSp,
                .sagemakerSp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computeSp: return "COMPUTE_SP"
            case .ec2InstanceSp: return "EC2_INSTANCE_SP"
            case .sagemakerSp: return "SAGEMAKER_SP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SupportedSavingsPlansType(rawValue: rawValue) ?? SupportedSavingsPlansType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.TagValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoptions0 in matchOptions {
                try matchOptionsContainer.encode(matchoptions0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[CostExplorerClientTypes.MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [CostExplorerClientTypes.MatchOption]()
            for string0 in matchOptionsContainer {
                if let string0 = string0 {
                    matchOptionsDecoded0?.append(string0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The values that are available for a tag. If Values and Key aren't specified, the ABSENTMatchOption is applied to all tags. That is, it's filtered on resources with no tags. If Values is provided and Key isn't specified, the ABSENTMatchOption is applied to the tag Key only. That is, it's filtered on resources without the given tag key.
    public struct TagValues: Swift.Equatable {
        /// The key for the tag.
        public var key: Swift.String?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to Cost Category. The default values for MatchOptions are EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The specific value of the tag.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }

}

extension CostExplorerClientTypes.TargetInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case defaultTargetInstance = "DefaultTargetInstance"
        case estimatedMonthlyCost = "EstimatedMonthlyCost"
        case estimatedMonthlySavings = "EstimatedMonthlySavings"
        case expectedResourceUtilization = "ExpectedResourceUtilization"
        case platformDifferences = "PlatformDifferences"
        case resourceDetails = "ResourceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if defaultTargetInstance != false {
            try encodeContainer.encode(defaultTargetInstance, forKey: .defaultTargetInstance)
        }
        if let estimatedMonthlyCost = estimatedMonthlyCost {
            try encodeContainer.encode(estimatedMonthlyCost, forKey: .estimatedMonthlyCost)
        }
        if let estimatedMonthlySavings = estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if let expectedResourceUtilization = expectedResourceUtilization {
            try encodeContainer.encode(expectedResourceUtilization, forKey: .expectedResourceUtilization)
        }
        if let platformDifferences = platformDifferences {
            var platformDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformDifferences)
            for platformdifferences0 in platformDifferences {
                try platformDifferencesContainer.encode(platformdifferences0.rawValue)
            }
        }
        if let resourceDetails = resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlyCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlyCost)
        estimatedMonthlyCost = estimatedMonthlyCostDecoded
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let defaultTargetInstanceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultTargetInstance)
        defaultTargetInstance = defaultTargetInstanceDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let expectedResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ResourceUtilization.self, forKey: .expectedResourceUtilization)
        expectedResourceUtilization = expectedResourceUtilizationDecoded
        let platformDifferencesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.PlatformDifference?].self, forKey: .platformDifferences)
        var platformDifferencesDecoded0:[CostExplorerClientTypes.PlatformDifference]? = nil
        if let platformDifferencesContainer = platformDifferencesContainer {
            platformDifferencesDecoded0 = [CostExplorerClientTypes.PlatformDifference]()
            for string0 in platformDifferencesContainer {
                if let string0 = string0 {
                    platformDifferencesDecoded0?.append(string0)
                }
            }
        }
        platformDifferences = platformDifferencesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// Details on recommended instance.
    public struct TargetInstance: Swift.Equatable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// Determines whether this recommendation is the defaulted Amazon Web Services recommendation.
        public var defaultTargetInstance: Swift.Bool
        /// The expected cost to operate this instance type on a monthly basis.
        public var estimatedMonthlyCost: Swift.String?
        /// The estimated savings that result from modification, on a monthly basis.
        public var estimatedMonthlySavings: Swift.String?
        /// The expected utilization metrics for target instance type.
        public var expectedResourceUtilization: CostExplorerClientTypes.ResourceUtilization?
        /// Explains the actions you might need to take in order to successfully migrate your workloads from the current instance type to the recommended instance type.
        public var platformDifferences: [CostExplorerClientTypes.PlatformDifference]?
        /// Details on the target instance type.
        public var resourceDetails: CostExplorerClientTypes.ResourceDetails?

        public init (
            currencyCode: Swift.String? = nil,
            defaultTargetInstance: Swift.Bool = false,
            estimatedMonthlyCost: Swift.String? = nil,
            estimatedMonthlySavings: Swift.String? = nil,
            expectedResourceUtilization: CostExplorerClientTypes.ResourceUtilization? = nil,
            platformDifferences: [CostExplorerClientTypes.PlatformDifference]? = nil,
            resourceDetails: CostExplorerClientTypes.ResourceDetails? = nil
        )
        {
            self.currencyCode = currencyCode
            self.defaultTargetInstance = defaultTargetInstance
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.expectedResourceUtilization = expectedResourceUtilization
            self.platformDifferences = platformDifferences
            self.resourceDetails = resourceDetails
        }
    }

}

extension CostExplorerClientTypes {
    public enum TermInYears: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneYear
        case threeYears
        case sdkUnknown(Swift.String)

        public static var allCases: [TermInYears] {
            return [
                .oneYear,
                .threeYears,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "ONE_YEAR"
            case .threeYears: return "THREE_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TermInYears(rawValue: rawValue) ?? TermInYears.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.TerminateRecommendationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case estimatedMonthlySavings = "EstimatedMonthlySavings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let estimatedMonthlySavings = estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details on termination recommendation.
    public struct TerminateRecommendationDetail: Swift.Equatable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// The estimated savings that result from modification, on a monthly basis.
        public var estimatedMonthlySavings: Swift.String?

        public init (
            currencyCode: Swift.String? = nil,
            estimatedMonthlySavings: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.estimatedMonthlySavings = estimatedMonthlySavings
        }
    }

}

extension CostExplorerClientTypes.TotalImpactFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endValue = "EndValue"
        case numericOperator = "NumericOperator"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if endValue != 0.0 {
            try encodeContainer.encode(endValue, forKey: .endValue)
        }
        if let numericOperator = numericOperator {
            try encodeContainer.encode(numericOperator.rawValue, forKey: .numericOperator)
        }
        if startValue != 0.0 {
            try encodeContainer.encode(startValue, forKey: .startValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numericOperatorDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.NumericOperator.self, forKey: .numericOperator)
        numericOperator = numericOperatorDecoded
        let startValueDecoded = try containerValues.decode(Swift.Double.self, forKey: .startValue)
        startValue = startValueDecoded
        let endValueDecoded = try containerValues.decode(Swift.Double.self, forKey: .endValue)
        endValue = endValueDecoded
    }
}

extension CostExplorerClientTypes {
    /// Filters cost anomalies based on the total impact.
    public struct TotalImpactFilter: Swift.Equatable {
        /// The upper bound dollar value that's used in the filter.
        public var endValue: Swift.Double
        /// The comparing value that's used in the filter.
        /// This member is required.
        public var numericOperator: CostExplorerClientTypes.NumericOperator?
        /// The lower bound dollar value that's used in the filter.
        /// This member is required.
        public var startValue: Swift.Double

        public init (
            endValue: Swift.Double = 0.0,
            numericOperator: CostExplorerClientTypes.NumericOperator? = nil,
            startValue: Swift.Double = 0.0
        )
        {
            self.endValue = endValue
            self.numericOperator = numericOperator
            self.startValue = startValue
        }
    }

}

extension UnknownMonitorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnknownMonitorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The cost anomaly monitor does not exist for the account.
public struct UnknownMonitorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownMonitorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnknownMonitorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownSubscriptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnknownSubscriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The cost anomaly subscription does not exist for the account.
public struct UnknownSubscriptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownSubscriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnknownSubscriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnresolvableUsageUnitException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnresolvableUsageUnitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Cost Explorer was unable to identify the usage unit. Provide UsageType/UsageTypeGroup filter selections that contain matching units, for example: hours.
public struct UnresolvableUsageUnitException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnresolvableUsageUnitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnresolvableUsageUnitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateAnomalyMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorName = monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
    }
}

extension UpdateAnomalyMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAnomalyMonitorInput: Swift.Equatable {
    /// Cost anomaly monitor Amazon Resource Names (ARNs).
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The new name for the cost anomaly monitor.
    public var monitorName: Swift.String?

    public init (
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
        self.monitorName = monitorName
    }
}

struct UpdateAnomalyMonitorInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
    let monitorName: Swift.String?
}

extension UpdateAnomalyMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
    }
}

extension UpdateAnomalyMonitorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnomalyMonitorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnomalyMonitorOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnomalyMonitorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAnomalyMonitorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.monitorArn = output.monitorArn
        } else {
            self.monitorArn = nil
        }
    }
}

public struct UpdateAnomalyMonitorOutputResponse: Swift.Equatable {
    /// A cost anomaly monitor ARN.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init (
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct UpdateAnomalyMonitorOutputResponseBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension UpdateAnomalyMonitorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension UpdateAnomalySubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for monitorarnlist0 in monitorArnList {
                try monitorArnListContainer.encode(monitorarnlist0)
            }
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
        if let subscriptionArn = subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }
}

extension UpdateAnomalySubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAnomalySubscriptionInput: Swift.Equatable {
    /// The update to the frequency value that subscribers receive notifications.
    public var frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency?
    /// A list of cost anomaly monitor ARNs.
    public var monitorArnList: [Swift.String]?
    /// The update to the subscriber list.
    public var subscribers: [CostExplorerClientTypes.Subscriber]?
    /// A cost anomaly subscription Amazon Resource Name (ARN).
    /// This member is required.
    public var subscriptionArn: Swift.String?
    /// The new name of the subscription.
    public var subscriptionName: Swift.String?
    /// The update to the threshold value for receiving notifications.
    public var threshold: Swift.Double?

    public init (
        frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency? = nil,
        monitorArnList: [Swift.String]? = nil,
        subscribers: [CostExplorerClientTypes.Subscriber]? = nil,
        subscriptionArn: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        threshold: Swift.Double? = nil
    )
    {
        self.frequency = frequency
        self.monitorArnList = monitorArnList
        self.subscribers = subscribers
        self.subscriptionArn = subscriptionArn
        self.subscriptionName = subscriptionName
        self.threshold = threshold
    }
}

struct UpdateAnomalySubscriptionInputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
    let threshold: Swift.Double?
    let frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency?
    let monitorArnList: [Swift.String]?
    let subscribers: [CostExplorerClientTypes.Subscriber]?
    let subscriptionName: Swift.String?
}

extension UpdateAnomalySubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalySubscriptionFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let monitorArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[Swift.String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [Swift.String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let subscribersContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[CostExplorerClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [CostExplorerClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension UpdateAnomalySubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnomalySubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownSubscriptionException" : self = .unknownSubscriptionException(try UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnomalySubscriptionOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknownSubscriptionException(UnknownSubscriptionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnomalySubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAnomalySubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

public struct UpdateAnomalySubscriptionOutputResponse: Swift.Equatable {
    /// A cost anomaly subscription ARN.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init (
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct UpdateAnomalySubscriptionOutputResponseBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension UpdateAnomalySubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension UpdateCostCategoryDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryruleslist0 in rules {
                try rulesContainer.encode(costcategoryruleslist0)
            }
        }
        if let splitChargeRules = splitChargeRules {
            var splitChargeRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .splitChargeRules)
            for costcategorysplitchargeruleslist0 in splitChargeRules {
                try splitChargeRulesContainer.encode(costcategorysplitchargeruleslist0)
            }
        }
    }
}

extension UpdateCostCategoryDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCostCategoryDefinitionInput: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?
    /// The default value for the cost category.
    public var defaultValue: Swift.String?
    /// The rule schema version in this particular Cost Category.
    /// This member is required.
    public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    /// The Expression object used to categorize costs. For more information, see [CostCategoryRule ](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html).
    /// This member is required.
    public var rules: [CostExplorerClientTypes.CostCategoryRule]?
    /// The split charge rules used to allocate your charges between your Cost Category values.
    public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

    public init (
        costCategoryArn: Swift.String? = nil,
        defaultValue: Swift.String? = nil,
        ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
        rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
        splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.defaultValue = defaultValue
        self.ruleVersion = ruleVersion
        self.rules = rules
        self.splitChargeRules = splitChargeRules
    }
}

struct UpdateCostCategoryDefinitionInputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    let rules: [CostExplorerClientTypes.CostCategoryRule]?
    let defaultValue: Swift.String?
    let splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?
}

extension UpdateCostCategoryDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostExplorerClientTypes.CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostExplorerClientTypes.CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let splitChargeRulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategorySplitChargeRule?].self, forKey: .splitChargeRules)
        var splitChargeRulesDecoded0:[CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        if let splitChargeRulesContainer = splitChargeRulesContainer {
            splitChargeRulesDecoded0 = [CostExplorerClientTypes.CostCategorySplitChargeRule]()
            for structure0 in splitChargeRulesContainer {
                if let structure0 = structure0 {
                    splitChargeRulesDecoded0?.append(structure0)
                }
            }
        }
        splitChargeRules = splitChargeRulesDecoded0
    }
}

extension UpdateCostCategoryDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCostCategoryDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCostCategoryDefinitionOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCostCategoryDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateCostCategoryDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveStart = output.effectiveStart
        } else {
            self.costCategoryArn = nil
            self.effectiveStart = nil
        }
    }
}

public struct UpdateCostCategoryDefinitionOutputResponse: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    public var costCategoryArn: Swift.String?
    /// The Cost Category's effective start date.
    public var effectiveStart: Swift.String?

    public init (
        costCategoryArn: Swift.String? = nil,
        effectiveStart: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveStart = effectiveStart
    }
}

struct UpdateCostCategoryDefinitionOutputResponseBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveStart: Swift.String?
}

extension UpdateCostCategoryDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveStart = "EffectiveStart"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
    }
}

extension CostExplorerClientTypes.UtilizationByTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for reservationutilizationgroups0 in groups {
                try groupsContainer.encode(reservationutilizationgroups0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ReservationUtilizationGroup?].self, forKey: .groups)
        var groupsDecoded0:[CostExplorerClientTypes.ReservationUtilizationGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [CostExplorerClientTypes.ReservationUtilizationGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationAggregates.self, forKey: .total)
        total = totalDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of utilization, in hours.
    public struct UtilizationByTime: Swift.Equatable {
        /// The groups that this utilization result uses.
        public var groups: [CostExplorerClientTypes.ReservationUtilizationGroup]?
        /// The period of time that this utilization was used for.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total number of reservation hours that were used.
        public var total: CostExplorerClientTypes.ReservationAggregates?

        public init (
            groups: [CostExplorerClientTypes.ReservationUtilizationGroup]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: CostExplorerClientTypes.ReservationAggregates? = nil
        )
        {
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }

}
