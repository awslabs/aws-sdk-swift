// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eq = "eq"
        case equals = "equals"
        case greaterThan = "greaterThan"
        case greaterThanOrEqual = "greaterThanOrEqual"
        case gt = "gt"
        case gte = "gte"
        case lessThan = "lessThan"
        case lessThanOrEqual = "lessThanOrEqual"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
        case notEquals = "notEquals"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for eq0 in eq {
                try eqContainer.encode(eq0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for equals0 in equals {
                try equalsContainer.encode(equals0)
            }
        }
        if greaterThan != 0 {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if greaterThanOrEqual != 0 {
            try encodeContainer.encode(greaterThanOrEqual, forKey: .greaterThanOrEqual)
        }
        if gt != 0 {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if gte != 0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lessThan != 0 {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
        if lessThanOrEqual != 0 {
            try encodeContainer.encode(lessThanOrEqual, forKey: .lessThanOrEqual)
        }
        if lt != 0 {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if lte != 0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for neq0 in neq {
                try neqContainer.encode(neq0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for notequals0 in notEquals {
                try notEqualsContainer.encode(notequals0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eq)
        var eqDecoded0:[String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let neqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .neq)
        var neqDecoded0:[String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let gtDecoded = try containerValues.decode(Int.self, forKey: .gt)
        gt = gtDecoded
        let gteDecoded = try containerValues.decode(Int.self, forKey: .gte)
        gte = gteDecoded
        let ltDecoded = try containerValues.decode(Int.self, forKey: .lt)
        lt = ltDecoded
        let lteDecoded = try containerValues.decode(Int.self, forKey: .lte)
        lte = lteDecoded
        let equalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .equals)
        var equalsDecoded0:[String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let greaterThanDecoded = try containerValues.decode(Int.self, forKey: .greaterThan)
        greaterThan = greaterThanDecoded
        let greaterThanOrEqualDecoded = try containerValues.decode(Int.self, forKey: .greaterThanOrEqual)
        greaterThanOrEqual = greaterThanOrEqualDecoded
        let lessThanDecoded = try containerValues.decode(Int.self, forKey: .lessThan)
        lessThan = lessThanDecoded
        let lessThanOrEqualDecoded = try containerValues.decode(Int.self, forKey: .lessThanOrEqual)
        lessThanOrEqual = lessThanOrEqualDecoded
    }
}
