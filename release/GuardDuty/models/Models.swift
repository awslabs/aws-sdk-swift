// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptInvitationInputBodyMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

extension AcceptInvitationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptInvitationInput(detectorId: \(String(describing: detectorId)), invitationId: \(String(describing: invitationId)), masterId: \(String(describing: masterId)))"}
}

extension AcceptInvitationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invitationId = "invitationId"
        case masterId = "masterId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let masterId = masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
    }
}

public struct AcceptInvitationInputHeadersMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInputQueryItemMiddleware: Middleware {
    public let id: String = "AcceptInvitationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcceptInvitationInput>,
                  next: H) -> Swift.Result<OperationOutput<AcceptInvitationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcceptInvitationInput>
    public typealias MOutput = OperationOutput<AcceptInvitationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcceptInvitationOutputError>
}

public struct AcceptInvitationInput: Equatable {
    /// <p>The unique ID of the detector of the GuardDuty member account.</p>
    public let detectorId: String?
    /// <p>The value that is used to validate the administrator account to the member account.</p>
    public let invitationId: String?
    /// <p>The account ID of the GuardDuty administrator account whose invitation you're accepting.</p>
    public let masterId: String?

    public init (
        detectorId: String? = nil,
        invitationId: String? = nil,
        masterId: String? = nil
    )
    {
        self.detectorId = detectorId
        self.invitationId = invitationId
        self.masterId = masterId
    }
}

struct AcceptInvitationInputBody: Equatable {
    public let masterId: String?
    public let invitationId: String?
}

extension AcceptInvitationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitationId = "invitationId"
        case masterId = "masterId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptInvitationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptInvitationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcceptInvitationOutputResponse()"}
}

extension AcceptInvitationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AcceptInvitationOutputResponse: Equatable {

    public init() {}
}

struct AcceptInvitationOutputResponseBody: Equatable {
}

extension AcceptInvitationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AccessControlList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decode(Bool.self, forKey: .allowsPublicReadAccess)
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decode(Bool.self, forKey: .allowsPublicWriteAccess)
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension AccessControlList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessControlList(allowsPublicReadAccess: \(String(describing: allowsPublicReadAccess)), allowsPublicWriteAccess: \(String(describing: allowsPublicWriteAccess)))"}
}

/// <p>Contains information on the current access control policies for the bucket.</p>
public struct AccessControlList: Equatable {
    /// <p>A value that indicates whether public read access for the bucket is enabled through an
    ///       Access Control List (ACL).</p>
    public let allowsPublicReadAccess: Bool
    /// <p>A value that indicates whether public write access for the bucket is enabled through an
    ///       Access Control List (ACL).</p>
    public let allowsPublicWriteAccess: Bool

    public init (
        allowsPublicReadAccess: Bool = false,
        allowsPublicWriteAccess: Bool = false
    )
    {
        self.allowsPublicReadAccess = allowsPublicReadAccess
        self.allowsPublicWriteAccess = allowsPublicWriteAccess
    }
}

extension AccessKeyDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "accessKeyId"
        case principalId = "principalId"
        case userName = "userName"
        case userType = "userType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = userType {
            try encodeContainer.encode(userType, forKey: .userType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userType)
        userType = userTypeDecoded
    }
}

extension AccessKeyDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessKeyDetails(accessKeyId: \(String(describing: accessKeyId)), principalId: \(String(describing: principalId)), userName: \(String(describing: userName)), userType: \(String(describing: userType)))"}
}

/// <p>Contains information about the access keys.</p>
public struct AccessKeyDetails: Equatable {
    /// <p>The access key ID of the user.</p>
    public let accessKeyId: String?
    /// <p>The principal ID of the user.</p>
    public let principalId: String?
    /// <p>The name of the user.</p>
    public let userName: String?
    /// <p>The type of the user.</p>
    public let userType: String?

    public init (
        accessKeyId: String? = nil,
        principalId: String? = nil,
        userName: String? = nil,
        userType: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.principalId = principalId
        self.userName = userName
        self.userType = userType
    }
}

extension AccountDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case email = "email"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
    }
}

extension AccountDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountDetail(accountId: \(String(describing: accountId)), email: \(String(describing: email)))"}
}

/// <p>Contains information about the account.</p>
public struct AccountDetail: Equatable {
    /// <p>The member account ID.</p>
    public let accountId: String?
    /// <p>The email address of the member account.</p>
    public let email: String?

    public init (
        accountId: String? = nil,
        email: String? = nil
    )
    {
        self.accountId = accountId
        self.email = email
    }
}

extension AccountLevelPermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockPublicAccess = "blockPublicAccess"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockPublicAccess = blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension AccountLevelPermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountLevelPermissions(blockPublicAccess: \(String(describing: blockPublicAccess)))"}
}

/// <p>Contains information about the account level permissions on the S3 bucket.</p>
public struct AccountLevelPermissions: Equatable {
    /// <p>Describes the S3 Block Public Access settings of the bucket's parent account.</p>
    public let blockPublicAccess: BlockPublicAccess?

    public init (
        blockPublicAccess: BlockPublicAccess? = nil
    )
    {
        self.blockPublicAccess = blockPublicAccess
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionType = "actionType"
        case awsApiCallAction = "awsApiCallAction"
        case dnsRequestAction = "dnsRequestAction"
        case networkConnectionAction = "networkConnectionAction"
        case portProbeAction = "portProbeAction"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
        if let awsApiCallAction = awsApiCallAction {
            try encodeContainer.encode(awsApiCallAction, forKey: .awsApiCallAction)
        }
        if let dnsRequestAction = dnsRequestAction {
            try encodeContainer.encode(dnsRequestAction, forKey: .dnsRequestAction)
        }
        if let networkConnectionAction = networkConnectionAction {
            try encodeContainer.encode(networkConnectionAction, forKey: .networkConnectionAction)
        }
        if let portProbeAction = portProbeAction {
            try encodeContainer.encode(portProbeAction, forKey: .portProbeAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let awsApiCallActionDecoded = try containerValues.decodeIfPresent(AwsApiCallAction.self, forKey: .awsApiCallAction)
        awsApiCallAction = awsApiCallActionDecoded
        let dnsRequestActionDecoded = try containerValues.decodeIfPresent(DnsRequestAction.self, forKey: .dnsRequestAction)
        dnsRequestAction = dnsRequestActionDecoded
        let networkConnectionActionDecoded = try containerValues.decodeIfPresent(NetworkConnectionAction.self, forKey: .networkConnectionAction)
        networkConnectionAction = networkConnectionActionDecoded
        let portProbeActionDecoded = try containerValues.decodeIfPresent(PortProbeAction.self, forKey: .portProbeAction)
        portProbeAction = portProbeActionDecoded
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(actionType: \(String(describing: actionType)), awsApiCallAction: \(String(describing: awsApiCallAction)), dnsRequestAction: \(String(describing: dnsRequestAction)), networkConnectionAction: \(String(describing: networkConnectionAction)), portProbeAction: \(String(describing: portProbeAction)))"}
}

/// <p>Contains information about actions.</p>
public struct Action: Equatable {
    /// <p>The GuardDuty finding activity type.</p>
    public let actionType: String?
    /// <p>Information about the AWS_API_CALL action described in this finding.</p>
    public let awsApiCallAction: AwsApiCallAction?
    /// <p>Information about the DNS_REQUEST action described in this finding.</p>
    public let dnsRequestAction: DnsRequestAction?
    /// <p>Information about the NETWORK_CONNECTION action described in this finding.</p>
    public let networkConnectionAction: NetworkConnectionAction?
    /// <p>Information about the PORT_PROBE action described in this finding.</p>
    public let portProbeAction: PortProbeAction?

    public init (
        actionType: String? = nil,
        awsApiCallAction: AwsApiCallAction? = nil,
        dnsRequestAction: DnsRequestAction? = nil,
        networkConnectionAction: NetworkConnectionAction? = nil,
        portProbeAction: PortProbeAction? = nil
    )
    {
        self.actionType = actionType
        self.awsApiCallAction = awsApiCallAction
        self.dnsRequestAction = dnsRequestAction
        self.networkConnectionAction = networkConnectionAction
        self.portProbeAction = portProbeAction
    }
}

extension AdminAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "adminAccountId"
        case adminStatus = "adminStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
        if let adminStatus = adminStatus {
            try encodeContainer.encode(adminStatus.rawValue, forKey: .adminStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let adminStatusDecoded = try containerValues.decodeIfPresent(AdminStatus.self, forKey: .adminStatus)
        adminStatus = adminStatusDecoded
    }
}

extension AdminAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdminAccount(adminAccountId: \(String(describing: adminAccountId)), adminStatus: \(String(describing: adminStatus)))"}
}

/// <p>The account within the organization specified as the GuardDuty delegated
///       administrator.</p>
public struct AdminAccount: Equatable {
    /// <p>The AWS account ID for the account.</p>
    public let adminAccountId: String?
    /// <p>Indicates whether the account is enabled as the delegated administrator.</p>
    public let adminStatus: AdminStatus?

    public init (
        adminAccountId: String? = nil,
        adminStatus: AdminStatus? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.adminStatus = adminStatus
    }
}

public enum AdminStatus {
    case disableInProgress
    case enabled
    case sdkUnknown(String)
}

extension AdminStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdminStatus] {
        return [
            .disableInProgress,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disableInProgress: return "DISABLE_IN_PROGRESS"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdminStatus(rawValue: rawValue) ?? AdminStatus.sdkUnknown(rawValue)
    }
}

public struct ArchiveFindingsInputBodyMiddleware: Middleware {
    public let id: String = "ArchiveFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ArchiveFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ArchiveFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ArchiveFindingsInput>
    public typealias MOutput = OperationOutput<ArchiveFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ArchiveFindingsOutputError>
}

extension ArchiveFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArchiveFindingsInput(detectorId: \(String(describing: detectorId)), findingIds: \(String(describing: findingIds)))"}
}

extension ArchiveFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
    }
}

public struct ArchiveFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "ArchiveFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ArchiveFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ArchiveFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ArchiveFindingsInput>
    public typealias MOutput = OperationOutput<ArchiveFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ArchiveFindingsOutputError>
}

public struct ArchiveFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ArchiveFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ArchiveFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ArchiveFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ArchiveFindingsInput>
    public typealias MOutput = OperationOutput<ArchiveFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ArchiveFindingsOutputError>
}

public struct ArchiveFindingsInput: Equatable {
    /// <p>The ID of the detector that specifies the GuardDuty service whose findings you want to
    ///       archive.</p>
    public let detectorId: String?
    /// <p>The IDs of the findings that you want to archive.</p>
    public let findingIds: [String]?

    public init (
        detectorId: String? = nil,
        findingIds: [String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
    }
}

struct ArchiveFindingsInputBody: Equatable {
    public let findingIds: [String]?
}

extension ArchiveFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
    }
}

extension ArchiveFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ArchiveFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ArchiveFindingsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ArchiveFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArchiveFindingsOutputResponse()"}
}

extension ArchiveFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ArchiveFindingsOutputResponse: Equatable {

    public init() {}
}

struct ArchiveFindingsOutputResponseBody: Equatable {
}

extension ArchiveFindingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AwsApiCallAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case api = "api"
        case callerType = "callerType"
        case domainDetails = "domainDetails"
        case errorCode = "errorCode"
        case remoteIpDetails = "remoteIpDetails"
        case serviceName = "serviceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let api = api {
            try encodeContainer.encode(api, forKey: .api)
        }
        if let callerType = callerType {
            try encodeContainer.encode(callerType, forKey: .callerType)
        }
        if let domainDetails = domainDetails {
            try encodeContainer.encode(domainDetails, forKey: .domainDetails)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .api)
        api = apiDecoded
        let callerTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerType)
        callerType = callerTypeDecoded
        let domainDetailsDecoded = try containerValues.decodeIfPresent(DomainDetails.self, forKey: .domainDetails)
        domainDetails = domainDetailsDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AwsApiCallAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsApiCallAction(api: \(String(describing: api)), callerType: \(String(describing: callerType)), domainDetails: \(String(describing: domainDetails)), errorCode: \(String(describing: errorCode)), remoteIpDetails: \(String(describing: remoteIpDetails)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>Contains information about the API action.</p>
public struct AwsApiCallAction: Equatable {
    /// <p>The AWS API name.</p>
    public let api: String?
    /// <p>The AWS API caller type.</p>
    public let callerType: String?
    /// <p>The domain information for the AWS API call.</p>
    public let domainDetails: DomainDetails?
    /// <p>The error code of the failed AWS API action.</p>
    public let errorCode: String?
    /// <p>The remote IP information of the connection that initiated the AWS API call.</p>
    public let remoteIpDetails: RemoteIpDetails?
    /// <p>The AWS service name whose API was invoked.</p>
    public let serviceName: String?

    public init (
        api: String? = nil,
        callerType: String? = nil,
        domainDetails: DomainDetails? = nil,
        errorCode: String? = nil,
        remoteIpDetails: RemoteIpDetails? = nil,
        serviceName: String? = nil
    )
    {
        self.api = api
        self.callerType = callerType
        self.domainDetails = domainDetails
        self.errorCode = errorCode
        self.remoteIpDetails = remoteIpDetails
        self.serviceName = serviceName
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A bad request exception object.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The error message.</p>
    public var message: String?
    /// <p>The error type.</p>
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
    public let type: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension BlockPublicAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blockPublicAcls = "blockPublicAcls"
        case blockPublicPolicy = "blockPublicPolicy"
        case ignorePublicAcls = "ignorePublicAcls"
        case restrictPublicBuckets = "restrictPublicBuckets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicAcls != false {
            try encodeContainer.encode(blockPublicAcls, forKey: .blockPublicAcls)
        }
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if ignorePublicAcls != false {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if restrictPublicBuckets != false {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignorePublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decode(Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
        let blockPublicAclsDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicAcls)
        blockPublicAcls = blockPublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decode(Bool.self, forKey: .blockPublicPolicy)
        blockPublicPolicy = blockPublicPolicyDecoded
    }
}

extension BlockPublicAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlockPublicAccess(blockPublicAcls: \(String(describing: blockPublicAcls)), blockPublicPolicy: \(String(describing: blockPublicPolicy)), ignorePublicAcls: \(String(describing: ignorePublicAcls)), restrictPublicBuckets: \(String(describing: restrictPublicBuckets)))"}
}

/// <p>Contains information on how the bucker owner's S3 Block Public Access settings are being
///       applied to the S3 bucket. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html">S3 Block Public
///         Access</a> for more information. </p>
public struct BlockPublicAccess: Equatable {
    /// <p>Indicates if S3 Block Public Access is set to <code>BlockPublicAcls</code>.</p>
    public let blockPublicAcls: Bool
    /// <p>Indicates if S3 Block Public Access is set to <code>BlockPublicPolicy</code>.</p>
    public let blockPublicPolicy: Bool
    /// <p>Indicates if S3 Block Public Access is set to <code>IgnorePublicAcls</code>.</p>
    public let ignorePublicAcls: Bool
    /// <p>Indicates if S3 Block Public Access is set to <code>RestrictPublicBuckets</code>.</p>
    public let restrictPublicBuckets: Bool

    public init (
        blockPublicAcls: Bool = false,
        blockPublicPolicy: Bool = false,
        ignorePublicAcls: Bool = false,
        restrictPublicBuckets: Bool = false
    )
    {
        self.blockPublicAcls = blockPublicAcls
        self.blockPublicPolicy = blockPublicPolicy
        self.ignorePublicAcls = ignorePublicAcls
        self.restrictPublicBuckets = restrictPublicBuckets
    }
}

extension BucketLevelPermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessControlList = "accessControlList"
        case blockPublicAccess = "blockPublicAccess"
        case bucketPolicy = "bucketPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = accessControlList {
            try encodeContainer.encode(accessControlList, forKey: .accessControlList)
        }
        if let blockPublicAccess = blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
        if let bucketPolicy = bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(BucketPolicy.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension BucketLevelPermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketLevelPermissions(accessControlList: \(String(describing: accessControlList)), blockPublicAccess: \(String(describing: blockPublicAccess)), bucketPolicy: \(String(describing: bucketPolicy)))"}
}

/// <p>Contains information about the bucket level permissions for the S3 bucket.</p>
public struct BucketLevelPermissions: Equatable {
    /// <p>Contains information on how Access Control Policies are applied to the bucket.</p>
    public let accessControlList: AccessControlList?
    /// <p>Contains information on which account level S3 Block Public Access settings are applied to
    ///       the S3 bucket.</p>
    public let blockPublicAccess: BlockPublicAccess?
    /// <p>Contains information on the bucket policies for the S3 bucket.</p>
    public let bucketPolicy: BucketPolicy?

    public init (
        accessControlList: AccessControlList? = nil,
        blockPublicAccess: BlockPublicAccess? = nil,
        bucketPolicy: BucketPolicy? = nil
    )
    {
        self.accessControlList = accessControlList
        self.blockPublicAccess = blockPublicAccess
        self.bucketPolicy = bucketPolicy
    }
}

extension BucketPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decode(Bool.self, forKey: .allowsPublicReadAccess)
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decode(Bool.self, forKey: .allowsPublicWriteAccess)
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension BucketPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BucketPolicy(allowsPublicReadAccess: \(String(describing: allowsPublicReadAccess)), allowsPublicWriteAccess: \(String(describing: allowsPublicWriteAccess)))"}
}

/// <p>Contains information on the current bucket policies for the S3 bucket.</p>
public struct BucketPolicy: Equatable {
    /// <p>A value that indicates whether public read access for the bucket is enabled through a
    ///       bucket policy.</p>
    public let allowsPublicReadAccess: Bool
    /// <p>A value that indicates whether public write access for the bucket is enabled through a
    ///       bucket policy.</p>
    public let allowsPublicWriteAccess: Bool

    public init (
        allowsPublicReadAccess: Bool = false,
        allowsPublicWriteAccess: Bool = false
    )
    {
        self.allowsPublicReadAccess = allowsPublicReadAccess
        self.allowsPublicWriteAccess = allowsPublicWriteAccess
    }
}

extension City: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cityName = "cityName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cityName = cityName {
            try encodeContainer.encode(cityName, forKey: .cityName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cityName)
        cityName = cityNameDecoded
    }
}

extension City: CustomDebugStringConvertible {
    public var debugDescription: String {
        "City(cityName: \(String(describing: cityName)))"}
}

/// <p>Contains information about the city associated with the IP address.</p>
public struct City: Equatable {
    /// <p>The city name of the remote IP address.</p>
    public let cityName: String?

    public init (
        cityName: String? = nil
    )
    {
        self.cityName = cityName
    }
}

extension CloudTrailConfigurationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CloudTrailConfigurationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudTrailConfigurationResult(status: \(String(describing: status)))"}
}

/// <p>Contains information on the status of CloudTrail as a data source for the detector.</p>
public struct CloudTrailConfigurationResult: Equatable {
    /// <p>Describes whether CloudTrail is enabled as a data source for the detector.</p>
    public let status: DataSourceStatus?

    public init (
        status: DataSourceStatus? = nil
    )
    {
        self.status = status
    }
}

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eq = "eq"
        case equals = "equals"
        case greaterThan = "greaterThan"
        case greaterThanOrEqual = "greaterThanOrEqual"
        case gt = "gt"
        case gte = "gte"
        case lessThan = "lessThan"
        case lessThanOrEqual = "lessThanOrEqual"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
        case notEquals = "notEquals"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for eq0 in eq {
                try eqContainer.encode(eq0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for equals0 in equals {
                try equalsContainer.encode(equals0)
            }
        }
        if greaterThan != 0 {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if greaterThanOrEqual != 0 {
            try encodeContainer.encode(greaterThanOrEqual, forKey: .greaterThanOrEqual)
        }
        if gt != 0 {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if gte != 0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lessThan != 0 {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
        if lessThanOrEqual != 0 {
            try encodeContainer.encode(lessThanOrEqual, forKey: .lessThanOrEqual)
        }
        if lt != 0 {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if lte != 0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for neq0 in neq {
                try neqContainer.encode(neq0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for notequals0 in notEquals {
                try notEqualsContainer.encode(notequals0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eq)
        var eqDecoded0:[String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let neqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .neq)
        var neqDecoded0:[String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let gtDecoded = try containerValues.decode(Int.self, forKey: .gt)
        gt = gtDecoded
        let gteDecoded = try containerValues.decode(Int.self, forKey: .gte)
        gte = gteDecoded
        let ltDecoded = try containerValues.decode(Int.self, forKey: .lt)
        lt = ltDecoded
        let lteDecoded = try containerValues.decode(Int.self, forKey: .lte)
        lte = lteDecoded
        let equalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .equals)
        var equalsDecoded0:[String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let greaterThanDecoded = try containerValues.decode(Int.self, forKey: .greaterThan)
        greaterThan = greaterThanDecoded
        let greaterThanOrEqualDecoded = try containerValues.decode(Int.self, forKey: .greaterThanOrEqual)
        greaterThanOrEqual = greaterThanOrEqualDecoded
        let lessThanDecoded = try containerValues.decode(Int.self, forKey: .lessThan)
        lessThan = lessThanDecoded
        let lessThanOrEqualDecoded = try containerValues.decode(Int.self, forKey: .lessThanOrEqual)
        lessThanOrEqual = lessThanOrEqualDecoded
    }
}

extension Condition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Condition(eq: \(String(describing: eq)), equals: \(String(describing: equals)), greaterThan: \(String(describing: greaterThan)), greaterThanOrEqual: \(String(describing: greaterThanOrEqual)), gt: \(String(describing: gt)), gte: \(String(describing: gte)), lessThan: \(String(describing: lessThan)), lessThanOrEqual: \(String(describing: lessThanOrEqual)), lt: \(String(describing: lt)), lte: \(String(describing: lte)), neq: \(String(describing: neq)), notEquals: \(String(describing: notEquals)))"}
}

/// <p>Contains information about the condition.</p>
public struct Condition: Equatable {
    /// <p>Represents the <i>equal</i> condition to be applied to a single field when
    ///       querying for findings.</p>
    @available(*, deprecated)
    public let eq: [String]?
    /// <p>Represents an <i>equal</i>
    ///             <b></b> condition to be applied to
    ///       a single field when querying for findings.</p>
    public let equals: [String]?
    /// <p>Represents a <i>greater than</i> condition to be applied to a single field
    ///       when querying for findings.</p>
    public let greaterThan: Int
    /// <p>Represents a <i>greater than or equal</i> condition to be applied to a
    ///       single field when querying for findings.</p>
    public let greaterThanOrEqual: Int
    /// <p>Represents a <i>greater than</i> condition to be applied to a single field
    ///       when querying for findings.</p>
    @available(*, deprecated)
    public let gt: Int
    /// <p>Represents a <i>greater than or equal</i> condition to be applied to a
    ///       single field when querying for findings.</p>
    @available(*, deprecated)
    public let gte: Int
    /// <p>Represents a <i>less than</i> condition to be applied to a single field when
    ///       querying for findings.</p>
    public let lessThan: Int
    /// <p>Represents a <i>less than or equal</i> condition to be applied to a single
    ///       field when querying for findings.</p>
    public let lessThanOrEqual: Int
    /// <p>Represents a <i>less than</i> condition to be applied to a single field when
    ///       querying for findings.</p>
    @available(*, deprecated)
    public let lt: Int
    /// <p>Represents a <i>less than or equal</i> condition to be applied to a single
    ///       field when querying for findings.</p>
    @available(*, deprecated)
    public let lte: Int
    /// <p>Represents the <i>not equal</i> condition to be applied to a single field
    ///       when querying for findings.</p>
    @available(*, deprecated)
    public let neq: [String]?
    /// <p>Represents a <i>not equal</i>
    ///             <b></b> condition to be applied
    ///       to a single field when querying for findings.</p>
    public let notEquals: [String]?

    public init (
        eq: [String]? = nil,
        equals: [String]? = nil,
        greaterThan: Int = 0,
        greaterThanOrEqual: Int = 0,
        gt: Int = 0,
        gte: Int = 0,
        lessThan: Int = 0,
        lessThanOrEqual: Int = 0,
        lt: Int = 0,
        lte: Int = 0,
        neq: [String]? = nil,
        notEquals: [String]? = nil
    )
    {
        self.eq = eq
        self.equals = equals
        self.greaterThan = greaterThan
        self.greaterThanOrEqual = greaterThanOrEqual
        self.gt = gt
        self.gte = gte
        self.lessThan = lessThan
        self.lessThanOrEqual = lessThanOrEqual
        self.lt = lt
        self.lte = lte
        self.neq = neq
        self.notEquals = notEquals
    }
}

extension Country: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case countryCode = "countryCode"
        case countryName = "countryName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let countryName = countryName {
            try encodeContainer.encode(countryName, forKey: .countryName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let countryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .countryName)
        countryName = countryNameDecoded
    }
}

extension Country: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Country(countryCode: \(String(describing: countryCode)), countryName: \(String(describing: countryName)))"}
}

/// <p>Contains information about the country where the remote IP address is located.</p>
public struct Country: Equatable {
    /// <p>The country code of the remote IP address.</p>
    public let countryCode: String?
    /// <p>The country name of the remote IP address.</p>
    public let countryName: String?

    public init (
        countryCode: String? = nil,
        countryName: String? = nil
    )
    {
        self.countryCode = countryCode
        self.countryName = countryName
    }
}

public struct CreateDetectorInputBodyMiddleware: Middleware {
    public let id: String = "CreateDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorInput>
    public typealias MOutput = OperationOutput<CreateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorOutputError>
}

extension CreateDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDetectorInput(clientToken: \(String(describing: clientToken)), dataSources: \(String(describing: dataSources)), enable: \(String(describing: enable)), findingPublishingFrequency: \(String(describing: findingPublishingFrequency)), tags: \(String(describing: tags)))"}
}

extension CreateDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let findingPublishingFrequency = findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorInput>
    public typealias MOutput = OperationOutput<CreateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorOutputError>
}

public struct CreateDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDetectorInput>
    public typealias MOutput = OperationOutput<CreateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDetectorOutputError>
}

public struct CreateDetectorInput: Equatable {
    /// <p>The idempotency token for the create request.</p>
    public var clientToken: String?
    /// <p>Describes which data sources will be enabled for the detector.</p>
    public let dataSources: DataSourceConfigurations?
    /// <p>A Boolean value that specifies whether the detector is to be enabled.</p>
    public let enable: Bool
    /// <p>A value that specifies how frequently updated findings are exported.</p>
    public let findingPublishingFrequency: FindingPublishingFrequency?
    /// <p>The tags to be added to a new detector resource.</p>
    public let tags: [String:String]?

    public init (
        clientToken: String? = nil,
        dataSources: DataSourceConfigurations? = nil,
        enable: Bool = false,
        findingPublishingFrequency: FindingPublishingFrequency? = nil,
        tags: [String:String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSources = dataSources
        self.enable = enable
        self.findingPublishingFrequency = findingPublishingFrequency
        self.tags = tags
    }
}

struct CreateDetectorInputBody: Equatable {
    public let enable: Bool
    public let clientToken: String?
    public let findingPublishingFrequency: FindingPublishingFrequency?
    public let dataSources: DataSourceConfigurations?
    public let tags: [String:String]?
}

extension CreateDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decode(Bool.self, forKey: .enable)
        enable = enableDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDetectorOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDetectorOutputResponse(detectorId: \(String(describing: detectorId)))"}
}

extension CreateDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorId = output.detectorId
        } else {
            self.detectorId = nil
        }
    }
}

public struct CreateDetectorOutputResponse: Equatable {
    /// <p>The unique ID of the created detector.</p>
    public let detectorId: String?

    public init (
        detectorId: String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct CreateDetectorOutputResponseBody: Equatable {
    public let detectorId: String?
}

extension CreateDetectorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorId = "detectorId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
    }
}

public struct CreateFilterInputBodyMiddleware: Middleware {
    public let id: String = "CreateFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFilterInput>
    public typealias MOutput = OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFilterOutputError>
}

extension CreateFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFilterInput(action: \(String(describing: action)), clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), findingCriteria: \(String(describing: findingCriteria)), name: \(String(describing: name)), rank: \(String(describing: rank)), tags: \(String(describing: tags)))"}
}

extension CreateFilterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateFilterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFilterInput>
    public typealias MOutput = OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFilterOutputError>
}

public struct CreateFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFilterInput>
    public typealias MOutput = OperationOutput<CreateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFilterOutputError>
}

public struct CreateFilterInput: Equatable {
    /// <p>Specifies the action that is to be applied to the findings that match the filter.</p>
    public let action: FilterAction?
    /// <p>The idempotency token for the create request.</p>
    public var clientToken: String?
    /// <p>The description of the filter.</p>
    public let description: String?
    /// <p>The ID of the detector belonging to the GuardDuty account that you want to create a filter
    ///       for.</p>
    public let detectorId: String?
    /// <p>Represents the criteria to be used in the filter for querying findings.</p>
    ///          <p>You can only use the following attributes to query findings:</p>
    ///          <ul>
    ///             <li>
    ///                <p>accountId</p>
    ///             </li>
    ///             <li>
    ///                <p>region</p>
    ///             </li>
    ///             <li>
    ///                <p>confidence</p>
    ///             </li>
    ///             <li>
    ///                <p>id</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.accessKeyDetails.accessKeyId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.accessKeyDetails.principalId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.accessKeyDetails.userName</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.accessKeyDetails.userType</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.iamInstanceProfile.id</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.imageId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.instanceId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.outpostArn</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.ipv6Addresses</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.publicDnsName</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.publicIp</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.securityGroups.groupId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.securityGroups.groupName</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.subnetId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.vpcId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.tags.key</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.tags.value</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.resourceType</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.actionType</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.api</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.callerType</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.errorCode</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.city.cityName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.country.countryName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.ipAddressV4</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.organization.asn</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.serviceName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.dnsRequestAction.domain</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.blocked</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.connectionDirection</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.localPortDetails.port</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.protocol</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.localIpDetails.ipAddressV4</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.city.cityName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.country.countryName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.ipAddressV4</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.organization.asn</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remotePortDetails.port</p>
    ///             </li>
    ///             <li>
    ///                <p>service.additionalInfo.threatListName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.archived</p>
    ///                <p>When this attribute is set to TRUE, only archived findings are listed. When it's set
    ///           to FALSE, only unarchived findings are listed. When this attribute is not set, all
    ///           existing findings are listed.</p>
    ///             </li>
    ///             <li>
    ///                <p>service.resourceRole</p>
    ///             </li>
    ///             <li>
    ///                <p>severity</p>
    ///             </li>
    ///             <li>
    ///                <p>type</p>
    ///             </li>
    ///             <li>
    ///                <p>updatedAt</p>
    ///                <p>Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ
    ///           depending on whether the value contains milliseconds.</p>
    ///             </li>
    ///          </ul>
    public let findingCriteria: FindingCriteria?
    /// <p>The name of the filter. Minimum length of 3. Maximum length of 64. Valid characters include alphanumeric characters, dot (.), underscore (_), and dash (-). Spaces are not allowed.</p>
    public let name: String?
    /// <p>Specifies the position of the filter in the list of current filters. Also specifies the
    ///       order in which this filter is applied to the findings.</p>
    public let rank: Int
    /// <p>The tags to be added to a new filter resource.</p>
    public let tags: [String:String]?

    public init (
        action: FilterAction? = nil,
        clientToken: String? = nil,
        description: String? = nil,
        detectorId: String? = nil,
        findingCriteria: FindingCriteria? = nil,
        name: String? = nil,
        rank: Int = 0,
        tags: [String:String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.description = description
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.name = name
        self.rank = rank
        self.tags = tags
    }
}

struct CreateFilterInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let action: FilterAction?
    public let rank: Int
    public let findingCriteria: FindingCriteria?
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateFilterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFilterOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFilterOutputResponse(name: \(String(describing: name)))"}
}

extension CreateFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateFilterOutputResponse: Equatable {
    /// <p>The name of the successfully created filter.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateFilterOutputResponseBody: Equatable {
    public let name: String?
}

extension CreateFilterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateIPSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

extension CreateIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIPSetInput(activate: \(String(describing: activate)), clientToken: \(String(describing: clientToken)), detectorId: \(String(describing: detectorId)), format: \(String(describing: format)), location: \(String(describing: location)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activate != false {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

public struct CreateIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

public struct CreateIPSetInput: Equatable {
    /// <p>A Boolean value that indicates whether GuardDuty is to start using the uploaded
    ///       IPSet.</p>
    public let activate: Bool
    /// <p>The idempotency token for the create request.</p>
    public var clientToken: String?
    /// <p>The unique ID of the detector of the GuardDuty account that you want to create an IPSet
    ///       for.</p>
    public let detectorId: String?
    /// <p>The format of the file that contains the IPSet.</p>
    public let format: IpSetFormat?
    /// <p>The URI of the file that contains the IPSet. For example:
    ///       https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.</p>
    public let location: String?
    /// <p>The user-friendly name to identify the IPSet.</p>
    ///          <p> Allowed characters are alphanumerics, spaces, hyphens (-), and underscores (_).</p>
    public let name: String?
    /// <p>The tags to be added to a new IP set resource.</p>
    public let tags: [String:String]?

    public init (
        activate: Bool = false,
        clientToken: String? = nil,
        detectorId: String? = nil,
        format: IpSetFormat? = nil,
        location: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.activate = activate
        self.clientToken = clientToken
        self.detectorId = detectorId
        self.format = format
        self.location = location
        self.name = name
        self.tags = tags
    }
}

struct CreateIPSetInputBody: Equatable {
    public let name: String?
    public let format: IpSetFormat?
    public let location: String?
    public let activate: Bool
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(IpSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decode(Bool.self, forKey: .activate)
        activate = activateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIPSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIPSetOutputResponse(ipSetId: \(String(describing: ipSetId)))"}
}

extension CreateIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateIPSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipSetId = output.ipSetId
        } else {
            self.ipSetId = nil
        }
    }
}

public struct CreateIPSetOutputResponse: Equatable {
    /// <p>The ID of the IPSet resource.</p>
    public let ipSetId: String?

    public init (
        ipSetId: String? = nil
    )
    {
        self.ipSetId = ipSetId
    }
}

struct CreateIPSetOutputResponseBody: Equatable {
    public let ipSetId: String?
}

extension CreateIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ipSetId = "ipSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipSetId)
        ipSetId = ipSetIdDecoded
    }
}

public struct CreateMembersInputBodyMiddleware: Middleware {
    public let id: String = "CreateMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

extension CreateMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMembersInput(accountDetails: \(String(describing: accountDetails)), detectorId: \(String(describing: detectorId)))"}
}

extension CreateMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountDetails = "accountDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountDetails = accountDetails {
            var accountDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountDetails)
            for accountdetails0 in accountDetails {
                try accountDetailsContainer.encode(accountdetails0)
            }
        }
    }
}

public struct CreateMembersInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

public struct CreateMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMembersInput>
    public typealias MOutput = OperationOutput<CreateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMembersOutputError>
}

public struct CreateMembersInput: Equatable {
    /// <p>A list of account ID and email address pairs of the accounts that you want to associate
    ///       with the GuardDuty administrator account.</p>
    public let accountDetails: [AccountDetail]?
    /// <p>The unique ID of the detector of the GuardDuty account that you want to associate member
    ///       accounts with.</p>
    public let detectorId: String?

    public init (
        accountDetails: [AccountDetail]? = nil,
        detectorId: String? = nil
    )
    {
        self.accountDetails = accountDetails
        self.detectorId = detectorId
    }
}

struct CreateMembersInputBody: Equatable {
    public let accountDetails: [AccountDetail]?
}

extension CreateMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountDetails = "accountDetails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDetailsContainer = try containerValues.decodeIfPresent([AccountDetail?].self, forKey: .accountDetails)
        var accountDetailsDecoded0:[AccountDetail]? = nil
        if let accountDetailsContainer = accountDetailsContainer {
            accountDetailsDecoded0 = [AccountDetail]()
            for structure0 in accountDetailsContainer {
                if let structure0 = structure0 {
                    accountDetailsDecoded0?.append(structure0)
                }
            }
        }
        accountDetails = accountDetailsDecoded0
    }
}

extension CreateMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMembersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension CreateMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutputResponse: Equatable {
    /// <p>A list of objects that include the <code>accountIds</code> of the unprocessed accounts and
    ///       a result string that explains why each was unprocessed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension CreateMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct CreatePublishingDestinationInputBodyMiddleware: Middleware {
    public let id: String = "CreatePublishingDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublishingDestinationInput>
    public typealias MOutput = OperationOutput<CreatePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublishingDestinationOutputError>
}

extension CreatePublishingDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePublishingDestinationInput(clientToken: \(String(describing: clientToken)), destinationProperties: \(String(describing: destinationProperties)), destinationType: \(String(describing: destinationType)), detectorId: \(String(describing: detectorId)))"}
}

extension CreatePublishingDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationProperties = destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
        if let destinationType = destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
    }
}

public struct CreatePublishingDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePublishingDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublishingDestinationInput>
    public typealias MOutput = OperationOutput<CreatePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublishingDestinationOutputError>
}

public struct CreatePublishingDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePublishingDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePublishingDestinationInput>
    public typealias MOutput = OperationOutput<CreatePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePublishingDestinationOutputError>
}

public struct CreatePublishingDestinationInput: Equatable {
    /// <p>The idempotency token for the request.</p>
    public var clientToken: String?
    /// <p>The properties of the publishing destination, including the ARNs for the destination and
    ///       the KMS key used for encryption.</p>
    public let destinationProperties: DestinationProperties?
    /// <p>The type of resource for the publishing destination. Currently only Amazon S3 buckets are
    ///       supported.</p>
    public let destinationType: DestinationType?
    /// <p>The ID of the GuardDuty detector associated with the publishing destination.</p>
    public let detectorId: String?

    public init (
        clientToken: String? = nil,
        destinationProperties: DestinationProperties? = nil,
        destinationType: DestinationType? = nil,
        detectorId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationProperties = destinationProperties
        self.destinationType = destinationType
        self.detectorId = detectorId
    }
}

struct CreatePublishingDestinationInputBody: Equatable {
    public let destinationType: DestinationType?
    public let destinationProperties: DestinationProperties?
    public let clientToken: String?
}

extension CreatePublishingDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "clientToken"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePublishingDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublishingDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePublishingDestinationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublishingDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePublishingDestinationOutputResponse(destinationId: \(String(describing: destinationId)))"}
}

extension CreatePublishingDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePublishingDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationId = output.destinationId
        } else {
            self.destinationId = nil
        }
    }
}

public struct CreatePublishingDestinationOutputResponse: Equatable {
    /// <p>The ID of the publishing destination that is created.</p>
    public let destinationId: String?

    public init (
        destinationId: String? = nil
    )
    {
        self.destinationId = destinationId
    }
}

struct CreatePublishingDestinationOutputResponseBody: Equatable {
    public let destinationId: String?
}

extension CreatePublishingDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationId = "destinationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
    }
}

public struct CreateSampleFindingsInputBodyMiddleware: Middleware {
    public let id: String = "CreateSampleFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSampleFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSampleFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSampleFindingsInput>
    public typealias MOutput = OperationOutput<CreateSampleFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSampleFindingsOutputError>
}

extension CreateSampleFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSampleFindingsInput(detectorId: \(String(describing: detectorId)), findingTypes: \(String(describing: findingTypes)))"}
}

extension CreateSampleFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingTypes = "findingTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingTypes = findingTypes {
            var findingTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingTypes)
            for findingtypes0 in findingTypes {
                try findingTypesContainer.encode(findingtypes0)
            }
        }
    }
}

public struct CreateSampleFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSampleFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSampleFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSampleFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSampleFindingsInput>
    public typealias MOutput = OperationOutput<CreateSampleFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSampleFindingsOutputError>
}

public struct CreateSampleFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSampleFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSampleFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSampleFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSampleFindingsInput>
    public typealias MOutput = OperationOutput<CreateSampleFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSampleFindingsOutputError>
}

public struct CreateSampleFindingsInput: Equatable {
    /// <p>The ID of the detector to create sample findings for.</p>
    public let detectorId: String?
    /// <p>The types of sample findings to generate.</p>
    public let findingTypes: [String]?

    public init (
        detectorId: String? = nil,
        findingTypes: [String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingTypes = findingTypes
    }
}

struct CreateSampleFindingsInputBody: Equatable {
    public let findingTypes: [String]?
}

extension CreateSampleFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingTypes = "findingTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingTypes)
        var findingTypesDecoded0:[String]? = nil
        if let findingTypesContainer = findingTypesContainer {
            findingTypesDecoded0 = [String]()
            for string0 in findingTypesContainer {
                if let string0 = string0 {
                    findingTypesDecoded0?.append(string0)
                }
            }
        }
        findingTypes = findingTypesDecoded0
    }
}

extension CreateSampleFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSampleFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSampleFindingsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSampleFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSampleFindingsOutputResponse()"}
}

extension CreateSampleFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateSampleFindingsOutputResponse: Equatable {

    public init() {}
}

struct CreateSampleFindingsOutputResponseBody: Equatable {
}

extension CreateSampleFindingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateThreatIntelSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateThreatIntelSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThreatIntelSetInput>
    public typealias MOutput = OperationOutput<CreateThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThreatIntelSetOutputError>
}

extension CreateThreatIntelSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThreatIntelSetInput(activate: \(String(describing: activate)), clientToken: \(String(describing: clientToken)), detectorId: \(String(describing: detectorId)), format: \(String(describing: format)), location: \(String(describing: location)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateThreatIntelSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activate != false {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateThreatIntelSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateThreatIntelSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThreatIntelSetInput>
    public typealias MOutput = OperationOutput<CreateThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThreatIntelSetOutputError>
}

public struct CreateThreatIntelSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateThreatIntelSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateThreatIntelSetInput>
    public typealias MOutput = OperationOutput<CreateThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateThreatIntelSetOutputError>
}

public struct CreateThreatIntelSetInput: Equatable {
    /// <p>A Boolean value that indicates whether GuardDuty is to start using the uploaded
    ///       ThreatIntelSet.</p>
    public let activate: Bool
    /// <p>The idempotency token for the create request.</p>
    public var clientToken: String?
    /// <p>The unique ID of the detector of the GuardDuty account that you want to create a
    ///       threatIntelSet for.</p>
    public let detectorId: String?
    /// <p>The format of the file that contains the ThreatIntelSet.</p>
    public let format: ThreatIntelSetFormat?
    /// <p>The URI of the file that contains the ThreatIntelSet. For example:
    ///       https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.</p>
    public let location: String?
    /// <p>A user-friendly ThreatIntelSet name displayed in all findings that are generated by
    ///       activity that involves IP addresses included in this ThreatIntelSet.</p>
    public let name: String?
    /// <p>The tags to be added to a new threat list resource.</p>
    public let tags: [String:String]?

    public init (
        activate: Bool = false,
        clientToken: String? = nil,
        detectorId: String? = nil,
        format: ThreatIntelSetFormat? = nil,
        location: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.activate = activate
        self.clientToken = clientToken
        self.detectorId = detectorId
        self.format = format
        self.location = location
        self.name = name
        self.tags = tags
    }
}

struct CreateThreatIntelSetInputBody: Equatable {
    public let name: String?
    public let format: ThreatIntelSetFormat?
    public let location: String?
    public let activate: Bool
    public let clientToken: String?
    public let tags: [String:String]?
}

extension CreateThreatIntelSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ThreatIntelSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decode(Bool.self, forKey: .activate)
        activate = activateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThreatIntelSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThreatIntelSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThreatIntelSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThreatIntelSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateThreatIntelSetOutputResponse(threatIntelSetId: \(String(describing: threatIntelSetId)))"}
}

extension CreateThreatIntelSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateThreatIntelSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.threatIntelSetId = output.threatIntelSetId
        } else {
            self.threatIntelSetId = nil
        }
    }
}

public struct CreateThreatIntelSetOutputResponse: Equatable {
    /// <p>The ID of the ThreatIntelSet resource.</p>
    public let threatIntelSetId: String?

    public init (
        threatIntelSetId: String? = nil
    )
    {
        self.threatIntelSetId = threatIntelSetId
    }
}

struct CreateThreatIntelSetOutputResponseBody: Equatable {
    public let threatIntelSetId: String?
}

extension CreateThreatIntelSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case threatIntelSetId = "threatIntelSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .threatIntelSetId)
        threatIntelSetId = threatIntelSetIdDecoded
    }
}

extension DNSLogsConfigurationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DNSLogsConfigurationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DNSLogsConfigurationResult(status: \(String(describing: status)))"}
}

/// <p>Contains information on the status of DNS logs as a data source.</p>
public struct DNSLogsConfigurationResult: Equatable {
    /// <p>Denotes whether DNS logs is enabled as a data source.</p>
    public let status: DataSourceStatus?

    public init (
        status: DataSourceStatus? = nil
    )
    {
        self.status = status
    }
}

public enum DataSource {
    case cloudTrail
    case dnsLogs
    case flowLogs
    case s3Logs
    case sdkUnknown(String)
}

extension DataSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSource] {
        return [
            .cloudTrail,
            .dnsLogs,
            .flowLogs,
            .s3Logs,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudTrail: return "CLOUD_TRAIL"
        case .dnsLogs: return "DNS_LOGS"
        case .flowLogs: return "FLOW_LOGS"
        case .s3Logs: return "S3_LOGS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
    }
}

extension DataSourceConfigurations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(S3LogsConfiguration.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension DataSourceConfigurations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceConfigurations(s3Logs: \(String(describing: s3Logs)))"}
}

/// <p>Contains information about which data sources are enabled.</p>
public struct DataSourceConfigurations: Equatable {
    /// <p>Describes whether S3 data event logs are enabled as a data source.</p>
    public let s3Logs: S3LogsConfiguration?

    public init (
        s3Logs: S3LogsConfiguration? = nil
    )
    {
        self.s3Logs = s3Logs
    }
}

extension DataSourceConfigurationsResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudTrail = "cloudTrail"
        case dNSLogs = "dnsLogs"
        case flowLogs = "flowLogs"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrail = cloudTrail {
            try encodeContainer.encode(cloudTrail, forKey: .cloudTrail)
        }
        if let dNSLogs = dNSLogs {
            try encodeContainer.encode(dNSLogs, forKey: .dNSLogs)
        }
        if let flowLogs = flowLogs {
            try encodeContainer.encode(flowLogs, forKey: .flowLogs)
        }
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailDecoded = try containerValues.decodeIfPresent(CloudTrailConfigurationResult.self, forKey: .cloudTrail)
        cloudTrail = cloudTrailDecoded
        let dNSLogsDecoded = try containerValues.decodeIfPresent(DNSLogsConfigurationResult.self, forKey: .dNSLogs)
        dNSLogs = dNSLogsDecoded
        let flowLogsDecoded = try containerValues.decodeIfPresent(FlowLogsConfigurationResult.self, forKey: .flowLogs)
        flowLogs = flowLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(S3LogsConfigurationResult.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension DataSourceConfigurationsResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSourceConfigurationsResult(cloudTrail: \(String(describing: cloudTrail)), dNSLogs: \(String(describing: dNSLogs)), flowLogs: \(String(describing: flowLogs)), s3Logs: \(String(describing: s3Logs)))"}
}

/// <p>Contains information on the status of data sources for the detector.</p>
public struct DataSourceConfigurationsResult: Equatable {
    /// <p>An object that contains information on the status of CloudTrail as a data source.</p>
    public let cloudTrail: CloudTrailConfigurationResult?
    /// <p>An object that contains information on the status of DNS logs as a data source.</p>
    public let dNSLogs: DNSLogsConfigurationResult?
    /// <p>An object that contains information on the status of VPC flow logs as a data
    ///       source.</p>
    public let flowLogs: FlowLogsConfigurationResult?
    /// <p>An object that contains information on the status of S3 Data event logs as a data
    ///       source.</p>
    public let s3Logs: S3LogsConfigurationResult?

    public init (
        cloudTrail: CloudTrailConfigurationResult? = nil,
        dNSLogs: DNSLogsConfigurationResult? = nil,
        flowLogs: FlowLogsConfigurationResult? = nil,
        s3Logs: S3LogsConfigurationResult? = nil
    )
    {
        self.cloudTrail = cloudTrail
        self.dNSLogs = dNSLogs
        self.flowLogs = flowLogs
        self.s3Logs = s3Logs
    }
}

public enum DataSourceStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension DataSourceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DataSourceStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
    }
}

public struct DeclineInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

extension DeclineInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeclineInvitationsInput(accountIds: \(String(describing: accountIds)))"}
}

extension DeclineInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

public struct DeclineInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

public struct DeclineInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeclineInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeclineInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeclineInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeclineInvitationsInput>
    public typealias MOutput = OperationOutput<DeclineInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeclineInvitationsOutputError>
}

public struct DeclineInvitationsInput: Equatable {
    /// <p>A list of account IDs of the AWS accounts that sent invitations to the current member
    ///       account that you want to decline invitations from.</p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeclineInvitationsInputBody: Equatable {
    public let accountIds: [String]?
}

extension DeclineInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeclineInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeclineInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeclineInvitationsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeclineInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeclineInvitationsOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeclineInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeclineInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeclineInvitationsOutputResponse: Equatable {
    /// <p>A list of objects that contain the unprocessed account and a result string that explains
    ///       why it was unprocessed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeclineInvitationsOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension DeclineInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DefaultServerSideEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionType = "encryptionType"
        case kmsMasterKeyArn = "kmsMasterKeyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if let kmsMasterKeyArn = kmsMasterKeyArn {
            try encodeContainer.encode(kmsMasterKeyArn, forKey: .kmsMasterKeyArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsMasterKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsMasterKeyArn)
        kmsMasterKeyArn = kmsMasterKeyArnDecoded
    }
}

extension DefaultServerSideEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultServerSideEncryption(encryptionType: \(String(describing: encryptionType)), kmsMasterKeyArn: \(String(describing: kmsMasterKeyArn)))"}
}

/// <p>Contains information on the server side encryption method used in the S3 bucket. See
///       <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html">S3
///         Server-Side Encryption</a> for more information.</p>
public struct DefaultServerSideEncryption: Equatable {
    /// <p>The type of encryption used for objects within the S3 bucket.</p>
    public let encryptionType: String?
    /// <p>The Amazon Resource Name (ARN) of the KMS encryption key. Only available if the bucket
    ///         <code>EncryptionType</code> is <code>aws:kms</code>.</p>
    public let kmsMasterKeyArn: String?

    public init (
        encryptionType: String? = nil,
        kmsMasterKeyArn: String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsMasterKeyArn = kmsMasterKeyArn
    }
}

extension DeleteDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDetectorInput(detectorId: \(String(describing: detectorId)))"}
}

extension DeleteDetectorInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorInput>
    public typealias MOutput = OperationOutput<DeleteDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorOutputError>
}

public struct DeleteDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDetectorInput>
    public typealias MOutput = OperationOutput<DeleteDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDetectorOutputError>
}

public struct DeleteDetectorInput: Equatable {
    /// <p>The unique ID of the detector that you want to delete.</p>
    public let detectorId: String?

    public init (
        detectorId: String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DeleteDetectorInputBody: Equatable {
}

extension DeleteDetectorInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDetectorOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDetectorOutputResponse()"}
}

extension DeleteDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorOutputResponse: Equatable {

    public init() {}
}

struct DeleteDetectorOutputResponseBody: Equatable {
}

extension DeleteDetectorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFilterInput(detectorId: \(String(describing: detectorId)), filterName: \(String(describing: filterName)))"}
}

extension DeleteFilterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFilterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFilterInput>
    public typealias MOutput = OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFilterOutputError>
}

public struct DeleteFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFilterInput>
    public typealias MOutput = OperationOutput<DeleteFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFilterOutputError>
}

public struct DeleteFilterInput: Equatable {
    /// <p>The unique ID of the detector that the filter is associated with.</p>
    public let detectorId: String?
    /// <p>The name of the filter that you want to delete.</p>
    public let filterName: String?

    public init (
        detectorId: String? = nil,
        filterName: String? = nil
    )
    {
        self.detectorId = detectorId
        self.filterName = filterName
    }
}

struct DeleteFilterInputBody: Equatable {
}

extension DeleteFilterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFilterOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFilterOutputResponse()"}
}

extension DeleteFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFilterOutputResponse: Equatable {

    public init() {}
}

struct DeleteFilterOutputResponseBody: Equatable {
}

extension DeleteFilterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIPSetInput(detectorId: \(String(describing: detectorId)), ipSetId: \(String(describing: ipSetId)))"}
}

extension DeleteIPSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIPSetInput>
    public typealias MOutput = OperationOutput<DeleteIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIPSetOutputError>
}

public struct DeleteIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIPSetInput>
    public typealias MOutput = OperationOutput<DeleteIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIPSetOutputError>
}

public struct DeleteIPSetInput: Equatable {
    /// <p>The unique ID of the detector associated with the IPSet.</p>
    public let detectorId: String?
    /// <p>The unique ID of the IPSet to delete.</p>
    public let ipSetId: String?

    public init (
        detectorId: String? = nil,
        ipSetId: String? = nil
    )
    {
        self.detectorId = detectorId
        self.ipSetId = ipSetId
    }
}

struct DeleteIPSetInputBody: Equatable {
}

extension DeleteIPSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIPSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIPSetOutputResponse()"}
}

extension DeleteIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIPSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteIPSetOutputResponseBody: Equatable {
}

extension DeleteIPSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteInvitationsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

extension DeleteInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInvitationsInput(accountIds: \(String(describing: accountIds)))"}
}

extension DeleteInvitationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

public struct DeleteInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

public struct DeleteInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteInvitationsInput>
    public typealias MOutput = OperationOutput<DeleteInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteInvitationsOutputError>
}

public struct DeleteInvitationsInput: Equatable {
    /// <p>A list of account IDs of the AWS accounts that sent invitations to the current member
    ///       account that you want to delete invitations from.</p>
    public let accountIds: [String]?

    public init (
        accountIds: [String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteInvitationsInputBody: Equatable {
    public let accountIds: [String]?
}

extension DeleteInvitationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInvitationsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteInvitationsOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeleteInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteInvitationsOutputResponse: Equatable {
    /// <p>A list of objects that contain the unprocessed account and a result string that explains
    ///       why it was unprocessed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteInvitationsOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension DeleteInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct DeleteMembersInputBodyMiddleware: Middleware {
    public let id: String = "DeleteMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

extension DeleteMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMembersInput(accountIds: \(String(describing: accountIds)), detectorId: \(String(describing: detectorId)))"}
}

extension DeleteMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

public struct DeleteMembersInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMembersInput>
    public typealias MOutput = OperationOutput<DeleteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMembersOutputError>
}

public struct DeleteMembersInput: Equatable {
    /// <p>A list of account IDs of the GuardDuty member accounts that you want to delete.</p>
    public let accountIds: [String]?
    /// <p>The unique ID of the detector of the GuardDuty account whose members you want to
    ///       delete.</p>
    public let detectorId: String?

    public init (
        accountIds: [String]? = nil,
        detectorId: String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct DeleteMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension DeleteMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMembersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DeleteMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutputResponse: Equatable {
    /// <p>The accounts that could not be processed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension DeleteMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeletePublishingDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePublishingDestinationInput(destinationId: \(String(describing: destinationId)), detectorId: \(String(describing: detectorId)))"}
}

extension DeletePublishingDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePublishingDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePublishingDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePublishingDestinationInput>
    public typealias MOutput = OperationOutput<DeletePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePublishingDestinationOutputError>
}

public struct DeletePublishingDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePublishingDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePublishingDestinationInput>
    public typealias MOutput = OperationOutput<DeletePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePublishingDestinationOutputError>
}

public struct DeletePublishingDestinationInput: Equatable {
    /// <p>The ID of the publishing destination to delete.</p>
    public let destinationId: String?
    /// <p>The unique ID of the detector associated with the publishing destination to delete.</p>
    public let detectorId: String?

    public init (
        destinationId: String? = nil,
        detectorId: String? = nil
    )
    {
        self.destinationId = destinationId
        self.detectorId = detectorId
    }
}

struct DeletePublishingDestinationInputBody: Equatable {
}

extension DeletePublishingDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePublishingDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePublishingDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePublishingDestinationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublishingDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePublishingDestinationOutputResponse()"}
}

extension DeletePublishingDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublishingDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeletePublishingDestinationOutputResponseBody: Equatable {
}

extension DeletePublishingDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThreatIntelSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThreatIntelSetInput(detectorId: \(String(describing: detectorId)), threatIntelSetId: \(String(describing: threatIntelSetId)))"}
}

extension DeleteThreatIntelSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteThreatIntelSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteThreatIntelSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThreatIntelSetInput>
    public typealias MOutput = OperationOutput<DeleteThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThreatIntelSetOutputError>
}

public struct DeleteThreatIntelSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteThreatIntelSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteThreatIntelSetInput>
    public typealias MOutput = OperationOutput<DeleteThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteThreatIntelSetOutputError>
}

public struct DeleteThreatIntelSetInput: Equatable {
    /// <p>The unique ID of the detector that the threatIntelSet is associated with.</p>
    public let detectorId: String?
    /// <p>The unique ID of the threatIntelSet that you want to delete.</p>
    public let threatIntelSetId: String?

    public init (
        detectorId: String? = nil,
        threatIntelSetId: String? = nil
    )
    {
        self.detectorId = detectorId
        self.threatIntelSetId = threatIntelSetId
    }
}

struct DeleteThreatIntelSetInputBody: Equatable {
}

extension DeleteThreatIntelSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteThreatIntelSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThreatIntelSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThreatIntelSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThreatIntelSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteThreatIntelSetOutputResponse()"}
}

extension DeleteThreatIntelSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteThreatIntelSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteThreatIntelSetOutputResponseBody: Equatable {
}

extension DeleteThreatIntelSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigurationInput(detectorId: \(String(describing: detectorId)))"}
}

extension DescribeOrganizationConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeOrganizationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigurationOutputError>
}

public struct DescribeOrganizationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrganizationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationConfigurationOutputError>
}

public struct DescribeOrganizationConfigurationInput: Equatable {
    /// <p>The ID of the detector to retrieve information about the delegated administrator
    ///       from.</p>
    public let detectorId: String?

    public init (
        detectorId: String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DescribeOrganizationConfigurationInputBody: Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationConfigurationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationConfigurationOutputResponse(autoEnable: \(String(describing: autoEnable)), dataSources: \(String(describing: dataSources)), memberAccountLimitReached: \(String(describing: memberAccountLimitReached)))"}
}

extension DescribeOrganizationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
            self.dataSources = output.dataSources
            self.memberAccountLimitReached = output.memberAccountLimitReached
        } else {
            self.autoEnable = false
            self.dataSources = nil
            self.memberAccountLimitReached = false
        }
    }
}

public struct DescribeOrganizationConfigurationOutputResponse: Equatable {
    /// <p>Indicates whether GuardDuty is automatically enabled for accounts added to the
    ///       organization.</p>
    public let autoEnable: Bool
    /// <p>Describes which data sources are enabled automatically for member
    ///       accounts.</p>
    public let dataSources: OrganizationDataSourceConfigurationsResult?
    /// <p>Indicates whether the maximum number of allowed member accounts are already associated
    ///       with the delegated administrator account for your organization.</p>
    public let memberAccountLimitReached: Bool

    public init (
        autoEnable: Bool = false,
        dataSources: OrganizationDataSourceConfigurationsResult? = nil,
        memberAccountLimitReached: Bool = false
    )
    {
        self.autoEnable = autoEnable
        self.dataSources = dataSources
        self.memberAccountLimitReached = memberAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputResponseBody: Equatable {
    public let autoEnable: Bool
    public let memberAccountLimitReached: Bool
    public let dataSources: OrganizationDataSourceConfigurationsResult?
}

extension DescribeOrganizationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
        case memberAccountLimitReached = "memberAccountLimitReached"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let memberAccountLimitReachedDecoded = try containerValues.decode(Bool.self, forKey: .memberAccountLimitReached)
        memberAccountLimitReached = memberAccountLimitReachedDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(OrganizationDataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension DescribePublishingDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePublishingDestinationInput(destinationId: \(String(describing: destinationId)), detectorId: \(String(describing: detectorId)))"}
}

extension DescribePublishingDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribePublishingDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePublishingDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePublishingDestinationInput>
    public typealias MOutput = OperationOutput<DescribePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePublishingDestinationOutputError>
}

public struct DescribePublishingDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePublishingDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePublishingDestinationInput>
    public typealias MOutput = OperationOutput<DescribePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePublishingDestinationOutputError>
}

public struct DescribePublishingDestinationInput: Equatable {
    /// <p>The ID of the publishing destination to retrieve.</p>
    public let destinationId: String?
    /// <p>The unique ID of the detector associated with the publishing destination to
    ///       retrieve.</p>
    public let detectorId: String?

    public init (
        destinationId: String? = nil,
        detectorId: String? = nil
    )
    {
        self.destinationId = destinationId
        self.detectorId = detectorId
    }
}

struct DescribePublishingDestinationInputBody: Equatable {
}

extension DescribePublishingDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribePublishingDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePublishingDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePublishingDestinationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePublishingDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePublishingDestinationOutputResponse(destinationId: \(String(describing: destinationId)), destinationProperties: \(String(describing: destinationProperties)), destinationType: \(String(describing: destinationType)), publishingFailureStartTimestamp: \(String(describing: publishingFailureStartTimestamp)), status: \(String(describing: status)))"}
}

extension DescribePublishingDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePublishingDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationId = output.destinationId
            self.destinationProperties = output.destinationProperties
            self.destinationType = output.destinationType
            self.publishingFailureStartTimestamp = output.publishingFailureStartTimestamp
            self.status = output.status
        } else {
            self.destinationId = nil
            self.destinationProperties = nil
            self.destinationType = nil
            self.publishingFailureStartTimestamp = 0
            self.status = nil
        }
    }
}

public struct DescribePublishingDestinationOutputResponse: Equatable {
    /// <p>The ID of the publishing destination.</p>
    public let destinationId: String?
    /// <p>A <code>DestinationProperties</code> object that includes the <code>DestinationArn</code>
    ///       and <code>KmsKeyArn</code> of the publishing destination.</p>
    public let destinationProperties: DestinationProperties?
    /// <p>The type of publishing destination. Currently, only Amazon S3 buckets are
    ///       supported.</p>
    public let destinationType: DestinationType?
    /// <p>The time, in epoch millisecond format, at which GuardDuty was first unable to publish
    ///       findings to the destination.</p>
    public let publishingFailureStartTimestamp: Int
    /// <p>The status of the publishing destination.</p>
    public let status: PublishingStatus?

    public init (
        destinationId: String? = nil,
        destinationProperties: DestinationProperties? = nil,
        destinationType: DestinationType? = nil,
        publishingFailureStartTimestamp: Int = 0,
        status: PublishingStatus? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationProperties = destinationProperties
        self.destinationType = destinationType
        self.publishingFailureStartTimestamp = publishingFailureStartTimestamp
        self.status = status
    }
}

struct DescribePublishingDestinationOutputResponseBody: Equatable {
    public let destinationId: String?
    public let destinationType: DestinationType?
    public let status: PublishingStatus?
    public let publishingFailureStartTimestamp: Int
    public let destinationProperties: DestinationProperties?
}

extension DescribePublishingDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationId = "destinationId"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
        case publishingFailureStartTimestamp = "publishingFailureStartTimestamp"
        case status = "status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PublishingStatus.self, forKey: .status)
        status = statusDecoded
        let publishingFailureStartTimestampDecoded = try containerValues.decode(Int.self, forKey: .publishingFailureStartTimestamp)
        publishingFailureStartTimestamp = publishingFailureStartTimestampDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension Destination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationId = "destinationId"
        case destinationType = "destinationType"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationId = destinationId {
            try encodeContainer.encode(destinationId, forKey: .destinationId)
        }
        if let destinationType = destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PublishingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Destination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destination(destinationId: \(String(describing: destinationId)), destinationType: \(String(describing: destinationType)), status: \(String(describing: status)))"}
}

/// <p>Contains information about the publishing destination, including the ID, type, and
///       status.</p>
public struct Destination: Equatable {
    /// <p>The unique ID of the publishing destination.</p>
    public let destinationId: String?
    /// <p>The type of resource used for the publishing destination. Currently, only Amazon S3
    ///       buckets are supported.</p>
    public let destinationType: DestinationType?
    /// <p>The status of the publishing destination.</p>
    public let status: PublishingStatus?

    public init (
        destinationId: String? = nil,
        destinationType: DestinationType? = nil,
        status: PublishingStatus? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationType = destinationType
        self.status = status
    }
}

extension DestinationProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationArn = "destinationArn"
        case kmsKeyArn = "kmsKeyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension DestinationProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationProperties(destinationArn: \(String(describing: destinationArn)), kmsKeyArn: \(String(describing: kmsKeyArn)))"}
}

/// <p>Contains the Amazon Resource Name (ARN) of the resource to publish to, such as an S3
///       bucket, and the ARN of the KMS key to use to encrypt published findings.</p>
public struct DestinationProperties: Equatable {
    /// <p>The ARN of the resource to publish to.</p>
    public let destinationArn: String?
    /// <p>The ARN of the KMS key to use for encryption.</p>
    public let kmsKeyArn: String?

    public init (
        destinationArn: String? = nil,
        kmsKeyArn: String? = nil
    )
    {
        self.destinationArn = destinationArn
        self.kmsKeyArn = kmsKeyArn
    }
}

public enum DestinationType {
    case s3
    case sdkUnknown(String)
}

extension DestinationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DestinationType] {
        return [
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
    }
}

public enum DetectorStatus {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension DetectorStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DetectorStatus] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DetectorStatus(rawValue: rawValue) ?? DetectorStatus.sdkUnknown(rawValue)
    }
}

public struct DisableOrganizationAdminAccountInputBodyMiddleware: Middleware {
    public let id: String = "DisableOrganizationAdminAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DisableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableOrganizationAdminAccountOutputError>
}

extension DisableOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableOrganizationAdminAccountInput(adminAccountId: \(String(describing: adminAccountId)))"}
}

extension DisableOrganizationAdminAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

public struct DisableOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisableOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DisableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableOrganizationAdminAccountOutputError>
}

public struct DisableOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DisableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableOrganizationAdminAccountOutputError>
}

public struct DisableOrganizationAdminAccountInput: Equatable {
    /// <p>The AWS Account ID for the organizations account to be disabled as a GuardDuty delegated
    ///       administrator.</p>
    public let adminAccountId: String?

    public init (
        adminAccountId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DisableOrganizationAdminAccountInputBody: Equatable {
    public let adminAccountId: String?
}

extension DisableOrganizationAdminAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DisableOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableOrganizationAdminAccountOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableOrganizationAdminAccountOutputResponse()"}
}

extension DisableOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableOrganizationAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct DisableOrganizationAdminAccountOutputResponseBody: Equatable {
}

extension DisableOrganizationAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromMasterAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromMasterAccountInput(detectorId: \(String(describing: detectorId)))"}
}

extension DisassociateFromMasterAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateFromMasterAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateFromMasterAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromMasterAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromMasterAccountOutputError>
}

public struct DisassociateFromMasterAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateFromMasterAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateFromMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateFromMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateFromMasterAccountInput>
    public typealias MOutput = OperationOutput<DisassociateFromMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateFromMasterAccountOutputError>
}

public struct DisassociateFromMasterAccountInput: Equatable {
    /// <p>The unique ID of the detector of the GuardDuty member account.</p>
    public let detectorId: String?

    public init (
        detectorId: String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DisassociateFromMasterAccountInputBody: Equatable {
}

extension DisassociateFromMasterAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateFromMasterAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromMasterAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFromMasterAccountOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromMasterAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateFromMasterAccountOutputResponse()"}
}

extension DisassociateFromMasterAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromMasterAccountOutputResponse: Equatable {

    public init() {}
}

struct DisassociateFromMasterAccountOutputResponseBody: Equatable {
}

extension DisassociateFromMasterAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateMembersInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembersInput>
    public typealias MOutput = OperationOutput<DisassociateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembersOutputError>
}

extension DisassociateMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMembersInput(accountIds: \(String(describing: accountIds)), detectorId: \(String(describing: detectorId)))"}
}

extension DisassociateMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

public struct DisassociateMembersInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembersInput>
    public typealias MOutput = OperationOutput<DisassociateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembersOutputError>
}

public struct DisassociateMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMembersInput>
    public typealias MOutput = OperationOutput<DisassociateMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMembersOutputError>
}

public struct DisassociateMembersInput: Equatable {
    /// <p>A list of account IDs of the GuardDuty member accounts that you want to disassociate from
    ///       the administrator account.</p>
    public let accountIds: [String]?
    /// <p>The unique ID of the detector of the GuardDuty account whose members you want to
    ///       disassociate from the administrator account.</p>
    public let detectorId: String?

    public init (
        accountIds: [String]? = nil,
        detectorId: String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct DisassociateMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension DisassociateMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DisassociateMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMembersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension DisassociateMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DisassociateMembersOutputResponse: Equatable {
    /// <p>A list of objects that contain the unprocessed account and a result string that explains
    ///       why it was unprocessed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DisassociateMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension DisassociateMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DnsRequestAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "domain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DnsRequestAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsRequestAction(domain: \(String(describing: domain)))"}
}

/// <p>Contains information about the DNS_REQUEST action described in this finding.</p>
public struct DnsRequestAction: Equatable {
    /// <p>The domain information for the API request.</p>
    public let domain: String?

    public init (
        domain: String? = nil
    )
    {
        self.domain = domain
    }
}

extension DomainDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domain = "domain"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension DomainDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DomainDetails(domain: \(String(describing: domain)))"}
}

/// <p>Contains information about the domain.</p>
public struct DomainDetails: Equatable {
    /// <p>The domain information for the AWS API call.</p>
    public let domain: String?

    public init (
        domain: String? = nil
    )
    {
        self.domain = domain
    }
}

public struct EnableOrganizationAdminAccountInputBodyMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

extension EnableOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableOrganizationAdminAccountInput(adminAccountId: \(String(describing: adminAccountId)))"}
}

extension EnableOrganizationAdminAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

public struct EnableOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

public struct EnableOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<EnableOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableOrganizationAdminAccountOutputError>
}

public struct EnableOrganizationAdminAccountInput: Equatable {
    /// <p>The AWS Account ID for the organization account to be enabled as a GuardDuty delegated
    ///       administrator.</p>
    public let adminAccountId: String?

    public init (
        adminAccountId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct EnableOrganizationAdminAccountInputBody: Equatable {
    public let adminAccountId: String?
}

extension EnableOrganizationAdminAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension EnableOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableOrganizationAdminAccountOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableOrganizationAdminAccountOutputResponse()"}
}

extension EnableOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableOrganizationAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct EnableOrganizationAdminAccountOutputResponseBody: Equatable {
}

extension EnableOrganizationAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Evidence: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case threatIntelligenceDetails = "threatIntelligenceDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let threatIntelligenceDetails = threatIntelligenceDetails {
            var threatIntelligenceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelligenceDetails)
            for threatintelligencedetails0 in threatIntelligenceDetails {
                try threatIntelligenceDetailsContainer.encode(threatintelligencedetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelligenceDetailsContainer = try containerValues.decodeIfPresent([ThreatIntelligenceDetail?].self, forKey: .threatIntelligenceDetails)
        var threatIntelligenceDetailsDecoded0:[ThreatIntelligenceDetail]? = nil
        if let threatIntelligenceDetailsContainer = threatIntelligenceDetailsContainer {
            threatIntelligenceDetailsDecoded0 = [ThreatIntelligenceDetail]()
            for structure0 in threatIntelligenceDetailsContainer {
                if let structure0 = structure0 {
                    threatIntelligenceDetailsDecoded0?.append(structure0)
                }
            }
        }
        threatIntelligenceDetails = threatIntelligenceDetailsDecoded0
    }
}

extension Evidence: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Evidence(threatIntelligenceDetails: \(String(describing: threatIntelligenceDetails)))"}
}

/// <p>Contains information about the reason that the finding was generated.</p>
public struct Evidence: Equatable {
    /// <p>A list of threat intelligence details related to the evidence.</p>
    public let threatIntelligenceDetails: [ThreatIntelligenceDetail]?

    public init (
        threatIntelligenceDetails: [ThreatIntelligenceDetail]? = nil
    )
    {
        self.threatIntelligenceDetails = threatIntelligenceDetails
    }
}

public enum Feedback {
    case notUseful
    case useful
    case sdkUnknown(String)
}

extension Feedback : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Feedback] {
        return [
            .notUseful,
            .useful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notUseful: return "NOT_USEFUL"
        case .useful: return "USEFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Feedback(rawValue: rawValue) ?? Feedback.sdkUnknown(rawValue)
    }
}

public enum FilterAction {
    case archive
    case noop
    case sdkUnknown(String)
}

extension FilterAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterAction] {
        return [
            .archive,
            .noop,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .archive: return "ARCHIVE"
        case .noop: return "NOOP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterAction(rawValue: rawValue) ?? FilterAction.sdkUnknown(rawValue)
    }
}

extension Finding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case confidence = "confidence"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case partition = "partition"
        case region = "region"
        case resource = "resource"
        case schemaVersion = "schemaVersion"
        case service = "service"
        case severity = "severity"
        case title = "title"
        case type = "type"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if confidence != 0.0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let schemaVersion = schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if severity != 0.0 {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let confidenceDecoded = try containerValues.decode(Double.self, forKey: .confidence)
        confidence = confidenceDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partition)
        partition = partitionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(Resource.self, forKey: .resource)
        resource = resourceDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Service.self, forKey: .service)
        service = serviceDecoded
        let severityDecoded = try containerValues.decode(Double.self, forKey: .severity)
        severity = severityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Finding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Finding(accountId: \(String(describing: accountId)), arn: \(String(describing: arn)), confidence: \(String(describing: confidence)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), partition: \(String(describing: partition)), region: \(String(describing: region)), resource: \(String(describing: resource)), schemaVersion: \(String(describing: schemaVersion)), service: \(String(describing: service)), severity: \(String(describing: severity)), title: \(String(describing: title)), type: \(String(describing: type)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Contains information about the finding, which is generated when abnormal or suspicious
///       activity is detected.</p>
public struct Finding: Equatable {
    /// <p>The ID of the account in which the finding was generated.</p>
    public let accountId: String?
    /// <p>The ARN of the finding.</p>
    public let arn: String?
    /// <p>The confidence score for the finding.</p>
    public let confidence: Double
    /// <p>The time and date when the finding was created.</p>
    public let createdAt: String?
    /// <p>The description of the finding.</p>
    public let description: String?
    /// <p>The ID of the finding.</p>
    public let id: String?
    /// <p>The partition associated with the finding.</p>
    public let partition: String?
    /// <p>The Region where the finding was generated.</p>
    public let region: String?
    /// <p>Contains information about the AWS resource associated with the activity that prompted
    ///       GuardDuty to generate a finding.</p>
    public let resource: Resource?
    /// <p>The version of the schema used for the finding.</p>
    public let schemaVersion: String?
    /// <p>Contains additional information about the generated finding.</p>
    public let service: Service?
    /// <p>The severity of the finding.</p>
    public let severity: Double
    /// <p>The title of the finding.</p>
    public let title: String?
    /// <p>The type of finding.</p>
    public let type: String?
    /// <p>The time and date when the finding was last updated.</p>
    public let updatedAt: String?

    public init (
        accountId: String? = nil,
        arn: String? = nil,
        confidence: Double = 0.0,
        createdAt: String? = nil,
        description: String? = nil,
        id: String? = nil,
        partition: String? = nil,
        region: String? = nil,
        resource: Resource? = nil,
        schemaVersion: String? = nil,
        service: Service? = nil,
        severity: Double = 0.0,
        title: String? = nil,
        type: String? = nil,
        updatedAt: String? = nil
    )
    {
        self.accountId = accountId
        self.arn = arn
        self.confidence = confidence
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.partition = partition
        self.region = region
        self.resource = resource
        self.schemaVersion = schemaVersion
        self.service = service
        self.severity = severity
        self.title = title
        self.type = type
        self.updatedAt = updatedAt
    }
}

extension FindingCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case criterion = "criterion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterion = criterion {
            var criterionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .criterion)
            for (dictKey0, criterion0) in criterion {
                try criterionContainer.encode(criterion0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionContainer = try containerValues.decodeIfPresent([String: Condition?].self, forKey: .criterion)
        var criterionDecoded0: [String:Condition]? = nil
        if let criterionContainer = criterionContainer {
            criterionDecoded0 = [String:Condition]()
            for (key0, condition0) in criterionContainer {
                if let condition0 = condition0 {
                    criterionDecoded0?[key0] = condition0
                }
            }
        }
        criterion = criterionDecoded0
    }
}

extension FindingCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingCriteria(criterion: \(String(describing: criterion)))"}
}

/// <p>Contains information about the criteria used for querying findings.</p>
public struct FindingCriteria: Equatable {
    /// <p>Represents a map of finding properties that match specified conditions and values when
    ///       querying findings.</p>
    public let criterion: [String:Condition]?

    public init (
        criterion: [String:Condition]? = nil
    )
    {
        self.criterion = criterion
    }
}

public enum FindingPublishingFrequency {
    case fifteenMinutes
    case oneHour
    case sixHours
    case sdkUnknown(String)
}

extension FindingPublishingFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingPublishingFrequency] {
        return [
            .fifteenMinutes,
            .oneHour,
            .sixHours,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fifteenMinutes: return "FIFTEEN_MINUTES"
        case .oneHour: return "ONE_HOUR"
        case .sixHours: return "SIX_HOURS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingPublishingFrequency(rawValue: rawValue) ?? FindingPublishingFrequency.sdkUnknown(rawValue)
    }
}

public enum FindingStatisticType {
    case countBySeverity
    case sdkUnknown(String)
}

extension FindingStatisticType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingStatisticType] {
        return [
            .countBySeverity,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .countBySeverity: return "COUNT_BY_SEVERITY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingStatisticType(rawValue: rawValue) ?? FindingStatisticType.sdkUnknown(rawValue)
    }
}

extension FindingStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case countBySeverity = "countBySeverity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countBySeverity = countBySeverity {
            var countBySeverityContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .countBySeverity)
            for (dictKey0, countbyseverity0) in countBySeverity {
                try countBySeverityContainer.encode(countbyseverity0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countBySeverityContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .countBySeverity)
        var countBySeverityDecoded0: [String:Int]? = nil
        if let countBySeverityContainer = countBySeverityContainer {
            countBySeverityDecoded0 = [String:Int]()
            for (key0, integer0) in countBySeverityContainer {
                if let integer0 = integer0 {
                    countBySeverityDecoded0?[key0] = integer0
                }
            }
        }
        countBySeverity = countBySeverityDecoded0
    }
}

extension FindingStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingStatistics(countBySeverity: \(String(describing: countBySeverity)))"}
}

/// <p>Contains information about finding statistics.</p>
public struct FindingStatistics: Equatable {
    /// <p>Represents a map of severity to count statistics for a set of findings.</p>
    public let countBySeverity: [String:Int]?

    public init (
        countBySeverity: [String:Int]? = nil
    )
    {
        self.countBySeverity = countBySeverity
    }
}

extension FlowLogsConfigurationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension FlowLogsConfigurationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FlowLogsConfigurationResult(status: \(String(describing: status)))"}
}

/// <p>Contains information on the status of VPC flow logs as a data source.</p>
public struct FlowLogsConfigurationResult: Equatable {
    /// <p>Denotes whether VPC flow logs is enabled as a data source.</p>
    public let status: DataSourceStatus?

    public init (
        status: DataSourceStatus? = nil
    )
    {
        self.status = status
    }
}

extension GeoLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lat = "lat"
        case lon = "lon"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if lat != 0.0 {
            try encodeContainer.encode(lat, forKey: .lat)
        }
        if lon != 0.0 {
            try encodeContainer.encode(lon, forKey: .lon)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latDecoded = try containerValues.decode(Double.self, forKey: .lat)
        lat = latDecoded
        let lonDecoded = try containerValues.decode(Double.self, forKey: .lon)
        lon = lonDecoded
    }
}

extension GeoLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoLocation(lat: \(String(describing: lat)), lon: \(String(describing: lon)))"}
}

/// <p>Contains information about the location of the remote IP address.</p>
public struct GeoLocation: Equatable {
    /// <p>The latitude information of the remote IP address.</p>
    public let lat: Double
    /// <p>The longitude information of the remote IP address.</p>
    public let lon: Double

    public init (
        lat: Double = 0.0,
        lon: Double = 0.0
    )
    {
        self.lat = lat
        self.lon = lon
    }
}

extension GetDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDetectorInput(detectorId: \(String(describing: detectorId)))"}
}

extension GetDetectorInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "GetDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorInput>
    public typealias MOutput = OperationOutput<GetDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorOutputError>
}

public struct GetDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDetectorInput>
    public typealias MOutput = OperationOutput<GetDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDetectorOutputError>
}

public struct GetDetectorInput: Equatable {
    /// <p>The unique ID of the detector that you want to get.</p>
    public let detectorId: String?

    public init (
        detectorId: String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetDetectorInputBody: Equatable {
}

extension GetDetectorInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDetectorOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDetectorOutputResponse(createdAt: \(String(describing: createdAt)), dataSources: \(String(describing: dataSources)), findingPublishingFrequency: \(String(describing: findingPublishingFrequency)), serviceRole: \(String(describing: serviceRole)), status: \(String(describing: status)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)))"}
}

extension GetDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.dataSources = output.dataSources
            self.findingPublishingFrequency = output.findingPublishingFrequency
            self.serviceRole = output.serviceRole
            self.status = output.status
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.dataSources = nil
            self.findingPublishingFrequency = nil
            self.serviceRole = nil
            self.status = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDetectorOutputResponse: Equatable {
    /// <p>The timestamp of when the detector was created.</p>
    public let createdAt: String?
    /// <p>Describes which data sources are enabled for the detector.</p>
    public let dataSources: DataSourceConfigurationsResult?
    /// <p>The publishing frequency of the finding.</p>
    public let findingPublishingFrequency: FindingPublishingFrequency?
    /// <p>The GuardDuty service role.</p>
    public let serviceRole: String?
    /// <p>The detector status.</p>
    public let status: DetectorStatus?
    /// <p>The tags of the detector resource.</p>
    public let tags: [String:String]?
    /// <p>The last-updated timestamp for the detector.</p>
    public let updatedAt: String?

    public init (
        createdAt: String? = nil,
        dataSources: DataSourceConfigurationsResult? = nil,
        findingPublishingFrequency: FindingPublishingFrequency? = nil,
        serviceRole: String? = nil,
        status: DetectorStatus? = nil,
        tags: [String:String]? = nil,
        updatedAt: String? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSources = dataSources
        self.findingPublishingFrequency = findingPublishingFrequency
        self.serviceRole = serviceRole
        self.status = status
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetDetectorOutputResponseBody: Equatable {
    public let createdAt: String?
    public let findingPublishingFrequency: FindingPublishingFrequency?
    public let serviceRole: String?
    public let status: DetectorStatus?
    public let updatedAt: String?
    public let dataSources: DataSourceConfigurationsResult?
    public let tags: [String:String]?
}

extension GetDetectorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt = "createdAt"
        case dataSources = "dataSources"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case serviceRole = "serviceRole"
        case status = "status"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DetectorStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(DataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFilterInput(detectorId: \(String(describing: detectorId)), filterName: \(String(describing: filterName)))"}
}

extension GetFilterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFilterInputHeadersMiddleware: Middleware {
    public let id: String = "GetFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFilterInput>
    public typealias MOutput = OperationOutput<GetFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFilterOutputError>
}

public struct GetFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFilterInput>
    public typealias MOutput = OperationOutput<GetFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFilterOutputError>
}

public struct GetFilterInput: Equatable {
    /// <p>The unique ID of the detector that the filter is associated with.</p>
    public let detectorId: String?
    /// <p>The name of the filter you want to get.</p>
    public let filterName: String?

    public init (
        detectorId: String? = nil,
        filterName: String? = nil
    )
    {
        self.detectorId = detectorId
        self.filterName = filterName
    }
}

struct GetFilterInputBody: Equatable {
}

extension GetFilterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFilterOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFilterOutputResponse(action: \(String(describing: action)), description: \(String(describing: description)), findingCriteria: \(String(describing: findingCriteria)), name: \(String(describing: name)), rank: \(String(describing: rank)), tags: \(String(describing: tags)))"}
}

extension GetFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.description = output.description
            self.findingCriteria = output.findingCriteria
            self.name = output.name
            self.rank = output.rank
            self.tags = output.tags
        } else {
            self.action = nil
            self.description = nil
            self.findingCriteria = nil
            self.name = nil
            self.rank = 0
            self.tags = nil
        }
    }
}

public struct GetFilterOutputResponse: Equatable {
    /// <p>Specifies the action that is to be applied to the findings that match the filter.</p>
    public let action: FilterAction?
    /// <p>The description of the filter.</p>
    public let description: String?
    /// <p>Represents the criteria to be used in the filter for querying findings.</p>
    public let findingCriteria: FindingCriteria?
    /// <p>The name of the filter.</p>
    public let name: String?
    /// <p>Specifies the position of the filter in the list of current filters. Also specifies the
    ///       order in which this filter is applied to the findings.</p>
    public let rank: Int
    /// <p>The tags of the filter resource.</p>
    public let tags: [String:String]?

    public init (
        action: FilterAction? = nil,
        description: String? = nil,
        findingCriteria: FindingCriteria? = nil,
        name: String? = nil,
        rank: Int = 0,
        tags: [String:String]? = nil
    )
    {
        self.action = action
        self.description = description
        self.findingCriteria = findingCriteria
        self.name = name
        self.rank = rank
        self.tags = tags
    }
}

struct GetFilterOutputResponseBody: Equatable {
    public let name: String?
    public let description: String?
    public let action: FilterAction?
    public let rank: Int
    public let findingCriteria: FindingCriteria?
    public let tags: [String:String]?
}

extension GetFilterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetFindingsInputBodyMiddleware: Middleware {
    public let id: String = "GetFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

extension GetFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsInput(detectorId: \(String(describing: detectorId)), findingIds: \(String(describing: findingIds)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension GetFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

public struct GetFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

public struct GetFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsInput>
    public typealias MOutput = OperationOutput<GetFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsOutputError>
}

public struct GetFindingsInput: Equatable {
    /// <p>The ID of the detector that specifies the GuardDuty service whose findings you want to
    ///       retrieve.</p>
    public let detectorId: String?
    /// <p>The IDs of the findings that you want to retrieve.</p>
    public let findingIds: [String]?
    /// <p>Represents the criteria used for sorting findings.</p>
    public let sortCriteria: SortCriteria?

    public init (
        detectorId: String? = nil,
        findingIds: [String]? = nil,
        sortCriteria: SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingsInputBody: Equatable {
    public let findingIds: [String]?
    public let sortCriteria: SortCriteria?
}

extension GetFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension GetFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsOutputResponse(findings: \(String(describing: findings)))"}
}

extension GetFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
        } else {
            self.findings = nil
        }
    }
}

public struct GetFindingsOutputResponse: Equatable {
    /// <p>A list of findings.</p>
    public let findings: [Finding]?

    public init (
        findings: [Finding]? = nil
    )
    {
        self.findings = findings
    }
}

struct GetFindingsOutputResponseBody: Equatable {
    public let findings: [Finding]?
}

extension GetFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findings = "findings"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([Finding?].self, forKey: .findings)
        var findingsDecoded0:[Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

public struct GetFindingsStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "GetFindingsStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsStatisticsInput>
    public typealias MOutput = OperationOutput<GetFindingsStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsStatisticsOutputError>
}

extension GetFindingsStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsStatisticsInput(detectorId: \(String(describing: detectorId)), findingCriteria: \(String(describing: findingCriteria)), findingStatisticTypes: \(String(describing: findingStatisticTypes)))"}
}

extension GetFindingsStatisticsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingCriteria = "findingCriteria"
        case findingStatisticTypes = "findingStatisticTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let findingStatisticTypes = findingStatisticTypes {
            var findingStatisticTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingStatisticTypes)
            for findingstatistictypes0 in findingStatisticTypes {
                try findingStatisticTypesContainer.encode(findingstatistictypes0.rawValue)
            }
        }
    }
}

public struct GetFindingsStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingsStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsStatisticsInput>
    public typealias MOutput = OperationOutput<GetFindingsStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsStatisticsOutputError>
}

public struct GetFindingsStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingsStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsStatisticsInput>
    public typealias MOutput = OperationOutput<GetFindingsStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsStatisticsOutputError>
}

public struct GetFindingsStatisticsInput: Equatable {
    /// <p>The ID of the detector that specifies the GuardDuty service whose findings' statistics you
    ///       want to retrieve.</p>
    public let detectorId: String?
    /// <p>Represents the criteria that is used for querying findings.</p>
    public let findingCriteria: FindingCriteria?
    /// <p>The types of finding statistics to retrieve.</p>
    public let findingStatisticTypes: [FindingStatisticType]?

    public init (
        detectorId: String? = nil,
        findingCriteria: FindingCriteria? = nil,
        findingStatisticTypes: [FindingStatisticType]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.findingStatisticTypes = findingStatisticTypes
    }
}

struct GetFindingsStatisticsInputBody: Equatable {
    public let findingStatisticTypes: [FindingStatisticType]?
    public let findingCriteria: FindingCriteria?
}

extension GetFindingsStatisticsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingCriteria = "findingCriteria"
        case findingStatisticTypes = "findingStatisticTypes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingStatisticTypesContainer = try containerValues.decodeIfPresent([FindingStatisticType?].self, forKey: .findingStatisticTypes)
        var findingStatisticTypesDecoded0:[FindingStatisticType]? = nil
        if let findingStatisticTypesContainer = findingStatisticTypesContainer {
            findingStatisticTypesDecoded0 = [FindingStatisticType]()
            for string0 in findingStatisticTypesContainer {
                if let string0 = string0 {
                    findingStatisticTypesDecoded0?.append(string0)
                }
            }
        }
        findingStatisticTypes = findingStatisticTypesDecoded0
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
    }
}

extension GetFindingsStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsStatisticsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsStatisticsOutputResponse(findingStatistics: \(String(describing: findingStatistics)))"}
}

extension GetFindingsStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFindingsStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingStatistics = output.findingStatistics
        } else {
            self.findingStatistics = nil
        }
    }
}

public struct GetFindingsStatisticsOutputResponse: Equatable {
    /// <p>The finding statistics object.</p>
    public let findingStatistics: FindingStatistics?

    public init (
        findingStatistics: FindingStatistics? = nil
    )
    {
        self.findingStatistics = findingStatistics
    }
}

struct GetFindingsStatisticsOutputResponseBody: Equatable {
    public let findingStatistics: FindingStatistics?
}

extension GetFindingsStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingStatistics = "findingStatistics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingStatisticsDecoded = try containerValues.decodeIfPresent(FindingStatistics.self, forKey: .findingStatistics)
        findingStatistics = findingStatisticsDecoded
    }
}

extension GetIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIPSetInput(detectorId: \(String(describing: detectorId)), ipSetId: \(String(describing: ipSetId)))"}
}

extension GetIPSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIPSetInput>
    public typealias MOutput = OperationOutput<GetIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIPSetOutputError>
}

public struct GetIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIPSetInput>
    public typealias MOutput = OperationOutput<GetIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIPSetOutputError>
}

public struct GetIPSetInput: Equatable {
    /// <p>The unique ID of the detector that the IPSet is associated with.</p>
    public let detectorId: String?
    /// <p>The unique ID of the IPSet to retrieve.</p>
    public let ipSetId: String?

    public init (
        detectorId: String? = nil,
        ipSetId: String? = nil
    )
    {
        self.detectorId = detectorId
        self.ipSetId = ipSetId
    }
}

struct GetIPSetInputBody: Equatable {
}

extension GetIPSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIPSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIPSetOutputResponse(format: \(String(describing: format)), location: \(String(describing: location)), name: \(String(describing: name)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension GetIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIPSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.location = output.location
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.format = nil
            self.location = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetIPSetOutputResponse: Equatable {
    /// <p>The format of the file that contains the IPSet.</p>
    public let format: IpSetFormat?
    /// <p>The URI of the file that contains the IPSet. For example:
    ///       https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.</p>
    public let location: String?
    /// <p>The user-friendly name for the IPSet.</p>
    public let name: String?
    /// <p>The status of IPSet file that was uploaded.</p>
    public let status: IpSetStatus?
    /// <p>The tags of the IPSet resource.</p>
    public let tags: [String:String]?

    public init (
        format: IpSetFormat? = nil,
        location: String? = nil,
        name: String? = nil,
        status: IpSetStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.format = format
        self.location = location
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetIPSetOutputResponseBody: Equatable {
    public let name: String?
    public let format: IpSetFormat?
    public let location: String?
    public let status: IpSetStatus?
    public let tags: [String:String]?
}

extension GetIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case format = "format"
        case location = "location"
        case name = "name"
        case status = "status"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(IpSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IpSetStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetInvitationsCountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvitationsCountInput()"}
}

extension GetInvitationsCountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetInvitationsCountInputHeadersMiddleware: Middleware {
    public let id: String = "GetInvitationsCountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvitationsCountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvitationsCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvitationsCountInput>
    public typealias MOutput = OperationOutput<GetInvitationsCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvitationsCountOutputError>
}

public struct GetInvitationsCountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInvitationsCountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInvitationsCountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInvitationsCountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInvitationsCountInput>
    public typealias MOutput = OperationOutput<GetInvitationsCountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInvitationsCountOutputError>
}

public struct GetInvitationsCountInput: Equatable {

    public init() {}
}

struct GetInvitationsCountInputBody: Equatable {
}

extension GetInvitationsCountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetInvitationsCountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInvitationsCountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvitationsCountOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvitationsCountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInvitationsCountOutputResponse(invitationsCount: \(String(describing: invitationsCount)))"}
}

extension GetInvitationsCountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInvitationsCountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitationsCount = output.invitationsCount
        } else {
            self.invitationsCount = 0
        }
    }
}

public struct GetInvitationsCountOutputResponse: Equatable {
    /// <p>The number of received invitations.</p>
    public let invitationsCount: Int

    public init (
        invitationsCount: Int = 0
    )
    {
        self.invitationsCount = invitationsCount
    }
}

struct GetInvitationsCountOutputResponseBody: Equatable {
    public let invitationsCount: Int
}

extension GetInvitationsCountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitationsCount = "invitationsCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsCountDecoded = try containerValues.decode(Int.self, forKey: .invitationsCount)
        invitationsCount = invitationsCountDecoded
    }
}

extension GetMasterAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMasterAccountInput(detectorId: \(String(describing: detectorId)))"}
}

extension GetMasterAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetMasterAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetMasterAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMasterAccountInput>
    public typealias MOutput = OperationOutput<GetMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMasterAccountOutputError>
}

public struct GetMasterAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMasterAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMasterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMasterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMasterAccountInput>
    public typealias MOutput = OperationOutput<GetMasterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMasterAccountOutputError>
}

public struct GetMasterAccountInput: Equatable {
    /// <p>The unique ID of the detector of the GuardDuty member account.</p>
    public let detectorId: String?

    public init (
        detectorId: String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetMasterAccountInputBody: Equatable {
}

extension GetMasterAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetMasterAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMasterAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMasterAccountOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMasterAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMasterAccountOutputResponse(master: \(String(describing: master)))"}
}

extension GetMasterAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMasterAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.master = output.master
        } else {
            self.master = nil
        }
    }
}

public struct GetMasterAccountOutputResponse: Equatable {
    /// <p>The administrator account details.</p>
    public let master: Master?

    public init (
        master: Master? = nil
    )
    {
        self.master = master
    }
}

struct GetMasterAccountOutputResponseBody: Equatable {
    public let master: Master?
}

extension GetMasterAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case master = "master"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterDecoded = try containerValues.decodeIfPresent(Master.self, forKey: .master)
        master = masterDecoded
    }
}

public struct GetMemberDetectorsInputBodyMiddleware: Middleware {
    public let id: String = "GetMemberDetectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMemberDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMemberDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMemberDetectorsInput>
    public typealias MOutput = OperationOutput<GetMemberDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMemberDetectorsOutputError>
}

extension GetMemberDetectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMemberDetectorsInput(accountIds: \(String(describing: accountIds)), detectorId: \(String(describing: detectorId)))"}
}

extension GetMemberDetectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

public struct GetMemberDetectorsInputHeadersMiddleware: Middleware {
    public let id: String = "GetMemberDetectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMemberDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMemberDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMemberDetectorsInput>
    public typealias MOutput = OperationOutput<GetMemberDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMemberDetectorsOutputError>
}

public struct GetMemberDetectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMemberDetectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMemberDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMemberDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMemberDetectorsInput>
    public typealias MOutput = OperationOutput<GetMemberDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMemberDetectorsOutputError>
}

public struct GetMemberDetectorsInput: Equatable {
    /// <p>The account ID of the member account.</p>
    public let accountIds: [String]?
    /// <p>The detector ID for the administrator account.</p>
    public let detectorId: String?

    public init (
        accountIds: [String]? = nil,
        detectorId: String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetMemberDetectorsInputBody: Equatable {
    public let accountIds: [String]?
}

extension GetMemberDetectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMemberDetectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMemberDetectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMemberDetectorsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMemberDetectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMemberDetectorsOutputResponse(memberDataSourceConfigurations: \(String(describing: memberDataSourceConfigurations)), unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension GetMemberDetectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMemberDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberDataSourceConfigurations = output.memberDataSourceConfigurations
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.memberDataSourceConfigurations = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMemberDetectorsOutputResponse: Equatable {
    /// <p>An object that describes which data sources are enabled for a member account.</p>
    public let memberDataSourceConfigurations: [MemberDataSourceConfiguration]?
    /// <p>A list of member account IDs that were unable to be processed along with an explanation
    ///       for why they were not processed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        memberDataSourceConfigurations: [MemberDataSourceConfiguration]? = nil,
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.memberDataSourceConfigurations = memberDataSourceConfigurations
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMemberDetectorsOutputResponseBody: Equatable {
    public let memberDataSourceConfigurations: [MemberDataSourceConfiguration]?
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension GetMemberDetectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case memberDataSourceConfigurations = "members"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDataSourceConfigurationsContainer = try containerValues.decodeIfPresent([MemberDataSourceConfiguration?].self, forKey: .memberDataSourceConfigurations)
        var memberDataSourceConfigurationsDecoded0:[MemberDataSourceConfiguration]? = nil
        if let memberDataSourceConfigurationsContainer = memberDataSourceConfigurationsContainer {
            memberDataSourceConfigurationsDecoded0 = [MemberDataSourceConfiguration]()
            for structure0 in memberDataSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    memberDataSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        memberDataSourceConfigurations = memberDataSourceConfigurationsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct GetMembersInputBodyMiddleware: Middleware {
    public let id: String = "GetMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

extension GetMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMembersInput(accountIds: \(String(describing: accountIds)), detectorId: \(String(describing: detectorId)))"}
}

extension GetMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

public struct GetMembersInputHeadersMiddleware: Middleware {
    public let id: String = "GetMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

public struct GetMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMembersInput>
    public typealias MOutput = OperationOutput<GetMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMembersOutputError>
}

public struct GetMembersInput: Equatable {
    /// <p>A list of account IDs of the GuardDuty member accounts that you want to describe.</p>
    public let accountIds: [String]?
    /// <p>The unique ID of the detector of the GuardDuty account whose members you want to
    ///       retrieve.</p>
    public let detectorId: String?

    public init (
        accountIds: [String]? = nil,
        detectorId: String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension GetMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMembersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMembersOutputResponse(members: \(String(describing: members)), unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension GetMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutputResponse: Equatable {
    /// <p>A list of members.</p>
    public let members: [Member]?
    /// <p>A list of objects that contain the unprocessed account and a result string that explains
    ///       why it was unprocessed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        members: [Member]? = nil,
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputResponseBody: Equatable {
    public let members: [Member]?
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension GetMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "members"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Member?].self, forKey: .members)
        var membersDecoded0:[Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GetThreatIntelSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetThreatIntelSetInput(detectorId: \(String(describing: detectorId)), threatIntelSetId: \(String(describing: threatIntelSetId)))"}
}

extension GetThreatIntelSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetThreatIntelSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetThreatIntelSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetThreatIntelSetInput>
    public typealias MOutput = OperationOutput<GetThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetThreatIntelSetOutputError>
}

public struct GetThreatIntelSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetThreatIntelSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetThreatIntelSetInput>
    public typealias MOutput = OperationOutput<GetThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetThreatIntelSetOutputError>
}

public struct GetThreatIntelSetInput: Equatable {
    /// <p>The unique ID of the detector that the threatIntelSet is associated with.</p>
    public let detectorId: String?
    /// <p>The unique ID of the threatIntelSet that you want to get.</p>
    public let threatIntelSetId: String?

    public init (
        detectorId: String? = nil,
        threatIntelSetId: String? = nil
    )
    {
        self.detectorId = detectorId
        self.threatIntelSetId = threatIntelSetId
    }
}

struct GetThreatIntelSetInputBody: Equatable {
}

extension GetThreatIntelSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetThreatIntelSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThreatIntelSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetThreatIntelSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThreatIntelSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetThreatIntelSetOutputResponse(format: \(String(describing: format)), location: \(String(describing: location)), name: \(String(describing: name)), status: \(String(describing: status)), tags: \(String(describing: tags)))"}
}

extension GetThreatIntelSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetThreatIntelSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.location = output.location
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.format = nil
            self.location = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetThreatIntelSetOutputResponse: Equatable {
    /// <p>The format of the threatIntelSet.</p>
    public let format: ThreatIntelSetFormat?
    /// <p>The URI of the file that contains the ThreatIntelSet. For example:
    ///       https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.</p>
    public let location: String?
    /// <p>A user-friendly ThreatIntelSet name displayed in all findings that are generated by
    ///       activity that involves IP addresses included in this ThreatIntelSet.</p>
    public let name: String?
    /// <p>The status of threatIntelSet file uploaded.</p>
    public let status: ThreatIntelSetStatus?
    /// <p>The tags of the threat list resource.</p>
    public let tags: [String:String]?

    public init (
        format: ThreatIntelSetFormat? = nil,
        location: String? = nil,
        name: String? = nil,
        status: ThreatIntelSetStatus? = nil,
        tags: [String:String]? = nil
    )
    {
        self.format = format
        self.location = location
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetThreatIntelSetOutputResponseBody: Equatable {
    public let name: String?
    public let format: ThreatIntelSetFormat?
    public let location: String?
    public let status: ThreatIntelSetStatus?
    public let tags: [String:String]?
}

extension GetThreatIntelSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case format = "format"
        case location = "location"
        case name = "name"
        case status = "status"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ThreatIntelSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ThreatIntelSetStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct GetUsageStatisticsInputBodyMiddleware: Middleware {
    public let id: String = "GetUsageStatisticsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageStatisticsInput>
    public typealias MOutput = OperationOutput<GetUsageStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageStatisticsOutputError>
}

extension GetUsageStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageStatisticsInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), unit: \(String(describing: unit)), usageCriteria: \(String(describing: usageCriteria)), usageStatisticType: \(String(describing: usageStatisticType)))"}
}

extension GetUsageStatisticsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case unit = "unit"
        case usageCriteria = "usageCriteria"
        case usageStatisticType = "usageStatisticsType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageCriteria = usageCriteria {
            try encodeContainer.encode(usageCriteria, forKey: .usageCriteria)
        }
        if let usageStatisticType = usageStatisticType {
            try encodeContainer.encode(usageStatisticType.rawValue, forKey: .usageStatisticType)
        }
    }
}

public struct GetUsageStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsageStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageStatisticsInput>
    public typealias MOutput = OperationOutput<GetUsageStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageStatisticsOutputError>
}

public struct GetUsageStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsageStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageStatisticsInput>
    public typealias MOutput = OperationOutput<GetUsageStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageStatisticsOutputError>
}

public struct GetUsageStatisticsInput: Equatable {
    /// <p>The ID of the detector that specifies the GuardDuty service whose usage statistics you
    ///       want to retrieve.</p>
    public let detectorId: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int
    /// <p>A token to use for paginating results that are returned in the response. Set the value of
    ///       this parameter to null for the first request to a list action. For subsequent calls, use the
    ///       NextToken value returned from the previous request to continue listing results after the first
    ///       page.</p>
    public let nextToken: String?
    /// <p>The currency unit you would like to view your usage statistics in. Current valid values
    ///       are USD.</p>
    public let unit: String?
    /// <p>Represents the criteria used for querying usage.</p>
    public let usageCriteria: UsageCriteria?
    /// <p>The type of usage statistics to retrieve.</p>
    public let usageStatisticType: UsageStatisticType?

    public init (
        detectorId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        unit: String? = nil,
        usageCriteria: UsageCriteria? = nil,
        usageStatisticType: UsageStatisticType? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.unit = unit
        self.usageCriteria = usageCriteria
        self.usageStatisticType = usageStatisticType
    }
}

struct GetUsageStatisticsInputBody: Equatable {
    public let usageStatisticType: UsageStatisticType?
    public let usageCriteria: UsageCriteria?
    public let unit: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension GetUsageStatisticsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case unit = "unit"
        case usageCriteria = "usageCriteria"
        case usageStatisticType = "usageStatisticsType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageStatisticTypeDecoded = try containerValues.decodeIfPresent(UsageStatisticType.self, forKey: .usageStatisticType)
        usageStatisticType = usageStatisticTypeDecoded
        let usageCriteriaDecoded = try containerValues.decodeIfPresent(UsageCriteria.self, forKey: .usageCriteria)
        usageCriteria = usageCriteriaDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetUsageStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsageStatisticsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageStatisticsOutputResponse(nextToken: \(String(describing: nextToken)), usageStatistics: \(String(describing: usageStatistics)))"}
}

extension GetUsageStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUsageStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageStatistics = output.usageStatistics
        } else {
            self.nextToken = nil
            self.usageStatistics = nil
        }
    }
}

public struct GetUsageStatisticsOutputResponse: Equatable {
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?
    /// <p>The usage statistics object. If a UsageStatisticType was provided, the objects
    ///       representing other types will be null.</p>
    public let usageStatistics: UsageStatistics?

    public init (
        nextToken: String? = nil,
        usageStatistics: UsageStatistics? = nil
    )
    {
        self.nextToken = nextToken
        self.usageStatistics = usageStatistics
    }
}

struct GetUsageStatisticsOutputResponseBody: Equatable {
    public let usageStatistics: UsageStatistics?
    public let nextToken: String?
}

extension GetUsageStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case usageStatistics = "usageStatistics"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageStatisticsDecoded = try containerValues.decodeIfPresent(UsageStatistics.self, forKey: .usageStatistics)
        usageStatistics = usageStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IamInstanceProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension IamInstanceProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IamInstanceProfile(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

/// <p>Contains information about the EC2 instance profile.</p>
public struct IamInstanceProfile: Equatable {
    /// <p>The profile ARN of the EC2 instance.</p>
    public let arn: String?
    /// <p>The profile ID of the EC2 instance.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

extension InstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "availabilityZone"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageDescription = "imageDescription"
        case imageId = "imageId"
        case instanceId = "instanceId"
        case instanceState = "instanceState"
        case instanceType = "instanceType"
        case launchTime = "launchTime"
        case networkInterfaces = "networkInterfaces"
        case outpostArn = "outpostArn"
        case platform = "platform"
        case productCodes = "productCodes"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let iamInstanceProfile = iamInstanceProfile {
            try encodeContainer.encode(iamInstanceProfile, forKey: .iamInstanceProfile)
        }
        if let imageDescription = imageDescription {
            try encodeContainer.encode(imageDescription, forKey: .imageDescription)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceId = instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceState = instanceState {
            try encodeContainer.encode(instanceState, forKey: .instanceState)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let launchTime = launchTime {
            try encodeContainer.encode(launchTime, forKey: .launchTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if let outpostArn = outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let productCodes = productCodes {
            var productCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productCodes)
            for productcodes0 in productCodes {
                try productCodesContainer.encode(productcodes0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(IamInstanceProfile.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let imageDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageDescription)
        imageDescription = imageDescriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceState)
        instanceState = instanceStateDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let launchTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let productCodesContainer = try containerValues.decodeIfPresent([ProductCode?].self, forKey: .productCodes)
        var productCodesDecoded0:[ProductCode]? = nil
        if let productCodesContainer = productCodesContainer {
            productCodesDecoded0 = [ProductCode]()
            for structure0 in productCodesContainer {
                if let structure0 = structure0 {
                    productCodesDecoded0?.append(structure0)
                }
            }
        }
        productCodes = productCodesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension InstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceDetails(availabilityZone: \(String(describing: availabilityZone)), iamInstanceProfile: \(String(describing: iamInstanceProfile)), imageDescription: \(String(describing: imageDescription)), imageId: \(String(describing: imageId)), instanceId: \(String(describing: instanceId)), instanceState: \(String(describing: instanceState)), instanceType: \(String(describing: instanceType)), launchTime: \(String(describing: launchTime)), networkInterfaces: \(String(describing: networkInterfaces)), outpostArn: \(String(describing: outpostArn)), platform: \(String(describing: platform)), productCodes: \(String(describing: productCodes)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about the details of an instance.</p>
public struct InstanceDetails: Equatable {
    /// <p>The Availability Zone of the EC2 instance.</p>
    public let availabilityZone: String?
    /// <p>The profile information of the EC2 instance.</p>
    public let iamInstanceProfile: IamInstanceProfile?
    /// <p>The image description of the EC2 instance.</p>
    public let imageDescription: String?
    /// <p>The image ID of the EC2 instance.</p>
    public let imageId: String?
    /// <p>The ID of the EC2 instance.</p>
    public let instanceId: String?
    /// <p>The state of the EC2 instance.</p>
    public let instanceState: String?
    /// <p>The type of the EC2 instance.</p>
    public let instanceType: String?
    /// <p>The launch time of the EC2 instance.</p>
    public let launchTime: String?
    /// <p>The elastic network interface information of the EC2 instance.</p>
    public let networkInterfaces: [NetworkInterface]?
    /// <p>The Amazon Resource Name (ARN) of the AWS Outpost. Only applicable to AWS Outposts
    ///       instances.</p>
    public let outpostArn: String?
    /// <p>The platform of the EC2 instance.</p>
    public let platform: String?
    /// <p>The product code of the EC2 instance.</p>
    public let productCodes: [ProductCode]?
    /// <p>The tags of the EC2 instance.</p>
    public let tags: [Tag]?

    public init (
        availabilityZone: String? = nil,
        iamInstanceProfile: IamInstanceProfile? = nil,
        imageDescription: String? = nil,
        imageId: String? = nil,
        instanceId: String? = nil,
        instanceState: String? = nil,
        instanceType: String? = nil,
        launchTime: String? = nil,
        networkInterfaces: [NetworkInterface]? = nil,
        outpostArn: String? = nil,
        platform: String? = nil,
        productCodes: [ProductCode]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.iamInstanceProfile = iamInstanceProfile
        self.imageDescription = imageDescription
        self.imageId = imageId
        self.instanceId = instanceId
        self.instanceState = instanceState
        self.instanceType = instanceType
        self.launchTime = launchTime
        self.networkInterfaces = networkInterfaces
        self.outpostArn = outpostArn
        self.platform = platform
        self.productCodes = productCodes
        self.tags = tags
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An internal server error exception object.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The error message.</p>
    public var message: String?
    /// <p>The error type.</p>
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
    public let type: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension Invitation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension Invitation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Invitation(accountId: \(String(describing: accountId)), invitationId: \(String(describing: invitationId)), invitedAt: \(String(describing: invitedAt)), relationshipStatus: \(String(describing: relationshipStatus)))"}
}

/// <p>Contains information about the invitation to become a member account.</p>
public struct Invitation: Equatable {
    /// <p>The ID of the account that the invitation was sent from.</p>
    public let accountId: String?
    /// <p>The ID of the invitation. This value is used to validate the inviter account to the member
    ///       account.</p>
    public let invitationId: String?
    /// <p>The timestamp when the invitation was sent.</p>
    public let invitedAt: String?
    /// <p>The status of the relationship between the inviter and invitee accounts.</p>
    public let relationshipStatus: String?

    public init (
        accountId: String? = nil,
        invitationId: String? = nil,
        invitedAt: String? = nil,
        relationshipStatus: String? = nil
    )
    {
        self.accountId = accountId
        self.invitationId = invitationId
        self.invitedAt = invitedAt
        self.relationshipStatus = relationshipStatus
    }
}

public struct InviteMembersInputBodyMiddleware: Middleware {
    public let id: String = "InviteMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InviteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<InviteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InviteMembersInput>
    public typealias MOutput = OperationOutput<InviteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InviteMembersOutputError>
}

extension InviteMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InviteMembersInput(accountIds: \(String(describing: accountIds)), detectorId: \(String(describing: detectorId)), disableEmailNotification: \(String(describing: disableEmailNotification)), message: \(String(describing: message)))"}
}

extension InviteMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if disableEmailNotification != false {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

public struct InviteMembersInputHeadersMiddleware: Middleware {
    public let id: String = "InviteMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InviteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<InviteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InviteMembersInput>
    public typealias MOutput = OperationOutput<InviteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InviteMembersOutputError>
}

public struct InviteMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "InviteMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InviteMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<InviteMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InviteMembersInput>
    public typealias MOutput = OperationOutput<InviteMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InviteMembersOutputError>
}

public struct InviteMembersInput: Equatable {
    /// <p>A list of account IDs of the accounts that you want to invite to GuardDuty as
    ///       members.</p>
    public let accountIds: [String]?
    /// <p>The unique ID of the detector of the GuardDuty account that you want to invite members
    ///       with.</p>
    public let detectorId: String?
    /// <p>A Boolean value that specifies whether you want to disable email notification to the accounts that you are inviting to GuardDuty as members.</p>
    public let disableEmailNotification: Bool
    /// <p>The invitation message that you want to send to the accounts that you're inviting to
    ///       GuardDuty as members.</p>
    public let message: String?

    public init (
        accountIds: [String]? = nil,
        detectorId: String? = nil,
        disableEmailNotification: Bool = false,
        message: String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
        self.disableEmailNotification = disableEmailNotification
        self.message = message
    }
}

struct InviteMembersInputBody: Equatable {
    public let accountIds: [String]?
    public let disableEmailNotification: Bool
    public let message: String?
}

extension InviteMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let disableEmailNotificationDecoded = try containerValues.decode(Bool.self, forKey: .disableEmailNotification)
        disableEmailNotification = disableEmailNotificationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InviteMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InviteMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InviteMembersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InviteMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InviteMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension InviteMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InviteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct InviteMembersOutputResponse: Equatable {
    /// <p>A list of objects that contain the unprocessed account and a result string that explains
    ///       why it was unprocessed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct InviteMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension InviteMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public enum IpSetFormat {
    case alienVault
    case fireEye
    case otxCsv
    case proofPoint
    case stix
    case txt
    case sdkUnknown(String)
}

extension IpSetFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IpSetFormat] {
        return [
            .alienVault,
            .fireEye,
            .otxCsv,
            .proofPoint,
            .stix,
            .txt,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alienVault: return "ALIEN_VAULT"
        case .fireEye: return "FIRE_EYE"
        case .otxCsv: return "OTX_CSV"
        case .proofPoint: return "PROOF_POINT"
        case .stix: return "STIX"
        case .txt: return "TXT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IpSetFormat(rawValue: rawValue) ?? IpSetFormat.sdkUnknown(rawValue)
    }
}

public enum IpSetStatus {
    case activating
    case active
    case deactivating
    case deleted
    case deletePending
    case error
    case inactive
    case sdkUnknown(String)
}

extension IpSetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IpSetStatus] {
        return [
            .activating,
            .active,
            .deactivating,
            .deleted,
            .deletePending,
            .error,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activating: return "ACTIVATING"
        case .active: return "ACTIVE"
        case .deactivating: return "DEACTIVATING"
        case .deleted: return "DELETED"
        case .deletePending: return "DELETE_PENDING"
        case .error: return "ERROR"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IpSetStatus(rawValue: rawValue) ?? IpSetStatus.sdkUnknown(rawValue)
    }
}

extension ListDetectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectorsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDetectorsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDetectorsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDetectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectorsInput>
    public typealias MOutput = OperationOutput<ListDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectorsOutputError>
}

public struct ListDetectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDetectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDetectorsInput>
    public typealias MOutput = OperationOutput<ListDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDetectorsOutputError>
}

public struct ListDetectorsInput: Equatable {
    /// <p>You can use this parameter to indicate the maximum number of items that you want in the
    ///       response. The default value is 50. The maximum value is 50.</p>
    public let maxResults: Int
    /// <p>You can use this parameter when paginating results. Set the value of this parameter to
    ///       null on your first call to the list action. For subsequent calls to the action, fill nextToken
    ///       in the request with the value of NextToken from the previous response to continue listing
    ///       data.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorsInputBody: Equatable {
}

extension ListDetectorsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDetectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDetectorsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDetectorsOutputResponse(detectorIds: \(String(describing: detectorIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDetectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorIds = output.detectorIds
            self.nextToken = output.nextToken
        } else {
            self.detectorIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorsOutputResponse: Equatable {
    /// <p>A list of detector IDs.</p>
    public let detectorIds: [String]?
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?

    public init (
        detectorIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.detectorIds = detectorIds
        self.nextToken = nextToken
    }
}

struct ListDetectorsOutputResponseBody: Equatable {
    public let detectorIds: [String]?
    public let nextToken: String?
}

extension ListDetectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectorIds = "detectorIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .detectorIds)
        var detectorIdsDecoded0:[String]? = nil
        if let detectorIdsContainer = detectorIdsContainer {
            detectorIdsDecoded0 = [String]()
            for string0 in detectorIdsContainer {
                if let string0 = string0 {
                    detectorIdsDecoded0?.append(string0)
                }
            }
        }
        detectorIds = detectorIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFiltersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFiltersInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFiltersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFiltersInputHeadersMiddleware: Middleware {
    public let id: String = "ListFiltersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFiltersInput>
    public typealias MOutput = OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFiltersOutputError>
}

public struct ListFiltersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFiltersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFiltersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFiltersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFiltersInput>
    public typealias MOutput = OperationOutput<ListFiltersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFiltersOutputError>
}

public struct ListFiltersInput: Equatable {
    /// <p>The unique ID of the detector that the filter is associated with.</p>
    public let detectorId: String?
    /// <p>You can use this parameter to indicate the maximum number of items that you want in the
    ///       response. The default value is 50. The maximum value is 50.</p>
    public let maxResults: Int
    /// <p>You can use this parameter when paginating results. Set the value of this parameter to
    ///       null on your first call to the list action. For subsequent calls to the action, fill nextToken
    ///       in the request with the value of NextToken from the previous response to continue listing
    ///       data.</p>
    public let nextToken: String?

    public init (
        detectorId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Equatable {
}

extension ListFiltersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFiltersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFiltersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFiltersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFiltersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFiltersOutputResponse(filterNames: \(String(describing: filterNames)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFiltersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFiltersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filterNames = output.filterNames
            self.nextToken = output.nextToken
        } else {
            self.filterNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutputResponse: Equatable {
    /// <p>A list of filter names.</p>
    public let filterNames: [String]?
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?

    public init (
        filterNames: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.filterNames = filterNames
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputResponseBody: Equatable {
    public let filterNames: [String]?
    public let nextToken: String?
}

extension ListFiltersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterNames = "filterNames"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .filterNames)
        var filterNamesDecoded0:[String]? = nil
        if let filterNamesContainer = filterNamesContainer {
            filterNamesDecoded0 = [String]()
            for string0 in filterNamesContainer {
                if let string0 = string0 {
                    filterNamesDecoded0?.append(string0)
                }
            }
        }
        filterNames = filterNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFindingsInputBodyMiddleware: Middleware {
    public let id: String = "ListFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

extension ListFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsInput(detectorId: \(String(describing: detectorId)), findingCriteria: \(String(describing: findingCriteria)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortCriteria: \(String(describing: sortCriteria)))"}
}

extension ListFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

public struct ListFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

public struct ListFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

public struct ListFindingsInput: Equatable {
    /// <p>The ID of the detector that specifies the GuardDuty service whose findings you want to
    ///       list.</p>
    public let detectorId: String?
    /// <p>Represents the criteria used for querying findings. Valid values include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>JSON field name</p>
    ///             </li>
    ///             <li>
    ///                <p>accountId</p>
    ///             </li>
    ///             <li>
    ///                <p>region</p>
    ///             </li>
    ///             <li>
    ///                <p>confidence</p>
    ///             </li>
    ///             <li>
    ///                <p>id</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.accessKeyDetails.accessKeyId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.accessKeyDetails.principalId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.accessKeyDetails.userName</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.accessKeyDetails.userType</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.iamInstanceProfile.id</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.imageId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.instanceId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.ipv6Addresses</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.publicDnsName</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.publicIp</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.securityGroups.groupId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.securityGroups.groupName</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.subnetId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.networkInterfaces.vpcId</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.tags.key</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.instanceDetails.tags.value</p>
    ///             </li>
    ///             <li>
    ///                <p>resource.resourceType</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.actionType</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.api</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.callerType</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.city.cityName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.country.countryName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.ipAddressV4</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.organization.asn</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.awsApiCallAction.serviceName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.dnsRequestAction.domain</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.blocked</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.connectionDirection</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.localPortDetails.port</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.protocol</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.city.cityName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.country.countryName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.ipAddressV4</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.organization.asn</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg</p>
    ///             </li>
    ///             <li>
    ///                <p>service.action.networkConnectionAction.remotePortDetails.port</p>
    ///             </li>
    ///             <li>
    ///                <p>service.additionalInfo.threatListName</p>
    ///             </li>
    ///             <li>
    ///                <p>service.archived</p>
    ///                <p>When this attribute is set to 'true', only archived findings are listed. When it's set
    ///           to 'false', only unarchived findings are listed. When this attribute is not set, all
    ///           existing findings are listed.</p>
    ///             </li>
    ///             <li>
    ///                <p>service.resourceRole</p>
    ///             </li>
    ///             <li>
    ///                <p>severity</p>
    ///             </li>
    ///             <li>
    ///                <p>type</p>
    ///             </li>
    ///             <li>
    ///                <p>updatedAt</p>
    ///                <p>Type: Timestamp in Unix Epoch millisecond format: 1486685375000</p>
    ///             </li>
    ///          </ul>
    public let findingCriteria: FindingCriteria?
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///       response. The default value is 50. The maximum value is 50.</p>
    public let maxResults: Int
    /// <p>You can use this parameter when paginating results. Set the value of this parameter to
    ///       null on your first call to the list action. For subsequent calls to the action, fill nextToken
    ///       in the request with the value of NextToken from the previous response to continue listing
    ///       data.</p>
    public let nextToken: String?
    /// <p>Represents the criteria used for sorting findings.</p>
    public let sortCriteria: SortCriteria?

    public init (
        detectorId: String? = nil,
        findingCriteria: FindingCriteria? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortCriteria: SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListFindingsInputBody: Equatable {
    public let findingCriteria: FindingCriteria?
    public let sortCriteria: SortCriteria?
    public let maxResults: Int
    public let nextToken: String?
}

extension ListFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsOutputResponse(findingIds: \(String(describing: findingIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingIds = output.findingIds
            self.nextToken = output.nextToken
        } else {
            self.findingIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutputResponse: Equatable {
    /// <p>The IDs of the findings that you're listing.</p>
    public let findingIds: [String]?
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?

    public init (
        findingIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.findingIds = findingIds
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Equatable {
    public let findingIds: [String]?
    public let nextToken: String?
}

extension ListFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIPSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIPSetsInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIPSetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListIPSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIPSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIPSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIPSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIPSetsInput>
    public typealias MOutput = OperationOutput<ListIPSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIPSetsOutputError>
}

public struct ListIPSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIPSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIPSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIPSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIPSetsInput>
    public typealias MOutput = OperationOutput<ListIPSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIPSetsOutputError>
}

public struct ListIPSetsInput: Equatable {
    /// <p>The unique ID of the detector that the IPSet is associated with.</p>
    public let detectorId: String?
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///       response. The default value is 50. The maximum value is 50.</p>
    public let maxResults: Int
    /// <p>You can use this parameter when paginating results. Set the value of this parameter to
    ///       null on your first call to the list action. For subsequent calls to the action, fill nextToken
    ///       in the request with the value of NextToken from the previous response to continue listing
    ///       data.</p>
    public let nextToken: String?

    public init (
        detectorId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIPSetsInputBody: Equatable {
}

extension ListIPSetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListIPSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIPSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIPSetsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIPSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIPSetsOutputResponse(ipSetIds: \(String(describing: ipSetIds)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIPSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListIPSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipSetIds = output.ipSetIds
            self.nextToken = output.nextToken
        } else {
            self.ipSetIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListIPSetsOutputResponse: Equatable {
    /// <p>The IDs of the IPSet resources.</p>
    public let ipSetIds: [String]?
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?

    public init (
        ipSetIds: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.ipSetIds = ipSetIds
        self.nextToken = nextToken
    }
}

struct ListIPSetsOutputResponseBody: Equatable {
    public let ipSetIds: [String]?
    public let nextToken: String?
}

extension ListIPSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ipSetIds = "ipSetIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipSetIds)
        var ipSetIdsDecoded0:[String]? = nil
        if let ipSetIdsContainer = ipSetIdsContainer {
            ipSetIdsDecoded0 = [String]()
            for string0 in ipSetIdsContainer {
                if let string0 = string0 {
                    ipSetIdsDecoded0?.append(string0)
                }
            }
        }
        ipSetIds = ipSetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInvitationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvitationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInvitationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListInvitationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListInvitationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListInvitationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListInvitationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListInvitationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListInvitationsInput>
    public typealias MOutput = OperationOutput<ListInvitationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListInvitationsOutputError>
}

public struct ListInvitationsInput: Equatable {
    /// <p>You can use this parameter to indicate the maximum number of items that you want in the
    ///       response. The default value is 50. The maximum value is 50.</p>
    public let maxResults: Int
    /// <p>You can use this parameter when paginating results. Set the value of this parameter to
    ///       null on your first call to the list action. For subsequent calls to the action, fill nextToken
    ///       in the request with the value of NextToken from the previous response to continue listing
    ///       data.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Equatable {
}

extension ListInvitationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListInvitationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInvitationsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListInvitationsOutputResponse(invitations: \(String(describing: invitations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListInvitationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Equatable {
    /// <p>A list of invitation descriptions.</p>
    public let invitations: [Invitation]?
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?

    public init (
        invitations: [Invitation]? = nil,
        nextToken: String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Equatable {
    public let invitations: [Invitation]?
    public let nextToken: String?
}

extension ListInvitationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invitations = "invitations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([Invitation?].self, forKey: .invitations)
        var invitationsDecoded0:[Invitation]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [Invitation]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMembersInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), onlyAssociated: \(String(describing: onlyAssociated)))"}
}

extension ListMembersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListMembersInputHeadersMiddleware: Middleware {
    public let id: String = "ListMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

public struct ListMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let onlyAssociated = input.operationInput.onlyAssociated {
            let onlyAssociatedQueryItem = URLQueryItem(name: "onlyAssociated".urlPercentEncoding(), value: String(onlyAssociated).urlPercentEncoding())
            input.builder.withQueryItem(onlyAssociatedQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMembersInput>
    public typealias MOutput = OperationOutput<ListMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMembersOutputError>
}

public struct ListMembersInput: Equatable {
    /// <p>The unique ID of the detector the member is associated with.</p>
    public let detectorId: String?
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///       response. The default value is 50. The maximum value is 50.</p>
    public let maxResults: Int
    /// <p>You can use this parameter when paginating results. Set the value of this parameter to
    ///       null on your first call to the list action. For subsequent calls to the action, fill nextToken
    ///       in the request with the value of NextToken from the previous response to continue listing
    ///       data.</p>
    public let nextToken: String?
    /// <p>Specifies whether to only return associated members or to return all members (including
    ///       members who haven't been invited yet or have been disassociated).</p>
    public let onlyAssociated: String?

    public init (
        detectorId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        onlyAssociated: String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Equatable {
}

extension ListMembersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMembersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMembersOutputResponse(members: \(String(describing: members)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Equatable {
    /// <p>A list of members.</p>
    public let members: [Member]?
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?

    public init (
        members: [Member]? = nil,
        nextToken: String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Equatable {
    public let members: [Member]?
    public let nextToken: String?
}

extension ListMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Member?].self, forKey: .members)
        var membersDecoded0:[Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationAdminAccountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationAdminAccountsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOrganizationAdminAccountsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListOrganizationAdminAccountsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOrganizationAdminAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationAdminAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationAdminAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationAdminAccountsInput>
    public typealias MOutput = OperationOutput<ListOrganizationAdminAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationAdminAccountsOutputError>
}

public struct ListOrganizationAdminAccountsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOrganizationAdminAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationAdminAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationAdminAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationAdminAccountsInput>
    public typealias MOutput = OperationOutput<ListOrganizationAdminAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationAdminAccountsOutputError>
}

public struct ListOrganizationAdminAccountsInput: Equatable {
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int
    /// <p>A token to use for paginating results that are returned in the response. Set the value of
    ///       this parameter to null for the first request to a list action. For subsequent calls, use the
    ///         <code>NextToken</code> value returned from the previous request to continue listing results
    ///       after the first page.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Equatable {
}

extension ListOrganizationAdminAccountsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListOrganizationAdminAccountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationAdminAccountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationAdminAccountsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationAdminAccountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationAdminAccountsOutputResponse(adminAccounts: \(String(describing: adminAccounts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOrganizationAdminAccountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOrganizationAdminAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccounts = output.adminAccounts
            self.nextToken = output.nextToken
        } else {
            self.adminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutputResponse: Equatable {
    /// <p>A list of accounts configured as GuardDuty delegated
    ///       administrators.</p>
    public let adminAccounts: [AdminAccount]?
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?

    public init (
        adminAccounts: [AdminAccount]? = nil,
        nextToken: String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputResponseBody: Equatable {
    public let adminAccounts: [AdminAccount]?
    public let nextToken: String?
}

extension ListOrganizationAdminAccountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccounts = "adminAccounts"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountsContainer = try containerValues.decodeIfPresent([AdminAccount?].self, forKey: .adminAccounts)
        var adminAccountsDecoded0:[AdminAccount]? = nil
        if let adminAccountsContainer = adminAccountsContainer {
            adminAccountsDecoded0 = [AdminAccount]()
            for structure0 in adminAccountsContainer {
                if let structure0 = structure0 {
                    adminAccountsDecoded0?.append(structure0)
                }
            }
        }
        adminAccounts = adminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPublishingDestinationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPublishingDestinationsInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPublishingDestinationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPublishingDestinationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPublishingDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublishingDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublishingDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublishingDestinationsInput>
    public typealias MOutput = OperationOutput<ListPublishingDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublishingDestinationsOutputError>
}

public struct ListPublishingDestinationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPublishingDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublishingDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublishingDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublishingDestinationsInput>
    public typealias MOutput = OperationOutput<ListPublishingDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublishingDestinationsOutputError>
}

public struct ListPublishingDestinationsInput: Equatable {
    /// <p>The ID of the detector to retrieve publishing destinations for.</p>
    public let detectorId: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int
    /// <p>A token to use for paginating results that are returned in the response. Set the value of
    ///       this parameter to null for the first request to a list action. For subsequent calls, use the
    ///         <code>NextToken</code> value returned from the previous request to continue listing results
    ///       after the first page.</p>
    public let nextToken: String?

    public init (
        detectorId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPublishingDestinationsInputBody: Equatable {
}

extension ListPublishingDestinationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPublishingDestinationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPublishingDestinationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublishingDestinationsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublishingDestinationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPublishingDestinationsOutputResponse(destinations: \(String(describing: destinations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPublishingDestinationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPublishingDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinations = output.destinations
            self.nextToken = output.nextToken
        } else {
            self.destinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListPublishingDestinationsOutputResponse: Equatable {
    /// <p>A <code>Destinations</code> object that includes information about each publishing
    ///       destination returned.</p>
    public let destinations: [Destination]?
    /// <p>A token to use for paginating results that are returned in the response. Set the value of
    ///       this parameter to null for the first request to a list action. For subsequent calls, use the
    ///         <code>NextToken</code> value returned from the previous request to continue listing results
    ///       after the first page.</p>
    public let nextToken: String?

    public init (
        destinations: [Destination]? = nil,
        nextToken: String? = nil
    )
    {
        self.destinations = destinations
        self.nextToken = nextToken
    }
}

struct ListPublishingDestinationsOutputResponseBody: Equatable {
    public let destinations: [Destination]?
    public let nextToken: String?
}

extension ListPublishingDestinationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinations = "destinations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the given GuardDuty resource. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags associated with the resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListThreatIntelSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThreatIntelSetsInput(detectorId: \(String(describing: detectorId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListThreatIntelSetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListThreatIntelSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListThreatIntelSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThreatIntelSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThreatIntelSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThreatIntelSetsInput>
    public typealias MOutput = OperationOutput<ListThreatIntelSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThreatIntelSetsOutputError>
}

public struct ListThreatIntelSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListThreatIntelSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListThreatIntelSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListThreatIntelSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if input.operationInput.maxResults != 0 {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListThreatIntelSetsInput>
    public typealias MOutput = OperationOutput<ListThreatIntelSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListThreatIntelSetsOutputError>
}

public struct ListThreatIntelSetsInput: Equatable {
    /// <p>The unique ID of the detector that the threatIntelSet is associated with.</p>
    public let detectorId: String?
    /// <p>You can use this parameter to indicate the maximum number of items that you want in the
    ///       response. The default value is 50. The maximum value is 50.</p>
    public let maxResults: Int
    /// <p>You can use this parameter to paginate results in the response. Set the value of this
    ///       parameter to null on your first call to the list action. For subsequent calls to the action,
    ///       fill nextToken in the request with the value of NextToken from the previous response to
    ///       continue listing data.</p>
    public let nextToken: String?

    public init (
        detectorId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThreatIntelSetsInputBody: Equatable {
}

extension ListThreatIntelSetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListThreatIntelSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThreatIntelSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThreatIntelSetsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThreatIntelSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListThreatIntelSetsOutputResponse(nextToken: \(String(describing: nextToken)), threatIntelSetIds: \(String(describing: threatIntelSetIds)))"}
}

extension ListThreatIntelSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListThreatIntelSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.threatIntelSetIds = output.threatIntelSetIds
        } else {
            self.nextToken = nil
            self.threatIntelSetIds = nil
        }
    }
}

public struct ListThreatIntelSetsOutputResponse: Equatable {
    /// <p>The pagination parameter to be used on the next list operation to retrieve more
    ///       items.</p>
    public let nextToken: String?
    /// <p>The IDs of the ThreatIntelSet resources.</p>
    public let threatIntelSetIds: [String]?

    public init (
        nextToken: String? = nil,
        threatIntelSetIds: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.threatIntelSetIds = threatIntelSetIds
    }
}

struct ListThreatIntelSetsOutputResponseBody: Equatable {
    public let threatIntelSetIds: [String]?
    public let nextToken: String?
}

extension ListThreatIntelSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case threatIntelSetIds = "threatIntelSetIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelSetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .threatIntelSetIds)
        var threatIntelSetIdsDecoded0:[String]? = nil
        if let threatIntelSetIdsContainer = threatIntelSetIdsContainer {
            threatIntelSetIdsDecoded0 = [String]()
            for string0 in threatIntelSetIdsContainer {
                if let string0 = string0 {
                    threatIntelSetIdsDecoded0?.append(string0)
                }
            }
        }
        threatIntelSetIds = threatIntelSetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LocalIpDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipAddressV4 = "ipAddressV4"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressV4 = ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
    }
}

extension LocalIpDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LocalIpDetails(ipAddressV4: \(String(describing: ipAddressV4)))"}
}

/// <p>Contains information about the local IP address of the connection.</p>
public struct LocalIpDetails: Equatable {
    /// <p>The IPv4 local address of the connection.</p>
    public let ipAddressV4: String?

    public init (
        ipAddressV4: String? = nil
    )
    {
        self.ipAddressV4 = ipAddressV4
    }
}

extension LocalPortDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case port = "port"
        case portName = "portName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension LocalPortDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LocalPortDetails(port: \(String(describing: port)), portName: \(String(describing: portName)))"}
}

/// <p>Contains information about the port for the local connection.</p>
public struct LocalPortDetails: Equatable {
    /// <p>The port number of the local connection.</p>
    public let port: Int
    /// <p>The port name of the local connection.</p>
    public let portName: String?

    public init (
        port: Int = 0,
        portName: String? = nil
    )
    {
        self.port = port
        self.portName = portName
    }
}

extension Master: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension Master: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Master(accountId: \(String(describing: accountId)), invitationId: \(String(describing: invitationId)), invitedAt: \(String(describing: invitedAt)), relationshipStatus: \(String(describing: relationshipStatus)))"}
}

/// <p>Contains information about the administrator account and invitation.</p>
public struct Master: Equatable {
    /// <p>The ID of the account used as the administrator account.</p>
    public let accountId: String?
    /// <p>The value used to validate the administrator account to the member account.</p>
    public let invitationId: String?
    /// <p>The timestamp when the invitation was sent.</p>
    public let invitedAt: String?
    /// <p>The status of the relationship between the administrator and member accounts.</p>
    public let relationshipStatus: String?

    public init (
        accountId: String? = nil,
        invitationId: String? = nil,
        invitedAt: String? = nil,
        relationshipStatus: String? = nil
    )
    {
        self.accountId = accountId
        self.invitationId = invitationId
        self.invitedAt = invitedAt
        self.relationshipStatus = relationshipStatus
    }
}

extension Member: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case detectorId = "detectorId"
        case email = "email"
        case invitedAt = "invitedAt"
        case masterId = "masterId"
        case relationshipStatus = "relationshipStatus"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let invitedAt = invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let masterId = masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let relationshipStatus = relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Member: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Member(accountId: \(String(describing: accountId)), detectorId: \(String(describing: detectorId)), email: \(String(describing: email)), invitedAt: \(String(describing: invitedAt)), masterId: \(String(describing: masterId)), relationshipStatus: \(String(describing: relationshipStatus)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Contains information about the member account. </p>
public struct Member: Equatable {
    /// <p>The ID of the member account.</p>
    public let accountId: String?
    /// <p>The detector ID of the member account.</p>
    public let detectorId: String?
    /// <p>The email address of the member account.</p>
    public let email: String?
    /// <p>The timestamp when the invitation was sent.</p>
    public let invitedAt: String?
    /// <p>The administrator account ID.</p>
    public let masterId: String?
    /// <p>The status of the relationship between the member and the administrator.</p>
    public let relationshipStatus: String?
    /// <p>The last-updated timestamp of the member.</p>
    public let updatedAt: String?

    public init (
        accountId: String? = nil,
        detectorId: String? = nil,
        email: String? = nil,
        invitedAt: String? = nil,
        masterId: String? = nil,
        relationshipStatus: String? = nil,
        updatedAt: String? = nil
    )
    {
        self.accountId = accountId
        self.detectorId = detectorId
        self.email = email
        self.invitedAt = invitedAt
        self.masterId = masterId
        self.relationshipStatus = relationshipStatus
        self.updatedAt = updatedAt
    }
}

extension MemberDataSourceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(DataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension MemberDataSourceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MemberDataSourceConfiguration(accountId: \(String(describing: accountId)), dataSources: \(String(describing: dataSources)))"}
}

/// <p>Contains information on which data sources are enabled for a member account.</p>
public struct MemberDataSourceConfiguration: Equatable {
    /// <p>The account ID for the member account.</p>
    public let accountId: String?
    /// <p>Contains information on the status of data sources for the account.</p>
    public let dataSources: DataSourceConfigurationsResult?

    public init (
        accountId: String? = nil,
        dataSources: DataSourceConfigurationsResult? = nil
    )
    {
        self.accountId = accountId
        self.dataSources = dataSources
    }
}

extension NetworkConnectionAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blocked = "blocked"
        case connectionDirection = "connectionDirection"
        case localIpDetails = "localIpDetails"
        case localPortDetails = "localPortDetails"
        case `protocol` = "protocol"
        case remoteIpDetails = "remoteIpDetails"
        case remotePortDetails = "remotePortDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let connectionDirection = connectionDirection {
            try encodeContainer.encode(connectionDirection, forKey: .connectionDirection)
        }
        if let localIpDetails = localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let remotePortDetails = remotePortDetails {
            try encodeContainer.encode(remotePortDetails, forKey: .remotePortDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedDecoded = try containerValues.decode(Bool.self, forKey: .blocked)
        blocked = blockedDecoded
        let connectionDirectionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionDirection)
        connectionDirection = connectionDirectionDecoded
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(LocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(LocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let remotePortDetailsDecoded = try containerValues.decodeIfPresent(RemotePortDetails.self, forKey: .remotePortDetails)
        remotePortDetails = remotePortDetailsDecoded
    }
}

extension NetworkConnectionAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkConnectionAction(blocked: \(String(describing: blocked)), connectionDirection: \(String(describing: connectionDirection)), localIpDetails: \(String(describing: localIpDetails)), localPortDetails: \(String(describing: localPortDetails)), protocol: \(String(describing: `protocol`)), remoteIpDetails: \(String(describing: remoteIpDetails)), remotePortDetails: \(String(describing: remotePortDetails)))"}
}

/// <p>Contains information about the NETWORK_CONNECTION action described in the finding.</p>
public struct NetworkConnectionAction: Equatable {
    /// <p>The network connection protocol.</p>
    public let `protocol`: String?
    /// <p>Indicates whether EC2 blocked the network connection to your instance.</p>
    public let blocked: Bool
    /// <p>The network connection direction.</p>
    public let connectionDirection: String?
    /// <p>The local IP information of the connection.</p>
    public let localIpDetails: LocalIpDetails?
    /// <p>The local port information of the connection.</p>
    public let localPortDetails: LocalPortDetails?
    /// <p>The remote IP information of the connection.</p>
    public let remoteIpDetails: RemoteIpDetails?
    /// <p>The remote port information of the connection.</p>
    public let remotePortDetails: RemotePortDetails?

    public init (
        `protocol`: String? = nil,
        blocked: Bool = false,
        connectionDirection: String? = nil,
        localIpDetails: LocalIpDetails? = nil,
        localPortDetails: LocalPortDetails? = nil,
        remoteIpDetails: RemoteIpDetails? = nil,
        remotePortDetails: RemotePortDetails? = nil
    )
    {
        self.`protocol` = `protocol`
        self.blocked = blocked
        self.connectionDirection = connectionDirection
        self.localIpDetails = localIpDetails
        self.localPortDetails = localPortDetails
        self.remoteIpDetails = remoteIpDetails
        self.remotePortDetails = remotePortDetails
    }
}

extension NetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipv6Addresses = "ipv6Addresses"
        case networkInterfaceId = "networkInterfaceId"
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
        case privateIpAddresses = "privateIpAddresses"
        case publicDnsName = "publicDnsName"
        case publicIp = "publicIp"
        case securityGroups = "securityGroups"
        case subnetId = "subnetId"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Addresses = ipv6Addresses {
            var ipv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Addresses)
            for ipv6addresses0 in ipv6Addresses {
                try ipv6AddressesContainer.encode(ipv6addresses0)
            }
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for privateipaddresses0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(privateipaddresses0)
            }
        }
        if let publicDnsName = publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6AddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipv6Addresses)
        var ipv6AddressesDecoded0:[String]? = nil
        if let ipv6AddressesContainer = ipv6AddressesContainer {
            ipv6AddressesDecoded0 = [String]()
            for string0 in ipv6AddressesContainer {
                if let string0 = string0 {
                    ipv6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv6Addresses = ipv6AddressesDecoded0
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([PrivateIpAddressDetails?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[PrivateIpAddressDetails]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [PrivateIpAddressDetails]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([SecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[SecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [SecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension NetworkInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkInterface(ipv6Addresses: \(String(describing: ipv6Addresses)), networkInterfaceId: \(String(describing: networkInterfaceId)), privateDnsName: \(String(describing: privateDnsName)), privateIpAddress: \(String(describing: privateIpAddress)), privateIpAddresses: \(String(describing: privateIpAddresses)), publicDnsName: \(String(describing: publicDnsName)), publicIp: \(String(describing: publicIp)), securityGroups: \(String(describing: securityGroups)), subnetId: \(String(describing: subnetId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains information about the elastic network interface of the EC2 instance.</p>
public struct NetworkInterface: Equatable {
    /// <p>A list of IPv6 addresses for the EC2 instance.</p>
    public let ipv6Addresses: [String]?
    /// <p>The ID of the network interface.</p>
    public let networkInterfaceId: String?
    /// <p>The private DNS name of the EC2 instance.</p>
    public let privateDnsName: String?
    /// <p>The private IP address of the EC2 instance.</p>
    public let privateIpAddress: String?
    /// <p>Other private IP address information of the EC2 instance.</p>
    public let privateIpAddresses: [PrivateIpAddressDetails]?
    /// <p>The public DNS name of the EC2 instance.</p>
    public let publicDnsName: String?
    /// <p>The public IP address of the EC2 instance.</p>
    public let publicIp: String?
    /// <p>The security groups associated with the EC2 instance.</p>
    public let securityGroups: [SecurityGroup]?
    /// <p>The subnet ID of the EC2 instance.</p>
    public let subnetId: String?
    /// <p>The VPC ID of the EC2 instance.</p>
    public let vpcId: String?

    public init (
        ipv6Addresses: [String]? = nil,
        networkInterfaceId: String? = nil,
        privateDnsName: String? = nil,
        privateIpAddress: String? = nil,
        privateIpAddresses: [PrivateIpAddressDetails]? = nil,
        publicDnsName: String? = nil,
        publicIp: String? = nil,
        securityGroups: [SecurityGroup]? = nil,
        subnetId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.ipv6Addresses = ipv6Addresses
        self.networkInterfaceId = networkInterfaceId
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.publicDnsName = publicDnsName
        self.publicIp = publicIp
        self.securityGroups = securityGroups
        self.subnetId = subnetId
        self.vpcId = vpcId
    }
}

public enum OrderBy {
    case asc
    case desc
    case sdkUnknown(String)
}

extension OrderBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrderBy] {
        return [
            .asc,
            .desc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asc: return "ASC"
        case .desc: return "DESC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
    }
}

extension Organization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case asn = "asn"
        case asnOrg = "asnOrg"
        case isp = "isp"
        case org = "org"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let asnOrg = asnOrg {
            try encodeContainer.encode(asnOrg, forKey: .asnOrg)
        }
        if let isp = isp {
            try encodeContainer.encode(isp, forKey: .isp)
        }
        if let org = org {
            try encodeContainer.encode(org, forKey: .org)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asn)
        asn = asnDecoded
        let asnOrgDecoded = try containerValues.decodeIfPresent(String.self, forKey: .asnOrg)
        asnOrg = asnOrgDecoded
        let ispDecoded = try containerValues.decodeIfPresent(String.self, forKey: .isp)
        isp = ispDecoded
        let orgDecoded = try containerValues.decodeIfPresent(String.self, forKey: .org)
        org = orgDecoded
    }
}

extension Organization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Organization(asn: \(String(describing: asn)), asnOrg: \(String(describing: asnOrg)), isp: \(String(describing: isp)), org: \(String(describing: org)))"}
}

/// <p>Contains information about the ISP organization of the remote IP address.</p>
public struct Organization: Equatable {
    /// <p>The Autonomous System Number (ASN) of the internet provider of the remote IP
    ///       address.</p>
    public let asn: String?
    /// <p>The organization that registered this ASN.</p>
    public let asnOrg: String?
    /// <p>The ISP information for the internet provider.</p>
    public let isp: String?
    /// <p>The name of the internet provider.</p>
    public let org: String?

    public init (
        asn: String? = nil,
        asnOrg: String? = nil,
        isp: String? = nil,
        org: String? = nil
    )
    {
        self.asn = asn
        self.asnOrg = asnOrg
        self.isp = isp
        self.org = org
    }
}

extension OrganizationDataSourceConfigurations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(OrganizationS3LogsConfiguration.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension OrganizationDataSourceConfigurations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationDataSourceConfigurations(s3Logs: \(String(describing: s3Logs)))"}
}

/// <p>An object that contains information on which data sources will be configured to be
///       automatically enabled for new members within the organization.</p>
public struct OrganizationDataSourceConfigurations: Equatable {
    /// <p>Describes whether S3 data event logs are enabled for new members of the
    ///       organization.</p>
    public let s3Logs: OrganizationS3LogsConfiguration?

    public init (
        s3Logs: OrganizationS3LogsConfiguration? = nil
    )
    {
        self.s3Logs = s3Logs
    }
}

extension OrganizationDataSourceConfigurationsResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(OrganizationS3LogsConfigurationResult.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension OrganizationDataSourceConfigurationsResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationDataSourceConfigurationsResult(s3Logs: \(String(describing: s3Logs)))"}
}

/// <p>An object that contains information on which data sources are automatically enabled for
///       new members within the organization.</p>
public struct OrganizationDataSourceConfigurationsResult: Equatable {
    /// <p>Describes whether S3 data event logs are enabled as a data source.</p>
    public let s3Logs: OrganizationS3LogsConfigurationResult?

    public init (
        s3Logs: OrganizationS3LogsConfigurationResult? = nil
    )
    {
        self.s3Logs = s3Logs
    }
}

extension OrganizationS3LogsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension OrganizationS3LogsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationS3LogsConfiguration(autoEnable: \(String(describing: autoEnable)))"}
}

/// <p>Describes whether S3 data event logs will be automatically enabled for new members of the
///       organization.</p>
public struct OrganizationS3LogsConfiguration: Equatable {
    /// <p>A value that contains information on whether S3 data event logs will be enabled
    ///       automatically as a data source for the organization.</p>
    public let autoEnable: Bool

    public init (
        autoEnable: Bool = false
    )
    {
        self.autoEnable = autoEnable
    }
}

extension OrganizationS3LogsConfigurationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension OrganizationS3LogsConfigurationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationS3LogsConfigurationResult(autoEnable: \(String(describing: autoEnable)))"}
}

/// <p>The current configuration of S3 data event logs as a data source for the
///       organization.</p>
public struct OrganizationS3LogsConfigurationResult: Equatable {
    /// <p>A value that describes whether S3 data event logs are automatically enabled for new
    ///       members of the organization.</p>
    public let autoEnable: Bool

    public init (
        autoEnable: Bool = false
    )
    {
        self.autoEnable = autoEnable
    }
}

extension Owner: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "id"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension Owner: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Owner(id: \(String(describing: id)))"}
}

/// <p>Contains information on the owner of the bucket.</p>
public struct Owner: Equatable {
    /// <p>The canonical user ID of the bucket owner. For information about locating your canonical
    ///       user ID see <a href="https://docs.aws.amazon.com/general/latest/gr/acct-identifiers.html#FindingCanonicalId">Finding Your Account
    ///         Canonical User ID.</a>
    ///          </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

extension PermissionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountLevelPermissions = "accountLevelPermissions"
        case bucketLevelPermissions = "bucketLevelPermissions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountLevelPermissions = accountLevelPermissions {
            try encodeContainer.encode(accountLevelPermissions, forKey: .accountLevelPermissions)
        }
        if let bucketLevelPermissions = bucketLevelPermissions {
            try encodeContainer.encode(bucketLevelPermissions, forKey: .bucketLevelPermissions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketLevelPermissionsDecoded = try containerValues.decodeIfPresent(BucketLevelPermissions.self, forKey: .bucketLevelPermissions)
        bucketLevelPermissions = bucketLevelPermissionsDecoded
        let accountLevelPermissionsDecoded = try containerValues.decodeIfPresent(AccountLevelPermissions.self, forKey: .accountLevelPermissions)
        accountLevelPermissions = accountLevelPermissionsDecoded
    }
}

extension PermissionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PermissionConfiguration(accountLevelPermissions: \(String(describing: accountLevelPermissions)), bucketLevelPermissions: \(String(describing: bucketLevelPermissions)))"}
}

/// <p>Contains information about how permissions are configured for the S3 bucket.</p>
public struct PermissionConfiguration: Equatable {
    /// <p>Contains information about the account level permissions on the S3 bucket.</p>
    public let accountLevelPermissions: AccountLevelPermissions?
    /// <p>Contains information about the bucket level permissions for the S3 bucket.</p>
    public let bucketLevelPermissions: BucketLevelPermissions?

    public init (
        accountLevelPermissions: AccountLevelPermissions? = nil,
        bucketLevelPermissions: BucketLevelPermissions? = nil
    )
    {
        self.accountLevelPermissions = accountLevelPermissions
        self.bucketLevelPermissions = bucketLevelPermissions
    }
}

extension PortProbeAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blocked = "blocked"
        case portProbeDetails = "portProbeDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let portProbeDetails = portProbeDetails {
            var portProbeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portProbeDetails)
            for portprobedetails0 in portProbeDetails {
                try portProbeDetailsContainer.encode(portprobedetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedDecoded = try containerValues.decode(Bool.self, forKey: .blocked)
        blocked = blockedDecoded
        let portProbeDetailsContainer = try containerValues.decodeIfPresent([PortProbeDetail?].self, forKey: .portProbeDetails)
        var portProbeDetailsDecoded0:[PortProbeDetail]? = nil
        if let portProbeDetailsContainer = portProbeDetailsContainer {
            portProbeDetailsDecoded0 = [PortProbeDetail]()
            for structure0 in portProbeDetailsContainer {
                if let structure0 = structure0 {
                    portProbeDetailsDecoded0?.append(structure0)
                }
            }
        }
        portProbeDetails = portProbeDetailsDecoded0
    }
}

extension PortProbeAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortProbeAction(blocked: \(String(describing: blocked)), portProbeDetails: \(String(describing: portProbeDetails)))"}
}

/// <p>Contains information about the PORT_PROBE action described in the finding.</p>
public struct PortProbeAction: Equatable {
    /// <p>Indicates whether EC2 blocked the port probe to the instance, such as with an ACL.</p>
    public let blocked: Bool
    /// <p>A list of objects related to port probe details.</p>
    public let portProbeDetails: [PortProbeDetail]?

    public init (
        blocked: Bool = false,
        portProbeDetails: [PortProbeDetail]? = nil
    )
    {
        self.blocked = blocked
        self.portProbeDetails = portProbeDetails
    }
}

extension PortProbeDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case localIpDetails = "localIpDetails"
        case localPortDetails = "localPortDetails"
        case remoteIpDetails = "remoteIpDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localIpDetails = localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let remoteIpDetails = remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(LocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(LocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
    }
}

extension PortProbeDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortProbeDetail(localIpDetails: \(String(describing: localIpDetails)), localPortDetails: \(String(describing: localPortDetails)), remoteIpDetails: \(String(describing: remoteIpDetails)))"}
}

/// <p>Contains information about the port probe details.</p>
public struct PortProbeDetail: Equatable {
    /// <p>The local IP information of the connection.</p>
    public let localIpDetails: LocalIpDetails?
    /// <p>The local port information of the connection.</p>
    public let localPortDetails: LocalPortDetails?
    /// <p>The remote IP information of the connection.</p>
    public let remoteIpDetails: RemoteIpDetails?

    public init (
        localIpDetails: LocalIpDetails? = nil,
        localPortDetails: LocalPortDetails? = nil,
        remoteIpDetails: RemoteIpDetails? = nil
    )
    {
        self.localIpDetails = localIpDetails
        self.localPortDetails = localPortDetails
        self.remoteIpDetails = remoteIpDetails
    }
}

extension PrivateIpAddressDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension PrivateIpAddressDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrivateIpAddressDetails(privateDnsName: \(String(describing: privateDnsName)), privateIpAddress: \(String(describing: privateIpAddress)))"}
}

/// <p>Contains other private IP address information of the EC2 instance.</p>
public struct PrivateIpAddressDetails: Equatable {
    /// <p>The private DNS name of the EC2 instance.</p>
    public let privateDnsName: String?
    /// <p>The private IP address of the EC2 instance.</p>
    public let privateIpAddress: String?

    public init (
        privateDnsName: String? = nil,
        privateIpAddress: String? = nil
    )
    {
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
    }
}

extension ProductCode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "code"
        case productType = "productType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let productType = productType {
            try encodeContainer.encode(productType, forKey: .productType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productType)
        productType = productTypeDecoded
    }
}

extension ProductCode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProductCode(code: \(String(describing: code)), productType: \(String(describing: productType)))"}
}

/// <p>Contains information about the product code for the EC2 instance.</p>
public struct ProductCode: Equatable {
    /// <p>The product code information.</p>
    public let code: String?
    /// <p>The product code type.</p>
    public let productType: String?

    public init (
        code: String? = nil,
        productType: String? = nil
    )
    {
        self.code = code
        self.productType = productType
    }
}

extension PublicAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case effectivePermission = "effectivePermission"
        case permissionConfiguration = "permissionConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectivePermission = effectivePermission {
            try encodeContainer.encode(effectivePermission, forKey: .effectivePermission)
        }
        if let permissionConfiguration = permissionConfiguration {
            try encodeContainer.encode(permissionConfiguration, forKey: .permissionConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionConfigurationDecoded = try containerValues.decodeIfPresent(PermissionConfiguration.self, forKey: .permissionConfiguration)
        permissionConfiguration = permissionConfigurationDecoded
        let effectivePermissionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectivePermission)
        effectivePermission = effectivePermissionDecoded
    }
}

extension PublicAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicAccess(effectivePermission: \(String(describing: effectivePermission)), permissionConfiguration: \(String(describing: permissionConfiguration)))"}
}

/// <p>Describes the public access policies that apply to the S3 bucket.</p>
public struct PublicAccess: Equatable {
    /// <p>Describes the effective permission on this bucket after factoring all attached
    ///       policies.</p>
    public let effectivePermission: String?
    /// <p>Contains information about how permissions are configured for the S3 bucket.</p>
    public let permissionConfiguration: PermissionConfiguration?

    public init (
        effectivePermission: String? = nil,
        permissionConfiguration: PermissionConfiguration? = nil
    )
    {
        self.effectivePermission = effectivePermission
        self.permissionConfiguration = permissionConfiguration
    }
}

public enum PublishingStatus {
    case pendingVerification
    case publishing
    case stopped
    case unableToPublishFixDestinationProperty
    case sdkUnknown(String)
}

extension PublishingStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PublishingStatus] {
        return [
            .pendingVerification,
            .publishing,
            .stopped,
            .unableToPublishFixDestinationProperty,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .pendingVerification: return "PENDING_VERIFICATION"
        case .publishing: return "PUBLISHING"
        case .stopped: return "STOPPED"
        case .unableToPublishFixDestinationProperty: return "UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PublishingStatus(rawValue: rawValue) ?? PublishingStatus.sdkUnknown(rawValue)
    }
}

extension RemoteIpDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case city = "city"
        case country = "country"
        case geoLocation = "geoLocation"
        case ipAddressV4 = "ipAddressV4"
        case organization = "organization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geoLocation = geoLocation {
            try encodeContainer.encode(geoLocation, forKey: .geoLocation)
        }
        if let ipAddressV4 = ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
        if let organization = organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityDecoded = try containerValues.decodeIfPresent(City.self, forKey: .city)
        city = cityDecoded
        let countryDecoded = try containerValues.decodeIfPresent(Country.self, forKey: .country)
        country = countryDecoded
        let geoLocationDecoded = try containerValues.decodeIfPresent(GeoLocation.self, forKey: .geoLocation)
        geoLocation = geoLocationDecoded
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
        let organizationDecoded = try containerValues.decodeIfPresent(Organization.self, forKey: .organization)
        organization = organizationDecoded
    }
}

extension RemoteIpDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoteIpDetails(city: \(String(describing: city)), country: \(String(describing: country)), geoLocation: \(String(describing: geoLocation)), ipAddressV4: \(String(describing: ipAddressV4)), organization: \(String(describing: organization)))"}
}

/// <p>Contains information about the remote IP address of the connection.</p>
public struct RemoteIpDetails: Equatable {
    /// <p>The city information of the remote IP address.</p>
    public let city: City?
    /// <p>The country code of the remote IP address.</p>
    public let country: Country?
    /// <p>The location information of the remote IP address.</p>
    public let geoLocation: GeoLocation?
    /// <p>The IPv4 remote address of the connection.</p>
    public let ipAddressV4: String?
    /// <p>The ISP organization information of the remote IP address.</p>
    public let organization: Organization?

    public init (
        city: City? = nil,
        country: Country? = nil,
        geoLocation: GeoLocation? = nil,
        ipAddressV4: String? = nil,
        organization: Organization? = nil
    )
    {
        self.city = city
        self.country = country
        self.geoLocation = geoLocation
        self.ipAddressV4 = ipAddressV4
        self.organization = organization
    }
}

extension RemotePortDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case port = "port"
        case portName = "portName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension RemotePortDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemotePortDetails(port: \(String(describing: port)), portName: \(String(describing: portName)))"}
}

/// <p>Contains information about the remote port.</p>
public struct RemotePortDetails: Equatable {
    /// <p>The port number of the remote connection.</p>
    public let port: Int
    /// <p>The port name of the remote connection.</p>
    public let portName: String?

    public init (
        port: Int = 0,
        portName: String? = nil
    )
    {
        self.port = port
        self.portName = portName
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyDetails = "accessKeyDetails"
        case instanceDetails = "instanceDetails"
        case resourceType = "resourceType"
        case s3BucketDetails = "s3BucketDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyDetails = accessKeyDetails {
            try encodeContainer.encode(accessKeyDetails, forKey: .accessKeyDetails)
        }
        if let instanceDetails = instanceDetails {
            try encodeContainer.encode(instanceDetails, forKey: .instanceDetails)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let s3BucketDetails = s3BucketDetails {
            var s3BucketDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3BucketDetails)
            for s3bucketdetails0 in s3BucketDetails {
                try s3BucketDetailsContainer.encode(s3bucketdetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyDetailsDecoded = try containerValues.decodeIfPresent(AccessKeyDetails.self, forKey: .accessKeyDetails)
        accessKeyDetails = accessKeyDetailsDecoded
        let s3BucketDetailsContainer = try containerValues.decodeIfPresent([S3BucketDetail?].self, forKey: .s3BucketDetails)
        var s3BucketDetailsDecoded0:[S3BucketDetail]? = nil
        if let s3BucketDetailsContainer = s3BucketDetailsContainer {
            s3BucketDetailsDecoded0 = [S3BucketDetail]()
            for structure0 in s3BucketDetailsContainer {
                if let structure0 = structure0 {
                    s3BucketDetailsDecoded0?.append(structure0)
                }
            }
        }
        s3BucketDetails = s3BucketDetailsDecoded0
        let instanceDetailsDecoded = try containerValues.decodeIfPresent(InstanceDetails.self, forKey: .instanceDetails)
        instanceDetails = instanceDetailsDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(accessKeyDetails: \(String(describing: accessKeyDetails)), instanceDetails: \(String(describing: instanceDetails)), resourceType: \(String(describing: resourceType)), s3BucketDetails: \(String(describing: s3BucketDetails)))"}
}

/// <p>Contains information about the AWS resource associated with the activity that prompted
///       GuardDuty to generate a finding.</p>
public struct Resource: Equatable {
    /// <p>The IAM access key details (IAM user information) of a user that engaged in the activity
    ///       that prompted GuardDuty to generate a finding.</p>
    public let accessKeyDetails: AccessKeyDetails?
    /// <p>The information about the EC2 instance associated with the activity that prompted
    ///       GuardDuty to generate a finding.</p>
    public let instanceDetails: InstanceDetails?
    /// <p>The type of AWS resource.</p>
    public let resourceType: String?
    /// <p>Contains information on the S3 bucket.</p>
    public let s3BucketDetails: [S3BucketDetail]?

    public init (
        accessKeyDetails: AccessKeyDetails? = nil,
        instanceDetails: InstanceDetails? = nil,
        resourceType: String? = nil,
        s3BucketDetails: [S3BucketDetail]? = nil
    )
    {
        self.accessKeyDetails = accessKeyDetails
        self.instanceDetails = instanceDetails
        self.resourceType = resourceType
        self.s3BucketDetails = s3BucketDetails
    }
}

extension S3BucketDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case defaultServerSideEncryption = "defaultServerSideEncryption"
        case name = "name"
        case owner = "owner"
        case publicAccess = "publicAccess"
        case tags = "tags"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let defaultServerSideEncryption = defaultServerSideEncryption {
            try encodeContainer.encode(defaultServerSideEncryption, forKey: .defaultServerSideEncryption)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let publicAccess = publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Owner.self, forKey: .owner)
        owner = ownerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let defaultServerSideEncryptionDecoded = try containerValues.decodeIfPresent(DefaultServerSideEncryption.self, forKey: .defaultServerSideEncryption)
        defaultServerSideEncryption = defaultServerSideEncryptionDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(PublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
    }
}

extension S3BucketDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketDetail(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), defaultServerSideEncryption: \(String(describing: defaultServerSideEncryption)), name: \(String(describing: name)), owner: \(String(describing: owner)), publicAccess: \(String(describing: publicAccess)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>Contains information on the S3 bucket.</p>
public struct S3BucketDetail: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the S3 bucket.</p>
    public let arn: String?
    /// <p>The date and time the bucket was created at.</p>
    public let createdAt: Date?
    /// <p>Describes the server side encryption method used in the S3 bucket.</p>
    public let defaultServerSideEncryption: DefaultServerSideEncryption?
    /// <p>The name of the S3 bucket.</p>
    public let name: String?
    /// <p>The owner of the S3 bucket.</p>
    public let owner: Owner?
    /// <p>Describes the public access policies that apply to the S3 bucket.</p>
    public let publicAccess: PublicAccess?
    /// <p>All tags attached to the S3 bucket</p>
    public let tags: [Tag]?
    /// <p>Describes whether the bucket is a source or destination bucket.</p>
    public let type: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        defaultServerSideEncryption: DefaultServerSideEncryption? = nil,
        name: String? = nil,
        owner: Owner? = nil,
        publicAccess: PublicAccess? = nil,
        tags: [Tag]? = nil,
        type: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.defaultServerSideEncryption = defaultServerSideEncryption
        self.name = name
        self.owner = owner
        self.publicAccess = publicAccess
        self.tags = tags
        self.type = type
    }
}

extension S3LogsConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enable = "enable"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decode(Bool.self, forKey: .enable)
        enable = enableDecoded
    }
}

extension S3LogsConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3LogsConfiguration(enable: \(String(describing: enable)))"}
}

/// <p>Describes whether S3 data event logs will be enabled as a data source.</p>
public struct S3LogsConfiguration: Equatable {
    /// <p> The status of S3 data event logs as a data source.</p>
    public let enable: Bool

    public init (
        enable: Bool = false
    )
    {
        self.enable = enable
    }
}

extension S3LogsConfigurationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension S3LogsConfigurationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3LogsConfigurationResult(status: \(String(describing: status)))"}
}

/// <p>Describes whether S3 data event logs will be enabled as a data source.</p>
public struct S3LogsConfigurationResult: Equatable {
    /// <p>A value that describes whether S3 data event logs are automatically enabled for new
    ///       members of the organization.</p>
    public let status: DataSourceStatus?

    public init (
        status: DataSourceStatus? = nil
    )
    {
        self.status = status
    }
}

extension SecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "groupId"
        case groupName = "groupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension SecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityGroup(groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)))"}
}

/// <p>Contains information about the security groups associated with the EC2 instance.</p>
public struct SecurityGroup: Equatable {
    /// <p>The security group ID of the EC2 instance.</p>
    public let groupId: String?
    /// <p>The security group name of the EC2 instance.</p>
    public let groupName: String?

    public init (
        groupId: String? = nil,
        groupName: String? = nil
    )
    {
        self.groupId = groupId
        self.groupName = groupName
    }
}

extension Service: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case archived = "archived"
        case count = "count"
        case detectorId = "detectorId"
        case eventFirstSeen = "eventFirstSeen"
        case eventLastSeen = "eventLastSeen"
        case evidence = "evidence"
        case resourceRole = "resourceRole"
        case serviceName = "serviceName"
        case userFeedback = "userFeedback"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if archived != false {
            try encodeContainer.encode(archived, forKey: .archived)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let detectorId = detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let eventFirstSeen = eventFirstSeen {
            try encodeContainer.encode(eventFirstSeen, forKey: .eventFirstSeen)
        }
        if let eventLastSeen = eventLastSeen {
            try encodeContainer.encode(eventLastSeen, forKey: .eventLastSeen)
        }
        if let evidence = evidence {
            try encodeContainer.encode(evidence, forKey: .evidence)
        }
        if let resourceRole = resourceRole {
            try encodeContainer.encode(resourceRole, forKey: .resourceRole)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let userFeedback = userFeedback {
            try encodeContainer.encode(userFeedback, forKey: .userFeedback)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let evidenceDecoded = try containerValues.decodeIfPresent(Evidence.self, forKey: .evidence)
        evidence = evidenceDecoded
        let archivedDecoded = try containerValues.decode(Bool.self, forKey: .archived)
        archived = archivedDecoded
        let countDecoded = try containerValues.decode(Int.self, forKey: .count)
        count = countDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let eventFirstSeenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventFirstSeen)
        eventFirstSeen = eventFirstSeenDecoded
        let eventLastSeenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventLastSeen)
        eventLastSeen = eventLastSeenDecoded
        let resourceRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceRole)
        resourceRole = resourceRoleDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let userFeedbackDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userFeedback)
        userFeedback = userFeedbackDecoded
    }
}

extension Service: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Service(action: \(String(describing: action)), archived: \(String(describing: archived)), count: \(String(describing: count)), detectorId: \(String(describing: detectorId)), eventFirstSeen: \(String(describing: eventFirstSeen)), eventLastSeen: \(String(describing: eventLastSeen)), evidence: \(String(describing: evidence)), resourceRole: \(String(describing: resourceRole)), serviceName: \(String(describing: serviceName)), userFeedback: \(String(describing: userFeedback)))"}
}

/// <p>Contains additional information about the generated finding.</p>
public struct Service: Equatable {
    /// <p>Information about the activity that is described in a finding.</p>
    public let action: Action?
    /// <p>Indicates whether this finding is archived.</p>
    public let archived: Bool
    /// <p>The total count of the occurrences of this finding type.</p>
    public let count: Int
    /// <p>The detector ID for the GuardDuty service.</p>
    public let detectorId: String?
    /// <p>The first-seen timestamp of the activity that prompted GuardDuty to generate this
    ///       finding.</p>
    public let eventFirstSeen: String?
    /// <p>The last-seen timestamp of the activity that prompted GuardDuty to generate this
    ///       finding.</p>
    public let eventLastSeen: String?
    /// <p>An evidence object associated with the service.</p>
    public let evidence: Evidence?
    /// <p>The resource role information for this finding.</p>
    public let resourceRole: String?
    /// <p>The name of the AWS service (GuardDuty) that generated a finding.</p>
    public let serviceName: String?
    /// <p>Feedback that was submitted about the finding.</p>
    public let userFeedback: String?

    public init (
        action: Action? = nil,
        archived: Bool = false,
        count: Int = 0,
        detectorId: String? = nil,
        eventFirstSeen: String? = nil,
        eventLastSeen: String? = nil,
        evidence: Evidence? = nil,
        resourceRole: String? = nil,
        serviceName: String? = nil,
        userFeedback: String? = nil
    )
    {
        self.action = action
        self.archived = archived
        self.count = count
        self.detectorId = detectorId
        self.eventFirstSeen = eventFirstSeen
        self.eventLastSeen = eventLastSeen
        self.evidence = evidence
        self.resourceRole = resourceRole
        self.serviceName = serviceName
        self.userFeedback = userFeedback
    }
}

extension SortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension SortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SortCriteria(attributeName: \(String(describing: attributeName)), orderBy: \(String(describing: orderBy)))"}
}

/// <p>Contains information about the criteria used for sorting findings.</p>
public struct SortCriteria: Equatable {
    /// <p>Represents the finding attribute (for example, accountId) to sort findings by.</p>
    public let attributeName: String?
    /// <p>The order by which the sorted findings are to be displayed.</p>
    public let orderBy: OrderBy?

    public init (
        attributeName: String? = nil,
        orderBy: OrderBy? = nil
    )
    {
        self.attributeName = attributeName
        self.orderBy = orderBy
    }
}

public struct StartMonitoringMembersInputBodyMiddleware: Middleware {
    public let id: String = "StartMonitoringMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMonitoringMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMonitoringMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMonitoringMembersInput>
    public typealias MOutput = OperationOutput<StartMonitoringMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMonitoringMembersOutputError>
}

extension StartMonitoringMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMonitoringMembersInput(accountIds: \(String(describing: accountIds)), detectorId: \(String(describing: detectorId)))"}
}

extension StartMonitoringMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

public struct StartMonitoringMembersInputHeadersMiddleware: Middleware {
    public let id: String = "StartMonitoringMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMonitoringMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMonitoringMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMonitoringMembersInput>
    public typealias MOutput = OperationOutput<StartMonitoringMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMonitoringMembersOutputError>
}

public struct StartMonitoringMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "StartMonitoringMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMonitoringMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMonitoringMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMonitoringMembersInput>
    public typealias MOutput = OperationOutput<StartMonitoringMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMonitoringMembersOutputError>
}

public struct StartMonitoringMembersInput: Equatable {
    /// <p>A list of account IDs of the GuardDuty member accounts to start monitoring.</p>
    public let accountIds: [String]?
    /// <p>The unique ID of the detector of the GuardDuty administrator account associated with the member
    ///       accounts to monitor.</p>
    public let detectorId: String?

    public init (
        accountIds: [String]? = nil,
        detectorId: String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct StartMonitoringMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension StartMonitoringMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension StartMonitoringMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMonitoringMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMonitoringMembersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMonitoringMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMonitoringMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension StartMonitoringMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartMonitoringMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct StartMonitoringMembersOutputResponse: Equatable {
    /// <p>A list of objects that contain the unprocessed account and a result string that explains
    ///       why it was unprocessed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct StartMonitoringMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension StartMonitoringMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct StopMonitoringMembersInputBodyMiddleware: Middleware {
    public let id: String = "StopMonitoringMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopMonitoringMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<StopMonitoringMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopMonitoringMembersInput>
    public typealias MOutput = OperationOutput<StopMonitoringMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopMonitoringMembersOutputError>
}

extension StopMonitoringMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopMonitoringMembersInput(accountIds: \(String(describing: accountIds)), detectorId: \(String(describing: detectorId)))"}
}

extension StopMonitoringMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
    }
}

public struct StopMonitoringMembersInputHeadersMiddleware: Middleware {
    public let id: String = "StopMonitoringMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopMonitoringMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<StopMonitoringMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopMonitoringMembersInput>
    public typealias MOutput = OperationOutput<StopMonitoringMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopMonitoringMembersOutputError>
}

public struct StopMonitoringMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "StopMonitoringMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopMonitoringMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<StopMonitoringMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopMonitoringMembersInput>
    public typealias MOutput = OperationOutput<StopMonitoringMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopMonitoringMembersOutputError>
}

public struct StopMonitoringMembersInput: Equatable {
    /// <p>A list of account IDs for the member accounts to stop monitoring.</p>
    public let accountIds: [String]?
    /// <p>The unique ID of the detector associated with the GuardDuty administrator account that is
    ///       monitoring member accounts.</p>
    public let detectorId: String?

    public init (
        accountIds: [String]? = nil,
        detectorId: String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct StopMonitoringMembersInputBody: Equatable {
    public let accountIds: [String]?
}

extension StopMonitoringMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension StopMonitoringMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopMonitoringMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopMonitoringMembersOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopMonitoringMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopMonitoringMembersOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension StopMonitoringMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopMonitoringMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct StopMonitoringMembersOutputResponse: Equatable {
    /// <p>A list of objects that contain an accountId for each account that could not be processed,
    ///       and a result string that indicates why the account was not processed. </p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct StopMonitoringMembersOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension StopMonitoringMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Contains information about a tag associated with the EC2 instance.</p>
public struct Tag: Equatable {
    /// <p>The EC2 instance tag key.</p>
    public let key: String?
    /// <p>The EC2 instance tag value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the GuardDuty resource to apply a tag to.</p>
    public let resourceArn: String?
    /// <p>The tags to be added to a resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ThreatIntelSetFormat {
    case alienVault
    case fireEye
    case otxCsv
    case proofPoint
    case stix
    case txt
    case sdkUnknown(String)
}

extension ThreatIntelSetFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThreatIntelSetFormat] {
        return [
            .alienVault,
            .fireEye,
            .otxCsv,
            .proofPoint,
            .stix,
            .txt,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alienVault: return "ALIEN_VAULT"
        case .fireEye: return "FIRE_EYE"
        case .otxCsv: return "OTX_CSV"
        case .proofPoint: return "PROOF_POINT"
        case .stix: return "STIX"
        case .txt: return "TXT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThreatIntelSetFormat(rawValue: rawValue) ?? ThreatIntelSetFormat.sdkUnknown(rawValue)
    }
}

public enum ThreatIntelSetStatus {
    case activating
    case active
    case deactivating
    case deleted
    case deletePending
    case error
    case inactive
    case sdkUnknown(String)
}

extension ThreatIntelSetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThreatIntelSetStatus] {
        return [
            .activating,
            .active,
            .deactivating,
            .deleted,
            .deletePending,
            .error,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .activating: return "ACTIVATING"
        case .active: return "ACTIVE"
        case .deactivating: return "DEACTIVATING"
        case .deleted: return "DELETED"
        case .deletePending: return "DELETE_PENDING"
        case .error: return "ERROR"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThreatIntelSetStatus(rawValue: rawValue) ?? ThreatIntelSetStatus.sdkUnknown(rawValue)
    }
}

extension ThreatIntelligenceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case threatListName = "threatListName"
        case threatNames = "threatNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let threatListName = threatListName {
            try encodeContainer.encode(threatListName, forKey: .threatListName)
        }
        if let threatNames = threatNames {
            var threatNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatNames)
            for threatnames0 in threatNames {
                try threatNamesContainer.encode(threatnames0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatListNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .threatListName)
        threatListName = threatListNameDecoded
        let threatNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .threatNames)
        var threatNamesDecoded0:[String]? = nil
        if let threatNamesContainer = threatNamesContainer {
            threatNamesDecoded0 = [String]()
            for string0 in threatNamesContainer {
                if let string0 = string0 {
                    threatNamesDecoded0?.append(string0)
                }
            }
        }
        threatNames = threatNamesDecoded0
    }
}

extension ThreatIntelligenceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThreatIntelligenceDetail(threatListName: \(String(describing: threatListName)), threatNames: \(String(describing: threatNames)))"}
}

/// <p>An instance of a threat intelligence detail that constitutes evidence for the
///       finding.</p>
public struct ThreatIntelligenceDetail: Equatable {
    /// <p>The name of the threat intelligence list that triggered the finding.</p>
    public let threatListName: String?
    /// <p>A list of names of the threats in the threat intelligence list that triggered the
    ///       finding.</p>
    public let threatNames: [String]?

    public init (
        threatListName: String? = nil,
        threatNames: [String]? = nil
    )
    {
        self.threatListName = threatListName
        self.threatNames = threatNames
    }
}

extension Total: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amount = "amount"
        case unit = "unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension Total: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Total(amount: \(String(describing: amount)), unit: \(String(describing: unit)))"}
}

/// <p>Contains the total usage with the corresponding currency unit for that value.</p>
public struct Total: Equatable {
    /// <p>The total usage.</p>
    public let amount: String?
    /// <p>The currency unit that the amount is given in.</p>
    public let unit: String?

    public init (
        amount: String? = nil,
        unit: String? = nil
    )
    {
        self.amount = amount
        self.unit = unit
    }
}

public struct UnarchiveFindingsInputBodyMiddleware: Middleware {
    public let id: String = "UnarchiveFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnarchiveFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UnarchiveFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnarchiveFindingsInput>
    public typealias MOutput = OperationOutput<UnarchiveFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnarchiveFindingsOutputError>
}

extension UnarchiveFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnarchiveFindingsInput(detectorId: \(String(describing: detectorId)), findingIds: \(String(describing: findingIds)))"}
}

extension UnarchiveFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
    }
}

public struct UnarchiveFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "UnarchiveFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnarchiveFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UnarchiveFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnarchiveFindingsInput>
    public typealias MOutput = OperationOutput<UnarchiveFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnarchiveFindingsOutputError>
}

public struct UnarchiveFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UnarchiveFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnarchiveFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UnarchiveFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnarchiveFindingsInput>
    public typealias MOutput = OperationOutput<UnarchiveFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnarchiveFindingsOutputError>
}

public struct UnarchiveFindingsInput: Equatable {
    /// <p>The ID of the detector associated with the findings to unarchive.</p>
    public let detectorId: String?
    /// <p>The IDs of the findings to unarchive.</p>
    public let findingIds: [String]?

    public init (
        detectorId: String? = nil,
        findingIds: [String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
    }
}

struct UnarchiveFindingsInputBody: Equatable {
    public let findingIds: [String]?
}

extension UnarchiveFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingIds = "findingIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
    }
}

extension UnarchiveFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnarchiveFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnarchiveFindingsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnarchiveFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnarchiveFindingsOutputResponse()"}
}

extension UnarchiveFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UnarchiveFindingsOutputResponse: Equatable {

    public init() {}
}

struct UnarchiveFindingsOutputResponseBody: Equatable {
}

extension UnarchiveFindingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnprocessedAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case result = "result"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .result)
        result = resultDecoded
    }
}

extension UnprocessedAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedAccount(accountId: \(String(describing: accountId)), result: \(String(describing: result)))"}
}

/// <p>Contains information about the accounts that weren't processed.</p>
public struct UnprocessedAccount: Equatable {
    /// <p>The AWS account ID.</p>
    public let accountId: String?
    /// <p>A reason why the account hasn't been processed.</p>
    public let result: String?

    public init (
        accountId: String? = nil,
        result: String? = nil
    )
    {
        self.accountId = accountId
        self.result = result
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the resource to remove tags from.</p>
    public let resourceArn: String?
    /// <p>The tag keys to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDetectorInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDetectorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorInput>
    public typealias MOutput = OperationOutput<UpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorOutputError>
}

extension UpdateDetectorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorInput(dataSources: \(String(describing: dataSources)), detectorId: \(String(describing: detectorId)), enable: \(String(describing: enable)), findingPublishingFrequency: \(String(describing: findingPublishingFrequency)))"}
}

extension UpdateDetectorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let findingPublishingFrequency = findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
    }
}

public struct UpdateDetectorInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDetectorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorInput>
    public typealias MOutput = OperationOutput<UpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorOutputError>
}

public struct UpdateDetectorInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDetectorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDetectorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDetectorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDetectorInput>
    public typealias MOutput = OperationOutput<UpdateDetectorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDetectorOutputError>
}

public struct UpdateDetectorInput: Equatable {
    /// <p>Describes which data sources will be updated.</p>
    public let dataSources: DataSourceConfigurations?
    /// <p>The unique ID of the detector to update.</p>
    public let detectorId: String?
    /// <p>Specifies whether the detector is enabled or not enabled.</p>
    public let enable: Bool
    /// <p>An enum value that specifies how frequently findings are exported, such as to CloudWatch
    ///       Events.</p>
    public let findingPublishingFrequency: FindingPublishingFrequency?

    public init (
        dataSources: DataSourceConfigurations? = nil,
        detectorId: String? = nil,
        enable: Bool = false,
        findingPublishingFrequency: FindingPublishingFrequency? = nil
    )
    {
        self.dataSources = dataSources
        self.detectorId = detectorId
        self.enable = enable
        self.findingPublishingFrequency = findingPublishingFrequency
    }
}

struct UpdateDetectorInputBody: Equatable {
    public let enable: Bool
    public let findingPublishingFrequency: FindingPublishingFrequency?
    public let dataSources: DataSourceConfigurations?
}

extension UpdateDetectorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decode(Bool.self, forKey: .enable)
        enable = enableDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateDetectorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDetectorOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDetectorOutputResponse()"}
}

extension UpdateDetectorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorOutputResponse: Equatable {

    public init() {}
}

struct UpdateDetectorOutputResponseBody: Equatable {
}

extension UpdateDetectorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFilterInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFilterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFilterInput>
    public typealias MOutput = OperationOutput<UpdateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFilterOutputError>
}

extension UpdateFilterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFilterInput(action: \(String(describing: action)), description: \(String(describing: description)), detectorId: \(String(describing: detectorId)), filterName: \(String(describing: filterName)), findingCriteria: \(String(describing: findingCriteria)), rank: \(String(describing: rank)))"}
}

extension UpdateFilterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case rank = "rank"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }
}

public struct UpdateFilterInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFilterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFilterInput>
    public typealias MOutput = OperationOutput<UpdateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFilterOutputError>
}

public struct UpdateFilterInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFilterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFilterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFilterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFilterInput>
    public typealias MOutput = OperationOutput<UpdateFilterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFilterOutputError>
}

public struct UpdateFilterInput: Equatable {
    /// <p>Specifies the action that is to be applied to the findings that match the filter.</p>
    public let action: FilterAction?
    /// <p>The description of the filter.</p>
    public let description: String?
    /// <p>The unique ID of the detector that specifies the GuardDuty service where you want to
    ///       update a filter.</p>
    public let detectorId: String?
    /// <p>The name of the filter.</p>
    public let filterName: String?
    /// <p>Represents the criteria to be used in the filter for querying findings.</p>
    public let findingCriteria: FindingCriteria?
    /// <p>Specifies the position of the filter in the list of current filters. Also specifies the
    ///       order in which this filter is applied to the findings.</p>
    public let rank: Int

    public init (
        action: FilterAction? = nil,
        description: String? = nil,
        detectorId: String? = nil,
        filterName: String? = nil,
        findingCriteria: FindingCriteria? = nil,
        rank: Int = 0
    )
    {
        self.action = action
        self.description = description
        self.detectorId = detectorId
        self.filterName = filterName
        self.findingCriteria = findingCriteria
        self.rank = rank
    }
}

struct UpdateFilterInputBody: Equatable {
    public let description: String?
    public let action: FilterAction?
    public let rank: Int
    public let findingCriteria: FindingCriteria?
}

extension UpdateFilterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case rank = "rank"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
    }
}

extension UpdateFilterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFilterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFilterOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFilterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFilterOutputResponse(name: \(String(describing: name)))"}
}

extension UpdateFilterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateFilterOutputResponse: Equatable {
    /// <p>The name of the filter.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateFilterOutputResponseBody: Equatable {
    public let name: String?
}

extension UpdateFilterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct UpdateFindingsFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFindingsFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsFeedbackInput>
    public typealias MOutput = OperationOutput<UpdateFindingsFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsFeedbackOutputError>
}

extension UpdateFindingsFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFindingsFeedbackInput(comments: \(String(describing: comments)), detectorId: \(String(describing: detectorId)), feedback: \(String(describing: feedback)), findingIds: \(String(describing: findingIds)))"}
}

extension UpdateFindingsFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comments = "comments"
        case feedback = "feedback"
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comments = comments {
            try encodeContainer.encode(comments, forKey: .comments)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingids0 in findingIds {
                try findingIdsContainer.encode(findingids0)
            }
        }
    }
}

public struct UpdateFindingsFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFindingsFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsFeedbackInput>
    public typealias MOutput = OperationOutput<UpdateFindingsFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsFeedbackOutputError>
}

public struct UpdateFindingsFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFindingsFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsFeedbackInput>
    public typealias MOutput = OperationOutput<UpdateFindingsFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsFeedbackOutputError>
}

public struct UpdateFindingsFeedbackInput: Equatable {
    /// <p>Additional feedback about the GuardDuty findings.</p>
    public let comments: String?
    /// <p>The ID of the detector associated with the findings to update feedback for.</p>
    public let detectorId: String?
    /// <p>The feedback for the finding.</p>
    public let feedback: Feedback?
    /// <p>The IDs of the findings that you want to mark as useful or not useful.</p>
    public let findingIds: [String]?

    public init (
        comments: String? = nil,
        detectorId: String? = nil,
        feedback: Feedback? = nil,
        findingIds: [String]? = nil
    )
    {
        self.comments = comments
        self.detectorId = detectorId
        self.feedback = feedback
        self.findingIds = findingIds
    }
}

struct UpdateFindingsFeedbackInputBody: Equatable {
    public let findingIds: [String]?
    public let feedback: Feedback?
    public let comments: String?
}

extension UpdateFindingsFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comments = "comments"
        case feedback = "feedback"
        case findingIds = "findingIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let feedbackDecoded = try containerValues.decodeIfPresent(Feedback.self, forKey: .feedback)
        feedback = feedbackDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comments)
        comments = commentsDecoded
    }
}

extension UpdateFindingsFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFindingsFeedbackOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFindingsFeedbackOutputResponse()"}
}

extension UpdateFindingsFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFindingsFeedbackOutputResponse: Equatable {

    public init() {}
}

struct UpdateFindingsFeedbackOutputResponseBody: Equatable {
}

extension UpdateFindingsFeedbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateIPSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

extension UpdateIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIPSetInput(activate: \(String(describing: activate)), detectorId: \(String(describing: detectorId)), ipSetId: \(String(describing: ipSetId)), location: \(String(describing: location)), name: \(String(describing: name)))"}
}

extension UpdateIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activate != false {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

public struct UpdateIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

public struct UpdateIPSetInput: Equatable {
    /// <p>The updated Boolean value that specifies whether the IPSet is active or not.</p>
    public let activate: Bool
    /// <p>The detectorID that specifies the GuardDuty service whose IPSet you want to update.</p>
    public let detectorId: String?
    /// <p>The unique ID that specifies the IPSet that you want to update.</p>
    public let ipSetId: String?
    /// <p>The updated URI of the file that contains the IPSet. For example:
    ///       https://s3.us-west-2.amazonaws.com/my-bucket/my-object-key.</p>
    public let location: String?
    /// <p>The unique ID that specifies the IPSet that you want to update.</p>
    public let name: String?

    public init (
        activate: Bool = false,
        detectorId: String? = nil,
        ipSetId: String? = nil,
        location: String? = nil,
        name: String? = nil
    )
    {
        self.activate = activate
        self.detectorId = detectorId
        self.ipSetId = ipSetId
        self.location = location
        self.name = name
    }
}

struct UpdateIPSetInputBody: Equatable {
    public let name: String?
    public let location: String?
    public let activate: Bool
}

extension UpdateIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decode(Bool.self, forKey: .activate)
        activate = activateDecoded
    }
}

extension UpdateIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIPSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIPSetOutputResponse()"}
}

extension UpdateIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIPSetOutputResponse: Equatable {

    public init() {}
}

struct UpdateIPSetOutputResponseBody: Equatable {
}

extension UpdateIPSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateMemberDetectorsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMemberDetectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMemberDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMemberDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMemberDetectorsInput>
    public typealias MOutput = OperationOutput<UpdateMemberDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMemberDetectorsOutputError>
}

extension UpdateMemberDetectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMemberDetectorsInput(accountIds: \(String(describing: accountIds)), dataSources: \(String(describing: dataSources)), detectorId: \(String(describing: detectorId)))"}
}

extension UpdateMemberDetectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }
}

public struct UpdateMemberDetectorsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMemberDetectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMemberDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMemberDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMemberDetectorsInput>
    public typealias MOutput = OperationOutput<UpdateMemberDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMemberDetectorsOutputError>
}

public struct UpdateMemberDetectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMemberDetectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMemberDetectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMemberDetectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMemberDetectorsInput>
    public typealias MOutput = OperationOutput<UpdateMemberDetectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMemberDetectorsOutputError>
}

public struct UpdateMemberDetectorsInput: Equatable {
    /// <p>A list of member account IDs to be updated.</p>
    public let accountIds: [String]?
    /// <p>Describes which data sources will be updated.</p>
    public let dataSources: DataSourceConfigurations?
    /// <p>The detector ID of the administrator account.</p>
    public let detectorId: String?

    public init (
        accountIds: [String]? = nil,
        dataSources: DataSourceConfigurations? = nil,
        detectorId: String? = nil
    )
    {
        self.accountIds = accountIds
        self.dataSources = dataSources
        self.detectorId = detectorId
    }
}

struct UpdateMemberDetectorsInputBody: Equatable {
    public let accountIds: [String]?
    public let dataSources: DataSourceConfigurations?
}

extension UpdateMemberDetectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let dataSourcesDecoded = try containerValues.decodeIfPresent(DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateMemberDetectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMemberDetectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMemberDetectorsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMemberDetectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMemberDetectorsOutputResponse(unprocessedAccounts: \(String(describing: unprocessedAccounts)))"}
}

extension UpdateMemberDetectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMemberDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct UpdateMemberDetectorsOutputResponse: Equatable {
    /// <p>A list of member account IDs that were unable to be processed along with an explanation
    ///       for why they were not processed.</p>
    public let unprocessedAccounts: [UnprocessedAccount]?

    public init (
        unprocessedAccounts: [UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct UpdateMemberDetectorsOutputResponseBody: Equatable {
    public let unprocessedAccounts: [UnprocessedAccount]?
}

extension UpdateMemberDetectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

public struct UpdateOrganizationConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

extension UpdateOrganizationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOrganizationConfigurationInput(autoEnable: \(String(describing: autoEnable)), dataSources: \(String(describing: dataSources)), detectorId: \(String(describing: detectorId)))"}
}

extension UpdateOrganizationConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
        if let dataSources = dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }
}

public struct UpdateOrganizationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

public struct UpdateOrganizationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateOrganizationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateOrganizationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateOrganizationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateOrganizationConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateOrganizationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateOrganizationConfigurationOutputError>
}

public struct UpdateOrganizationConfigurationInput: Equatable {
    /// <p>Indicates whether to automatically enable member accounts in the organization.</p>
    public let autoEnable: Bool
    /// <p>Describes which data sources will be updated.</p>
    public let dataSources: OrganizationDataSourceConfigurations?
    /// <p>The ID of the detector to update the delegated administrator for.</p>
    public let detectorId: String?

    public init (
        autoEnable: Bool = false,
        dataSources: OrganizationDataSourceConfigurations? = nil,
        detectorId: String? = nil
    )
    {
        self.autoEnable = autoEnable
        self.dataSources = dataSources
        self.detectorId = detectorId
    }
}

struct UpdateOrganizationConfigurationInputBody: Equatable {
    public let autoEnable: Bool
    public let dataSources: OrganizationDataSourceConfigurations?
}

extension UpdateOrganizationConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decode(Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(OrganizationDataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateOrganizationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOrganizationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateOrganizationConfigurationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOrganizationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateOrganizationConfigurationOutputResponse()"}
}

extension UpdateOrganizationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOrganizationConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateOrganizationConfigurationOutputResponseBody: Equatable {
}

extension UpdateOrganizationConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePublishingDestinationInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePublishingDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePublishingDestinationInput>
    public typealias MOutput = OperationOutput<UpdatePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePublishingDestinationOutputError>
}

extension UpdatePublishingDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePublishingDestinationInput(destinationId: \(String(describing: destinationId)), destinationProperties: \(String(describing: destinationProperties)), detectorId: \(String(describing: detectorId)))"}
}

extension UpdatePublishingDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationProperties = "destinationProperties"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationProperties = destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
    }
}

public struct UpdatePublishingDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePublishingDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePublishingDestinationInput>
    public typealias MOutput = OperationOutput<UpdatePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePublishingDestinationOutputError>
}

public struct UpdatePublishingDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePublishingDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePublishingDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePublishingDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePublishingDestinationInput>
    public typealias MOutput = OperationOutput<UpdatePublishingDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePublishingDestinationOutputError>
}

public struct UpdatePublishingDestinationInput: Equatable {
    /// <p>The ID of the publishing destination to update.</p>
    public let destinationId: String?
    /// <p>A <code>DestinationProperties</code> object that includes the <code>DestinationArn</code>
    ///       and <code>KmsKeyArn</code> of the publishing destination.</p>
    public let destinationProperties: DestinationProperties?
    /// <p>The ID of the detector associated with the publishing destinations to update.</p>
    public let detectorId: String?

    public init (
        destinationId: String? = nil,
        destinationProperties: DestinationProperties? = nil,
        detectorId: String? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationProperties = destinationProperties
        self.detectorId = detectorId
    }
}

struct UpdatePublishingDestinationInputBody: Equatable {
    public let destinationProperties: DestinationProperties?
}

extension UpdatePublishingDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationProperties = "destinationProperties"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension UpdatePublishingDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePublishingDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePublishingDestinationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublishingDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePublishingDestinationOutputResponse()"}
}

extension UpdatePublishingDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePublishingDestinationOutputResponse: Equatable {

    public init() {}
}

struct UpdatePublishingDestinationOutputResponseBody: Equatable {
}

extension UpdatePublishingDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateThreatIntelSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateThreatIntelSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThreatIntelSetInput>
    public typealias MOutput = OperationOutput<UpdateThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThreatIntelSetOutputError>
}

extension UpdateThreatIntelSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThreatIntelSetInput(activate: \(String(describing: activate)), detectorId: \(String(describing: detectorId)), location: \(String(describing: location)), name: \(String(describing: name)), threatIntelSetId: \(String(describing: threatIntelSetId)))"}
}

extension UpdateThreatIntelSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activate != false {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateThreatIntelSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateThreatIntelSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThreatIntelSetInput>
    public typealias MOutput = OperationOutput<UpdateThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThreatIntelSetOutputError>
}

public struct UpdateThreatIntelSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateThreatIntelSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateThreatIntelSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateThreatIntelSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateThreatIntelSetInput>
    public typealias MOutput = OperationOutput<UpdateThreatIntelSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateThreatIntelSetOutputError>
}

public struct UpdateThreatIntelSetInput: Equatable {
    /// <p>The updated Boolean value that specifies whether the ThreateIntelSet is active or
    ///       not.</p>
    public let activate: Bool
    /// <p>The detectorID that specifies the GuardDuty service whose ThreatIntelSet you want to
    ///       update.</p>
    public let detectorId: String?
    /// <p>The updated URI of the file that contains the ThreateIntelSet.</p>
    public let location: String?
    /// <p>The unique ID that specifies the ThreatIntelSet that you want to update.</p>
    public let name: String?
    /// <p>The unique ID that specifies the ThreatIntelSet that you want to update.</p>
    public let threatIntelSetId: String?

    public init (
        activate: Bool = false,
        detectorId: String? = nil,
        location: String? = nil,
        name: String? = nil,
        threatIntelSetId: String? = nil
    )
    {
        self.activate = activate
        self.detectorId = detectorId
        self.location = location
        self.name = name
        self.threatIntelSetId = threatIntelSetId
    }
}

struct UpdateThreatIntelSetInputBody: Equatable {
    public let name: String?
    public let location: String?
    public let activate: Bool
}

extension UpdateThreatIntelSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decode(Bool.self, forKey: .activate)
        activate = activateDecoded
    }
}

extension UpdateThreatIntelSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThreatIntelSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThreatIntelSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThreatIntelSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateThreatIntelSetOutputResponse()"}
}

extension UpdateThreatIntelSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateThreatIntelSetOutputResponse: Equatable {

    public init() {}
}

struct UpdateThreatIntelSetOutputResponseBody: Equatable {
}

extension UpdateThreatIntelSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UsageAccountResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "accountId"
        case total = "total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let totalDecoded = try containerValues.decodeIfPresent(Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension UsageAccountResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageAccountResult(accountId: \(String(describing: accountId)), total: \(String(describing: total)))"}
}

/// <p>Contains information on the total of usage based on account IDs.</p>
public struct UsageAccountResult: Equatable {
    /// <p>The Account ID that generated usage.</p>
    public let accountId: String?
    /// <p>Represents the total of usage for the Account ID.</p>
    public let total: Total?

    public init (
        accountId: String? = nil,
        total: Total? = nil
    )
    {
        self.accountId = accountId
        self.total = total
    }
}

extension UsageCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
        case resources = "resources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountids0 in accountIds {
                try accountIdsContainer.encode(accountids0)
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasourcelist0 in dataSources {
                try dataSourcesContainer.encode(datasourcelist0.rawValue)
            }
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcelist0 in resources {
                try resourcesContainer.encode(resourcelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [DataSource]()
            for string0 in dataSourcesContainer {
                if let string0 = string0 {
                    dataSourcesDecoded0?.append(string0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resources)
        var resourcesDecoded0:[String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension UsageCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageCriteria(accountIds: \(String(describing: accountIds)), dataSources: \(String(describing: dataSources)), resources: \(String(describing: resources)))"}
}

/// <p>Contains information about the criteria used to query usage statistics.</p>
public struct UsageCriteria: Equatable {
    /// <p>The account IDs to aggregate usage statistics from.</p>
    public let accountIds: [String]?
    /// <p>The data sources to aggregate usage statistics from.</p>
    public let dataSources: [DataSource]?
    /// <p>The resources to aggregate usage statistics from. Only accepts exact resource
    ///       names.</p>
    public let resources: [String]?

    public init (
        accountIds: [String]? = nil,
        dataSources: [DataSource]? = nil,
        resources: [String]? = nil
    )
    {
        self.accountIds = accountIds
        self.dataSources = dataSources
        self.resources = resources
    }
}

extension UsageDataSourceResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource = "dataSource"
        case total = "total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let totalDecoded = try containerValues.decodeIfPresent(Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension UsageDataSourceResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageDataSourceResult(dataSource: \(String(describing: dataSource)), total: \(String(describing: total)))"}
}

/// <p>Contains information on the result of usage based on data source type.</p>
public struct UsageDataSourceResult: Equatable {
    /// <p>The data source type that generated usage.</p>
    public let dataSource: DataSource?
    /// <p>Represents the total of usage for the specified data source.</p>
    public let total: Total?

    public init (
        dataSource: DataSource? = nil,
        total: Total? = nil
    )
    {
        self.dataSource = dataSource
        self.total = total
    }
}

extension UsageResourceResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resource = "resource"
        case total = "total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let totalDecoded = try containerValues.decodeIfPresent(Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension UsageResourceResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageResourceResult(resource: \(String(describing: resource)), total: \(String(describing: total)))"}
}

/// <p>Contains information on the sum of usage based on an AWS resource.</p>
public struct UsageResourceResult: Equatable {
    /// <p>The AWS resource that generated usage.</p>
    public let resource: String?
    /// <p>Represents the sum total of usage for the specified resource type.</p>
    public let total: Total?

    public init (
        resource: String? = nil,
        total: Total? = nil
    )
    {
        self.resource = resource
        self.total = total
    }
}

public enum UsageStatisticType {
    case sumByAccount
    case sumByDataSource
    case sumByResource
    case topResources
    case sdkUnknown(String)
}

extension UsageStatisticType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UsageStatisticType] {
        return [
            .sumByAccount,
            .sumByDataSource,
            .sumByResource,
            .topResources,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sumByAccount: return "SUM_BY_ACCOUNT"
        case .sumByDataSource: return "SUM_BY_DATA_SOURCE"
        case .sumByResource: return "SUM_BY_RESOURCE"
        case .topResources: return "TOP_RESOURCES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UsageStatisticType(rawValue: rawValue) ?? UsageStatisticType.sdkUnknown(rawValue)
    }
}

extension UsageStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sumByAccount = "sumByAccount"
        case sumByDataSource = "sumByDataSource"
        case sumByResource = "sumByResource"
        case topResources = "topResources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sumByAccount = sumByAccount {
            var sumByAccountContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByAccount)
            for usageaccountresultlist0 in sumByAccount {
                try sumByAccountContainer.encode(usageaccountresultlist0)
            }
        }
        if let sumByDataSource = sumByDataSource {
            var sumByDataSourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByDataSource)
            for usagedatasourceresultlist0 in sumByDataSource {
                try sumByDataSourceContainer.encode(usagedatasourceresultlist0)
            }
        }
        if let sumByResource = sumByResource {
            var sumByResourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByResource)
            for usageresourceresultlist0 in sumByResource {
                try sumByResourceContainer.encode(usageresourceresultlist0)
            }
        }
        if let topResources = topResources {
            var topResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topResources)
            for usageresourceresultlist0 in topResources {
                try topResourcesContainer.encode(usageresourceresultlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sumByAccountContainer = try containerValues.decodeIfPresent([UsageAccountResult?].self, forKey: .sumByAccount)
        var sumByAccountDecoded0:[UsageAccountResult]? = nil
        if let sumByAccountContainer = sumByAccountContainer {
            sumByAccountDecoded0 = [UsageAccountResult]()
            for structure0 in sumByAccountContainer {
                if let structure0 = structure0 {
                    sumByAccountDecoded0?.append(structure0)
                }
            }
        }
        sumByAccount = sumByAccountDecoded0
        let sumByDataSourceContainer = try containerValues.decodeIfPresent([UsageDataSourceResult?].self, forKey: .sumByDataSource)
        var sumByDataSourceDecoded0:[UsageDataSourceResult]? = nil
        if let sumByDataSourceContainer = sumByDataSourceContainer {
            sumByDataSourceDecoded0 = [UsageDataSourceResult]()
            for structure0 in sumByDataSourceContainer {
                if let structure0 = structure0 {
                    sumByDataSourceDecoded0?.append(structure0)
                }
            }
        }
        sumByDataSource = sumByDataSourceDecoded0
        let sumByResourceContainer = try containerValues.decodeIfPresent([UsageResourceResult?].self, forKey: .sumByResource)
        var sumByResourceDecoded0:[UsageResourceResult]? = nil
        if let sumByResourceContainer = sumByResourceContainer {
            sumByResourceDecoded0 = [UsageResourceResult]()
            for structure0 in sumByResourceContainer {
                if let structure0 = structure0 {
                    sumByResourceDecoded0?.append(structure0)
                }
            }
        }
        sumByResource = sumByResourceDecoded0
        let topResourcesContainer = try containerValues.decodeIfPresent([UsageResourceResult?].self, forKey: .topResources)
        var topResourcesDecoded0:[UsageResourceResult]? = nil
        if let topResourcesContainer = topResourcesContainer {
            topResourcesDecoded0 = [UsageResourceResult]()
            for structure0 in topResourcesContainer {
                if let structure0 = structure0 {
                    topResourcesDecoded0?.append(structure0)
                }
            }
        }
        topResources = topResourcesDecoded0
    }
}

extension UsageStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UsageStatistics(sumByAccount: \(String(describing: sumByAccount)), sumByDataSource: \(String(describing: sumByDataSource)), sumByResource: \(String(describing: sumByResource)), topResources: \(String(describing: topResources)))"}
}

/// <p>Contains the result of GuardDuty usage. If a UsageStatisticType is provided the result for
///       other types will be null. </p>
public struct UsageStatistics: Equatable {
    /// <p>The usage statistic sum organized by account ID.</p>
    public let sumByAccount: [UsageAccountResult]?
    /// <p>The usage statistic sum organized by on data source.</p>
    public let sumByDataSource: [UsageDataSourceResult]?
    /// <p>The usage statistic sum organized by resource.</p>
    public let sumByResource: [UsageResourceResult]?
    /// <p>Lists the top 50 resources that have generated the most GuardDuty usage, in order from
    ///       most to least expensive.</p>
    public let topResources: [UsageResourceResult]?

    public init (
        sumByAccount: [UsageAccountResult]? = nil,
        sumByDataSource: [UsageDataSourceResult]? = nil,
        sumByResource: [UsageResourceResult]? = nil,
        topResources: [UsageResourceResult]? = nil
    )
    {
        self.sumByAccount = sumByAccount
        self.sumByDataSource = sumByDataSource
        self.sumByResource = sumByResource
        self.topResources = topResources
    }
}
