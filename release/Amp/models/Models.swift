// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// User does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Description of the error.
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Description of the error.
    public var message: String?
    /// Identifier of the resource affected.
    public var resourceId: String?
    /// Type of the resource affected.
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateWorkspaceInputBodyMiddleware: Middleware {
    public let id: String = "CreateWorkspaceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspaceInput>
    public typealias MOutput = OperationOutput<CreateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspaceOutputError>
}

extension CreateWorkspaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkspaceInput(alias: \(String(describing: alias)), clientToken: \(String(describing: clientToken)))"}
}

extension CreateWorkspaceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct CreateWorkspaceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWorkspaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspaceInput>
    public typealias MOutput = OperationOutput<CreateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspaceOutputError>
}

public struct CreateWorkspaceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWorkspaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWorkspaceInput>
    public typealias MOutput = OperationOutput<CreateWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWorkspaceOutputError>
}

/// Represents the input of a CreateWorkspace operation.
public struct CreateWorkspaceInput: Equatable {
    /// An optional user-assigned alias for this workspace. This alias is for user reference and does not need to be unique.
    public let alias: String?
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: String?

    public init (
        alias: String? = nil,
        clientToken: String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
    }
}

struct CreateWorkspaceInputBody: Equatable {
    public let alias: String?
    public let clientToken: String?
}

extension CreateWorkspaceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateWorkspaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkspaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWorkspaceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkspaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWorkspaceOutputResponse(arn: \(String(describing: arn)), status: \(String(describing: status)), workspaceId: \(String(describing: workspaceId)))"}
}

extension CreateWorkspaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.status = output.status
            self.workspaceId = output.workspaceId
        } else {
            self.arn = nil
            self.status = nil
            self.workspaceId = nil
        }
    }
}

/// Represents the output of a CreateWorkspace operation.
public struct CreateWorkspaceOutputResponse: Equatable {
    /// The ARN of the workspace that was just created.
    public let arn: String?
    /// The status of the workspace that was just created (usually CREATING).
    public let status: WorkspaceStatus?
    /// The generated ID of the workspace that was just created.
    public let workspaceId: String?

    public init (
        arn: String? = nil,
        status: WorkspaceStatus? = nil,
        workspaceId: String? = nil
    )
    {
        self.arn = arn
        self.status = status
        self.workspaceId = workspaceId
    }
}

struct CreateWorkspaceOutputResponseBody: Equatable {
    public let workspaceId: String?
    public let arn: String?
    public let status: WorkspaceStatus?
}

extension CreateWorkspaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case status
        case workspaceId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteWorkspaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkspaceInput(clientToken: \(String(describing: clientToken)), workspaceId: \(String(describing: workspaceId)))"}
}

extension DeleteWorkspaceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteWorkspaceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWorkspaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkspaceInput>
    public typealias MOutput = OperationOutput<DeleteWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkspaceOutputError>
}

public struct DeleteWorkspaceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWorkspaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWorkspaceInput>
    public typealias MOutput = OperationOutput<DeleteWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWorkspaceOutputError>
}

/// Represents the input of a DeleteWorkspace operation.
public struct DeleteWorkspaceInput: Equatable {
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: String?
    /// The ID of the workspace to delete.
    public let workspaceId: String?

    public init (
        clientToken: String? = nil,
        workspaceId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct DeleteWorkspaceInputBody: Equatable {
}

extension DeleteWorkspaceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWorkspaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkspaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWorkspaceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkspaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWorkspaceOutputResponse()"}
}

extension DeleteWorkspaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkspaceOutputResponse: Equatable {

    public init() {}
}

struct DeleteWorkspaceOutputResponseBody: Equatable {
}

extension DeleteWorkspaceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeWorkspaceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceInput(workspaceId: \(String(describing: workspaceId)))"}
}

extension DescribeWorkspaceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeWorkspaceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceOutputError>
}

public struct DescribeWorkspaceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeWorkspaceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeWorkspaceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeWorkspaceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeWorkspaceInput>
    public typealias MOutput = OperationOutput<DescribeWorkspaceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeWorkspaceOutputError>
}

/// Represents the input of a DescribeWorkspace operation.
public struct DescribeWorkspaceInput: Equatable {
    /// The ID of the workspace to describe.
    public let workspaceId: String?

    public init (
        workspaceId: String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

struct DescribeWorkspaceInputBody: Equatable {
}

extension DescribeWorkspaceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeWorkspaceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeWorkspaceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeWorkspaceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeWorkspaceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeWorkspaceOutputResponse(workspace: \(String(describing: workspace)))"}
}

extension DescribeWorkspaceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeWorkspaceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.workspace = output.workspace
        } else {
            self.workspace = nil
        }
    }
}

/// Represents the output of a DescribeWorkspace operation.
public struct DescribeWorkspaceOutputResponse: Equatable {
    /// The properties of the selected workspace.
    public let workspace: WorkspaceDescription?

    public init (
        workspace: WorkspaceDescription? = nil
    )
    {
        self.workspace = workspace
    }
}

struct DescribeWorkspaceOutputResponseBody: Equatable {
    public let workspace: WorkspaceDescription?
}

extension DescribeWorkspaceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workspace
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceDecoded = try containerValues.decodeIfPresent(WorkspaceDescription.self, forKey: .workspace)
        workspace = workspaceDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// Description of the error.
    public var message: String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Int?

    public init (
        message: String? = nil,
        retryAfterSeconds: Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListWorkspacesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkspacesInput(alias: \(String(describing: alias)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWorkspacesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListWorkspacesInputHeadersMiddleware: Middleware {
    public let id: String = "ListWorkspacesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkspacesInput>
    public typealias MOutput = OperationOutput<ListWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkspacesOutputError>
}

public struct ListWorkspacesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWorkspacesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWorkspacesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWorkspacesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let alias = input.operationInput.alias {
            let aliasQueryItem = URLQueryItem(name: "alias".urlPercentEncoding(), value: String(alias).urlPercentEncoding())
            input.builder.withQueryItem(aliasQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWorkspacesInput>
    public typealias MOutput = OperationOutput<ListWorkspacesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWorkspacesOutputError>
}

/// Represents the input of a ListWorkspaces operation.
public struct ListWorkspacesInput: Equatable {
    /// Optional filter for workspace alias. Only the workspaces with aliases that begin with this value will be returned.
    public let alias: String?
    /// Maximum results to return in response (default=100, maximum=1000).
    public let maxResults: Int?
    /// Pagination token to request the next page in a paginated list. This token is obtained from the output of the previous ListWorkspaces request.
    public let nextToken: String?

    public init (
        alias: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.alias = alias
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWorkspacesInputBody: Equatable {
}

extension ListWorkspacesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListWorkspacesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkspacesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWorkspacesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkspacesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWorkspacesOutputResponse(nextToken: \(String(describing: nextToken)), workspaces: \(String(describing: workspaces)))"}
}

extension ListWorkspacesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWorkspacesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.workspaces = output.workspaces
        } else {
            self.nextToken = nil
            self.workspaces = nil
        }
    }
}

/// Represents the output of a ListWorkspaces operation.
public struct ListWorkspacesOutputResponse: Equatable {
    /// Pagination token to use when requesting the next page in this list.
    public let nextToken: String?
    /// The list of existing workspaces, including those undergoing creation or deletion.
    public let workspaces: [WorkspaceSummary]?

    public init (
        nextToken: String? = nil,
        workspaces: [WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaces = workspaces
    }
}

struct ListWorkspacesOutputResponseBody: Equatable {
    public let workspaces: [WorkspaceSummary]?
    public let nextToken: String?
}

extension ListWorkspacesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case workspaces
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspacesContainer = try containerValues.decodeIfPresent([WorkspaceSummary?].self, forKey: .workspaces)
        var workspacesDecoded0:[WorkspaceSummary]? = nil
        if let workspacesContainer = workspacesContainer {
            workspacesDecoded0 = [WorkspaceSummary]()
            for structure0 in workspacesContainer {
                if let structure0 = structure0 {
                    workspacesDecoded0?.append(structure0)
                }
            }
        }
        workspaces = workspacesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Description of the error.
    public var message: String?
    /// Identifier of the resource affected.
    public var resourceId: String?
    /// Type of the resource affected.
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Description of the error.
    public var message: String?
    /// Service Quotas requirement to identify originating quota.
    public var quotaCode: String?
    /// Identifier of the resource affected.
    public var resourceId: String?
    /// Type of the resource affected.
    public var resourceType: String?
    /// Service Quotas requirement to identify originating service.
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
    public let serviceCode: String?
    public let quotaCode: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), retryAfterSeconds: \(String(describing: retryAfterSeconds)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// Description of the error.
    public var message: String?
    /// Service Quotas requirement to identify originating quota.
    public var quotaCode: String?
    /// Advice to clients on when the call can be safely retried.
    public var retryAfterSeconds: Int?
    /// Service Quotas requirement to identify originating service.
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        retryAfterSeconds: Int? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let serviceCode: String?
    public let quotaCode: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

public struct UpdateWorkspaceAliasInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceAliasInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceAliasOutputError>
}

extension UpdateWorkspaceAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkspaceAliasInput(alias: \(String(describing: alias)), clientToken: \(String(describing: clientToken)), workspaceId: \(String(describing: workspaceId)))"}
}

extension UpdateWorkspaceAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateWorkspaceAliasInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceAliasInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceAliasOutputError>
}

public struct UpdateWorkspaceAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWorkspaceAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWorkspaceAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWorkspaceAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWorkspaceAliasInput>
    public typealias MOutput = OperationOutput<UpdateWorkspaceAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWorkspaceAliasOutputError>
}

/// Represents the input of an UpdateWorkspaceAlias operation.
public struct UpdateWorkspaceAliasInput: Equatable {
    /// The new alias of the workspace.
    public let alias: String?
    /// Optional, unique, case-sensitive, user-provided identifier to ensure the idempotency of the request.
    public var clientToken: String?
    /// The ID of the workspace being updated.
    public let workspaceId: String?

    public init (
        alias: String? = nil,
        clientToken: String? = nil,
        workspaceId: String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.workspaceId = workspaceId
    }
}

struct UpdateWorkspaceAliasInputBody: Equatable {
    public let alias: String?
    public let clientToken: String?
}

extension UpdateWorkspaceAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateWorkspaceAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkspaceAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWorkspaceAliasOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkspaceAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWorkspaceAliasOutputResponse()"}
}

extension UpdateWorkspaceAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkspaceAliasOutputResponse: Equatable {

    public init() {}
}

struct UpdateWorkspaceAliasOutputResponseBody: Equatable {
}

extension UpdateWorkspaceAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fieldList: \(String(describing: fieldList)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// The field that caused the error, if applicable. If more than one field caused the error, pick one and elaborate in the message.
    public var fieldList: [ValidationExceptionField]?
    /// Description of the error.
    public var message: String?
    /// Reason the request failed validation.
    public var reason: ValidationExceptionReason?

    public init (
        fieldList: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fieldList: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// Stores information about a field passed inside a request that resulted in an exception.
public struct ValidationExceptionField: Equatable {
    /// Message describing why the field failed validation.
    public let message: String?
    /// The field name.
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

/// Possible reasons a request failed validation.
public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "CANNOT_PARSE"
        case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
        case .other: return "OTHER"
        case .unknownOperation: return "UNKNOWN_OPERATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}

extension WorkspaceDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias
        case arn
        case createdAt
        case prometheusEndpoint
        case status
        case workspaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let prometheusEndpoint = prometheusEndpoint {
            try encodeContainer.encode(prometheusEndpoint, forKey: .prometheusEndpoint)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let prometheusEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prometheusEndpoint)
        prometheusEndpoint = prometheusEndpointDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension WorkspaceDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceDescription(alias: \(String(describing: alias)), arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), prometheusEndpoint: \(String(describing: prometheusEndpoint)), status: \(String(describing: status)), workspaceId: \(String(describing: workspaceId)))"}
}

/// Represents the properties of a workspace.
public struct WorkspaceDescription: Equatable {
    /// Alias of this workspace.
    public let alias: String?
    /// The Amazon Resource Name (ARN) of this workspace.
    public let arn: String?
    /// The time when the workspace was created.
    public let createdAt: Date?
    /// Prometheus endpoint URI.
    public let prometheusEndpoint: String?
    /// The status of this workspace.
    public let status: WorkspaceStatus?
    /// Unique string identifying this workspace.
    public let workspaceId: String?

    public init (
        alias: String? = nil,
        arn: String? = nil,
        createdAt: Date? = nil,
        prometheusEndpoint: String? = nil,
        status: WorkspaceStatus? = nil,
        workspaceId: String? = nil
    )
    {
        self.alias = alias
        self.arn = arn
        self.createdAt = createdAt
        self.prometheusEndpoint = prometheusEndpoint
        self.status = status
        self.workspaceId = workspaceId
    }
}

extension WorkspaceStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statusCode
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(WorkspaceStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension WorkspaceStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceStatus(statusCode: \(String(describing: statusCode)))"}
}

/// Represents the status of a workspace.
public struct WorkspaceStatus: Equatable {
    /// Status code of this workspace.
    public let statusCode: WorkspaceStatusCode?

    public init (
        statusCode: WorkspaceStatusCode? = nil
    )
    {
        self.statusCode = statusCode
    }
}

/// State of a workspace.
public enum WorkspaceStatusCode {
    /// Workspace has been created and is usable.
    case active
    /// Workspace is being created. Deletion is disallowed until status is ACTIVE.
    case creating
    /// Workspace creation failed. Refer to WorkspaceStatus.failureReason for more details.
    case creationFailed
    /// Workspace is being deleted. Deletions are allowed only when status is ACTIVE.
    case deleting
    /// Workspace is being updated. Updates are allowed only when status is ACTIVE.
    case updating
    case sdkUnknown(String)
}

extension WorkspaceStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WorkspaceStatusCode] {
        return [
            .active,
            .creating,
            .creationFailed,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .creationFailed: return "CREATION_FAILED"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WorkspaceStatusCode(rawValue: rawValue) ?? WorkspaceStatusCode.sdkUnknown(rawValue)
    }
}

extension WorkspaceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias
        case arn
        case createdAt
        case status
        case workspaceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let workspaceId = workspaceId {
            try encodeContainer.encode(workspaceId, forKey: .workspaceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workspaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceId = workspaceIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkspaceStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension WorkspaceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WorkspaceSummary(alias: \(String(describing: alias)), arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), status: \(String(describing: status)), workspaceId: \(String(describing: workspaceId)))"}
}

/// Represents a summary of the properties of a workspace.
public struct WorkspaceSummary: Equatable {
    /// Alias of this workspace.
    public let alias: String?
    /// The AmazonResourceName of this workspace.
    public let arn: String?
    /// The time when the workspace was created.
    public let createdAt: Date?
    /// The status of this workspace.
    public let status: WorkspaceStatus?
    /// Unique string identifying this workspace.
    public let workspaceId: String?

    public init (
        alias: String? = nil,
        arn: String? = nil,
        createdAt: Date? = nil,
        status: WorkspaceStatus? = nil,
        workspaceId: String? = nil
    )
    {
        self.alias = alias
        self.arn = arn
        self.createdAt = createdAt
        self.status = status
        self.workspaceId = workspaceId
    }
}
