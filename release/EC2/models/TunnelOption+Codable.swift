// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension TunnelOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dpdTimeoutAction = "dpdTimeoutAction"
        case dpdTimeoutSeconds = "dpdTimeoutSeconds"
        case ikeVersions = "ikeVersionSet"
        case outsideIpAddress = "outsideIpAddress"
        case phase1DHGroupNumbers = "phase1DHGroupNumberSet"
        case phase1EncryptionAlgorithms = "phase1EncryptionAlgorithmSet"
        case phase1IntegrityAlgorithms = "phase1IntegrityAlgorithmSet"
        case phase1LifetimeSeconds = "phase1LifetimeSeconds"
        case phase2DHGroupNumbers = "phase2DHGroupNumberSet"
        case phase2EncryptionAlgorithms = "phase2EncryptionAlgorithmSet"
        case phase2IntegrityAlgorithms = "phase2IntegrityAlgorithmSet"
        case phase2LifetimeSeconds = "phase2LifetimeSeconds"
        case preSharedKey = "preSharedKey"
        case rekeyFuzzPercentage = "rekeyFuzzPercentage"
        case rekeyMarginTimeSeconds = "rekeyMarginTimeSeconds"
        case replayWindowSize = "replayWindowSize"
        case startupAction = "startupAction"
        case tunnelInsideCidr = "tunnelInsideCidr"
        case tunnelInsideIpv6Cidr = "tunnelInsideIpv6Cidr"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let dpdTimeoutAction = dpdTimeoutAction {
            try container.encode(dpdTimeoutAction, forKey: Key("DpdTimeoutAction"))
        }
        if dpdTimeoutSeconds != 0 {
            try container.encode(dpdTimeoutSeconds, forKey: Key("DpdTimeoutSeconds"))
        }
        if let ikeVersions = ikeVersions {
            if !ikeVersions.isEmpty {
                for (index0, ikeversionslistvalue0) in ikeVersions.enumerated() {
                    var ikeVersionsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("IkeVersionSet.\(index0.advanced(by: 1))"))
                    try ikeVersionsContainer0.encode(ikeversionslistvalue0, forKey: Key(""))
                }
            }
        }
        if let outsideIpAddress = outsideIpAddress {
            try container.encode(outsideIpAddress, forKey: Key("OutsideIpAddress"))
        }
        if let phase1DHGroupNumbers = phase1DHGroupNumbers {
            if !phase1DHGroupNumbers.isEmpty {
                for (index0, phase1dhgroupnumberslistvalue0) in phase1DHGroupNumbers.enumerated() {
                    var phase1DHGroupNumbersContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Phase1DHGroupNumberSet.\(index0.advanced(by: 1))"))
                    try phase1DHGroupNumbersContainer0.encode(phase1dhgroupnumberslistvalue0, forKey: Key(""))
                }
            }
        }
        if let phase1EncryptionAlgorithms = phase1EncryptionAlgorithms {
            if !phase1EncryptionAlgorithms.isEmpty {
                for (index0, phase1encryptionalgorithmslistvalue0) in phase1EncryptionAlgorithms.enumerated() {
                    var phase1EncryptionAlgorithmsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Phase1EncryptionAlgorithmSet.\(index0.advanced(by: 1))"))
                    try phase1EncryptionAlgorithmsContainer0.encode(phase1encryptionalgorithmslistvalue0, forKey: Key(""))
                }
            }
        }
        if let phase1IntegrityAlgorithms = phase1IntegrityAlgorithms {
            if !phase1IntegrityAlgorithms.isEmpty {
                for (index0, phase1integrityalgorithmslistvalue0) in phase1IntegrityAlgorithms.enumerated() {
                    var phase1IntegrityAlgorithmsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Phase1IntegrityAlgorithmSet.\(index0.advanced(by: 1))"))
                    try phase1IntegrityAlgorithmsContainer0.encode(phase1integrityalgorithmslistvalue0, forKey: Key(""))
                }
            }
        }
        if phase1LifetimeSeconds != 0 {
            try container.encode(phase1LifetimeSeconds, forKey: Key("Phase1LifetimeSeconds"))
        }
        if let phase2DHGroupNumbers = phase2DHGroupNumbers {
            if !phase2DHGroupNumbers.isEmpty {
                for (index0, phase2dhgroupnumberslistvalue0) in phase2DHGroupNumbers.enumerated() {
                    var phase2DHGroupNumbersContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Phase2DHGroupNumberSet.\(index0.advanced(by: 1))"))
                    try phase2DHGroupNumbersContainer0.encode(phase2dhgroupnumberslistvalue0, forKey: Key(""))
                }
            }
        }
        if let phase2EncryptionAlgorithms = phase2EncryptionAlgorithms {
            if !phase2EncryptionAlgorithms.isEmpty {
                for (index0, phase2encryptionalgorithmslistvalue0) in phase2EncryptionAlgorithms.enumerated() {
                    var phase2EncryptionAlgorithmsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Phase2EncryptionAlgorithmSet.\(index0.advanced(by: 1))"))
                    try phase2EncryptionAlgorithmsContainer0.encode(phase2encryptionalgorithmslistvalue0, forKey: Key(""))
                }
            }
        }
        if let phase2IntegrityAlgorithms = phase2IntegrityAlgorithms {
            if !phase2IntegrityAlgorithms.isEmpty {
                for (index0, phase2integrityalgorithmslistvalue0) in phase2IntegrityAlgorithms.enumerated() {
                    var phase2IntegrityAlgorithmsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Phase2IntegrityAlgorithmSet.\(index0.advanced(by: 1))"))
                    try phase2IntegrityAlgorithmsContainer0.encode(phase2integrityalgorithmslistvalue0, forKey: Key(""))
                }
            }
        }
        if phase2LifetimeSeconds != 0 {
            try container.encode(phase2LifetimeSeconds, forKey: Key("Phase2LifetimeSeconds"))
        }
        if let preSharedKey = preSharedKey {
            try container.encode(preSharedKey, forKey: Key("PreSharedKey"))
        }
        if rekeyFuzzPercentage != 0 {
            try container.encode(rekeyFuzzPercentage, forKey: Key("RekeyFuzzPercentage"))
        }
        if rekeyMarginTimeSeconds != 0 {
            try container.encode(rekeyMarginTimeSeconds, forKey: Key("RekeyMarginTimeSeconds"))
        }
        if replayWindowSize != 0 {
            try container.encode(replayWindowSize, forKey: Key("ReplayWindowSize"))
        }
        if let startupAction = startupAction {
            try container.encode(startupAction, forKey: Key("StartupAction"))
        }
        if let tunnelInsideCidr = tunnelInsideCidr {
            try container.encode(tunnelInsideCidr, forKey: Key("TunnelInsideCidr"))
        }
        if let tunnelInsideIpv6Cidr = tunnelInsideIpv6Cidr {
            try container.encode(tunnelInsideIpv6Cidr, forKey: Key("TunnelInsideIpv6Cidr"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outsideIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outsideIpAddress)
        outsideIpAddress = outsideIpAddressDecoded
        let tunnelInsideCidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tunnelInsideCidr)
        tunnelInsideCidr = tunnelInsideCidrDecoded
        let tunnelInsideIpv6CidrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tunnelInsideIpv6Cidr)
        tunnelInsideIpv6Cidr = tunnelInsideIpv6CidrDecoded
        let preSharedKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preSharedKey)
        preSharedKey = preSharedKeyDecoded
        let phase1LifetimeSecondsDecoded = try containerValues.decode(Int.self, forKey: .phase1LifetimeSeconds)
        phase1LifetimeSeconds = phase1LifetimeSecondsDecoded
        let phase2LifetimeSecondsDecoded = try containerValues.decode(Int.self, forKey: .phase2LifetimeSeconds)
        phase2LifetimeSeconds = phase2LifetimeSecondsDecoded
        let rekeyMarginTimeSecondsDecoded = try containerValues.decode(Int.self, forKey: .rekeyMarginTimeSeconds)
        rekeyMarginTimeSeconds = rekeyMarginTimeSecondsDecoded
        let rekeyFuzzPercentageDecoded = try containerValues.decode(Int.self, forKey: .rekeyFuzzPercentage)
        rekeyFuzzPercentage = rekeyFuzzPercentageDecoded
        let replayWindowSizeDecoded = try containerValues.decode(Int.self, forKey: .replayWindowSize)
        replayWindowSize = replayWindowSizeDecoded
        let dpdTimeoutSecondsDecoded = try containerValues.decode(Int.self, forKey: .dpdTimeoutSeconds)
        dpdTimeoutSeconds = dpdTimeoutSecondsDecoded
        let dpdTimeoutActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dpdTimeoutAction)
        dpdTimeoutAction = dpdTimeoutActionDecoded
        if containerValues.contains(.phase1EncryptionAlgorithms) {
            struct KeyVal0{struct item{}}
            let phase1EncryptionAlgorithmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase1EncryptionAlgorithms)
            if let phase1EncryptionAlgorithmsWrappedContainer = phase1EncryptionAlgorithmsWrappedContainer {
                let phase1EncryptionAlgorithmsContainer = try phase1EncryptionAlgorithmsWrappedContainer.decodeIfPresent([Phase1EncryptionAlgorithmsListValue].self, forKey: .member)
                var phase1EncryptionAlgorithmsBuffer:[Phase1EncryptionAlgorithmsListValue]? = nil
                if let phase1EncryptionAlgorithmsContainer = phase1EncryptionAlgorithmsContainer {
                    phase1EncryptionAlgorithmsBuffer = [Phase1EncryptionAlgorithmsListValue]()
                    for structureContainer0 in phase1EncryptionAlgorithmsContainer {
                        phase1EncryptionAlgorithmsBuffer?.append(structureContainer0)
                    }
                }
                phase1EncryptionAlgorithms = phase1EncryptionAlgorithmsBuffer
            } else {
                phase1EncryptionAlgorithms = []
            }
        } else {
            phase1EncryptionAlgorithms = nil
        }
        if containerValues.contains(.phase2EncryptionAlgorithms) {
            struct KeyVal0{struct item{}}
            let phase2EncryptionAlgorithmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase2EncryptionAlgorithms)
            if let phase2EncryptionAlgorithmsWrappedContainer = phase2EncryptionAlgorithmsWrappedContainer {
                let phase2EncryptionAlgorithmsContainer = try phase2EncryptionAlgorithmsWrappedContainer.decodeIfPresent([Phase2EncryptionAlgorithmsListValue].self, forKey: .member)
                var phase2EncryptionAlgorithmsBuffer:[Phase2EncryptionAlgorithmsListValue]? = nil
                if let phase2EncryptionAlgorithmsContainer = phase2EncryptionAlgorithmsContainer {
                    phase2EncryptionAlgorithmsBuffer = [Phase2EncryptionAlgorithmsListValue]()
                    for structureContainer0 in phase2EncryptionAlgorithmsContainer {
                        phase2EncryptionAlgorithmsBuffer?.append(structureContainer0)
                    }
                }
                phase2EncryptionAlgorithms = phase2EncryptionAlgorithmsBuffer
            } else {
                phase2EncryptionAlgorithms = []
            }
        } else {
            phase2EncryptionAlgorithms = nil
        }
        if containerValues.contains(.phase1IntegrityAlgorithms) {
            struct KeyVal0{struct item{}}
            let phase1IntegrityAlgorithmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase1IntegrityAlgorithms)
            if let phase1IntegrityAlgorithmsWrappedContainer = phase1IntegrityAlgorithmsWrappedContainer {
                let phase1IntegrityAlgorithmsContainer = try phase1IntegrityAlgorithmsWrappedContainer.decodeIfPresent([Phase1IntegrityAlgorithmsListValue].self, forKey: .member)
                var phase1IntegrityAlgorithmsBuffer:[Phase1IntegrityAlgorithmsListValue]? = nil
                if let phase1IntegrityAlgorithmsContainer = phase1IntegrityAlgorithmsContainer {
                    phase1IntegrityAlgorithmsBuffer = [Phase1IntegrityAlgorithmsListValue]()
                    for structureContainer0 in phase1IntegrityAlgorithmsContainer {
                        phase1IntegrityAlgorithmsBuffer?.append(structureContainer0)
                    }
                }
                phase1IntegrityAlgorithms = phase1IntegrityAlgorithmsBuffer
            } else {
                phase1IntegrityAlgorithms = []
            }
        } else {
            phase1IntegrityAlgorithms = nil
        }
        if containerValues.contains(.phase2IntegrityAlgorithms) {
            struct KeyVal0{struct item{}}
            let phase2IntegrityAlgorithmsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase2IntegrityAlgorithms)
            if let phase2IntegrityAlgorithmsWrappedContainer = phase2IntegrityAlgorithmsWrappedContainer {
                let phase2IntegrityAlgorithmsContainer = try phase2IntegrityAlgorithmsWrappedContainer.decodeIfPresent([Phase2IntegrityAlgorithmsListValue].self, forKey: .member)
                var phase2IntegrityAlgorithmsBuffer:[Phase2IntegrityAlgorithmsListValue]? = nil
                if let phase2IntegrityAlgorithmsContainer = phase2IntegrityAlgorithmsContainer {
                    phase2IntegrityAlgorithmsBuffer = [Phase2IntegrityAlgorithmsListValue]()
                    for structureContainer0 in phase2IntegrityAlgorithmsContainer {
                        phase2IntegrityAlgorithmsBuffer?.append(structureContainer0)
                    }
                }
                phase2IntegrityAlgorithms = phase2IntegrityAlgorithmsBuffer
            } else {
                phase2IntegrityAlgorithms = []
            }
        } else {
            phase2IntegrityAlgorithms = nil
        }
        if containerValues.contains(.phase1DHGroupNumbers) {
            struct KeyVal0{struct item{}}
            let phase1DHGroupNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase1DHGroupNumbers)
            if let phase1DHGroupNumbersWrappedContainer = phase1DHGroupNumbersWrappedContainer {
                let phase1DHGroupNumbersContainer = try phase1DHGroupNumbersWrappedContainer.decodeIfPresent([Phase1DHGroupNumbersListValue].self, forKey: .member)
                var phase1DHGroupNumbersBuffer:[Phase1DHGroupNumbersListValue]? = nil
                if let phase1DHGroupNumbersContainer = phase1DHGroupNumbersContainer {
                    phase1DHGroupNumbersBuffer = [Phase1DHGroupNumbersListValue]()
                    for structureContainer0 in phase1DHGroupNumbersContainer {
                        phase1DHGroupNumbersBuffer?.append(structureContainer0)
                    }
                }
                phase1DHGroupNumbers = phase1DHGroupNumbersBuffer
            } else {
                phase1DHGroupNumbers = []
            }
        } else {
            phase1DHGroupNumbers = nil
        }
        if containerValues.contains(.phase2DHGroupNumbers) {
            struct KeyVal0{struct item{}}
            let phase2DHGroupNumbersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .phase2DHGroupNumbers)
            if let phase2DHGroupNumbersWrappedContainer = phase2DHGroupNumbersWrappedContainer {
                let phase2DHGroupNumbersContainer = try phase2DHGroupNumbersWrappedContainer.decodeIfPresent([Phase2DHGroupNumbersListValue].self, forKey: .member)
                var phase2DHGroupNumbersBuffer:[Phase2DHGroupNumbersListValue]? = nil
                if let phase2DHGroupNumbersContainer = phase2DHGroupNumbersContainer {
                    phase2DHGroupNumbersBuffer = [Phase2DHGroupNumbersListValue]()
                    for structureContainer0 in phase2DHGroupNumbersContainer {
                        phase2DHGroupNumbersBuffer?.append(structureContainer0)
                    }
                }
                phase2DHGroupNumbers = phase2DHGroupNumbersBuffer
            } else {
                phase2DHGroupNumbers = []
            }
        } else {
            phase2DHGroupNumbers = nil
        }
        if containerValues.contains(.ikeVersions) {
            struct KeyVal0{struct item{}}
            let ikeVersionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .ikeVersions)
            if let ikeVersionsWrappedContainer = ikeVersionsWrappedContainer {
                let ikeVersionsContainer = try ikeVersionsWrappedContainer.decodeIfPresent([IKEVersionsListValue].self, forKey: .member)
                var ikeVersionsBuffer:[IKEVersionsListValue]? = nil
                if let ikeVersionsContainer = ikeVersionsContainer {
                    ikeVersionsBuffer = [IKEVersionsListValue]()
                    for structureContainer0 in ikeVersionsContainer {
                        ikeVersionsBuffer?.append(structureContainer0)
                    }
                }
                ikeVersions = ikeVersionsBuffer
            } else {
                ikeVersions = []
            }
        } else {
            ikeVersions = nil
        }
        let startupActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startupAction)
        startupAction = startupActionDecoded
    }
}
