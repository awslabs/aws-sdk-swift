// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Host: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocationTime = "allocationTime"
        case allowsMultipleInstanceTypes = "allowsMultipleInstanceTypes"
        case autoPlacement = "autoPlacement"
        case availabilityZone = "availabilityZone"
        case availabilityZoneId = "availabilityZoneId"
        case availableCapacity = "availableCapacity"
        case clientToken = "clientToken"
        case hostId = "hostId"
        case hostProperties = "hostProperties"
        case hostRecovery = "hostRecovery"
        case hostReservationId = "hostReservationId"
        case instances = "instances"
        case memberOfServiceLinkedResourceGroup = "memberOfServiceLinkedResourceGroup"
        case ownerId = "ownerId"
        case releaseTime = "releaseTime"
        case state = "state"
        case tags = "tagSet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocationTime = allocationTime {
            try container.encode(TimestampWrapper(allocationTime, format: .dateTime), forKey: Key("AllocationTime"))
        }
        if let allowsMultipleInstanceTypes = allowsMultipleInstanceTypes {
            try container.encode(allowsMultipleInstanceTypes, forKey: Key("AllowsMultipleInstanceTypes"))
        }
        if let autoPlacement = autoPlacement {
            try container.encode(autoPlacement, forKey: Key("AutoPlacement"))
        }
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let availabilityZoneId = availabilityZoneId {
            try container.encode(availabilityZoneId, forKey: Key("AvailabilityZoneId"))
        }
        if let availableCapacity = availableCapacity {
            try container.encode(availableCapacity, forKey: Key("AvailableCapacity"))
        }
        if let clientToken = clientToken {
            try container.encode(clientToken, forKey: Key("ClientToken"))
        }
        if let hostId = hostId {
            try container.encode(hostId, forKey: Key("HostId"))
        }
        if let hostProperties = hostProperties {
            try container.encode(hostProperties, forKey: Key("HostProperties"))
        }
        if let hostRecovery = hostRecovery {
            try container.encode(hostRecovery, forKey: Key("HostRecovery"))
        }
        if let hostReservationId = hostReservationId {
            try container.encode(hostReservationId, forKey: Key("HostReservationId"))
        }
        if let instances = instances {
            if !instances.isEmpty {
                for (index0, hostinstance0) in instances.enumerated() {
                    var instancesContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("Instances.\(index0.advanced(by: 1))"))
                    try instancesContainer0.encode(hostinstance0, forKey: Key(""))
                }
            }
        }
        if memberOfServiceLinkedResourceGroup != false {
            try container.encode(memberOfServiceLinkedResourceGroup, forKey: Key("MemberOfServiceLinkedResourceGroup"))
        }
        if let ownerId = ownerId {
            try container.encode(ownerId, forKey: Key("OwnerId"))
        }
        if let releaseTime = releaseTime {
            try container.encode(TimestampWrapper(releaseTime, format: .dateTime), forKey: Key("ReleaseTime"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                for (index0, tag0) in tags.enumerated() {
                    var tagsContainer0 = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagSet.\(index0.advanced(by: 1))"))
                    try tagsContainer0.encode(tag0, forKey: Key(""))
                }
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoPlacementDecoded = try containerValues.decodeIfPresent(AutoPlacement.self, forKey: .autoPlacement)
        autoPlacement = autoPlacementDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let availableCapacityDecoded = try containerValues.decodeIfPresent(AvailableCapacity.self, forKey: .availableCapacity)
        availableCapacity = availableCapacityDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let hostIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostId)
        hostId = hostIdDecoded
        let hostPropertiesDecoded = try containerValues.decodeIfPresent(HostProperties.self, forKey: .hostProperties)
        hostProperties = hostPropertiesDecoded
        let hostReservationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostReservationId)
        hostReservationId = hostReservationIdDecoded
        if containerValues.contains(.instances) {
            struct KeyVal0{struct item{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([HostInstance].self, forKey: .member)
                var instancesBuffer:[HostInstance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [HostInstance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
        let stateDecoded = try containerValues.decodeIfPresent(AllocationState.self, forKey: .state)
        state = stateDecoded
        let allocationTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allocationTime)
        var allocationTimeBuffer:Date? = nil
        if let allocationTimeDecoded = allocationTimeDecoded {
            allocationTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(allocationTimeDecoded, format: .dateTime)
        }
        allocationTime = allocationTimeBuffer
        let releaseTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .releaseTime)
        var releaseTimeBuffer:Date? = nil
        if let releaseTimeDecoded = releaseTimeDecoded {
            releaseTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(releaseTimeDecoded, format: .dateTime)
        }
        releaseTime = releaseTimeBuffer
        if containerValues.contains(.tags) {
            struct KeyVal0{struct item{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.item>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
        let hostRecoveryDecoded = try containerValues.decodeIfPresent(HostRecovery.self, forKey: .hostRecovery)
        hostRecovery = hostRecoveryDecoded
        let allowsMultipleInstanceTypesDecoded = try containerValues.decodeIfPresent(AllowsMultipleInstanceTypes.self, forKey: .allowsMultipleInstanceTypes)
        allowsMultipleInstanceTypes = allowsMultipleInstanceTypesDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let memberOfServiceLinkedResourceGroupDecoded = try containerValues.decode(Bool.self, forKey: .memberOfServiceLinkedResourceGroup)
        memberOfServiceLinkedResourceGroup = memberOfServiceLinkedResourceGroupDecoded
    }
}
