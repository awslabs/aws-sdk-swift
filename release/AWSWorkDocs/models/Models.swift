// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbortDocumentVersionUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension AbortDocumentVersionUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

public struct AbortDocumentVersionUploadInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The ID of the version.
    /// This member is required.
    public var versionId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.versionId = versionId
    }
}

struct AbortDocumentVersionUploadInputBody: Swift.Equatable {
}

extension AbortDocumentVersionUploadInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AbortDocumentVersionUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AbortDocumentVersionUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AbortDocumentVersionUploadOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AbortDocumentVersionUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AbortDocumentVersionUploadOutputResponse: Swift.Equatable {

}

extension ActivateUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension ActivateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())/activation"
    }
}

public struct ActivateUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct ActivateUserInputBody: Swift.Equatable {
}

extension ActivateUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ActivateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateUserOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActivateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct ActivateUserOutputResponse: Swift.Equatable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init (
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct ActivateUserOutputResponseBody: Swift.Equatable {
    let user: WorkDocsClientTypes.User?
}

extension ActivateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension WorkDocsClientTypes.Activity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentMetadata = "CommentMetadata"
        case initiator = "Initiator"
        case isIndirectActivity = "IsIndirectActivity"
        case organizationId = "OrganizationId"
        case originalParent = "OriginalParent"
        case participants = "Participants"
        case resourceMetadata = "ResourceMetadata"
        case timeStamp = "TimeStamp"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentMetadata = commentMetadata {
            try encodeContainer.encode(commentMetadata, forKey: .commentMetadata)
        }
        if let initiator = initiator {
            try encodeContainer.encode(initiator, forKey: .initiator)
        }
        if isIndirectActivity != false {
            try encodeContainer.encode(isIndirectActivity, forKey: .isIndirectActivity)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let originalParent = originalParent {
            try encodeContainer.encode(originalParent, forKey: .originalParent)
        }
        if let participants = participants {
            try encodeContainer.encode(participants, forKey: .participants)
        }
        if let resourceMetadata = resourceMetadata {
            try encodeContainer.encode(resourceMetadata, forKey: .resourceMetadata)
        }
        if let timeStamp = timeStamp {
            try encodeContainer.encode(timeStamp.timeIntervalSince1970, forKey: .timeStamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ActivityType.self, forKey: .type)
        type = typeDecoded
        let timeStampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timeStamp)
        timeStamp = timeStampDecoded
        let isIndirectActivityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isIndirectActivity)
        isIndirectActivity = isIndirectActivityDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let initiatorDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserMetadata.self, forKey: .initiator)
        initiator = initiatorDecoded
        let participantsDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.Participants.self, forKey: .participants)
        participants = participantsDecoded
        let resourceMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceMetadata.self, forKey: .resourceMetadata)
        resourceMetadata = resourceMetadataDecoded
        let originalParentDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceMetadata.self, forKey: .originalParent)
        originalParent = originalParentDecoded
        let commentMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentMetadata.self, forKey: .commentMetadata)
        commentMetadata = commentMetadataDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the activity information.
    public struct Activity: Swift.Equatable {
        /// Metadata of the commenting activity. This is an optional field and is filled for commenting activities.
        public var commentMetadata: WorkDocsClientTypes.CommentMetadata?
        /// The user who performed the action.
        public var initiator: WorkDocsClientTypes.UserMetadata?
        /// Indicates whether an activity is indirect or direct. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).
        public var isIndirectActivity: Swift.Bool
        /// The ID of the organization.
        public var organizationId: Swift.String?
        /// The original parent of the resource. This is an optional field and is filled for move activities.
        public var originalParent: WorkDocsClientTypes.ResourceMetadata?
        /// The list of users or groups impacted by this action. This is an optional field and is filled for the following sharing activities: DOCUMENT_SHARED, DOCUMENT_SHARED, DOCUMENT_UNSHARED, FOLDER_SHARED, FOLDER_UNSHARED.
        public var participants: WorkDocsClientTypes.Participants?
        /// The metadata of the resource involved in the user action.
        public var resourceMetadata: WorkDocsClientTypes.ResourceMetadata?
        /// The timestamp when the action was performed.
        public var timeStamp: ClientRuntime.Date?
        /// The activity type.
        public var type: WorkDocsClientTypes.ActivityType?

        public init (
            commentMetadata: WorkDocsClientTypes.CommentMetadata? = nil,
            initiator: WorkDocsClientTypes.UserMetadata? = nil,
            isIndirectActivity: Swift.Bool = false,
            organizationId: Swift.String? = nil,
            originalParent: WorkDocsClientTypes.ResourceMetadata? = nil,
            participants: WorkDocsClientTypes.Participants? = nil,
            resourceMetadata: WorkDocsClientTypes.ResourceMetadata? = nil,
            timeStamp: ClientRuntime.Date? = nil,
            type: WorkDocsClientTypes.ActivityType? = nil
        )
        {
            self.commentMetadata = commentMetadata
            self.initiator = initiator
            self.isIndirectActivity = isIndirectActivity
            self.organizationId = organizationId
            self.originalParent = originalParent
            self.participants = participants
            self.resourceMetadata = resourceMetadata
            self.timeStamp = timeStamp
            self.type = type
        }
    }

}

extension WorkDocsClientTypes {
    public enum ActivityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documentAnnotationAdded
        case documentAnnotationDeleted
        case documentCheckedIn
        case documentCheckedOut
        case documentCommentAdded
        case documentCommentDeleted
        case documentMoved
        case documentRecycled
        case documentRenamed
        case documentRestored
        case documentReverted
        case documentShareableLinkCreated
        case documentShareableLinkPermissionChanged
        case documentShareableLinkRemoved
        case documentShared
        case documentSharePermissionChanged
        case documentUnshared
        case documentVersionDeleted
        case documentVersionDownloaded
        case documentVersionUploaded
        case documentVersionViewed
        case folderCreated
        case folderDeleted
        case folderMoved
        case folderRecycled
        case folderRenamed
        case folderRestored
        case folderShareableLinkCreated
        case folderShareableLinkPermissionChanged
        case folderShareableLinkRemoved
        case folderShared
        case folderSharePermissionChanged
        case folderUnshared
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivityType] {
            return [
                .documentAnnotationAdded,
                .documentAnnotationDeleted,
                .documentCheckedIn,
                .documentCheckedOut,
                .documentCommentAdded,
                .documentCommentDeleted,
                .documentMoved,
                .documentRecycled,
                .documentRenamed,
                .documentRestored,
                .documentReverted,
                .documentShareableLinkCreated,
                .documentShareableLinkPermissionChanged,
                .documentShareableLinkRemoved,
                .documentShared,
                .documentSharePermissionChanged,
                .documentUnshared,
                .documentVersionDeleted,
                .documentVersionDownloaded,
                .documentVersionUploaded,
                .documentVersionViewed,
                .folderCreated,
                .folderDeleted,
                .folderMoved,
                .folderRecycled,
                .folderRenamed,
                .folderRestored,
                .folderShareableLinkCreated,
                .folderShareableLinkPermissionChanged,
                .folderShareableLinkRemoved,
                .folderShared,
                .folderSharePermissionChanged,
                .folderUnshared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documentAnnotationAdded: return "DOCUMENT_ANNOTATION_ADDED"
            case .documentAnnotationDeleted: return "DOCUMENT_ANNOTATION_DELETED"
            case .documentCheckedIn: return "DOCUMENT_CHECKED_IN"
            case .documentCheckedOut: return "DOCUMENT_CHECKED_OUT"
            case .documentCommentAdded: return "DOCUMENT_COMMENT_ADDED"
            case .documentCommentDeleted: return "DOCUMENT_COMMENT_DELETED"
            case .documentMoved: return "DOCUMENT_MOVED"
            case .documentRecycled: return "DOCUMENT_RECYCLED"
            case .documentRenamed: return "DOCUMENT_RENAMED"
            case .documentRestored: return "DOCUMENT_RESTORED"
            case .documentReverted: return "DOCUMENT_REVERTED"
            case .documentShareableLinkCreated: return "DOCUMENT_SHAREABLE_LINK_CREATED"
            case .documentShareableLinkPermissionChanged: return "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED"
            case .documentShareableLinkRemoved: return "DOCUMENT_SHAREABLE_LINK_REMOVED"
            case .documentShared: return "DOCUMENT_SHARED"
            case .documentSharePermissionChanged: return "DOCUMENT_SHARE_PERMISSION_CHANGED"
            case .documentUnshared: return "DOCUMENT_UNSHARED"
            case .documentVersionDeleted: return "DOCUMENT_VERSION_DELETED"
            case .documentVersionDownloaded: return "DOCUMENT_VERSION_DOWNLOADED"
            case .documentVersionUploaded: return "DOCUMENT_VERSION_UPLOADED"
            case .documentVersionViewed: return "DOCUMENT_VERSION_VIEWED"
            case .folderCreated: return "FOLDER_CREATED"
            case .folderDeleted: return "FOLDER_DELETED"
            case .folderMoved: return "FOLDER_MOVED"
            case .folderRecycled: return "FOLDER_RECYCLED"
            case .folderRenamed: return "FOLDER_RENAMED"
            case .folderRestored: return "FOLDER_RESTORED"
            case .folderShareableLinkCreated: return "FOLDER_SHAREABLE_LINK_CREATED"
            case .folderShareableLinkPermissionChanged: return "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED"
            case .folderShareableLinkRemoved: return "FOLDER_SHAREABLE_LINK_REMOVED"
            case .folderShared: return "FOLDER_SHARED"
            case .folderSharePermissionChanged: return "FOLDER_SHARE_PERMISSION_CHANGED"
            case .folderUnshared: return "FOLDER_UNSHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivityType(rawValue: rawValue) ?? ActivityType.sdkUnknown(rawValue)
        }
    }
}

extension AddResourcePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationOptions = "NotificationOptions"
        case principals = "Principals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationOptions = notificationOptions {
            try encodeContainer.encode(notificationOptions, forKey: .notificationOptions)
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for shareprincipallist0 in principals {
                try principalsContainer.encode(shareprincipallist0)
            }
        }
    }
}

extension AddResourcePermissionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension AddResourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

public struct AddResourcePermissionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The notification options.
    public var notificationOptions: WorkDocsClientTypes.NotificationOptions?
    /// The users, groups, or organization being granted permission.
    /// This member is required.
    public var principals: [WorkDocsClientTypes.SharePrincipal]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        notificationOptions: WorkDocsClientTypes.NotificationOptions? = nil,
        principals: [WorkDocsClientTypes.SharePrincipal]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.notificationOptions = notificationOptions
        self.principals = principals
        self.resourceId = resourceId
    }
}

struct AddResourcePermissionsInputBody: Swift.Equatable {
    let principals: [WorkDocsClientTypes.SharePrincipal]?
    let notificationOptions: WorkDocsClientTypes.NotificationOptions?
}

extension AddResourcePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationOptions = "NotificationOptions"
        case principals = "Principals"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.SharePrincipal?].self, forKey: .principals)
        var principalsDecoded0:[WorkDocsClientTypes.SharePrincipal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [WorkDocsClientTypes.SharePrincipal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let notificationOptionsDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.NotificationOptions.self, forKey: .notificationOptions)
        notificationOptions = notificationOptionsDecoded
    }
}

extension AddResourcePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddResourcePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddResourcePermissionsOutputError: Swift.Error, Swift.Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddResourcePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddResourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.shareResults = output.shareResults
        } else {
            self.shareResults = nil
        }
    }
}

public struct AddResourcePermissionsOutputResponse: Swift.Equatable {
    /// The share results.
    public var shareResults: [WorkDocsClientTypes.ShareResult]?

    public init (
        shareResults: [WorkDocsClientTypes.ShareResult]? = nil
    )
    {
        self.shareResults = shareResults
    }
}

struct AddResourcePermissionsOutputResponseBody: Swift.Equatable {
    let shareResults: [WorkDocsClientTypes.ShareResult]?
}

extension AddResourcePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareResults = "ShareResults"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shareResultsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.ShareResult?].self, forKey: .shareResults)
        var shareResultsDecoded0:[WorkDocsClientTypes.ShareResult]? = nil
        if let shareResultsContainer = shareResultsContainer {
            shareResultsDecoded0 = [WorkDocsClientTypes.ShareResult]()
            for structure0 in shareResultsContainer {
                if let structure0 = structure0 {
                    shareResultsDecoded0?.append(structure0)
                }
            }
        }
        shareResults = shareResultsDecoded0
    }
}

extension WorkDocsClientTypes {
    public enum BooleanEnumType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [BooleanEnumType] {
            return [
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BooleanEnumType(rawValue: rawValue) ?? BooleanEnumType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.Comment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId = "CommentId"
        case contributor = "Contributor"
        case createdTimestamp = "CreatedTimestamp"
        case parentId = "ParentId"
        case recipientId = "RecipientId"
        case status = "Status"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let contributor = contributor {
            try encodeContainer.encode(contributor, forKey: .contributor)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let parentId = parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let recipientId = recipientId {
            try encodeContainer.encode(recipientId, forKey: .recipientId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let threadId = threadId {
            try encodeContainer.encode(threadId, forKey: .threadId)
        }
        if let visibility = visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let threadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threadId)
        threadId = threadIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let contributorDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .contributor)
        contributor = contributorDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentStatusType.self, forKey: .status)
        status = statusDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentVisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let recipientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipientId)
        recipientId = recipientIdDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes a comment.
    public struct Comment: Swift.Equatable {
        /// The ID of the comment.
        /// This member is required.
        public var commentId: Swift.String?
        /// The details of the user who made the comment.
        public var contributor: WorkDocsClientTypes.User?
        /// The time that the comment was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the parent comment.
        public var parentId: Swift.String?
        /// If the comment is a reply to another user's comment, this field contains the user ID of the user being replied to.
        public var recipientId: Swift.String?
        /// The status of the comment.
        public var status: WorkDocsClientTypes.CommentStatusType?
        /// The text of the comment.
        public var text: Swift.String?
        /// The ID of the root comment in the thread.
        public var threadId: Swift.String?
        /// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
        public var visibility: WorkDocsClientTypes.CommentVisibilityType?

        public init (
            commentId: Swift.String? = nil,
            contributor: WorkDocsClientTypes.User? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            parentId: Swift.String? = nil,
            recipientId: Swift.String? = nil,
            status: WorkDocsClientTypes.CommentStatusType? = nil,
            text: Swift.String? = nil,
            threadId: Swift.String? = nil,
            visibility: WorkDocsClientTypes.CommentVisibilityType? = nil
        )
        {
            self.commentId = commentId
            self.contributor = contributor
            self.createdTimestamp = createdTimestamp
            self.parentId = parentId
            self.recipientId = recipientId
            self.status = status
            self.text = text
            self.threadId = threadId
            self.visibility = visibility
        }
    }

}

extension WorkDocsClientTypes.CommentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commentId = "CommentId"
        case commentStatus = "CommentStatus"
        case contributor = "Contributor"
        case createdTimestamp = "CreatedTimestamp"
        case recipientId = "RecipientId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentId = commentId {
            try encodeContainer.encode(commentId, forKey: .commentId)
        }
        if let commentStatus = commentStatus {
            try encodeContainer.encode(commentStatus.rawValue, forKey: .commentStatus)
        }
        if let contributor = contributor {
            try encodeContainer.encode(contributor, forKey: .contributor)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let recipientId = recipientId {
            try encodeContainer.encode(recipientId, forKey: .recipientId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commentId)
        commentId = commentIdDecoded
        let contributorDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .contributor)
        contributor = contributorDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let commentStatusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentStatusType.self, forKey: .commentStatus)
        commentStatus = commentStatusDecoded
        let recipientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipientId)
        recipientId = recipientIdDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the metadata of a comment.
    public struct CommentMetadata: Swift.Equatable {
        /// The ID of the comment.
        public var commentId: Swift.String?
        /// The status of the comment.
        public var commentStatus: WorkDocsClientTypes.CommentStatusType?
        /// The user who made the comment.
        public var contributor: WorkDocsClientTypes.User?
        /// The timestamp that the comment was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the user being replied to.
        public var recipientId: Swift.String?

        public init (
            commentId: Swift.String? = nil,
            commentStatus: WorkDocsClientTypes.CommentStatusType? = nil,
            contributor: WorkDocsClientTypes.User? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            recipientId: Swift.String? = nil
        )
        {
            self.commentId = commentId
            self.commentStatus = commentStatus
            self.contributor = contributor
            self.createdTimestamp = createdTimestamp
            self.recipientId = recipientId
        }
    }

}

extension WorkDocsClientTypes {
    public enum CommentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case draft
        case published
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentStatusType] {
            return [
                .deleted,
                .draft,
                .published,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .draft: return "DRAFT"
            case .published: return "PUBLISHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommentStatusType(rawValue: rawValue) ?? CommentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum CommentVisibilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [CommentVisibilityType] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommentVisibilityType(rawValue: rawValue) ?? CommentVisibilityType.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource hierarchy is changing.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictingOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictingOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another operation is in progress on the resource that conflicts with the current operation.
public struct ConflictingOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictingOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictingOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateCommentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notifyCollaborators = "NotifyCollaborators"
        case parentId = "ParentId"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if notifyCollaborators != false {
            try encodeContainer.encode(notifyCollaborators, forKey: .notifyCollaborators)
        }
        if let parentId = parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let threadId = threadId {
            try encodeContainer.encode(threadId, forKey: .threadId)
        }
        if let visibility = visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }
}

extension CreateCommentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateCommentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comment"
    }
}

public struct CreateCommentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Set this parameter to TRUE to send an email out to the document collaborators after the comment is created.
    public var notifyCollaborators: Swift.Bool
    /// The ID of the parent comment.
    public var parentId: Swift.String?
    /// The text of the comment.
    /// This member is required.
    public var text: Swift.String?
    /// The ID of the root comment in the thread.
    public var threadId: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?
    /// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
    public var visibility: WorkDocsClientTypes.CommentVisibilityType?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        notifyCollaborators: Swift.Bool = false,
        parentId: Swift.String? = nil,
        text: Swift.String? = nil,
        threadId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        visibility: WorkDocsClientTypes.CommentVisibilityType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.notifyCollaborators = notifyCollaborators
        self.parentId = parentId
        self.text = text
        self.threadId = threadId
        self.versionId = versionId
        self.visibility = visibility
    }
}

struct CreateCommentInputBody: Swift.Equatable {
    let parentId: Swift.String?
    let threadId: Swift.String?
    let text: Swift.String?
    let visibility: WorkDocsClientTypes.CommentVisibilityType?
    let notifyCollaborators: Swift.Bool
}

extension CreateCommentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notifyCollaborators = "NotifyCollaborators"
        case parentId = "ParentId"
        case text = "Text"
        case threadId = "ThreadId"
        case visibility = "Visibility"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let threadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threadId)
        threadId = threadIdDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.CommentVisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let notifyCollaboratorsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .notifyCollaborators)
        notifyCollaborators = notifyCollaboratorsDecoded
    }
}

extension CreateCommentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCommentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DocumentLockedForCommentsException" : self = .documentLockedForCommentsException(try DocumentLockedForCommentsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCommentOperationException" : self = .invalidCommentOperationException(try InvalidCommentOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCommentOutputError: Swift.Error, Swift.Equatable {
    case documentLockedForCommentsException(DocumentLockedForCommentsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidCommentOperationException(InvalidCommentOperationException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCommentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCommentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comment = output.comment
        } else {
            self.comment = nil
        }
    }
}

public struct CreateCommentOutputResponse: Swift.Equatable {
    /// The comment that has been created.
    public var comment: WorkDocsClientTypes.Comment?

    public init (
        comment: WorkDocsClientTypes.Comment? = nil
    )
    {
        self.comment = comment
    }
}

struct CreateCommentOutputResponseBody: Swift.Equatable {
    let comment: WorkDocsClientTypes.Comment?
}

extension CreateCommentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment = "Comment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.Comment.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension CreateCustomMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customMetadata = customMetadata {
            var customMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .customMetadata)
            for (dictKey0, custommetadatamap0) in customMetadata {
                try customMetadataContainer.encode(custommetadatamap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCustomMetadataInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateCustomMetadataInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionid".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        return items
    }
}

extension CreateCustomMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/customMetadata"
    }
}

public struct CreateCustomMetadataInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Custom metadata in the form of name-value pairs.
    /// This member is required.
    public var customMetadata: [Swift.String:Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The ID of the version, if the custom metadata is being added to a document version.
    public var versionId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        customMetadata: [Swift.String:Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.customMetadata = customMetadata
        self.resourceId = resourceId
        self.versionId = versionId
    }
}

struct CreateCustomMetadataInputBody: Swift.Equatable {
    let customMetadata: [Swift.String:Swift.String]?
}

extension CreateCustomMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension CreateCustomMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CustomMetadataLimitExceededException" : self = .customMetadataLimitExceededException(try CustomMetadataLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomMetadataOutputError: Swift.Error, Swift.Equatable {
    case customMetadataLimitExceededException(CustomMetadataLimitExceededException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateCustomMetadataOutputResponse: Swift.Equatable {

}

extension CreateFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
    }
}

extension CreateFolderInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/folders"
    }
}

public struct CreateFolderInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The name of the new folder.
    public var name: Swift.String?
    /// The ID of the parent folder.
    /// This member is required.
    public var parentFolderId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.name = name
        self.parentFolderId = parentFolderId
    }
}

struct CreateFolderInputBody: Swift.Equatable {
    let name: Swift.String?
    let parentFolderId: Swift.String?
}

extension CreateFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
    }
}

extension CreateFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFolderOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case limitExceededException(LimitExceededException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
        } else {
            self.metadata = nil
        }
    }
}

public struct CreateFolderOutputResponse: Swift.Equatable {
    /// The metadata of the folder.
    public var metadata: WorkDocsClientTypes.FolderMetadata?

    public init (
        metadata: WorkDocsClientTypes.FolderMetadata? = nil
    )
    {
        self.metadata = metadata
    }
}

struct CreateFolderOutputResponseBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.FolderMetadata?
}

extension CreateFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.FolderMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension CreateLabelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabels0 in labels {
                try labelsContainer.encode(sharedlabels0)
            }
        }
    }
}

extension CreateLabelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateLabelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/labels"
    }
}

public struct CreateLabelsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// List of labels to add to the resource.
    /// This member is required.
    public var labels: [Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.labels = labels
        self.resourceId = resourceId
    }
}

struct CreateLabelsInputBody: Swift.Equatable {
    let labels: [Swift.String]?
}

extension CreateLabelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels = "Labels"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension CreateLabelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLabelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLabelsException" : self = .tooManyLabelsException(try TooManyLabelsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLabelsOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyLabelsException(TooManyLabelsException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLabelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateLabelsOutputResponse: Swift.Equatable {

}

extension CreateNotificationSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
        case subscriptionType = "SubscriptionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let subscriptionType = subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
    }
}

extension CreateNotificationSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationId = organizationId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions"
    }
}

public struct CreateNotificationSubscriptionInput: Swift.Equatable {
    /// The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint is a URL that begins with https.
    /// This member is required.
    public var endpoint: Swift.String?
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The protocol to use. The supported value is https, which delivers JSON-encoded messages using HTTPS POST.
    /// This member is required.
    public var `protocol`: WorkDocsClientTypes.SubscriptionProtocolType?
    /// The notification type.
    /// This member is required.
    public var subscriptionType: WorkDocsClientTypes.SubscriptionType?

    public init (
        endpoint: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        `protocol`: WorkDocsClientTypes.SubscriptionProtocolType? = nil,
        subscriptionType: WorkDocsClientTypes.SubscriptionType? = nil
    )
    {
        self.endpoint = endpoint
        self.organizationId = organizationId
        self.`protocol` = `protocol`
        self.subscriptionType = subscriptionType
    }
}

struct CreateNotificationSubscriptionInputBody: Swift.Equatable {
    let endpoint: Swift.String?
    let `protocol`: WorkDocsClientTypes.SubscriptionProtocolType?
    let subscriptionType: WorkDocsClientTypes.SubscriptionType?
}

extension CreateNotificationSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
        case subscriptionType = "SubscriptionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.SubscriptionProtocolType.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
    }
}

extension CreateNotificationSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNotificationSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManySubscriptionsException" : self = .tooManySubscriptionsException(try TooManySubscriptionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNotificationSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManySubscriptionsException(TooManySubscriptionsException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNotificationSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNotificationSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscription = output.subscription
        } else {
            self.subscription = nil
        }
    }
}

public struct CreateNotificationSubscriptionOutputResponse: Swift.Equatable {
    /// The subscription.
    public var subscription: WorkDocsClientTypes.Subscription?

    public init (
        subscription: WorkDocsClientTypes.Subscription? = nil
    )
    {
        self.subscription = subscription
    }
}

struct CreateNotificationSubscriptionOutputResponseBody: Swift.Equatable {
    let subscription: WorkDocsClientTypes.Subscription?
}

extension CreateNotificationSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscription = "Subscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.Subscription.self, forKey: .subscription)
        subscription = subscriptionDecoded
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case organizationId = "OrganizationId"
        case password = "Password"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let storageRule = storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }
}

extension CreateUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/users"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The email address of the user.
    public var emailAddress: Swift.String?
    /// The given name of the user.
    /// This member is required.
    public var givenName: Swift.String?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// The password of the user.
    /// This member is required.
    public var password: Swift.String?
    /// The amount of storage for the user.
    public var storageRule: WorkDocsClientTypes.StorageRuleType?
    /// The surname of the user.
    /// This member is required.
    public var surname: Swift.String?
    /// The time zone ID of the user.
    public var timeZoneId: Swift.String?
    /// The login name of the user.
    /// This member is required.
    public var username: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        givenName: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
        surname: Swift.String? = nil,
        timeZoneId: Swift.String? = nil,
        username: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.emailAddress = emailAddress
        self.givenName = givenName
        self.organizationId = organizationId
        self.password = password
        self.storageRule = storageRule
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.username = username
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let organizationId: Swift.String?
    let username: Swift.String?
    let emailAddress: Swift.String?
    let givenName: Swift.String?
    let surname: Swift.String?
    let password: Swift.String?
    let timeZoneId: Swift.String?
    let storageRule: WorkDocsClientTypes.StorageRuleType?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case organizationId = "OrganizationId"
        case password = "Password"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case username = "Username"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init (
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let user: WorkDocsClientTypes.User?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension CustomMetadataLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CustomMetadataLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit has been reached on the number of custom properties for the specified resource.
public struct CustomMetadataLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CustomMetadataLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CustomMetadataLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeactivateUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeactivateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())/activation"
    }
}

public struct DeactivateUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct DeactivateUserInputBody: Swift.Equatable {
}

extension DeactivateUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeactivateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivateUserOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateUserOutputResponse: Swift.Equatable {

}

extension DeactivatingLastSystemUserException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeactivatingLastSystemUserExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The last user in the organization is being deactivated.
public struct DeactivatingLastSystemUserException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct DeactivatingLastSystemUserExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension DeactivatingLastSystemUserExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DeleteCommentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteCommentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        guard let commentId = commentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comment/\(commentId.urlPercentEncoding())"
    }
}

public struct DeleteCommentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the comment.
    /// This member is required.
    public var commentId: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        commentId: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.commentId = commentId
        self.documentId = documentId
        self.versionId = versionId
    }
}

struct DeleteCommentInputBody: Swift.Equatable {
}

extension DeleteCommentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCommentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCommentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DocumentLockedForCommentsException" : self = .documentLockedForCommentsException(try DocumentLockedForCommentsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCommentOutputError: Swift.Error, Swift.Equatable {
    case documentLockedForCommentsException(DocumentLockedForCommentsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCommentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCommentOutputResponse: Swift.Equatable {

}

extension DeleteCustomMetadataInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteCustomMetadataInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let versionId = versionId {
            let versionIdQueryItem = ClientRuntime.URLQueryItem(name: "versionId".urlPercentEncoding(), value: Swift.String(versionId).urlPercentEncoding())
            items.append(versionIdQueryItem)
        }
        if deleteAll != false {
            let deleteAllQueryItem = ClientRuntime.URLQueryItem(name: "deleteAll".urlPercentEncoding(), value: Swift.String(deleteAll).urlPercentEncoding())
            items.append(deleteAllQueryItem)
        }
        if let keys = keys {
            keys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "keys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension DeleteCustomMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/customMetadata"
    }
}

public struct DeleteCustomMetadataInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Flag to indicate removal of all custom metadata properties from the specified resource.
    public var deleteAll: Swift.Bool
    /// List of properties to remove.
    public var keys: [Swift.String]?
    /// The ID of the resource, either a document or folder.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The ID of the version, if the custom metadata is being deleted from a document version.
    public var versionId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        deleteAll: Swift.Bool = false,
        keys: [Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deleteAll = deleteAll
        self.keys = keys
        self.resourceId = resourceId
        self.versionId = versionId
    }
}

struct DeleteCustomMetadataInputBody: Swift.Equatable {
}

extension DeleteCustomMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCustomMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomMetadataOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomMetadataOutputResponse: Swift.Equatable {

}

extension DeleteDocumentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

public struct DeleteDocumentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
    }
}

struct DeleteDocumentInputBody: Swift.Equatable {
}

extension DeleteDocumentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictingOperationException(ConflictingOperationException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentOutputResponse: Swift.Equatable {

}

extension DeleteFolderContentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteFolderContentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/contents"
    }
}

public struct DeleteFolderContentsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
    }
}

struct DeleteFolderContentsInputBody: Swift.Equatable {
}

extension DeleteFolderContentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFolderContentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFolderContentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFolderContentsOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFolderContentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFolderContentsOutputResponse: Swift.Equatable {

}

extension DeleteFolderInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct DeleteFolderInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
    }
}

struct DeleteFolderInputBody: Swift.Equatable {
}

extension DeleteFolderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFolderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictingOperationException(ConflictingOperationException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFolderOutputResponse: Swift.Equatable {

}

extension DeleteLabelsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteLabelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if deleteAll != false {
            let deleteAllQueryItem = ClientRuntime.URLQueryItem(name: "deleteAll".urlPercentEncoding(), value: Swift.String(deleteAll).urlPercentEncoding())
            items.append(deleteAllQueryItem)
        }
        if let labels = labels {
            labels.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "labels".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension DeleteLabelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/labels"
    }
}

public struct DeleteLabelsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// Flag to request removal of all labels from the specified resource.
    public var deleteAll: Swift.Bool
    /// List of labels to delete from the resource.
    public var labels: [Swift.String]?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        deleteAll: Swift.Bool = false,
        labels: [Swift.String]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.deleteAll = deleteAll
        self.labels = labels
        self.resourceId = resourceId
    }
}

struct DeleteLabelsInputBody: Swift.Equatable {
}

extension DeleteLabelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLabelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLabelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLabelsOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLabelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLabelsOutputResponse: Swift.Equatable {

}

extension DeleteNotificationSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationId = organizationId else {
            return nil
        }
        guard let subscriptionId = subscriptionId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions/\(subscriptionId.urlPercentEncoding())"
    }
}

public struct DeleteNotificationSubscriptionInput: Swift.Equatable {
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The ID of the subscription.
    /// This member is required.
    public var subscriptionId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        subscriptionId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.subscriptionId = subscriptionId
    }
}

struct DeleteNotificationSubscriptionInputBody: Swift.Equatable {
}

extension DeleteNotificationSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteNotificationSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNotificationSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNotificationSubscriptionOutputResponse: Swift.Equatable {

}

extension DeleteUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Do not set this field when using administrative API actions, as in accessing the API using AWS credentials.
    public var authenticationToken: Swift.String?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
}

extension DeleteUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

}

extension DescribeActivitiesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeActivitiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let endTime = endTime {
            let endTimeQueryItem = ClientRuntime.URLQueryItem(name: "endTime".urlPercentEncoding(), value: Swift.String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(endTimeQueryItem)
        }
        if let resourceId = resourceId {
            let resourceIdQueryItem = ClientRuntime.URLQueryItem(name: "resourceId".urlPercentEncoding(), value: Swift.String(resourceId).urlPercentEncoding())
            items.append(resourceIdQueryItem)
        }
        if let userId = userId {
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        if let startTime = startTime {
            let startTimeQueryItem = ClientRuntime.URLQueryItem(name: "startTime".urlPercentEncoding(), value: Swift.String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(startTimeQueryItem)
        }
        if includeIndirectActivities != false {
            let includeIndirectActivitiesQueryItem = ClientRuntime.URLQueryItem(name: "includeIndirectActivities".urlPercentEncoding(), value: Swift.String(includeIndirectActivities).urlPercentEncoding())
            items.append(includeIndirectActivitiesQueryItem)
        }
        if let organizationId = organizationId {
            let organizationIdQueryItem = ClientRuntime.URLQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
            items.append(organizationIdQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let activityTypes = activityTypes {
            let activityTypesQueryItem = ClientRuntime.URLQueryItem(name: "activityTypes".urlPercentEncoding(), value: Swift.String(activityTypes).urlPercentEncoding())
            items.append(activityTypesQueryItem)
        }
        return items
    }
}

extension DescribeActivitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/activities"
    }
}

public struct DescribeActivitiesInput: Swift.Equatable {
    /// Specifies which activity types to include in the response. If this field is left empty, all activity types are returned.
    public var activityTypes: Swift.String?
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The timestamp that determines the end time of the activities. The response includes the activities performed before the specified timestamp.
    public var endTime: ClientRuntime.Date?
    /// Includes indirect activities. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).
    public var includeIndirectActivities: Swift.Bool
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The ID of the organization. This is a mandatory parameter when using administrative API (SigV4) requests.
    public var organizationId: Swift.String?
    /// The document or folder ID for which to describe activity types.
    public var resourceId: Swift.String?
    /// The timestamp that determines the starting time of the activities. The response includes the activities performed after the specified timestamp.
    public var startTime: ClientRuntime.Date?
    /// The ID of the user who performed the action. The response includes activities pertaining to this user. This is an optional parameter and is only applicable for administrative API (SigV4) requests.
    public var userId: Swift.String?

    public init (
        activityTypes: Swift.String? = nil,
        authenticationToken: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        includeIndirectActivities: Swift.Bool = false,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        userId: Swift.String? = nil
    )
    {
        self.activityTypes = activityTypes
        self.authenticationToken = authenticationToken
        self.endTime = endTime
        self.includeIndirectActivities = includeIndirectActivities
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
        self.resourceId = resourceId
        self.startTime = startTime
        self.userId = userId
    }
}

struct DescribeActivitiesInputBody: Swift.Equatable {
}

extension DescribeActivitiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeActivitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeActivitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeActivitiesOutputError: Swift.Error, Swift.Equatable {
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeActivitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeActivitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.userActivities = output.userActivities
        } else {
            self.marker = nil
            self.userActivities = nil
        }
    }
}

public struct DescribeActivitiesOutputResponse: Swift.Equatable {
    /// The marker for the next set of results.
    public var marker: Swift.String?
    /// The list of activities for the specified user and time period.
    public var userActivities: [WorkDocsClientTypes.Activity]?

    public init (
        marker: Swift.String? = nil,
        userActivities: [WorkDocsClientTypes.Activity]? = nil
    )
    {
        self.marker = marker
        self.userActivities = userActivities
    }
}

struct DescribeActivitiesOutputResponseBody: Swift.Equatable {
    let userActivities: [WorkDocsClientTypes.Activity]?
    let marker: Swift.String?
}

extension DescribeActivitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case userActivities = "UserActivities"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userActivitiesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.Activity?].self, forKey: .userActivities)
        var userActivitiesDecoded0:[WorkDocsClientTypes.Activity]? = nil
        if let userActivitiesContainer = userActivitiesContainer {
            userActivitiesDecoded0 = [WorkDocsClientTypes.Activity]()
            for structure0 in userActivitiesContainer {
                if let structure0 = structure0 {
                    userActivitiesDecoded0?.append(structure0)
                }
            }
        }
        userActivities = userActivitiesDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeCommentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeCommentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension DescribeCommentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())/comments"
    }
}

public struct DescribeCommentsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The ID of the document version.
    /// This member is required.
    public var versionId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.limit = limit
        self.marker = marker
        self.versionId = versionId
    }
}

struct DescribeCommentsInputBody: Swift.Equatable {
}

extension DescribeCommentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeCommentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCommentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCommentsOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCommentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCommentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.comments = output.comments
            self.marker = output.marker
        } else {
            self.comments = nil
            self.marker = nil
        }
    }
}

public struct DescribeCommentsOutputResponse: Swift.Equatable {
    /// The list of comments for the specified document version.
    public var comments: [WorkDocsClientTypes.Comment]?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?

    public init (
        comments: [WorkDocsClientTypes.Comment]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.comments = comments
        self.marker = marker
    }
}

struct DescribeCommentsOutputResponseBody: Swift.Equatable {
    let comments: [WorkDocsClientTypes.Comment]?
    let marker: Swift.String?
}

extension DescribeCommentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "Comments"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.Comment?].self, forKey: .comments)
        var commentsDecoded0:[WorkDocsClientTypes.Comment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [WorkDocsClientTypes.Comment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeDocumentVersionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeDocumentVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let fields = fields {
            let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let include = include {
            let includeQueryItem = ClientRuntime.URLQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include).urlPercentEncoding())
            items.append(includeQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension DescribeDocumentVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions"
    }
}

public struct DescribeDocumentVersionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Specify "SOURCE" to include initialized versions and a URL for the source document.
    public var fields: Swift.String?
    /// A comma-separated list of values. Specify "INITIALIZED" to include incomplete versions.
    public var include: Swift.String?
    /// The maximum number of versions to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        include: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.include = include
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeDocumentVersionsInputBody: Swift.Equatable {
}

extension DescribeDocumentVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDocumentVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDocumentVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDocumentVersionsOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDocumentVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDocumentVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documentVersions = output.documentVersions
            self.marker = output.marker
        } else {
            self.documentVersions = nil
            self.marker = nil
        }
    }
}

public struct DescribeDocumentVersionsOutputResponse: Swift.Equatable {
    /// The document versions.
    public var documentVersions: [WorkDocsClientTypes.DocumentVersionMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init (
        documentVersions: [WorkDocsClientTypes.DocumentVersionMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documentVersions = documentVersions
        self.marker = marker
    }
}

struct DescribeDocumentVersionsOutputResponseBody: Swift.Equatable {
    let documentVersions: [WorkDocsClientTypes.DocumentVersionMetadata]?
    let marker: Swift.String?
}

extension DescribeDocumentVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentVersions = "DocumentVersions"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentVersionsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.DocumentVersionMetadata?].self, forKey: .documentVersions)
        var documentVersionsDecoded0:[WorkDocsClientTypes.DocumentVersionMetadata]? = nil
        if let documentVersionsContainer = documentVersionsContainer {
            documentVersionsDecoded0 = [WorkDocsClientTypes.DocumentVersionMetadata]()
            for structure0 in documentVersionsContainer {
                if let structure0 = structure0 {
                    documentVersionsDecoded0?.append(structure0)
                }
            }
        }
        documentVersions = documentVersionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeFolderContentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeFolderContentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let order = order {
            let orderQueryItem = ClientRuntime.URLQueryItem(name: "order".urlPercentEncoding(), value: Swift.String(order.rawValue).urlPercentEncoding())
            items.append(orderQueryItem)
        }
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let sort = sort {
            let sortQueryItem = ClientRuntime.URLQueryItem(name: "sort".urlPercentEncoding(), value: Swift.String(sort.rawValue).urlPercentEncoding())
            items.append(sortQueryItem)
        }
        if let include = include {
            let includeQueryItem = ClientRuntime.URLQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include).urlPercentEncoding())
            items.append(includeQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension DescribeFolderContentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/contents"
    }
}

public struct DescribeFolderContentsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The contents to include. Specify "INITIALIZED" to include initialized documents.
    public var include: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The order for the contents of the folder.
    public var order: WorkDocsClientTypes.OrderType?
    /// The sorting criteria.
    public var sort: WorkDocsClientTypes.ResourceSortType?
    /// The type of items.
    public var type: WorkDocsClientTypes.FolderContentType?

    public init (
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        include: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        order: WorkDocsClientTypes.OrderType? = nil,
        sort: WorkDocsClientTypes.ResourceSortType? = nil,
        type: WorkDocsClientTypes.FolderContentType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.include = include
        self.limit = limit
        self.marker = marker
        self.order = order
        self.sort = sort
        self.type = type
    }
}

struct DescribeFolderContentsInputBody: Swift.Equatable {
}

extension DescribeFolderContentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFolderContentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFolderContentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFolderContentsOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFolderContentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFolderContentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documents = output.documents
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.documents = nil
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct DescribeFolderContentsOutputResponse: Swift.Equatable {
    /// The documents in the specified folder.
    public var documents: [WorkDocsClientTypes.DocumentMetadata]?
    /// The subfolders in the specified folder.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init (
        documents: [WorkDocsClientTypes.DocumentMetadata]? = nil,
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documents = documents
        self.folders = folders
        self.marker = marker
    }
}

struct DescribeFolderContentsOutputResponseBody: Swift.Equatable {
    let folders: [WorkDocsClientTypes.FolderMetadata]?
    let documents: [WorkDocsClientTypes.DocumentMetadata]?
    let marker: Swift.String?
}

extension DescribeFolderContentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documents = "Documents"
        case folders = "Folders"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[WorkDocsClientTypes.FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [WorkDocsClientTypes.FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let documentsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.DocumentMetadata?].self, forKey: .documents)
        var documentsDecoded0:[WorkDocsClientTypes.DocumentMetadata]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [WorkDocsClientTypes.DocumentMetadata]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeGroupsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let searchQuery = searchQuery {
            let searchQueryQueryItem = ClientRuntime.URLQueryItem(name: "searchQuery".urlPercentEncoding(), value: Swift.String(searchQuery).urlPercentEncoding())
            items.append(searchQueryQueryItem)
        }
        if let organizationId = organizationId {
            let organizationIdQueryItem = ClientRuntime.URLQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
            items.append(organizationIdQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension DescribeGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/groups"
    }
}

public struct DescribeGroupsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// A query to describe groups by group name.
    /// This member is required.
    public var searchQuery: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        searchQuery: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
        self.searchQuery = searchQuery
    }
}

struct DescribeGroupsInputBody: Swift.Equatable {
}

extension DescribeGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGroupsOutputError: Swift.Error, Swift.Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.marker = output.marker
        } else {
            self.groups = nil
            self.marker = nil
        }
    }
}

public struct DescribeGroupsOutputResponse: Swift.Equatable {
    /// The list of groups.
    public var groups: [WorkDocsClientTypes.GroupMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init (
        groups: [WorkDocsClientTypes.GroupMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.groups = groups
        self.marker = marker
    }
}

struct DescribeGroupsOutputResponseBody: Swift.Equatable {
    let groups: [WorkDocsClientTypes.GroupMetadata]?
    let marker: Swift.String?
}

extension DescribeGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.GroupMetadata?].self, forKey: .groups)
        var groupsDecoded0:[WorkDocsClientTypes.GroupMetadata]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [WorkDocsClientTypes.GroupMetadata]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeNotificationSubscriptionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        return items
    }
}

extension DescribeNotificationSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationId = organizationId else {
            return nil
        }
        return "/api/v1/organizations/\(organizationId.urlPercentEncoding())/subscriptions"
    }
}

public struct DescribeNotificationSubscriptionsInput: Swift.Equatable {
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The ID of the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.marker = marker
        self.organizationId = organizationId
    }
}

struct DescribeNotificationSubscriptionsInputBody: Swift.Equatable {
}

extension DescribeNotificationSubscriptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeNotificationSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNotificationSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNotificationSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNotificationSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeNotificationSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.subscriptions = output.subscriptions
        } else {
            self.marker = nil
            self.subscriptions = nil
        }
    }
}

public struct DescribeNotificationSubscriptionsOutputResponse: Swift.Equatable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The subscriptions.
    public var subscriptions: [WorkDocsClientTypes.Subscription]?

    public init (
        marker: Swift.String? = nil,
        subscriptions: [WorkDocsClientTypes.Subscription]? = nil
    )
    {
        self.marker = marker
        self.subscriptions = subscriptions
    }
}

struct DescribeNotificationSubscriptionsOutputResponseBody: Swift.Equatable {
    let subscriptions: [WorkDocsClientTypes.Subscription]?
    let marker: Swift.String?
}

extension DescribeNotificationSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case subscriptions = "Subscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[WorkDocsClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [WorkDocsClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeResourcePermissionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeResourcePermissionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let principalId = principalId {
            let principalIdQueryItem = ClientRuntime.URLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension DescribeResourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

public struct DescribeResourcePermissionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return with this call.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call)
    public var marker: Swift.String?
    /// The ID of the principal to filter permissions by.
    public var principalId: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        principalId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
        self.principalId = principalId
        self.resourceId = resourceId
    }
}

struct DescribeResourcePermissionsInputBody: Swift.Equatable {
}

extension DescribeResourcePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeResourcePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourcePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourcePermissionsOutputError: Swift.Error, Swift.Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourcePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeResourcePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.principals = output.principals
        } else {
            self.marker = nil
            self.principals = nil
        }
    }
}

public struct DescribeResourcePermissionsOutputResponse: Swift.Equatable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The principals.
    public var principals: [WorkDocsClientTypes.Principal]?

    public init (
        marker: Swift.String? = nil,
        principals: [WorkDocsClientTypes.Principal]? = nil
    )
    {
        self.marker = marker
        self.principals = principals
    }
}

struct DescribeResourcePermissionsOutputResponseBody: Swift.Equatable {
    let principals: [WorkDocsClientTypes.Principal]?
    let marker: Swift.String?
}

extension DescribeResourcePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case principals = "Principals"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[WorkDocsClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [WorkDocsClientTypes.Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeRootFoldersInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeRootFoldersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension DescribeRootFoldersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/me/root"
    }
}

public struct DescribeRootFoldersInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token.
    /// This member is required.
    public var authenticationToken: Swift.String?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.limit = limit
        self.marker = marker
    }
}

struct DescribeRootFoldersInputBody: Swift.Equatable {
}

extension DescribeRootFoldersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRootFoldersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRootFoldersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRootFoldersOutputError: Swift.Error, Swift.Equatable {
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRootFoldersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRootFoldersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct DescribeRootFoldersOutputResponse: Swift.Equatable {
    /// The user's special folders.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker for the next set of results.
    public var marker: Swift.String?

    public init (
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.folders = folders
        self.marker = marker
    }
}

struct DescribeRootFoldersOutputResponseBody: Swift.Equatable {
    let folders: [WorkDocsClientTypes.FolderMetadata]?
    let marker: Swift.String?
}

extension DescribeRootFoldersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case folders = "Folders"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[WorkDocsClientTypes.FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [WorkDocsClientTypes.FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DescribeUsersInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension DescribeUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let order = order {
            let orderQueryItem = ClientRuntime.URLQueryItem(name: "order".urlPercentEncoding(), value: Swift.String(order.rawValue).urlPercentEncoding())
            items.append(orderQueryItem)
        }
        if let fields = fields {
            let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let query = query {
            let queryQueryItem = ClientRuntime.URLQueryItem(name: "query".urlPercentEncoding(), value: Swift.String(query).urlPercentEncoding())
            items.append(queryQueryItem)
        }
        if let include = include {
            let includeQueryItem = ClientRuntime.URLQueryItem(name: "include".urlPercentEncoding(), value: Swift.String(include.rawValue).urlPercentEncoding())
            items.append(includeQueryItem)
        }
        if let sort = sort {
            let sortQueryItem = ClientRuntime.URLQueryItem(name: "sort".urlPercentEncoding(), value: Swift.String(sort.rawValue).urlPercentEncoding())
            items.append(sortQueryItem)
        }
        if let organizationId = organizationId {
            let organizationIdQueryItem = ClientRuntime.URLQueryItem(name: "organizationId".urlPercentEncoding(), value: Swift.String(organizationId).urlPercentEncoding())
            items.append(organizationIdQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let userIds = userIds {
            let userIdsQueryItem = ClientRuntime.URLQueryItem(name: "userIds".urlPercentEncoding(), value: Swift.String(userIds).urlPercentEncoding())
            items.append(userIdsQueryItem)
        }
        return items
    }
}

extension DescribeUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/users"
    }
}

public struct DescribeUsersInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// A comma-separated list of values. Specify "STORAGE_METADATA" to include the user storage quota and utilization information.
    public var fields: Swift.String?
    /// The state of the users. Specify "ALL" to include inactive users.
    public var include: WorkDocsClientTypes.UserFilterType?
    /// The maximum number of items to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. (You received this marker from a previous call.)
    public var marker: Swift.String?
    /// The order for the results.
    public var order: WorkDocsClientTypes.OrderType?
    /// The ID of the organization.
    public var organizationId: Swift.String?
    /// A query to filter users by user name.
    public var query: Swift.String?
    /// The sorting criteria.
    public var sort: WorkDocsClientTypes.UserSortType?
    /// The IDs of the users.
    public var userIds: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        fields: Swift.String? = nil,
        include: WorkDocsClientTypes.UserFilterType? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        order: WorkDocsClientTypes.OrderType? = nil,
        organizationId: Swift.String? = nil,
        query: Swift.String? = nil,
        sort: WorkDocsClientTypes.UserSortType? = nil,
        userIds: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.fields = fields
        self.include = include
        self.limit = limit
        self.marker = marker
        self.order = order
        self.organizationId = organizationId
        self.query = query
        self.sort = sort
        self.userIds = userIds
    }
}

struct DescribeUsersInputBody: Swift.Equatable {
}

extension DescribeUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestedEntityTooLargeException" : self = .requestedEntityTooLargeException(try RequestedEntityTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsersOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case requestedEntityTooLargeException(RequestedEntityTooLargeException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.totalNumberOfUsers = output.totalNumberOfUsers
            self.users = output.users
        } else {
            self.marker = nil
            self.totalNumberOfUsers = nil
            self.users = nil
        }
    }
}

public struct DescribeUsersOutputResponse: Swift.Equatable {
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?
    /// The total number of users included in the results.
    @available(*, deprecated)
    public var totalNumberOfUsers: Swift.Int?
    /// The users.
    public var users: [WorkDocsClientTypes.User]?

    public init (
        marker: Swift.String? = nil,
        totalNumberOfUsers: Swift.Int? = nil,
        users: [WorkDocsClientTypes.User]? = nil
    )
    {
        self.marker = marker
        self.totalNumberOfUsers = totalNumberOfUsers
        self.users = users
    }
}

struct DescribeUsersOutputResponseBody: Swift.Equatable {
    let users: [WorkDocsClientTypes.User]?
    let totalNumberOfUsers: Swift.Int?
    let marker: Swift.String?
}

extension DescribeUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case totalNumberOfUsers = "TotalNumberOfUsers"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[WorkDocsClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [WorkDocsClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let totalNumberOfUsersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalNumberOfUsers)
        totalNumberOfUsers = totalNumberOfUsersDecoded
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension DocumentLockedForCommentsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DocumentLockedForCommentsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the document is locked for comments and user tries to create or delete a comment on that document.
public struct DocumentLockedForCommentsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DocumentLockedForCommentsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DocumentLockedForCommentsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes.DocumentMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case labels = "Labels"
        case latestVersionMetadata = "LatestVersionMetadata"
        case modifiedTimestamp = "ModifiedTimestamp"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let creatorId = creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabels0 in labels {
                try labelsContainer.encode(sharedlabels0)
            }
        }
        if let latestVersionMetadata = latestVersionMetadata {
            try encodeContainer.encode(latestVersionMetadata, forKey: .latestVersionMetadata)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let latestVersionMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentVersionMetadata.self, forKey: .latestVersionMetadata)
        latestVersionMetadata = latestVersionMetadataDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes the document.
    public struct DocumentMetadata: Swift.Equatable {
        /// The time when the document was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the document.
        public var id: Swift.String?
        /// List of labels on the document.
        public var labels: [Swift.String]?
        /// The latest version of the document.
        public var latestVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata?
        /// The time when the document was updated.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The ID of the parent folder.
        public var parentFolderId: Swift.String?
        /// The resource state.
        public var resourceState: WorkDocsClientTypes.ResourceStateType?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            latestVersionMetadata: WorkDocsClientTypes.DocumentVersionMetadata? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            parentFolderId: Swift.String? = nil,
            resourceState: WorkDocsClientTypes.ResourceStateType? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.labels = labels
            self.latestVersionMetadata = latestVersionMetadata
            self.modifiedTimestamp = modifiedTimestamp
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
        }
    }

}

extension WorkDocsClientTypes {
    public enum DocumentSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case original
        case withComments
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentSourceType] {
            return [
                .original,
                .withComments,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .original: return "ORIGINAL"
            case .withComments: return "WITH_COMMENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentSourceType(rawValue: rawValue) ?? DocumentSourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum DocumentStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case initialized
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentStatusType] {
            return [
                .active,
                .initialized,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .initialized: return "INITIALIZED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentStatusType(rawValue: rawValue) ?? DocumentStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum DocumentThumbnailType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case large
        case small
        case smallHq
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentThumbnailType] {
            return [
                .large,
                .small,
                .smallHq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .large: return "LARGE"
            case .small: return "SMALL"
            case .smallHq: return "SMALL_HQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentThumbnailType(rawValue: rawValue) ?? DocumentThumbnailType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.DocumentVersionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case modifiedTimestamp = "ModifiedTimestamp"
        case name = "Name"
        case signature = "Signature"
        case size = "Size"
        case source = "Source"
        case status = "Status"
        case thumbnail = "Thumbnail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentCreatedTimestamp = contentCreatedTimestamp {
            try encodeContainer.encode(contentCreatedTimestamp.timeIntervalSince1970, forKey: .contentCreatedTimestamp)
        }
        if let contentModifiedTimestamp = contentModifiedTimestamp {
            try encodeContainer.encode(contentModifiedTimestamp.timeIntervalSince1970, forKey: .contentModifiedTimestamp)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let creatorId = creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let source = source {
            var sourceContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .source)
            for (dictKey0, documentsourceurlmap0) in source {
                try sourceContainer.encode(documentsourceurlmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let thumbnail = thumbnail {
            var thumbnailContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .thumbnail)
            for (dictKey0, documentthumbnailurlmap0) in thumbnail {
                try thumbnailContainer.encode(documentthumbnailurlmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentStatusType.self, forKey: .status)
        status = statusDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let contentCreatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .contentCreatedTimestamp)
        contentCreatedTimestamp = contentCreatedTimestampDecoded
        let contentModifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .contentModifiedTimestamp)
        contentModifiedTimestamp = contentModifiedTimestampDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let thumbnailContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .thumbnail)
        var thumbnailDecoded0: [Swift.String:Swift.String]? = nil
        if let thumbnailContainer = thumbnailContainer {
            thumbnailDecoded0 = [Swift.String:Swift.String]()
            for (key0, urltype0) in thumbnailContainer {
                if let urltype0 = urltype0 {
                    thumbnailDecoded0?[key0] = urltype0
                }
            }
        }
        thumbnail = thumbnailDecoded0
        let sourceContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .source)
        var sourceDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceContainer = sourceContainer {
            sourceDecoded0 = [Swift.String:Swift.String]()
            for (key0, urltype0) in sourceContainer {
                if let urltype0 = urltype0 {
                    sourceDecoded0?[key0] = urltype0
                }
            }
        }
        source = sourceDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes a version of a document.
    public struct DocumentVersionMetadata: Swift.Equatable {
        /// The timestamp when the content of the document was originally created.
        public var contentCreatedTimestamp: ClientRuntime.Date?
        /// The timestamp when the content of the document was modified.
        public var contentModifiedTimestamp: ClientRuntime.Date?
        /// The content type of the document.
        public var contentType: Swift.String?
        /// The timestamp when the document was first uploaded.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the version.
        public var id: Swift.String?
        /// The timestamp when the document was last uploaded.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The name of the version.
        public var name: Swift.String?
        /// The signature of the document.
        public var signature: Swift.String?
        /// The size of the document, in bytes.
        public var size: Swift.Int?
        /// The source of the document.
        public var source: [Swift.String:Swift.String]?
        /// The status of the document.
        public var status: WorkDocsClientTypes.DocumentStatusType?
        /// The thumbnail of the document.
        public var thumbnail: [Swift.String:Swift.String]?

        public init (
            contentCreatedTimestamp: ClientRuntime.Date? = nil,
            contentModifiedTimestamp: ClientRuntime.Date? = nil,
            contentType: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            signature: Swift.String? = nil,
            size: Swift.Int? = nil,
            source: [Swift.String:Swift.String]? = nil,
            status: WorkDocsClientTypes.DocumentStatusType? = nil,
            thumbnail: [Swift.String:Swift.String]? = nil
        )
        {
            self.contentCreatedTimestamp = contentCreatedTimestamp
            self.contentModifiedTimestamp = contentModifiedTimestamp
            self.contentType = contentType
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.modifiedTimestamp = modifiedTimestamp
            self.name = name
            self.signature = signature
            self.size = size
            self.source = source
            self.status = status
            self.thumbnail = thumbnail
        }
    }

}

extension WorkDocsClientTypes {
    public enum DocumentVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentVersionStatus] {
            return [
                .active,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentVersionStatus(rawValue: rawValue) ?? DocumentVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DraftUploadOutOfSyncException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DraftUploadOutOfSyncExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when a valid checkout ID is not presented on document version upload calls for a document that has been checked out from Web client.
public struct DraftUploadOutOfSyncException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DraftUploadOutOfSyncExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DraftUploadOutOfSyncExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EntityAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct EntityAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EntityAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityNotExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EntityNotExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.entityIds = output.entityIds
            self.message = output.message
        } else {
            self.entityIds = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource does not exist.
public struct EntityNotExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var entityIds: [Swift.String]?
    public var message: Swift.String?

    public init (
        entityIds: [Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.entityIds = entityIds
        self.message = message
    }
}

struct EntityNotExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let entityIds: [Swift.String]?
}

extension EntityNotExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityIds = "EntityIds"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let entityIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityIds)
        var entityIdsDecoded0:[Swift.String]? = nil
        if let entityIdsContainer = entityIdsContainer {
            entityIdsDecoded0 = [Swift.String]()
            for string0 in entityIdsContainer {
                if let string0 = string0 {
                    entityIdsDecoded0?.append(string0)
                }
            }
        }
        entityIds = entityIdsDecoded0
    }
}

extension FailedDependencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FailedDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The AWS Directory Service cannot reach an on-premises instance. Or a dependency under the control of the organization is failing, such as a connected Active Directory.
public struct FailedDependencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct FailedDependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension FailedDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes {
    public enum FolderContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case document
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderContentType] {
            return [
                .all,
                .document,
                .folder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .document: return "DOCUMENT"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderContentType(rawValue: rawValue) ?? FolderContentType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.FolderMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case creatorId = "CreatorId"
        case id = "Id"
        case labels = "Labels"
        case latestVersionSize = "LatestVersionSize"
        case modifiedTimestamp = "ModifiedTimestamp"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
        case signature = "Signature"
        case size = "Size"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let creatorId = creatorId {
            try encodeContainer.encode(creatorId, forKey: .creatorId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for sharedlabels0 in labels {
                try labelsContainer.encode(sharedlabels0)
            }
        }
        if let latestVersionSize = latestVersionSize {
            try encodeContainer.encode(latestVersionSize, forKey: .latestVersionSize)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
        if let signature = signature {
            try encodeContainer.encode(signature, forKey: .signature)
        }
        if let size = size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorId)
        creatorId = creatorIdDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
        let signatureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signature)
        signature = signatureDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let latestVersionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .latestVersionSize)
        latestVersionSize = latestVersionSizeDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes a folder.
    public struct FolderMetadata: Swift.Equatable {
        /// The time when the folder was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The ID of the creator.
        public var creatorId: Swift.String?
        /// The ID of the folder.
        public var id: Swift.String?
        /// List of labels on the folder.
        public var labels: [Swift.String]?
        /// The size of the latest version of the folder metadata.
        public var latestVersionSize: Swift.Int?
        /// The time when the folder was updated.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The name of the folder.
        public var name: Swift.String?
        /// The ID of the parent folder.
        public var parentFolderId: Swift.String?
        /// The resource state of the folder.
        public var resourceState: WorkDocsClientTypes.ResourceStateType?
        /// The unique identifier created from the subfolders and documents of the folder.
        public var signature: Swift.String?
        /// The size of the folder metadata.
        public var size: Swift.Int?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            creatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            latestVersionSize: Swift.Int? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            parentFolderId: Swift.String? = nil,
            resourceState: WorkDocsClientTypes.ResourceStateType? = nil,
            signature: Swift.String? = nil,
            size: Swift.Int? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.creatorId = creatorId
            self.id = id
            self.labels = labels
            self.latestVersionSize = latestVersionSize
            self.modifiedTimestamp = modifiedTimestamp
            self.name = name
            self.parentFolderId = parentFolderId
            self.resourceState = resourceState
            self.signature = signature
            self.size = size
        }
    }

}

extension GetCurrentUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetCurrentUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/me"
    }
}

public struct GetCurrentUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token.
    /// This member is required.
    public var authenticationToken: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
    }
}

struct GetCurrentUserInputBody: Swift.Equatable {
}

extension GetCurrentUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetCurrentUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCurrentUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCurrentUserOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCurrentUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetCurrentUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct GetCurrentUserOutputResponse: Swift.Equatable {
    /// Metadata of the user.
    public var user: WorkDocsClientTypes.User?

    public init (
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct GetCurrentUserOutputResponseBody: Swift.Equatable {
    let user: WorkDocsClientTypes.User?
}

extension GetCurrentUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension GetDocumentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if includeCustomMetadata != false {
            let includeCustomMetadataQueryItem = ClientRuntime.URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
            items.append(includeCustomMetadataQueryItem)
        }
        return items
    }
}

extension GetDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

public struct GetDocumentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// Set this to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool = false
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.includeCustomMetadata = includeCustomMetadata
    }
}

struct GetDocumentInputBody: Swift.Equatable {
}

extension GetDocumentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidPasswordException(InvalidPasswordException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetDocumentOutputResponse: Swift.Equatable {
    /// The custom metadata on the document.
    public var customMetadata: [Swift.String:Swift.String]?
    /// The metadata details of the document.
    public var metadata: WorkDocsClientTypes.DocumentMetadata?

    public init (
        customMetadata: [Swift.String:Swift.String]? = nil,
        metadata: WorkDocsClientTypes.DocumentMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetDocumentOutputResponseBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.DocumentMetadata?
    let customMetadata: [Swift.String:Swift.String]?
}

extension GetDocumentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension GetDocumentPathInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentPathInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let fields = fields {
            let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension GetDocumentPathInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/path"
    }
}

public struct GetDocumentPathInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// A comma-separated list of values. Specify NAME to include the names of the parent folders.
    public var fields: Swift.String?
    /// The maximum number of levels in the hierarchy to return.
    public var limit: Swift.Int?
    /// This value is not supported.
    public var marker: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.limit = limit
        self.marker = marker
    }
}

struct GetDocumentPathInputBody: Swift.Equatable {
}

extension GetDocumentPathInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentPathOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentPathOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentPathOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentPathOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentPathOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.path = output.path
        } else {
            self.path = nil
        }
    }
}

public struct GetDocumentPathOutputResponse: Swift.Equatable {
    /// The path information.
    public var path: WorkDocsClientTypes.ResourcePath?

    public init (
        path: WorkDocsClientTypes.ResourcePath? = nil
    )
    {
        self.path = path
    }
}

struct GetDocumentPathOutputResponseBody: Swift.Equatable {
    let path: WorkDocsClientTypes.ResourcePath?
}

extension GetDocumentPathOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourcePath.self, forKey: .path)
        path = pathDecoded
    }
}

extension GetDocumentVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetDocumentVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let fields = fields {
            let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if includeCustomMetadata != false {
            let includeCustomMetadataQueryItem = ClientRuntime.URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
            items.append(includeCustomMetadataQueryItem)
        }
        return items
    }
}

extension GetDocumentVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

public struct GetDocumentVersionInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// A comma-separated list of values. Specify "SOURCE" to include a URL for the source document.
    public var fields: Swift.String?
    /// Set this to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool
    /// The version ID of the document.
    /// This member is required.
    public var versionId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        fields: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool = false,
        versionId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.fields = fields
        self.includeCustomMetadata = includeCustomMetadata
        self.versionId = versionId
    }
}

struct GetDocumentVersionInputBody: Swift.Equatable {
}

extension GetDocumentVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentVersionOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidPasswordException(InvalidPasswordException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetDocumentVersionOutputResponse: Swift.Equatable {
    /// The custom metadata on the document version.
    public var customMetadata: [Swift.String:Swift.String]?
    /// The version metadata.
    public var metadata: WorkDocsClientTypes.DocumentVersionMetadata?

    public init (
        customMetadata: [Swift.String:Swift.String]? = nil,
        metadata: WorkDocsClientTypes.DocumentVersionMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetDocumentVersionOutputResponseBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.DocumentVersionMetadata?
    let customMetadata: [Swift.String:Swift.String]?
}

extension GetDocumentVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentVersionMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension GetFolderInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetFolderInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if includeCustomMetadata != false {
            let includeCustomMetadataQueryItem = ClientRuntime.URLQueryItem(name: "includeCustomMetadata".urlPercentEncoding(), value: Swift.String(includeCustomMetadata).urlPercentEncoding())
            items.append(includeCustomMetadataQueryItem)
        }
        return items
    }
}

extension GetFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct GetFolderInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// Set to TRUE to include custom metadata in the response.
    public var includeCustomMetadata: Swift.Bool

    public init (
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        includeCustomMetadata: Swift.Bool = false
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.includeCustomMetadata = includeCustomMetadata
    }
}

struct GetFolderInputBody: Swift.Equatable {
}

extension GetFolderInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFolderOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFolderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customMetadata = output.customMetadata
            self.metadata = output.metadata
        } else {
            self.customMetadata = nil
            self.metadata = nil
        }
    }
}

public struct GetFolderOutputResponse: Swift.Equatable {
    /// The custom metadata on the folder.
    public var customMetadata: [Swift.String:Swift.String]?
    /// The metadata of the folder.
    public var metadata: WorkDocsClientTypes.FolderMetadata?

    public init (
        customMetadata: [Swift.String:Swift.String]? = nil,
        metadata: WorkDocsClientTypes.FolderMetadata? = nil
    )
    {
        self.customMetadata = customMetadata
        self.metadata = metadata
    }
}

struct GetFolderOutputResponseBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.FolderMetadata?
    let customMetadata: [Swift.String:Swift.String]?
}

extension GetFolderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customMetadata = "CustomMetadata"
        case metadata = "Metadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.FolderMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let customMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customMetadata)
        var customMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let customMetadataContainer = customMetadataContainer {
            customMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, custommetadatavaluetype0) in customMetadataContainer {
                if let custommetadatavaluetype0 = custommetadatavaluetype0 {
                    customMetadataDecoded0?[key0] = custommetadatavaluetype0
                }
            }
        }
        customMetadata = customMetadataDecoded0
    }
}

extension GetFolderPathInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetFolderPathInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let fields = fields {
            let fieldsQueryItem = ClientRuntime.URLQueryItem(name: "fields".urlPercentEncoding(), value: Swift.String(fields).urlPercentEncoding())
            items.append(fieldsQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension GetFolderPathInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())/path"
    }
}

public struct GetFolderPathInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// A comma-separated list of values. Specify "NAME" to include the names of the parent folders.
    public var fields: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The maximum number of levels in the hierarchy to return.
    public var limit: Swift.Int?
    /// This value is not supported.
    public var marker: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        fields: Swift.String? = nil,
        folderId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.fields = fields
        self.folderId = folderId
        self.limit = limit
        self.marker = marker
    }
}

struct GetFolderPathInputBody: Swift.Equatable {
}

extension GetFolderPathInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFolderPathOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFolderPathOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFolderPathOutputError: Swift.Error, Swift.Equatable {
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFolderPathOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFolderPathOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.path = output.path
        } else {
            self.path = nil
        }
    }
}

public struct GetFolderPathOutputResponse: Swift.Equatable {
    /// The path information.
    public var path: WorkDocsClientTypes.ResourcePath?

    public init (
        path: WorkDocsClientTypes.ResourcePath? = nil
    )
    {
        self.path = path
    }
}

struct GetFolderPathOutputResponseBody: Swift.Equatable {
    let path: WorkDocsClientTypes.ResourcePath?
}

extension GetFolderPathOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "Path"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourcePath.self, forKey: .path)
        path = pathDecoded
    }
}

extension GetResourcesInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension GetResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let userId = userId {
            let userIdQueryItem = ClientRuntime.URLQueryItem(name: "userId".urlPercentEncoding(), value: Swift.String(userId).urlPercentEncoding())
            items.append(userIdQueryItem)
        }
        if let collectionType = collectionType {
            let collectionTypeQueryItem = ClientRuntime.URLQueryItem(name: "collectionType".urlPercentEncoding(), value: Swift.String(collectionType.rawValue).urlPercentEncoding())
            items.append(collectionTypeQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let marker = marker {
            let markerQueryItem = ClientRuntime.URLQueryItem(name: "marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
            items.append(markerQueryItem)
        }
        return items
    }
}

extension GetResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/resources"
    }
}

public struct GetResourcesInput: Swift.Equatable {
    /// The Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The collection type.
    public var collectionType: WorkDocsClientTypes.ResourceCollectionType?
    /// The maximum number of resources to return.
    public var limit: Swift.Int?
    /// The marker for the next set of results. This marker was received from a previous call.
    public var marker: Swift.String?
    /// The user ID for the resource collection. This is a required field for accessing the API operation using IAM credentials.
    public var userId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        collectionType: WorkDocsClientTypes.ResourceCollectionType? = nil,
        limit: Swift.Int? = nil,
        marker: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.collectionType = collectionType
        self.limit = limit
        self.marker = marker
        self.userId = userId
    }
}

struct GetResourcesInputBody: Swift.Equatable {
}

extension GetResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcesOutputError: Swift.Error, Swift.Equatable {
    case failedDependencyException(FailedDependencyException)
    case invalidArgumentException(InvalidArgumentException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.documents = output.documents
            self.folders = output.folders
            self.marker = output.marker
        } else {
            self.documents = nil
            self.folders = nil
            self.marker = nil
        }
    }
}

public struct GetResourcesOutputResponse: Swift.Equatable {
    /// The documents in the specified collection.
    public var documents: [WorkDocsClientTypes.DocumentMetadata]?
    /// The folders in the specified folder.
    public var folders: [WorkDocsClientTypes.FolderMetadata]?
    /// The marker to use when requesting the next set of results. If there are no additional results, the string is empty.
    public var marker: Swift.String?

    public init (
        documents: [WorkDocsClientTypes.DocumentMetadata]? = nil,
        folders: [WorkDocsClientTypes.FolderMetadata]? = nil,
        marker: Swift.String? = nil
    )
    {
        self.documents = documents
        self.folders = folders
        self.marker = marker
    }
}

struct GetResourcesOutputResponseBody: Swift.Equatable {
    let folders: [WorkDocsClientTypes.FolderMetadata]?
    let documents: [WorkDocsClientTypes.DocumentMetadata]?
    let marker: Swift.String?
}

extension GetResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documents = "Documents"
        case folders = "Folders"
        case marker = "Marker"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let foldersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.FolderMetadata?].self, forKey: .folders)
        var foldersDecoded0:[WorkDocsClientTypes.FolderMetadata]? = nil
        if let foldersContainer = foldersContainer {
            foldersDecoded0 = [WorkDocsClientTypes.FolderMetadata]()
            for structure0 in foldersContainer {
                if let structure0 = structure0 {
                    foldersDecoded0?.append(structure0)
                }
            }
        }
        folders = foldersDecoded0
        let documentsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.DocumentMetadata?].self, forKey: .documents)
        var documentsDecoded0:[WorkDocsClientTypes.DocumentMetadata]? = nil
        if let documentsContainer = documentsContainer {
            documentsDecoded0 = [WorkDocsClientTypes.DocumentMetadata]()
            for structure0 in documentsContainer {
                if let structure0 = structure0 {
                    documentsDecoded0?.append(structure0)
                }
            }
        }
        documents = documentsDecoded0
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
    }
}

extension WorkDocsClientTypes.GroupMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the metadata of a user group.
    public struct GroupMetadata: Swift.Equatable {
        /// The ID of the user group.
        public var id: Swift.String?
        /// The name of the group.
        public var name: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension IllegalUserStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IllegalUserStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user is undergoing transfer of ownership.
public struct IllegalUserStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalUserStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IllegalUserStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InitiateDocumentVersionUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case documentSizeInBytes = "DocumentSizeInBytes"
        case id = "Id"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentCreatedTimestamp = contentCreatedTimestamp {
            try encodeContainer.encode(contentCreatedTimestamp.timeIntervalSince1970, forKey: .contentCreatedTimestamp)
        }
        if let contentModifiedTimestamp = contentModifiedTimestamp {
            try encodeContainer.encode(contentModifiedTimestamp.timeIntervalSince1970, forKey: .contentModifiedTimestamp)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let documentSizeInBytes = documentSizeInBytes {
            try encodeContainer.encode(documentSizeInBytes, forKey: .documentSizeInBytes)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
    }
}

extension InitiateDocumentVersionUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension InitiateDocumentVersionUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/api/v1/documents"
    }
}

public struct InitiateDocumentVersionUploadInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The timestamp when the content of the document was originally created.
    public var contentCreatedTimestamp: ClientRuntime.Date?
    /// The timestamp when the content of the document was modified.
    public var contentModifiedTimestamp: ClientRuntime.Date?
    /// The content type of the document.
    public var contentType: Swift.String?
    /// The size of the document, in bytes.
    public var documentSizeInBytes: Swift.Int?
    /// The ID of the document.
    public var id: Swift.String?
    /// The name of the document.
    public var name: Swift.String?
    /// The ID of the parent folder.
    /// This member is required.
    public var parentFolderId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        contentCreatedTimestamp: ClientRuntime.Date? = nil,
        contentModifiedTimestamp: ClientRuntime.Date? = nil,
        contentType: Swift.String? = nil,
        documentSizeInBytes: Swift.Int? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.contentCreatedTimestamp = contentCreatedTimestamp
        self.contentModifiedTimestamp = contentModifiedTimestamp
        self.contentType = contentType
        self.documentSizeInBytes = documentSizeInBytes
        self.id = id
        self.name = name
        self.parentFolderId = parentFolderId
    }
}

struct InitiateDocumentVersionUploadInputBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let contentCreatedTimestamp: ClientRuntime.Date?
    let contentModifiedTimestamp: ClientRuntime.Date?
    let contentType: Swift.String?
    let documentSizeInBytes: Swift.Int?
    let parentFolderId: Swift.String?
}

extension InitiateDocumentVersionUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentCreatedTimestamp = "ContentCreatedTimestamp"
        case contentModifiedTimestamp = "ContentModifiedTimestamp"
        case contentType = "ContentType"
        case documentSizeInBytes = "DocumentSizeInBytes"
        case id = "Id"
        case name = "Name"
        case parentFolderId = "ParentFolderId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contentCreatedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .contentCreatedTimestamp)
        contentCreatedTimestamp = contentCreatedTimestampDecoded
        let contentModifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .contentModifiedTimestamp)
        contentModifiedTimestamp = contentModifiedTimestampDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let documentSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .documentSizeInBytes)
        documentSizeInBytes = documentSizeInBytesDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
    }
}

extension InitiateDocumentVersionUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateDocumentVersionUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DraftUploadOutOfSyncException" : self = .draftUploadOutOfSyncException(try DraftUploadOutOfSyncException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyCheckedOutException" : self = .resourceAlreadyCheckedOutException(try ResourceAlreadyCheckedOutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageLimitExceededException" : self = .storageLimitExceededException(try StorageLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StorageLimitWillExceedException" : self = .storageLimitWillExceedException(try StorageLimitWillExceedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateDocumentVersionUploadOutputError: Swift.Error, Swift.Equatable {
    case draftUploadOutOfSyncException(DraftUploadOutOfSyncException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case prohibitedStateException(ProhibitedStateException)
    case resourceAlreadyCheckedOutException(ResourceAlreadyCheckedOutException)
    case serviceUnavailableException(ServiceUnavailableException)
    case storageLimitExceededException(StorageLimitExceededException)
    case storageLimitWillExceedException(StorageLimitWillExceedException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateDocumentVersionUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InitiateDocumentVersionUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.uploadMetadata = output.uploadMetadata
        } else {
            self.metadata = nil
            self.uploadMetadata = nil
        }
    }
}

public struct InitiateDocumentVersionUploadOutputResponse: Swift.Equatable {
    /// The document metadata.
    public var metadata: WorkDocsClientTypes.DocumentMetadata?
    /// The upload metadata.
    public var uploadMetadata: WorkDocsClientTypes.UploadMetadata?

    public init (
        metadata: WorkDocsClientTypes.DocumentMetadata? = nil,
        uploadMetadata: WorkDocsClientTypes.UploadMetadata? = nil
    )
    {
        self.metadata = metadata
        self.uploadMetadata = uploadMetadata
    }
}

struct InitiateDocumentVersionUploadOutputResponseBody: Swift.Equatable {
    let metadata: WorkDocsClientTypes.DocumentMetadata?
    let uploadMetadata: WorkDocsClientTypes.UploadMetadata?
}

extension InitiateDocumentVersionUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case uploadMetadata = "UploadMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let uploadMetadataDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UploadMetadata.self, forKey: .uploadMetadata)
        uploadMetadata = uploadMetadataDecoded
    }
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pagination marker or limit fields are not valid.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCommentOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidCommentOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested operation is not allowed on the specified comment object.
public struct InvalidCommentOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCommentOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCommentOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation is invalid.
public struct InvalidOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPasswordException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The password is invalid.
public struct InvalidPasswordException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPasswordExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPasswordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The maximum of 100,000 folders under the parent folder has been exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes {
    public enum LocaleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case de
        case `default`
        case en
        case es
        case fr
        case ja
        case ko
        case ptBr
        case ru
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LocaleType] {
            return [
                .de,
                .default,
                .en,
                .es,
                .fr,
                .ja,
                .ko,
                .ptBr,
                .ru,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .de: return "de"
            case .default: return "default"
            case .en: return "en"
            case .es: return "es"
            case .fr: return "fr"
            case .ja: return "ja"
            case .ko: return "ko"
            case .ptBr: return "pt_BR"
            case .ru: return "ru"
            case .zhCn: return "zh_CN"
            case .zhTw: return "zh_TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocaleType(rawValue: rawValue) ?? LocaleType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.NotificationOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailMessage = "EmailMessage"
        case sendEmail = "SendEmail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailMessage = emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if sendEmail != false {
            try encodeContainer.encode(sendEmail, forKey: .sendEmail)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendEmailDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sendEmail)
        sendEmail = sendEmailDecoded
        let emailMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
    }
}

extension WorkDocsClientTypes {
    /// Set of options which defines notification preferences of given action.
    public struct NotificationOptions: Swift.Equatable {
        /// Text value to be included in the email body.
        public var emailMessage: Swift.String?
        /// Boolean value to indicate an email notification should be sent to the receipients.
        public var sendEmail: Swift.Bool

        public init (
            emailMessage: Swift.String? = nil,
            sendEmail: Swift.Bool = false
        )
        {
            self.emailMessage = emailMessage
            self.sendEmail = sendEmail
        }
    }

}

extension WorkDocsClientTypes {
    public enum OrderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderType] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderType(rawValue: rawValue) ?? OrderType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.Participants: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case users = "Users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groupmetadatalist0 in groups {
                try groupsContainer.encode(groupmetadatalist0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for usermetadatalist0 in users {
                try usersContainer.encode(usermetadatalist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.UserMetadata?].self, forKey: .users)
        var usersDecoded0:[WorkDocsClientTypes.UserMetadata]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [WorkDocsClientTypes.UserMetadata]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.GroupMetadata?].self, forKey: .groups)
        var groupsDecoded0:[WorkDocsClientTypes.GroupMetadata]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [WorkDocsClientTypes.GroupMetadata]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes the users or user groups.
    public struct Participants: Swift.Equatable {
        /// The list of user groups.
        public var groups: [WorkDocsClientTypes.GroupMetadata]?
        /// The list of users.
        public var users: [WorkDocsClientTypes.UserMetadata]?

        public init (
            groups: [WorkDocsClientTypes.GroupMetadata]? = nil,
            users: [WorkDocsClientTypes.UserMetadata]? = nil
        )
        {
            self.groups = groups
            self.users = users
        }
    }

}

extension WorkDocsClientTypes.PermissionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case role = "Role"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.RoleType.self, forKey: .role)
        role = roleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.RolePermissionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the permissions.
    public struct PermissionInfo: Swift.Equatable {
        /// The role of the user.
        public var role: WorkDocsClientTypes.RoleType?
        /// The type of permissions.
        public var type: WorkDocsClientTypes.RolePermissionType?

        public init (
            role: WorkDocsClientTypes.RoleType? = nil,
            type: WorkDocsClientTypes.RolePermissionType? = nil
        )
        {
            self.role = role
            self.type = type
        }
    }

}

extension WorkDocsClientTypes.Principal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case roles = "Roles"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for permissioninfolist0 in roles {
                try rolesContainer.encode(permissioninfolist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.PrincipalType.self, forKey: .type)
        type = typeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.PermissionInfo?].self, forKey: .roles)
        var rolesDecoded0:[WorkDocsClientTypes.PermissionInfo]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [WorkDocsClientTypes.PermissionInfo]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes a resource.
    public struct Principal: Swift.Equatable {
        /// The ID of the resource.
        public var id: Swift.String?
        /// The permission information for the resource.
        public var roles: [WorkDocsClientTypes.PermissionInfo]?
        /// The type of resource.
        public var type: WorkDocsClientTypes.PrincipalType?

        public init (
            id: Swift.String? = nil,
            roles: [WorkDocsClientTypes.PermissionInfo]? = nil,
            type: WorkDocsClientTypes.PrincipalType? = nil
        )
        {
            self.id = id
            self.roles = roles
            self.type = type
        }
    }

}

extension WorkDocsClientTypes {
    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case anonymous
        case group
        case invite
        case organization
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .anonymous,
                .group,
                .invite,
                .organization,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .anonymous: return "ANONYMOUS"
            case .group: return "GROUP"
            case .invite: return "INVITE"
            case .organization: return "ORGANIZATION"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension ProhibitedStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProhibitedStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified document version is not in the INITIALIZED state.
public struct ProhibitedStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ProhibitedStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ProhibitedStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RemoveAllResourcePermissionsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension RemoveAllResourcePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions"
    }
}

public struct RemoveAllResourcePermissionsInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.resourceId = resourceId
    }
}

struct RemoveAllResourcePermissionsInputBody: Swift.Equatable {
}

extension RemoveAllResourcePermissionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveAllResourcePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveAllResourcePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveAllResourcePermissionsOutputError: Swift.Error, Swift.Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveAllResourcePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveAllResourcePermissionsOutputResponse: Swift.Equatable {

}

extension RemoveResourcePermissionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension RemoveResourcePermissionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let principalType = principalType {
            let principalTypeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(principalType.rawValue).urlPercentEncoding())
            items.append(principalTypeQueryItem)
        }
        return items
    }
}

extension RemoveResourcePermissionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/api/v1/resources/\(resourceId.urlPercentEncoding())/permissions/\(principalId.urlPercentEncoding())"
    }
}

public struct RemoveResourcePermissionInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The principal ID of the resource.
    /// This member is required.
    public var principalId: Swift.String?
    /// The principal type of the resource.
    public var principalType: WorkDocsClientTypes.PrincipalType?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: WorkDocsClientTypes.PrincipalType? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.principalId = principalId
        self.principalType = principalType
        self.resourceId = resourceId
    }
}

struct RemoveResourcePermissionInputBody: Swift.Equatable {
}

extension RemoveResourcePermissionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveResourcePermissionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveResourcePermissionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveResourcePermissionOutputError: Swift.Error, Swift.Equatable {
    case failedDependencyException(FailedDependencyException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveResourcePermissionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveResourcePermissionOutputResponse: Swift.Equatable {

}

extension RequestedEntityTooLargeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestedEntityTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The response is too large to return. The request must include a filter to reduce the size of the response.
public struct RequestedEntityTooLargeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestedEntityTooLargeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestedEntityTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAlreadyCheckedOutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyCheckedOutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is already checked out.
public struct ResourceAlreadyCheckedOutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyCheckedOutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyCheckedOutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes {
    public enum ResourceCollectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sharedWithMe
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceCollectionType] {
            return [
                .sharedWithMe,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sharedWithMe: return "SHARED_WITH_ME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceCollectionType(rawValue: rawValue) ?? ResourceCollectionType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.ResourceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case originalName = "OriginalName"
        case owner = "Owner"
        case parentId = "ParentId"
        case type = "Type"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let originalName = originalName {
            try encodeContainer.encode(originalName, forKey: .originalName)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentId = parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalName)
        originalName = originalNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserMetadata.self, forKey: .owner)
        owner = ownerDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the metadata of a resource.
    public struct ResourceMetadata: Swift.Equatable {
        /// The ID of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The original name of the resource before a rename operation.
        public var originalName: Swift.String?
        /// The owner of the resource.
        public var owner: WorkDocsClientTypes.UserMetadata?
        /// The parent ID of the resource before a rename operation.
        public var parentId: Swift.String?
        /// The type of resource.
        public var type: WorkDocsClientTypes.ResourceType?
        /// The version ID of the resource. This is an optional field and is filled for action on document version.
        public var versionId: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            originalName: Swift.String? = nil,
            owner: WorkDocsClientTypes.UserMetadata? = nil,
            parentId: Swift.String? = nil,
            type: WorkDocsClientTypes.ResourceType? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.originalName = originalName
            self.owner = owner
            self.parentId = parentId
            self.type = type
            self.versionId = versionId
        }
    }

}

extension WorkDocsClientTypes.ResourcePath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case components = "Components"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for resourcepathcomponentlist0 in components {
                try componentsContainer.encode(resourcepathcomponentlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentsContainer = try containerValues.decodeIfPresent([WorkDocsClientTypes.ResourcePathComponent?].self, forKey: .components)
        var componentsDecoded0:[WorkDocsClientTypes.ResourcePathComponent]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [WorkDocsClientTypes.ResourcePathComponent]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes the path information of a resource.
    public struct ResourcePath: Swift.Equatable {
        /// The components of the resource path.
        public var components: [WorkDocsClientTypes.ResourcePathComponent]?

        public init (
            components: [WorkDocsClientTypes.ResourcePathComponent]? = nil
        )
        {
            self.components = components
        }
    }

}

extension WorkDocsClientTypes.ResourcePathComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the resource path.
    public struct ResourcePathComponent: Swift.Equatable {
        /// The ID of the resource path.
        public var id: Swift.String?
        /// The name of the resource path.
        public var name: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension WorkDocsClientTypes {
    public enum ResourceSortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case name
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSortType] {
            return [
                .date,
                .name,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .name: return "NAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceSortType(rawValue: rawValue) ?? ResourceSortType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum ResourceStateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case recycled
        case recycling
        case restoring
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStateType] {
            return [
                .active,
                .recycled,
                .recycling,
                .restoring,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .recycled: return "RECYCLED"
            case .recycling: return "RECYCLING"
            case .restoring: return "RESTORING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStateType(rawValue: rawValue) ?? ResourceStateType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case document
        case folder
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .document,
                .folder,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .document: return "DOCUMENT"
            case .folder: return "FOLDER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum RolePermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case direct
        case inherited
        case sdkUnknown(Swift.String)

        public static var allCases: [RolePermissionType] {
            return [
                .direct,
                .inherited,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .direct: return "DIRECT"
            case .inherited: return "INHERITED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RolePermissionType(rawValue: rawValue) ?? RolePermissionType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum RoleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contributor
        case coowner
        case owner
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [RoleType] {
            return [
                .contributor,
                .coowner,
                .owner,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contributor: return "CONTRIBUTOR"
            case .coowner: return "COOWNER"
            case .owner: return "OWNER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RoleType(rawValue: rawValue) ?? RoleType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the dependencies is unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes.SharePrincipal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case role = "Role"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.PrincipalType.self, forKey: .type)
        type = typeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.RoleType.self, forKey: .role)
        role = roleDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the recipient type and ID, if available.
    public struct SharePrincipal: Swift.Equatable {
        /// The ID of the recipient.
        /// This member is required.
        public var id: Swift.String?
        /// The role of the recipient.
        /// This member is required.
        public var role: WorkDocsClientTypes.RoleType?
        /// The type of the recipient.
        /// This member is required.
        public var type: WorkDocsClientTypes.PrincipalType?

        public init (
            id: Swift.String? = nil,
            role: WorkDocsClientTypes.RoleType? = nil,
            type: WorkDocsClientTypes.PrincipalType? = nil
        )
        {
            self.id = id
            self.role = role
            self.type = type
        }
    }

}

extension WorkDocsClientTypes.ShareResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inviteePrincipalId = "InviteePrincipalId"
        case principalId = "PrincipalId"
        case role = "Role"
        case shareId = "ShareId"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inviteePrincipalId = inviteePrincipalId {
            try encodeContainer.encode(inviteePrincipalId, forKey: .inviteePrincipalId)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let role = role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
        if let shareId = shareId {
            try encodeContainer.encode(shareId, forKey: .shareId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let inviteePrincipalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inviteePrincipalId)
        inviteePrincipalId = inviteePrincipalIdDecoded
        let roleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.RoleType.self, forKey: .role)
        role = roleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ShareStatusType.self, forKey: .status)
        status = statusDecoded
        let shareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareId)
        shareId = shareIdDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the share results of a resource.
    public struct ShareResult: Swift.Equatable {
        /// The ID of the invited user.
        public var inviteePrincipalId: Swift.String?
        /// The ID of the principal.
        public var principalId: Swift.String?
        /// The role.
        public var role: WorkDocsClientTypes.RoleType?
        /// The ID of the resource that was shared.
        public var shareId: Swift.String?
        /// The status.
        public var status: WorkDocsClientTypes.ShareStatusType?
        /// The status message.
        public var statusMessage: Swift.String?

        public init (
            inviteePrincipalId: Swift.String? = nil,
            principalId: Swift.String? = nil,
            role: WorkDocsClientTypes.RoleType? = nil,
            shareId: Swift.String? = nil,
            status: WorkDocsClientTypes.ShareStatusType? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.inviteePrincipalId = inviteePrincipalId
            self.principalId = principalId
            self.role = role
            self.shareId = shareId
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension WorkDocsClientTypes {
    public enum ShareStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failure
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatusType] {
            return [
                .failure,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failure: return "FAILURE"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatusType(rawValue: rawValue) ?? ShareStatusType.sdkUnknown(rawValue)
        }
    }
}

extension StorageLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StorageLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The storage limit has been exceeded.
public struct StorageLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StorageLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StorageLimitWillExceedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StorageLimitWillExceedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The storage limit will be exceeded.
public struct StorageLimitWillExceedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StorageLimitWillExceedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StorageLimitWillExceedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkDocsClientTypes.StorageRuleType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageAllocatedInBytes = "StorageAllocatedInBytes"
        case storageType = "StorageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageAllocatedInBytes = storageAllocatedInBytes {
            try encodeContainer.encode(storageAllocatedInBytes, forKey: .storageAllocatedInBytes)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageAllocatedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageAllocatedInBytes)
        storageAllocatedInBytes = storageAllocatedInBytesDecoded
        let storageTypeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the storage for a user.
    public struct StorageRuleType: Swift.Equatable {
        /// The amount of storage allocated, in bytes.
        public var storageAllocatedInBytes: Swift.Int?
        /// The type of storage.
        public var storageType: WorkDocsClientTypes.StorageType?

        public init (
            storageAllocatedInBytes: Swift.Int? = nil,
            storageType: WorkDocsClientTypes.StorageType? = nil
        )
        {
            self.storageAllocatedInBytes = storageAllocatedInBytes
            self.storageType = storageType
        }
    }

}

extension WorkDocsClientTypes {
    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case quota
        case unlimited
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .quota,
                .unlimited,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .quota: return "QUOTA"
            case .unlimited: return "UNLIMITED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endPoint = "EndPoint"
        case `protocol` = "Protocol"
        case subscriptionId = "SubscriptionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endPoint = endPoint {
            try encodeContainer.encode(endPoint, forKey: .endPoint)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let subscriptionId = subscriptionId {
            try encodeContainer.encode(subscriptionId, forKey: .subscriptionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionId)
        subscriptionId = subscriptionIdDecoded
        let endPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endPoint)
        endPoint = endPointDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.SubscriptionProtocolType.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes a subscription.
    public struct Subscription: Swift.Equatable {
        /// The endpoint of the subscription.
        public var endPoint: Swift.String?
        /// The protocol of the subscription.
        public var `protocol`: WorkDocsClientTypes.SubscriptionProtocolType?
        /// The ID of the subscription.
        public var subscriptionId: Swift.String?

        public init (
            endPoint: Swift.String? = nil,
            `protocol`: WorkDocsClientTypes.SubscriptionProtocolType? = nil,
            subscriptionId: Swift.String? = nil
        )
        {
            self.endPoint = endPoint
            self.`protocol` = `protocol`
            self.subscriptionId = subscriptionId
        }
    }

}

extension WorkDocsClientTypes {
    public enum SubscriptionProtocolType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case https
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionProtocolType] {
            return [
                .https,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionProtocolType(rawValue: rawValue) ?? SubscriptionProtocolType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
        }
    }
}

extension TooManyLabelsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyLabelsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The limit has been reached on the number of labels for the specified resource.
public struct TooManyLabelsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyLabelsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyLabelsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManySubscriptionsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManySubscriptionsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've reached the limit on the number of subscriptions for the WorkDocs instance.
public struct TooManySubscriptionsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManySubscriptionsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManySubscriptionsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation is not permitted.
public struct UnauthorizedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UnauthorizedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension UnauthorizedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UnauthorizedResourceAccessException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedResourceAccessExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The caller does not have access to perform the action on the resource.
public struct UnauthorizedResourceAccessException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedResourceAccessExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedResourceAccessExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateDocumentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }
}

extension UpdateDocumentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateDocumentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())"
    }
}

public struct UpdateDocumentInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The name of the document.
    public var name: Swift.String?
    /// The ID of the parent folder.
    public var parentFolderId: Swift.String?
    /// The resource state of the document. Only ACTIVE and RECYCLED are supported.
    public var resourceState: WorkDocsClientTypes.ResourceStateType?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil,
        resourceState: WorkDocsClientTypes.ResourceStateType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

struct UpdateDocumentInputBody: Swift.Equatable {
    let name: Swift.String?
    let parentFolderId: Swift.String?
    let resourceState: WorkDocsClientTypes.ResourceStateType?
}

extension UpdateDocumentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
    }
}

extension UpdateDocumentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictingOperationException(ConflictingOperationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case limitExceededException(LimitExceededException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDocumentOutputResponse: Swift.Equatable {

}

extension UpdateDocumentVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionStatus = "VersionStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versionStatus = versionStatus {
            try encodeContainer.encode(versionStatus.rawValue, forKey: .versionStatus)
        }
    }
}

extension UpdateDocumentVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateDocumentVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let documentId = documentId else {
            return nil
        }
        guard let versionId = versionId else {
            return nil
        }
        return "/api/v1/documents/\(documentId.urlPercentEncoding())/versions/\(versionId.urlPercentEncoding())"
    }
}

public struct UpdateDocumentVersionInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the document.
    /// This member is required.
    public var documentId: Swift.String?
    /// The version ID of the document.
    /// This member is required.
    public var versionId: Swift.String?
    /// The status of the version.
    public var versionStatus: WorkDocsClientTypes.DocumentVersionStatus?

    public init (
        authenticationToken: Swift.String? = nil,
        documentId: Swift.String? = nil,
        versionId: Swift.String? = nil,
        versionStatus: WorkDocsClientTypes.DocumentVersionStatus? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.documentId = documentId
        self.versionId = versionId
        self.versionStatus = versionStatus
    }
}

struct UpdateDocumentVersionInputBody: Swift.Equatable {
    let versionStatus: WorkDocsClientTypes.DocumentVersionStatus?
}

extension UpdateDocumentVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionStatus = "VersionStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionStatusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.DocumentVersionStatus.self, forKey: .versionStatus)
        versionStatus = versionStatusDecoded
    }
}

extension UpdateDocumentVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentVersionOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case invalidOperationException(InvalidOperationException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDocumentVersionOutputResponse: Swift.Equatable {

}

extension UpdateFolderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentFolderId = parentFolderId {
            try encodeContainer.encode(parentFolderId, forKey: .parentFolderId)
        }
        if let resourceState = resourceState {
            try encodeContainer.encode(resourceState.rawValue, forKey: .resourceState)
        }
    }
}

extension UpdateFolderInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateFolderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let folderId = folderId else {
            return nil
        }
        return "/api/v1/folders/\(folderId.urlPercentEncoding())"
    }
}

public struct UpdateFolderInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The ID of the folder.
    /// This member is required.
    public var folderId: Swift.String?
    /// The name of the folder.
    public var name: Swift.String?
    /// The ID of the parent folder.
    public var parentFolderId: Swift.String?
    /// The resource state of the folder. Only ACTIVE and RECYCLED are accepted values from the API.
    public var resourceState: WorkDocsClientTypes.ResourceStateType?

    public init (
        authenticationToken: Swift.String? = nil,
        folderId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentFolderId: Swift.String? = nil,
        resourceState: WorkDocsClientTypes.ResourceStateType? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.folderId = folderId
        self.name = name
        self.parentFolderId = parentFolderId
        self.resourceState = resourceState
    }
}

struct UpdateFolderInputBody: Swift.Equatable {
    let name: Swift.String?
    let parentFolderId: Swift.String?
    let resourceState: WorkDocsClientTypes.ResourceStateType?
}

extension UpdateFolderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case parentFolderId = "ParentFolderId"
        case resourceState = "ResourceState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let parentFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentFolderId)
        parentFolderId = parentFolderIdDecoded
        let resourceStateDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.ResourceStateType.self, forKey: .resourceState)
        resourceState = resourceStateDecoded
    }
}

extension UpdateFolderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFolderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyExistsException" : self = .entityAlreadyExistsException(try EntityAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProhibitedStateException" : self = .prohibitedStateException(try ProhibitedStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFolderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case conflictingOperationException(ConflictingOperationException)
    case entityAlreadyExistsException(EntityAlreadyExistsException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case limitExceededException(LimitExceededException)
    case prohibitedStateException(ProhibitedStateException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFolderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFolderOutputResponse: Swift.Equatable {

}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case givenName = "GivenName"
        case grantPoweruserPrivileges = "GrantPoweruserPrivileges"
        case locale = "Locale"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let grantPoweruserPrivileges = grantPoweruserPrivileges {
            try encodeContainer.encode(grantPoweruserPrivileges.rawValue, forKey: .grantPoweruserPrivileges)
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let storageRule = storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateUserInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let authenticationToken = authenticationToken {
            items.add(Header(name: "Authentication", value: Swift.String(authenticationToken)))
        }
        return items
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/api/v1/users/\(userId.urlPercentEncoding())"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// Amazon WorkDocs authentication token. Not required when using AWS administrator credentials to access the API.
    public var authenticationToken: Swift.String?
    /// The given name of the user.
    public var givenName: Swift.String?
    /// Boolean value to determine whether the user is granted Poweruser privileges.
    public var grantPoweruserPrivileges: WorkDocsClientTypes.BooleanEnumType?
    /// The locale of the user.
    public var locale: WorkDocsClientTypes.LocaleType?
    /// The amount of storage for the user.
    public var storageRule: WorkDocsClientTypes.StorageRuleType?
    /// The surname of the user.
    public var surname: Swift.String?
    /// The time zone ID of the user.
    public var timeZoneId: Swift.String?
    /// The type of the user.
    public var type: WorkDocsClientTypes.UserType?
    /// The ID of the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        authenticationToken: Swift.String? = nil,
        givenName: Swift.String? = nil,
        grantPoweruserPrivileges: WorkDocsClientTypes.BooleanEnumType? = nil,
        locale: WorkDocsClientTypes.LocaleType? = nil,
        storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
        surname: Swift.String? = nil,
        timeZoneId: Swift.String? = nil,
        type: WorkDocsClientTypes.UserType? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationToken = authenticationToken
        self.givenName = givenName
        self.grantPoweruserPrivileges = grantPoweruserPrivileges
        self.locale = locale
        self.storageRule = storageRule
        self.surname = surname
        self.timeZoneId = timeZoneId
        self.type = type
        self.userId = userId
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let givenName: Swift.String?
    let surname: Swift.String?
    let type: WorkDocsClientTypes.UserType?
    let storageRule: WorkDocsClientTypes.StorageRuleType?
    let timeZoneId: Swift.String?
    let locale: WorkDocsClientTypes.LocaleType?
    let grantPoweruserPrivileges: WorkDocsClientTypes.BooleanEnumType?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case givenName = "GivenName"
        case grantPoweruserPrivileges = "GrantPoweruserPrivileges"
        case locale = "Locale"
        case storageRule = "StorageRule"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let localeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.LocaleType.self, forKey: .locale)
        locale = localeDecoded
        let grantPoweruserPrivilegesDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.BooleanEnumType.self, forKey: .grantPoweruserPrivileges)
        grantPoweruserPrivileges = grantPoweruserPrivilegesDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeactivatingLastSystemUserException" : self = .deactivatingLastSystemUserException(try DeactivatingLastSystemUserException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotExistsException" : self = .entityNotExistsException(try EntityNotExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "FailedDependencyException" : self = .failedDependencyException(try FailedDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalUserStateException" : self = .illegalUserStateException(try IllegalUserStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedOperationException" : self = .unauthorizedOperationException(try UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedResourceAccessException" : self = .unauthorizedResourceAccessException(try UnauthorizedResourceAccessException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case deactivatingLastSystemUserException(DeactivatingLastSystemUserException)
    case entityNotExistsException(EntityNotExistsException)
    case failedDependencyException(FailedDependencyException)
    case illegalUserStateException(IllegalUserStateException)
    case invalidArgumentException(InvalidArgumentException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unauthorizedOperationException(UnauthorizedOperationException)
    case unauthorizedResourceAccessException(UnauthorizedResourceAccessException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.user = output.user
        } else {
            self.user = nil
        }
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {
    /// The user information.
    public var user: WorkDocsClientTypes.User?

    public init (
        user: WorkDocsClientTypes.User? = nil
    )
    {
        self.user = user
    }
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
    let user: WorkDocsClientTypes.User?
}

extension UpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case user = "User"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.User.self, forKey: .user)
        user = userDecoded
    }
}

extension WorkDocsClientTypes.UploadMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signedHeaders = "SignedHeaders"
        case uploadUrl = "UploadUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signedHeaders = signedHeaders {
            var signedHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .signedHeaders)
            for (dictKey0, signedheadermap0) in signedHeaders {
                try signedHeadersContainer.encode(signedheadermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uploadUrl = uploadUrl {
            try encodeContainer.encode(uploadUrl, forKey: .uploadUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadUrl)
        uploadUrl = uploadUrlDecoded
        let signedHeadersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .signedHeaders)
        var signedHeadersDecoded0: [Swift.String:Swift.String]? = nil
        if let signedHeadersContainer = signedHeadersContainer {
            signedHeadersDecoded0 = [Swift.String:Swift.String]()
            for (key0, headervaluetype0) in signedHeadersContainer {
                if let headervaluetype0 = headervaluetype0 {
                    signedHeadersDecoded0?[key0] = headervaluetype0
                }
            }
        }
        signedHeaders = signedHeadersDecoded0
    }
}

extension WorkDocsClientTypes {
    /// Describes the upload.
    public struct UploadMetadata: Swift.Equatable {
        /// The signed headers.
        public var signedHeaders: [Swift.String:Swift.String]?
        /// The URL of the upload.
        public var uploadUrl: Swift.String?

        public init (
            signedHeaders: [Swift.String:Swift.String]? = nil,
            uploadUrl: Swift.String? = nil
        )
        {
            self.signedHeaders = signedHeaders
            self.uploadUrl = uploadUrl
        }
    }

}

extension WorkDocsClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTimestamp = "CreatedTimestamp"
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case id = "Id"
        case locale = "Locale"
        case modifiedTimestamp = "ModifiedTimestamp"
        case organizationId = "OrganizationId"
        case recycleBinFolderId = "RecycleBinFolderId"
        case rootFolderId = "RootFolderId"
        case status = "Status"
        case storage = "Storage"
        case surname = "Surname"
        case timeZoneId = "TimeZoneId"
        case type = "Type"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTimestamp = createdTimestamp {
            try encodeContainer.encode(createdTimestamp.timeIntervalSince1970, forKey: .createdTimestamp)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let modifiedTimestamp = modifiedTimestamp {
            try encodeContainer.encode(modifiedTimestamp.timeIntervalSince1970, forKey: .modifiedTimestamp)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let recycleBinFolderId = recycleBinFolderId {
            try encodeContainer.encode(recycleBinFolderId, forKey: .recycleBinFolderId)
        }
        if let rootFolderId = rootFolderId {
            try encodeContainer.encode(rootFolderId, forKey: .rootFolderId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storage = storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let timeZoneId = timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let rootFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootFolderId)
        rootFolderId = rootFolderIdDecoded
        let recycleBinFolderIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recycleBinFolderId)
        recycleBinFolderId = recycleBinFolderIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserStatusType.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let createdTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let modifiedTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .modifiedTimestamp)
        modifiedTimestamp = modifiedTimestampDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let localeDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.LocaleType.self, forKey: .locale)
        locale = localeDecoded
        let storageDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.UserStorageMetadata.self, forKey: .storage)
        storage = storageDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes a user.
    public struct User: Swift.Equatable {
        /// The time when the user was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The email address of the user.
        public var emailAddress: Swift.String?
        /// The given name of the user.
        public var givenName: Swift.String?
        /// The ID of the user.
        public var id: Swift.String?
        /// The locale of the user.
        public var locale: WorkDocsClientTypes.LocaleType?
        /// The time when the user was modified.
        public var modifiedTimestamp: ClientRuntime.Date?
        /// The ID of the organization.
        public var organizationId: Swift.String?
        /// The ID of the recycle bin folder.
        public var recycleBinFolderId: Swift.String?
        /// The ID of the root folder.
        public var rootFolderId: Swift.String?
        /// The status of the user.
        public var status: WorkDocsClientTypes.UserStatusType?
        /// The storage for the user.
        public var storage: WorkDocsClientTypes.UserStorageMetadata?
        /// The surname of the user.
        public var surname: Swift.String?
        /// The time zone ID of the user.
        public var timeZoneId: Swift.String?
        /// The type of user.
        public var type: WorkDocsClientTypes.UserType?
        /// The login name of the user.
        public var username: Swift.String?

        public init (
            createdTimestamp: ClientRuntime.Date? = nil,
            emailAddress: Swift.String? = nil,
            givenName: Swift.String? = nil,
            id: Swift.String? = nil,
            locale: WorkDocsClientTypes.LocaleType? = nil,
            modifiedTimestamp: ClientRuntime.Date? = nil,
            organizationId: Swift.String? = nil,
            recycleBinFolderId: Swift.String? = nil,
            rootFolderId: Swift.String? = nil,
            status: WorkDocsClientTypes.UserStatusType? = nil,
            storage: WorkDocsClientTypes.UserStorageMetadata? = nil,
            surname: Swift.String? = nil,
            timeZoneId: Swift.String? = nil,
            type: WorkDocsClientTypes.UserType? = nil,
            username: Swift.String? = nil
        )
        {
            self.createdTimestamp = createdTimestamp
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.id = id
            self.locale = locale
            self.modifiedTimestamp = modifiedTimestamp
            self.organizationId = organizationId
            self.recycleBinFolderId = recycleBinFolderId
            self.rootFolderId = rootFolderId
            self.status = status
            self.storage = storage
            self.surname = surname
            self.timeZoneId = timeZoneId
            self.type = type
            self.username = username
        }
    }

}

extension WorkDocsClientTypes {
    public enum UserFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activePending
        case all
        case sdkUnknown(Swift.String)

        public static var allCases: [UserFilterType] {
            return [
                .activePending,
                .all,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activePending: return "ACTIVE_PENDING"
            case .all: return "ALL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserFilterType(rawValue: rawValue) ?? UserFilterType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.UserMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emailAddress = "EmailAddress"
        case givenName = "GivenName"
        case id = "Id"
        case surname = "Surname"
        case username = "Username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let givenName = givenName {
            try encodeContainer.encode(givenName, forKey: .givenName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let surname = surname {
            try encodeContainer.encode(surname, forKey: .surname)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let givenNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .givenName)
        givenName = givenNameDecoded
        let surnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .surname)
        surname = surnameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the metadata of the user.
    public struct UserMetadata: Swift.Equatable {
        /// The email address of the user.
        public var emailAddress: Swift.String?
        /// The given name of the user before a rename operation.
        public var givenName: Swift.String?
        /// The ID of the user.
        public var id: Swift.String?
        /// The surname of the user.
        public var surname: Swift.String?
        /// The name of the user.
        public var username: Swift.String?

        public init (
            emailAddress: Swift.String? = nil,
            givenName: Swift.String? = nil,
            id: Swift.String? = nil,
            surname: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.emailAddress = emailAddress
            self.givenName = givenName
            self.id = id
            self.surname = surname
            self.username = username
        }
    }

}

extension WorkDocsClientTypes {
    public enum UserSortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullName
        case storageLimit
        case storageUsed
        case userName
        case userStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [UserSortType] {
            return [
                .fullName,
                .storageLimit,
                .storageUsed,
                .userName,
                .userStatus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullName: return "FULL_NAME"
            case .storageLimit: return "STORAGE_LIMIT"
            case .storageUsed: return "STORAGE_USED"
            case .userName: return "USER_NAME"
            case .userStatus: return "USER_STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserSortType(rawValue: rawValue) ?? UserSortType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes {
    public enum UserStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStatusType] {
            return [
                .active,
                .inactive,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserStatusType(rawValue: rawValue) ?? UserStatusType.sdkUnknown(rawValue)
        }
    }
}

extension WorkDocsClientTypes.UserStorageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case storageRule = "StorageRule"
        case storageUtilizedInBytes = "StorageUtilizedInBytes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let storageRule = storageRule {
            try encodeContainer.encode(storageRule, forKey: .storageRule)
        }
        if let storageUtilizedInBytes = storageUtilizedInBytes {
            try encodeContainer.encode(storageUtilizedInBytes, forKey: .storageUtilizedInBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageUtilizedInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageUtilizedInBytes)
        storageUtilizedInBytes = storageUtilizedInBytesDecoded
        let storageRuleDecoded = try containerValues.decodeIfPresent(WorkDocsClientTypes.StorageRuleType.self, forKey: .storageRule)
        storageRule = storageRuleDecoded
    }
}

extension WorkDocsClientTypes {
    /// Describes the storage for a user.
    public struct UserStorageMetadata: Swift.Equatable {
        /// The storage for a user.
        public var storageRule: WorkDocsClientTypes.StorageRuleType?
        /// The amount of storage used, in bytes.
        public var storageUtilizedInBytes: Swift.Int?

        public init (
            storageRule: WorkDocsClientTypes.StorageRuleType? = nil,
            storageUtilizedInBytes: Swift.Int? = nil
        )
        {
            self.storageRule = storageRule
            self.storageUtilizedInBytes = storageUtilizedInBytes
        }
    }

}

extension WorkDocsClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case admin
        case minimaluser
        case poweruser
        case user
        case workspacesuser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .admin,
                .minimaluser,
                .poweruser,
                .user,
                .workspacesuser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .admin: return "ADMIN"
            case .minimaluser: return "MINIMALUSER"
            case .poweruser: return "POWERUSER"
            case .user: return "USER"
            case .workspacesuser: return "WORKSPACESUSER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}
