// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>User does not have sufficient access to perform this action.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let exceptionMessage: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension BatchError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case code
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchError(arn: \(String(describing: arn)), code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Error related to a specific channel, specified by its ARN.</p>
public struct BatchError: Equatable {
    /// <p>Channel ARN.</p>
    public let arn: String?
    /// <p>Error code.</p>
    public let code: String?
    /// <p>Error message, determined by the application.</p>
    public let message: String?

    public init (
        arn: String? = nil,
        code: String? = nil,
        message: String? = nil
    )
    {
        self.arn = arn
        self.code = code
        self.message = message
    }
}

public struct BatchGetChannelInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetChannelInput>
    public typealias MOutput = OperationOutput<BatchGetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetChannelOutputError>
}

extension BatchGetChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetChannelInput(arns: \(String(describing: arns)))"}
}

extension BatchGetChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for channelarnlist0 in arns {
                try arnsContainer.encode(channelarnlist0)
            }
        }
    }
}

public struct BatchGetChannelInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetChannelInput>
    public typealias MOutput = OperationOutput<BatchGetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetChannelOutputError>
}

public struct BatchGetChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetChannelInput>
    public typealias MOutput = OperationOutput<BatchGetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetChannelOutputError>
}

public struct BatchGetChannelInput: Equatable {
    /// <p>Array of ARNs, one per channel.</p>
    public let arns: [String]?

    public init (
        arns: [String]? = nil
    )
    {
        self.arns = arns
    }
}

struct BatchGetChannelInputBody: Equatable {
    public let arns: [String]?
}

extension BatchGetChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .arns)
        var arnsDecoded0:[String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BatchGetChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetChannelOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetChannelOutputResponse(channels: \(String(describing: channels)), errors: \(String(describing: errors)))"}
}

extension BatchGetChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channels = output.channels
            self.errors = output.errors
        } else {
            self.channels = nil
            self.errors = nil
        }
    }
}

public struct BatchGetChannelOutputResponse: Equatable {
    public let channels: [Channel]?
    /// <p>Each error object is related to a specific ARN in the request.</p>
    public let errors: [BatchError]?

    public init (
        channels: [Channel]? = nil,
        errors: [BatchError]? = nil
    )
    {
        self.channels = channels
        self.errors = errors
    }
}

struct BatchGetChannelOutputResponseBody: Equatable {
    public let channels: [Channel]?
    public let errors: [BatchError]?
}

extension BatchGetChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channels
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([Channel?].self, forKey: .channels)
        var channelsDecoded0:[Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([BatchError?].self, forKey: .errors)
        var errorsDecoded0:[BatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchGetStreamKeyInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetStreamKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetStreamKeyInput>
    public typealias MOutput = OperationOutput<BatchGetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetStreamKeyOutputError>
}

extension BatchGetStreamKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetStreamKeyInput(arns: \(String(describing: arns)))"}
}

extension BatchGetStreamKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for streamkeyarnlist0 in arns {
                try arnsContainer.encode(streamkeyarnlist0)
            }
        }
    }
}

public struct BatchGetStreamKeyInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetStreamKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetStreamKeyInput>
    public typealias MOutput = OperationOutput<BatchGetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetStreamKeyOutputError>
}

public struct BatchGetStreamKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetStreamKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetStreamKeyInput>
    public typealias MOutput = OperationOutput<BatchGetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetStreamKeyOutputError>
}

public struct BatchGetStreamKeyInput: Equatable {
    /// <p>Array of ARNs, one per channel.</p>
    public let arns: [String]?

    public init (
        arns: [String]? = nil
    )
    {
        self.arns = arns
    }
}

struct BatchGetStreamKeyInputBody: Equatable {
    public let arns: [String]?
}

extension BatchGetStreamKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .arns)
        var arnsDecoded0:[String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BatchGetStreamKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetStreamKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetStreamKeyOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetStreamKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetStreamKeyOutputResponse(errors: \(String(describing: errors)), streamKeys: \(String(describing: streamKeys)))"}
}

extension BatchGetStreamKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.streamKeys = output.streamKeys
        } else {
            self.errors = nil
            self.streamKeys = nil
        }
    }
}

public struct BatchGetStreamKeyOutputResponse: Equatable {
    public let errors: [BatchError]?
    public let streamKeys: [StreamKey]?

    public init (
        errors: [BatchError]? = nil,
        streamKeys: [StreamKey]? = nil
    )
    {
        self.errors = errors
        self.streamKeys = streamKeys
    }
}

struct BatchGetStreamKeyOutputResponseBody: Equatable {
    public let streamKeys: [StreamKey]?
    public let errors: [BatchError]?
}

extension BatchGetStreamKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
        case streamKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeysContainer = try containerValues.decodeIfPresent([StreamKey?].self, forKey: .streamKeys)
        var streamKeysDecoded0:[StreamKey]? = nil
        if let streamKeysContainer = streamKeysContainer {
            streamKeysDecoded0 = [StreamKey]()
            for structure0 in streamKeysContainer {
                if let structure0 = structure0 {
                    streamKeysDecoded0?.append(structure0)
                }
            }
        }
        streamKeys = streamKeysDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([BatchError?].self, forKey: .errors)
        var errorsDecoded0:[BatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension Channel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case authorized
        case ingestEndpoint
        case latencyMode
        case name
        case playbackUrl
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let ingestEndpoint = ingestEndpoint {
            try encodeContainer.encode(ingestEndpoint, forKey: .ingestEndpoint)
        }
        if let latencyMode = latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let playbackUrl = playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let recordingConfigurationArn = recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .type)
        type = typeDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let ingestEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ingestEndpoint)
        ingestEndpoint = ingestEndpointDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let authorizedDecoded = try containerValues.decode(Bool.self, forKey: .authorized)
        authorized = authorizedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Channel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Channel(arn: \(String(describing: arn)), authorized: \(String(describing: authorized)), ingestEndpoint: \(String(describing: ingestEndpoint)), latencyMode: \(String(describing: latencyMode)), name: \(String(describing: name)), playbackUrl: \(String(describing: playbackUrl)), recordingConfigurationArn: \(String(describing: recordingConfigurationArn)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>Object specifying a channel.</p>
public struct Channel: Equatable {
    /// <p>Channel ARN.</p>
    public let arn: String?
    /// <p>Whether the channel is private (enabled for playback authorization). Default:
    ///         <code>false</code>.</p>
    public let authorized: Bool
    /// <p>Channel ingest endpoint, part of the definition of an ingest server, used when you set up
    ///       streaming software.</p>
    public let ingestEndpoint: String?
    /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
    ///       Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. Default: <code>LOW</code>. (Note: In the Amazon IVS console, <code>LOW</code> and
    ///       <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.)</p>
    public let latencyMode: ChannelLatencyMode?
    /// <p>Channel name.</p>
    public let name: String?
    /// <p>Channel playback URL.</p>
    public let playbackUrl: String?
    /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
    ///       is enabled. Default: "" (empty string, recording is disabled).</p>
    public let recordingConfigurationArn: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?
    /// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
    ///         exceed the allowable resolution or bitrate, the stream probably will disconnect
    ///         immediately.</i> Default: <code>STANDARD</code>. Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>STANDARD</code>: Multiple qualities are generated from the original input, to
    ///           automatically give viewers the best experience for their devices and network conditions.
    ///           Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
    ///           video-quality choice is limited to the original input. Vertical resolution can be up to
    ///           480 and bitrate can be up to 1.5 Mbps.</p>
    ///             </li>
    ///          </ul>
    public let type: ChannelType?

    public init (
        arn: String? = nil,
        authorized: Bool = false,
        ingestEndpoint: String? = nil,
        latencyMode: ChannelLatencyMode? = nil,
        name: String? = nil,
        playbackUrl: String? = nil,
        recordingConfigurationArn: String? = nil,
        tags: [String:String]? = nil,
        type: ChannelType? = nil
    )
    {
        self.arn = arn
        self.authorized = authorized
        self.ingestEndpoint = ingestEndpoint
        self.latencyMode = latencyMode
        self.name = name
        self.playbackUrl = playbackUrl
        self.recordingConfigurationArn = recordingConfigurationArn
        self.tags = tags
        self.type = type
    }
}

public enum ChannelLatencyMode {
    case lowlatency
    case normallatency
    case sdkUnknown(String)
}

extension ChannelLatencyMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelLatencyMode] {
        return [
            .lowlatency,
            .normallatency,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lowlatency: return "LOW"
        case .normallatency: return "NORMAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelLatencyMode(rawValue: rawValue) ?? ChannelLatencyMode.sdkUnknown(rawValue)
    }
}

extension ChannelNotBroadcasting: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelNotBroadcasting(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension ChannelNotBroadcasting: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ChannelNotBroadcastingBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ChannelNotBroadcasting: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The stream is offline for the given channel ARN.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ChannelNotBroadcastingBody: Equatable {
    public let exceptionMessage: String?
}

extension ChannelNotBroadcastingBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension ChannelSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let authorizedDecoded = try containerValues.decode(Bool.self, forKey: .authorized)
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ChannelSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelSummary(arn: \(String(describing: arn)), authorized: \(String(describing: authorized)), latencyMode: \(String(describing: latencyMode)), name: \(String(describing: name)), recordingConfigurationArn: \(String(describing: recordingConfigurationArn)), tags: \(String(describing: tags)))"}
}

/// <p>Summary information about a channel.</p>
public struct ChannelSummary: Equatable {
    /// <p>Channel ARN.</p>
    public let arn: String?
    /// <p>Whether the channel is private (enabled for playback authorization). Default: <code>false</code>.</p>
    public let authorized: Bool
    /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to Full HD. Use
    ///       <code>LOW</code> for near-real-time interaction with viewers. Default: <code>LOW</code>. (Note: In the Amazon IVS
    ///       console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.)</p>
    public let latencyMode: ChannelLatencyMode?
    /// <p>Channel name.</p>
    public let name: String?
    /// <p>Recording-configuration ARN. A value other than an empty string indicates that recording
    ///       is enabled. Default: "" (empty string, recording is disabled).</p>
    public let recordingConfigurationArn: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        authorized: Bool = false,
        latencyMode: ChannelLatencyMode? = nil,
        name: String? = nil,
        recordingConfigurationArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.authorized = authorized
        self.latencyMode = latencyMode
        self.name = name
        self.recordingConfigurationArn = recordingConfigurationArn
        self.tags = tags
    }
}

public enum ChannelType {
    case basicchanneltype
    case standardchanneltype
    case sdkUnknown(String)
}

extension ChannelType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelType] {
        return [
            .basicchanneltype,
            .standardchanneltype,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .basicchanneltype: return "BASIC"
        case .standardchanneltype: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Updating or deleting a resource can cause an inconsistent state.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ConflictExceptionBody: Equatable {
    public let exceptionMessage: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

public struct CreateChannelInputBodyMiddleware: Middleware {
    public let id: String = "CreateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

extension CreateChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChannelInput(authorized: \(String(describing: authorized)), latencyMode: \(String(describing: latencyMode)), name: \(String(describing: name)), recordingConfigurationArn: \(String(describing: recordingConfigurationArn)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateChannelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

public struct CreateChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateChannelInput>
    public typealias MOutput = OperationOutput<CreateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateChannelOutputError>
}

public struct CreateChannelInput: Equatable {
    /// <p>Whether the channel is private (enabled for playback authorization). Default:
    ///         <code>false</code>.</p>
    public let authorized: Bool
    /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to
    ///       Full HD. Use <code>LOW</code> for near-real-time interaction with viewers. (Note: In the
    ///       Amazon IVS console, <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard, respectively.)
    ///       Default: <code>LOW</code>.</p>
    public let latencyMode: ChannelLatencyMode?
    /// <p>Channel name.</p>
    public let name: String?
    /// <p>Recording-configuration ARN. Default: "" (empty string, recording is disabled).</p>
    public let recordingConfigurationArn: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?
    /// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
    ///         exceed the allowable resolution or bitrate, the stream probably will disconnect
    ///         immediately.</i> Default: <code>STANDARD</code>. Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>STANDARD</code>: Multiple qualities are generated from the original input, to
    ///           automatically give viewers the best experience for their devices and network conditions.
    ///           Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
    ///           video-quality choice is limited to the original input. Vertical resolution can be up to
    ///           480 and bitrate can be up to 1.5 Mbps.</p>
    ///             </li>
    ///          </ul>
    public let type: ChannelType?

    public init (
        authorized: Bool = false,
        latencyMode: ChannelLatencyMode? = nil,
        name: String? = nil,
        recordingConfigurationArn: String? = nil,
        tags: [String:String]? = nil,
        type: ChannelType? = nil
    )
    {
        self.authorized = authorized
        self.latencyMode = latencyMode
        self.name = name
        self.recordingConfigurationArn = recordingConfigurationArn
        self.tags = tags
        self.type = type
    }
}

struct CreateChannelInputBody: Equatable {
    public let name: String?
    public let latencyMode: ChannelLatencyMode?
    public let type: ChannelType?
    public let authorized: Bool
    public let recordingConfigurationArn: String?
    public let tags: [String:String]?
}

extension CreateChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .type)
        type = typeDecoded
        let authorizedDecoded = try containerValues.decode(Bool.self, forKey: .authorized)
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateChannelOutputResponse(channel: \(String(describing: channel)), streamKey: \(String(describing: streamKey)))"}
}

extension CreateChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channel = output.channel
            self.streamKey = output.streamKey
        } else {
            self.channel = nil
            self.streamKey = nil
        }
    }
}

public struct CreateChannelOutputResponse: Equatable {
    /// <p>Object specifying a channel.</p>
    public let channel: Channel?
    /// <p>Object specifying a stream key.</p>
    public let streamKey: StreamKey?

    public init (
        channel: Channel? = nil,
        streamKey: StreamKey? = nil
    )
    {
        self.channel = channel
        self.streamKey = streamKey
    }
}

struct CreateChannelOutputResponseBody: Equatable {
    public let channel: Channel?
    public let streamKey: StreamKey?
}

extension CreateChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channel
        case streamKey
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Channel.self, forKey: .channel)
        channel = channelDecoded
        let streamKeyDecoded = try containerValues.decodeIfPresent(StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

public struct CreateRecordingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateRecordingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<CreateRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecordingConfigurationOutputError>
}

extension CreateRecordingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecordingConfigurationInput(destinationConfiguration: \(String(describing: destinationConfiguration)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateRecordingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationConfiguration
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateRecordingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRecordingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<CreateRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecordingConfigurationOutputError>
}

public struct CreateRecordingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRecordingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<CreateRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecordingConfigurationOutputError>
}

public struct CreateRecordingConfigurationInput: Equatable {
    /// <p>A complex type that contains a destination configuration for where recorded video will be
    ///       stored.</p>
    public let destinationConfiguration: DestinationConfiguration?
    /// <p>An arbitrary string (a nickname) that helps the customer identify that resource. The value
    ///       does not need to be unique.</p>
    public let name: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?

    public init (
        destinationConfiguration: DestinationConfiguration? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.tags = tags
    }
}

struct CreateRecordingConfigurationInputBody: Equatable {
    public let name: String?
    public let destinationConfiguration: DestinationConfiguration?
    public let tags: [String:String]?
}

extension CreateRecordingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationConfiguration
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRecordingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecordingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRecordingConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case pendingVerification(PendingVerification)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecordingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecordingConfigurationOutputResponse(recordingConfiguration: \(String(describing: recordingConfiguration)))"}
}

extension CreateRecordingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRecordingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recordingConfiguration = output.recordingConfiguration
        } else {
            self.recordingConfiguration = nil
        }
    }
}

public struct CreateRecordingConfigurationOutputResponse: Equatable {
    /// <p>An object representing a configuration to record a channel stream.</p>
    public let recordingConfiguration: RecordingConfiguration?

    public init (
        recordingConfiguration: RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

struct CreateRecordingConfigurationOutputResponseBody: Equatable {
    public let recordingConfiguration: RecordingConfiguration?
}

extension CreateRecordingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recordingConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

public struct CreateStreamKeyInputBodyMiddleware: Middleware {
    public let id: String = "CreateStreamKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamKeyInput>
    public typealias MOutput = OperationOutput<CreateStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamKeyOutputError>
}

extension CreateStreamKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamKeyInput(channelArn: \(String(describing: channelArn)), tags: \(String(describing: tags)))"}
}

extension CreateStreamKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateStreamKeyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateStreamKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamKeyInput>
    public typealias MOutput = OperationOutput<CreateStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamKeyOutputError>
}

public struct CreateStreamKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateStreamKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateStreamKeyInput>
    public typealias MOutput = OperationOutput<CreateStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateStreamKeyOutputError>
}

public struct CreateStreamKeyInput: Equatable {
    /// <p>ARN of the channel for which to create the stream key.</p>
    public let channelArn: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?

    public init (
        channelArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.channelArn = channelArn
        self.tags = tags
    }
}

struct CreateStreamKeyInputBody: Equatable {
    public let channelArn: String?
    public let tags: [String:String]?
}

extension CreateStreamKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamKeyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateStreamKeyOutputResponse(streamKey: \(String(describing: streamKey)))"}
}

extension CreateStreamKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamKey = output.streamKey
        } else {
            self.streamKey = nil
        }
    }
}

public struct CreateStreamKeyOutputResponse: Equatable {
    /// <p>Stream key used to authenticate an RTMPS stream for ingestion.</p>
    public let streamKey: StreamKey?

    public init (
        streamKey: StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

struct CreateStreamKeyOutputResponseBody: Equatable {
    public let streamKey: StreamKey?
}

extension CreateStreamKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamKey
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeyDecoded = try containerValues.decodeIfPresent(StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

public struct DeleteChannelInputBodyMiddleware: Middleware {
    public let id: String = "DeleteChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

extension DeleteChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelInput(arn: \(String(describing: arn)))"}
}

extension DeleteChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteChannelInput>
    public typealias MOutput = OperationOutput<DeleteChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteChannelOutputError>
}

public struct DeleteChannelInput: Equatable {
    /// <p>ARN of the channel to be deleted.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteChannelInputBody: Equatable {
    public let arn: String?
}

extension DeleteChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteChannelOutputResponse()"}
}

extension DeleteChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Equatable {

    public init() {}
}

struct DeleteChannelOutputResponseBody: Equatable {
}

extension DeleteChannelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePlaybackKeyPairInputBodyMiddleware: Middleware {
    public let id: String = "DeletePlaybackKeyPairInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<DeletePlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlaybackKeyPairOutputError>
}

extension DeletePlaybackKeyPairInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlaybackKeyPairInput(arn: \(String(describing: arn)))"}
}

extension DeletePlaybackKeyPairInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeletePlaybackKeyPairInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePlaybackKeyPairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<DeletePlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlaybackKeyPairOutputError>
}

public struct DeletePlaybackKeyPairInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePlaybackKeyPairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<DeletePlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePlaybackKeyPairOutputError>
}

public struct DeletePlaybackKeyPairInput: Equatable {
    /// <p>ARN of the key pair to be deleted.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePlaybackKeyPairInputBody: Equatable {
    public let arn: String?
}

extension DeletePlaybackKeyPairInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePlaybackKeyPairOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlaybackKeyPairOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePlaybackKeyPairOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlaybackKeyPairOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePlaybackKeyPairOutputResponse()"}
}

extension DeletePlaybackKeyPairOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlaybackKeyPairOutputResponse: Equatable {

    public init() {}
}

struct DeletePlaybackKeyPairOutputResponseBody: Equatable {
}

extension DeletePlaybackKeyPairOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRecordingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRecordingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecordingConfigurationOutputError>
}

extension DeleteRecordingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecordingConfigurationInput(arn: \(String(describing: arn)))"}
}

extension DeleteRecordingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteRecordingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRecordingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecordingConfigurationOutputError>
}

public struct DeleteRecordingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRecordingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecordingConfigurationOutputError>
}

public struct DeleteRecordingConfigurationInput: Equatable {
    /// <p>ARN of the recording configuration to be deleted.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRecordingConfigurationInputBody: Equatable {
    public let arn: String?
}

extension DeleteRecordingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRecordingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecordingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecordingConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecordingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecordingConfigurationOutputResponse()"}
}

extension DeleteRecordingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecordingConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteRecordingConfigurationOutputResponseBody: Equatable {
}

extension DeleteRecordingConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteStreamKeyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteStreamKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamKeyInput>
    public typealias MOutput = OperationOutput<DeleteStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamKeyOutputError>
}

extension DeleteStreamKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamKeyInput(arn: \(String(describing: arn)))"}
}

extension DeleteStreamKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteStreamKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteStreamKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamKeyInput>
    public typealias MOutput = OperationOutput<DeleteStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamKeyOutputError>
}

public struct DeleteStreamKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteStreamKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteStreamKeyInput>
    public typealias MOutput = OperationOutput<DeleteStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteStreamKeyOutputError>
}

public struct DeleteStreamKeyInput: Equatable {
    /// <p>ARN of the stream key to be deleted.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteStreamKeyInputBody: Equatable {
    public let arn: String?
}

extension DeleteStreamKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteStreamKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStreamKeyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteStreamKeyOutputResponse()"}
}

extension DeleteStreamKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamKeyOutputResponse: Equatable {

    public init() {}
}

struct DeleteStreamKeyOutputResponseBody: Equatable {
}

extension DeleteStreamKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(S3DestinationConfiguration.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension DestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationConfiguration(s3: \(String(describing: s3)))"}
}

/// <p>A complex type that describes a location where recorded videos will be stored. Each member
///       represents a type of destination configuration. For recording, you define one and only one
///       type of destination configuration.</p>
public struct DestinationConfiguration: Equatable {
    /// <p>An S3 destination configuration where recorded videos will be stored.</p>
    public let s3: S3DestinationConfiguration?

    public init (
        s3: S3DestinationConfiguration? = nil
    )
    {
        self.s3 = s3
    }
}

public struct GetChannelInputBodyMiddleware: Middleware {
    public let id: String = "GetChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelInput>
    public typealias MOutput = OperationOutput<GetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelOutputError>
}

extension GetChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChannelInput(arn: \(String(describing: arn)))"}
}

extension GetChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelInput>
    public typealias MOutput = OperationOutput<GetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelOutputError>
}

public struct GetChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelInput>
    public typealias MOutput = OperationOutput<GetChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelOutputError>
}

public struct GetChannelInput: Equatable {
    /// <p>ARN of the channel for which the configuration is to be retrieved.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetChannelInputBody: Equatable {
    public let arn: String?
}

extension GetChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChannelOutputResponse(channel: \(String(describing: channel)))"}
}

extension GetChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct GetChannelOutputResponse: Equatable {
    /// <p>Object specifying a channel.</p>
    public let channel: Channel?

    public init (
        channel: Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct GetChannelOutputResponseBody: Equatable {
    public let channel: Channel?
}

extension GetChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channel
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

public struct GetPlaybackKeyPairInputBodyMiddleware: Middleware {
    public let id: String = "GetPlaybackKeyPairInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<GetPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlaybackKeyPairOutputError>
}

extension GetPlaybackKeyPairInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPlaybackKeyPairInput(arn: \(String(describing: arn)))"}
}

extension GetPlaybackKeyPairInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetPlaybackKeyPairInputHeadersMiddleware: Middleware {
    public let id: String = "GetPlaybackKeyPairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<GetPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlaybackKeyPairOutputError>
}

public struct GetPlaybackKeyPairInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPlaybackKeyPairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<GetPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPlaybackKeyPairOutputError>
}

public struct GetPlaybackKeyPairInput: Equatable {
    /// <p>ARN of the key pair to be returned.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetPlaybackKeyPairInputBody: Equatable {
    public let arn: String?
}

extension GetPlaybackKeyPairInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetPlaybackKeyPairOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlaybackKeyPairOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPlaybackKeyPairOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlaybackKeyPairOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPlaybackKeyPairOutputResponse(keyPair: \(String(describing: keyPair)))"}
}

extension GetPlaybackKeyPairOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPlaybackKeyPairOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyPair = output.keyPair
        } else {
            self.keyPair = nil
        }
    }
}

public struct GetPlaybackKeyPairOutputResponse: Equatable {
    /// <p>A key pair used to sign and validate a playback authorization token.</p>
    public let keyPair: PlaybackKeyPair?

    public init (
        keyPair: PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

struct GetPlaybackKeyPairOutputResponseBody: Equatable {
    public let keyPair: PlaybackKeyPair?
}

extension GetPlaybackKeyPairOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyPair
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairDecoded = try containerValues.decodeIfPresent(PlaybackKeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

public struct GetRecordingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetRecordingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<GetRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordingConfigurationOutputError>
}

extension GetRecordingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecordingConfigurationInput(arn: \(String(describing: arn)))"}
}

extension GetRecordingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetRecordingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecordingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<GetRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordingConfigurationOutputError>
}

public struct GetRecordingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecordingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecordingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecordingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecordingConfigurationInput>
    public typealias MOutput = OperationOutput<GetRecordingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecordingConfigurationOutputError>
}

public struct GetRecordingConfigurationInput: Equatable {
    /// <p>ARN of the recording configuration to be retrieved.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRecordingConfigurationInputBody: Equatable {
    public let arn: String?
}

extension GetRecordingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRecordingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecordingConfigurationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecordingConfigurationOutputResponse(recordingConfiguration: \(String(describing: recordingConfiguration)))"}
}

extension GetRecordingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRecordingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.recordingConfiguration = output.recordingConfiguration
        } else {
            self.recordingConfiguration = nil
        }
    }
}

public struct GetRecordingConfigurationOutputResponse: Equatable {
    /// <p>An object representing a configuration to record a channel stream.</p>
    public let recordingConfiguration: RecordingConfiguration?

    public init (
        recordingConfiguration: RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

struct GetRecordingConfigurationOutputResponseBody: Equatable {
    public let recordingConfiguration: RecordingConfiguration?
}

extension GetRecordingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recordingConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

public struct GetStreamInputBodyMiddleware: Middleware {
    public let id: String = "GetStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamInput>
    public typealias MOutput = OperationOutput<GetStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamOutputError>
}

extension GetStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamInput(channelArn: \(String(describing: channelArn)))"}
}

extension GetStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
    }
}

public struct GetStreamInputHeadersMiddleware: Middleware {
    public let id: String = "GetStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamInput>
    public typealias MOutput = OperationOutput<GetStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamOutputError>
}

public struct GetStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamInput>
    public typealias MOutput = OperationOutput<GetStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamOutputError>
}

public struct GetStreamInput: Equatable {
    /// <p>Channel ARN for stream to be accessed.</p>
    public let channelArn: String?

    public init (
        channelArn: String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct GetStreamInputBody: Equatable {
    public let channelArn: String?
}

extension GetStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

public struct GetStreamKeyInputBodyMiddleware: Middleware {
    public let id: String = "GetStreamKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamKeyInput>
    public typealias MOutput = OperationOutput<GetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamKeyOutputError>
}

extension GetStreamKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamKeyInput(arn: \(String(describing: arn)))"}
}

extension GetStreamKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct GetStreamKeyInputHeadersMiddleware: Middleware {
    public let id: String = "GetStreamKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamKeyInput>
    public typealias MOutput = OperationOutput<GetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamKeyOutputError>
}

public struct GetStreamKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetStreamKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetStreamKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetStreamKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetStreamKeyInput>
    public typealias MOutput = OperationOutput<GetStreamKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetStreamKeyOutputError>
}

public struct GetStreamKeyInput: Equatable {
    /// <p>ARN for the stream key to be retrieved.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetStreamKeyInputBody: Equatable {
    public let arn: String?
}

extension GetStreamKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetStreamKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamKeyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamKeyOutputResponse(streamKey: \(String(describing: streamKey)))"}
}

extension GetStreamKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.streamKey = output.streamKey
        } else {
            self.streamKey = nil
        }
    }
}

public struct GetStreamKeyOutputResponse: Equatable {
    /// <p>Object specifying a stream key.</p>
    public let streamKey: StreamKey?

    public init (
        streamKey: StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

struct GetStreamKeyOutputResponseBody: Equatable {
    public let streamKey: StreamKey?
}

extension GetStreamKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case streamKey
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeyDecoded = try containerValues.decodeIfPresent(StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

extension GetStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStreamOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetStreamOutputResponse(stream: \(String(describing: stream)))"}
}

extension GetStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetStreamOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct GetStreamOutputResponse: Equatable {
    /// <p>Specifies a live video stream that has been ingested and distributed.</p>
    public let stream: Stream?

    public init (
        stream: Stream? = nil
    )
    {
        self.stream = stream
    }
}

struct GetStreamOutputResponseBody: Equatable {
    public let stream: Stream?
}

extension GetStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case stream
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(Stream.self, forKey: .stream)
        stream = streamDecoded
    }
}

public struct ImportPlaybackKeyPairInputBodyMiddleware: Middleware {
    public let id: String = "ImportPlaybackKeyPairInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportPlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<ImportPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportPlaybackKeyPairOutputError>
}

extension ImportPlaybackKeyPairInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportPlaybackKeyPairInput(name: \(String(describing: name)), publicKeyMaterial: \(String(describing: publicKeyMaterial)), tags: \(String(describing: tags)))"}
}

extension ImportPlaybackKeyPairInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case publicKeyMaterial
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publicKeyMaterial = publicKeyMaterial {
            try encodeContainer.encode(publicKeyMaterial, forKey: .publicKeyMaterial)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ImportPlaybackKeyPairInputHeadersMiddleware: Middleware {
    public let id: String = "ImportPlaybackKeyPairInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportPlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<ImportPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportPlaybackKeyPairOutputError>
}

public struct ImportPlaybackKeyPairInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportPlaybackKeyPairInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportPlaybackKeyPairInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportPlaybackKeyPairOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportPlaybackKeyPairInput>
    public typealias MOutput = OperationOutput<ImportPlaybackKeyPairOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportPlaybackKeyPairOutputError>
}

public struct ImportPlaybackKeyPairInput: Equatable {
    /// <p>An arbitrary string (a nickname) assigned to a playback key pair that helps the customer
    ///       identify that resource. The value does not need to be unique.</p>
    public let name: String?
    /// <p>The public portion of a customer-generated key pair.</p>
    public let publicKeyMaterial: String?
    /// <p>Any tags provided with the request are added to the playback key pair tags.</p>
    public let tags: [String:String]?

    public init (
        name: String? = nil,
        publicKeyMaterial: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.name = name
        self.publicKeyMaterial = publicKeyMaterial
        self.tags = tags
    }
}

struct ImportPlaybackKeyPairInputBody: Equatable {
    public let publicKeyMaterial: String?
    public let name: String?
    public let tags: [String:String]?
}

extension ImportPlaybackKeyPairInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case publicKeyMaterial
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyMaterialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicKeyMaterial)
        publicKeyMaterial = publicKeyMaterialDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportPlaybackKeyPairOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportPlaybackKeyPairOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportPlaybackKeyPairOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportPlaybackKeyPairOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportPlaybackKeyPairOutputResponse(keyPair: \(String(describing: keyPair)))"}
}

extension ImportPlaybackKeyPairOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportPlaybackKeyPairOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyPair = output.keyPair
        } else {
            self.keyPair = nil
        }
    }
}

public struct ImportPlaybackKeyPairOutputResponse: Equatable {
    /// <p>A key pair used to sign and validate a playback authorization token.</p>
    public let keyPair: PlaybackKeyPair?

    public init (
        keyPair: PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

struct ImportPlaybackKeyPairOutputResponseBody: Equatable {
    public let keyPair: PlaybackKeyPair?
}

extension ImportPlaybackKeyPairOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyPair
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairDecoded = try containerValues.decodeIfPresent(PlaybackKeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>Unexpected error during processing of request.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct InternalServerExceptionBody: Equatable {
    public let exceptionMessage: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

public struct ListChannelsInputBodyMiddleware: Middleware {
    public let id: String = "ListChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

extension ListChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChannelsInput(filterByName: \(String(describing: filterByName)), filterByRecordingConfigurationArn: \(String(describing: filterByRecordingConfigurationArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChannelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterByName
        case filterByRecordingConfigurationArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterByName = filterByName {
            try encodeContainer.encode(filterByName, forKey: .filterByName)
        }
        if let filterByRecordingConfigurationArn = filterByRecordingConfigurationArn {
            try encodeContainer.encode(filterByRecordingConfigurationArn, forKey: .filterByRecordingConfigurationArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

public struct ListChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListChannelsInput>
    public typealias MOutput = OperationOutput<ListChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListChannelsOutputError>
}

public struct ListChannelsInput: Equatable {
    /// <p>Filters the channel list to match the specified name.</p>
    public let filterByName: String?
    /// <p>Filters the channel list to match the specified recording-configuration ARN.</p>
    public let filterByRecordingConfigurationArn: String?
    /// <p>Maximum number of channels to return. Default: 50.</p>
    public let maxResults: Int
    /// <p>The first channel to retrieve. This is used for pagination; see the <code>nextToken</code>
    ///       response field.</p>
    public let nextToken: String?

    public init (
        filterByName: String? = nil,
        filterByRecordingConfigurationArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.filterByName = filterByName
        self.filterByRecordingConfigurationArn = filterByRecordingConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Equatable {
    public let filterByName: String?
    public let filterByRecordingConfigurationArn: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListChannelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterByName
        case filterByRecordingConfigurationArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterByName)
        filterByName = filterByNameDecoded
        let filterByRecordingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .filterByRecordingConfigurationArn)
        filterByRecordingConfigurationArn = filterByRecordingConfigurationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListChannelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListChannelsOutputResponse(channels: \(String(describing: channels)), nextToken: \(String(describing: nextToken)))"}
}

extension ListChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Equatable {
    /// <p>List of the matching channels.</p>
    public let channels: [ChannelSummary]?
    /// <p>If there are more channels than <code>maxResults</code>, use <code>nextToken</code> in the
    ///       request to get the next set.</p>
    public let nextToken: String?

    public init (
        channels: [ChannelSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Equatable {
    public let channels: [ChannelSummary]?
    public let nextToken: String?
}

extension ListChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channels
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPlaybackKeyPairsInputBodyMiddleware: Middleware {
    public let id: String = "ListPlaybackKeyPairsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlaybackKeyPairsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlaybackKeyPairsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlaybackKeyPairsInput>
    public typealias MOutput = OperationOutput<ListPlaybackKeyPairsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlaybackKeyPairsOutputError>
}

extension ListPlaybackKeyPairsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlaybackKeyPairsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPlaybackKeyPairsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPlaybackKeyPairsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPlaybackKeyPairsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlaybackKeyPairsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlaybackKeyPairsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlaybackKeyPairsInput>
    public typealias MOutput = OperationOutput<ListPlaybackKeyPairsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlaybackKeyPairsOutputError>
}

public struct ListPlaybackKeyPairsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPlaybackKeyPairsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPlaybackKeyPairsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPlaybackKeyPairsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPlaybackKeyPairsInput>
    public typealias MOutput = OperationOutput<ListPlaybackKeyPairsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPlaybackKeyPairsOutputError>
}

public struct ListPlaybackKeyPairsInput: Equatable {
    /// <p>The first key pair to retrieve. This is used for pagination; see the
    ///         <code>nextToken</code> response field. Default: 50.</p>
    public let maxResults: Int
    /// <p>Maximum number of key pairs to return.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaybackKeyPairsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListPlaybackKeyPairsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPlaybackKeyPairsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlaybackKeyPairsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPlaybackKeyPairsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlaybackKeyPairsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPlaybackKeyPairsOutputResponse(keyPairs: \(String(describing: keyPairs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPlaybackKeyPairsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPlaybackKeyPairsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keyPairs = output.keyPairs
            self.nextToken = output.nextToken
        } else {
            self.keyPairs = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaybackKeyPairsOutputResponse: Equatable {
    /// <p>List of key pairs.</p>
    public let keyPairs: [PlaybackKeyPairSummary]?
    /// <p>If there are more key pairs than <code>maxResults</code>, use <code>nextToken</code> in
    ///       the request to get the next set.</p>
    public let nextToken: String?

    public init (
        keyPairs: [PlaybackKeyPairSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.keyPairs = keyPairs
        self.nextToken = nextToken
    }
}

struct ListPlaybackKeyPairsOutputResponseBody: Equatable {
    public let keyPairs: [PlaybackKeyPairSummary]?
    public let nextToken: String?
}

extension ListPlaybackKeyPairsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keyPairs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairsContainer = try containerValues.decodeIfPresent([PlaybackKeyPairSummary?].self, forKey: .keyPairs)
        var keyPairsDecoded0:[PlaybackKeyPairSummary]? = nil
        if let keyPairsContainer = keyPairsContainer {
            keyPairsDecoded0 = [PlaybackKeyPairSummary]()
            for structure0 in keyPairsContainer {
                if let structure0 = structure0 {
                    keyPairsDecoded0?.append(structure0)
                }
            }
        }
        keyPairs = keyPairsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRecordingConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListRecordingConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecordingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecordingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecordingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListRecordingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecordingConfigurationsOutputError>
}

extension ListRecordingConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecordingConfigurationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRecordingConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRecordingConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRecordingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecordingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecordingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecordingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListRecordingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecordingConfigurationsOutputError>
}

public struct ListRecordingConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRecordingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRecordingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRecordingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRecordingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListRecordingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRecordingConfigurationsOutputError>
}

public struct ListRecordingConfigurationsInput: Equatable {
    /// <p>Maximum number of recording configurations to return. Default: 50. </p>
    public let maxResults: Int
    /// <p>The first recording configuration to retrieve. This is used for pagination; see the
    ///         <code>nextToken</code> response field.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecordingConfigurationsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListRecordingConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRecordingConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecordingConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecordingConfigurationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecordingConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecordingConfigurationsOutputResponse(nextToken: \(String(describing: nextToken)), recordingConfigurations: \(String(describing: recordingConfigurations)))"}
}

extension ListRecordingConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRecordingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.recordingConfigurations = output.recordingConfigurations
        } else {
            self.nextToken = nil
            self.recordingConfigurations = nil
        }
    }
}

public struct ListRecordingConfigurationsOutputResponse: Equatable {
    /// <p>If there are more recording configurations than <code>maxResults</code>, use
    ///         <code>nextToken</code> in the request to get the next set.</p>
    public let nextToken: String?
    /// <p>List of the matching recording configurations.</p>
    public let recordingConfigurations: [RecordingConfigurationSummary]?

    public init (
        nextToken: String? = nil,
        recordingConfigurations: [RecordingConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recordingConfigurations = recordingConfigurations
    }
}

struct ListRecordingConfigurationsOutputResponseBody: Equatable {
    public let recordingConfigurations: [RecordingConfigurationSummary]?
    public let nextToken: String?
}

extension ListRecordingConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case recordingConfigurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationsContainer = try containerValues.decodeIfPresent([RecordingConfigurationSummary?].self, forKey: .recordingConfigurations)
        var recordingConfigurationsDecoded0:[RecordingConfigurationSummary]? = nil
        if let recordingConfigurationsContainer = recordingConfigurationsContainer {
            recordingConfigurationsDecoded0 = [RecordingConfigurationSummary]()
            for structure0 in recordingConfigurationsContainer {
                if let structure0 = structure0 {
                    recordingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        recordingConfigurations = recordingConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamKeysInputBodyMiddleware: Middleware {
    public let id: String = "ListStreamKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamKeysInput>
    public typealias MOutput = OperationOutput<ListStreamKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamKeysOutputError>
}

extension ListStreamKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamKeysInput(channelArn: \(String(describing: channelArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListStreamKeysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListStreamKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamKeysInput>
    public typealias MOutput = OperationOutput<ListStreamKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamKeysOutputError>
}

public struct ListStreamKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamKeysInput>
    public typealias MOutput = OperationOutput<ListStreamKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamKeysOutputError>
}

public struct ListStreamKeysInput: Equatable {
    /// <p>Channel ARN used to filter the list.</p>
    public let channelArn: String?
    /// <p>Maximum number of streamKeys to return. Default: 50.</p>
    public let maxResults: Int
    /// <p>The first stream key to retrieve. This is used for pagination; see the
    ///         <code>nextToken</code> response field.</p>
    public let nextToken: String?

    public init (
        channelArn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.channelArn = channelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamKeysInputBody: Equatable {
    public let channelArn: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListStreamKeysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStreamKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamKeysOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamKeysOutputResponse(nextToken: \(String(describing: nextToken)), streamKeys: \(String(describing: streamKeys)))"}
}

extension ListStreamKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStreamKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.streamKeys = output.streamKeys
        } else {
            self.nextToken = nil
            self.streamKeys = nil
        }
    }
}

public struct ListStreamKeysOutputResponse: Equatable {
    /// <p>If there are more stream keys than <code>maxResults</code>, use <code>nextToken</code> in
    ///       the request to get the next set.</p>
    public let nextToken: String?
    /// <p>List of stream keys.</p>
    public let streamKeys: [StreamKeySummary]?

    public init (
        nextToken: String? = nil,
        streamKeys: [StreamKeySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamKeys = streamKeys
    }
}

struct ListStreamKeysOutputResponseBody: Equatable {
    public let streamKeys: [StreamKeySummary]?
    public let nextToken: String?
}

extension ListStreamKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case streamKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeysContainer = try containerValues.decodeIfPresent([StreamKeySummary?].self, forKey: .streamKeys)
        var streamKeysDecoded0:[StreamKeySummary]? = nil
        if let streamKeysContainer = streamKeysContainer {
            streamKeysDecoded0 = [StreamKeySummary]()
            for structure0 in streamKeysContainer {
                if let structure0 = structure0 {
                    streamKeysDecoded0?.append(structure0)
                }
            }
        }
        streamKeys = streamKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListStreamsInputBodyMiddleware: Middleware {
    public let id: String = "ListStreamsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

extension ListStreamsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListStreamsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListStreamsInputHeadersMiddleware: Middleware {
    public let id: String = "ListStreamsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

public struct ListStreamsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListStreamsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListStreamsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListStreamsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListStreamsInput>
    public typealias MOutput = OperationOutput<ListStreamsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListStreamsOutputError>
}

public struct ListStreamsInput: Equatable {
    /// <p>Maximum number of streams to return. Default: 50.</p>
    public let maxResults: Int
    /// <p>The first stream to retrieve. This is used for pagination; see the <code>nextToken</code>
    ///       response field.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListStreamsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListStreamsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStreamsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListStreamsOutputResponse(nextToken: \(String(describing: nextToken)), streams: \(String(describing: streams)))"}
}

extension ListStreamsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.streams = output.streams
        } else {
            self.nextToken = nil
            self.streams = nil
        }
    }
}

public struct ListStreamsOutputResponse: Equatable {
    /// <p>If there are more streams than <code>maxResults</code>, use <code>nextToken</code> in the
    ///       request to get the next set.</p>
    public let nextToken: String?
    /// <p>List of streams.</p>
    public let streams: [StreamSummary]?

    public init (
        nextToken: String? = nil,
        streams: [StreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

struct ListStreamsOutputResponseBody: Equatable {
    public let streams: [StreamSummary]?
    public let nextToken: String?
}

extension ListStreamsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case streams
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([StreamSummary?].self, forKey: .streams)
        var streamsDecoded0:[StreamSummary]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [StreamSummary]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>Maximum number of tags to return. Default: 50.</p>
    public let maxResults: Int
    /// <p>The first tag to retrieve. This is used for pagination; see the <code>nextToken</code>
    ///       response field.</p>
    public let nextToken: String?
    /// <p>The ARN of the resource to be retrieved.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>If there are more tags than <code>maxResults</code>, use <code>nextToken</code> in the
    ///       request to get the next set.</p>
    public let nextToken: String?
    public let tags: [String:String]?

    public init (
        nextToken: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PendingVerification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PendingVerification(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension PendingVerification: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct PendingVerification: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p> Your account is pending verification. </p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct PendingVerificationBody: Equatable {
    public let exceptionMessage: String?
}

extension PendingVerificationBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension PlaybackKeyPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case fingerprint
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PlaybackKeyPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlaybackKeyPair(arn: \(String(describing: arn)), fingerprint: \(String(describing: fingerprint)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>A key pair used to sign and validate a playback authorization token.</p>
public struct PlaybackKeyPair: Equatable {
    /// <p>Key-pair ARN.</p>
    public let arn: String?
    /// <p>Key-pair identifier.</p>
    public let fingerprint: String?
    /// <p>An arbitrary string (a nickname) assigned to a playback key pair that helps the customer
    ///       identify that resource. The value does not need to be unique.</p>
    public let name: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        fingerprint: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.fingerprint = fingerprint
        self.name = name
        self.tags = tags
    }
}

extension PlaybackKeyPairSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PlaybackKeyPairSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlaybackKeyPairSummary(arn: \(String(describing: arn)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>Summary information about a playback key pair.</p>
public struct PlaybackKeyPairSummary: Equatable {
    /// <p>Key-pair ARN.</p>
    public let arn: String?
    /// <p>An arbitrary string (a nickname) assigned to a playback key pair that helps the customer
    ///       identify that resource. The value does not need to be unique.</p>
    public let name: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.tags = tags
    }
}

public struct PutMetadataInputBodyMiddleware: Middleware {
    public let id: String = "PutMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMetadataInput>
    public typealias MOutput = OperationOutput<PutMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMetadataOutputError>
}

extension PutMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMetadataInput(channelArn: \(String(describing: channelArn)), metadata: \(String(describing: metadata)))"}
}

extension PutMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case metadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }
}

public struct PutMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "PutMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMetadataInput>
    public typealias MOutput = OperationOutput<PutMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMetadataOutputError>
}

public struct PutMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "PutMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMetadataInput>
    public typealias MOutput = OperationOutput<PutMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMetadataOutputError>
}

public struct PutMetadataInput: Equatable {
    /// <p>ARN of the channel into which metadata is inserted. This channel must have an active
    ///       stream.</p>
    public let channelArn: String?
    /// <p>Metadata to insert into the stream. Maximum: 1 KB per request.</p>
    public let metadata: String?

    public init (
        channelArn: String? = nil,
        metadata: String? = nil
    )
    {
        self.channelArn = channelArn
        self.metadata = metadata
    }
}

struct PutMetadataInputBody: Equatable {
    public let channelArn: String?
    public let metadata: String?
}

extension PutMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case metadata
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension PutMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMetadataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMetadataOutputResponse()"}
}

extension PutMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutMetadataOutputResponse: Equatable {

    public init() {}
}

struct PutMetadataOutputResponseBody: Equatable {
}

extension PutMetadataOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RecordingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case destinationConfiguration
        case name
        case state
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationConfiguration = destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RecordingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RecordingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordingConfiguration(arn: \(String(describing: arn)), destinationConfiguration: \(String(describing: destinationConfiguration)), name: \(String(describing: name)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

/// <p>An object representing a configuration to record a channel stream.</p>
public struct RecordingConfiguration: Equatable {
    /// <p>Recording-configuration ARN.</p>
    public let arn: String?
    /// <p>A complex type that contains information about where recorded video will be stored.</p>
    public let destinationConfiguration: DestinationConfiguration?
    /// <p>An arbitrary string (a nickname) assigned to a recording configuration that helps the
    ///       customer identify that resource. The value does not need to be unique.</p>
    public let name: String?
    /// <p>Indicates the current state of the recording configuration. When the state is
    ///         <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
    public let state: RecordingConfigurationState?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        destinationConfiguration: DestinationConfiguration? = nil,
        name: String? = nil,
        state: RecordingConfigurationState? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.state = state
        self.tags = tags
    }
}

public enum RecordingConfigurationState {
    case active
    case createfailed
    case creating
    case sdkUnknown(String)
}

extension RecordingConfigurationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecordingConfigurationState] {
        return [
            .active,
            .createfailed,
            .creating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .createfailed: return "CREATE_FAILED"
        case .creating: return "CREATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecordingConfigurationState(rawValue: rawValue) ?? RecordingConfigurationState.sdkUnknown(rawValue)
    }
}

extension RecordingConfigurationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case destinationConfiguration
        case name
        case state
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationConfiguration = destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RecordingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RecordingConfigurationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecordingConfigurationSummary(arn: \(String(describing: arn)), destinationConfiguration: \(String(describing: destinationConfiguration)), name: \(String(describing: name)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

/// <p>Summary information about a RecordingConfiguration.</p>
public struct RecordingConfigurationSummary: Equatable {
    /// <p>Recording-configuration ARN.</p>
    public let arn: String?
    /// <p>A complex type that contains information about where recorded video will be stored.</p>
    public let destinationConfiguration: DestinationConfiguration?
    /// <p>An arbitrary string (a nickname) assigned to a recording configuration that helps the
    ///       customer identify that resource. The value does not need to be unique.</p>
    public let name: String?
    /// <p>Indicates the current state of the recording configuration. When the state is
    ///       <code>ACTIVE</code>, the configuration is ready for recording a channel stream.</p>
    public let state: RecordingConfigurationState?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        destinationConfiguration: DestinationConfiguration? = nil,
        name: String? = nil,
        state: RecordingConfigurationState? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.state = state
        self.tags = tags
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Request references a resource which does not exist.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let exceptionMessage: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension S3DestinationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension S3DestinationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3DestinationConfiguration(bucketName: \(String(describing: bucketName)))"}
}

/// <p>A complex type that describes an S3 location where recorded videos will be stored.</p>
public struct S3DestinationConfiguration: Equatable {
    /// <p>Location (S3 bucket name) where recorded videos will be stored.</p>
    public let bucketName: String?

    public init (
        bucketName: String? = nil
    )
    {
        self.bucketName = bucketName
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Request would cause a service quota to be exceeded.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let exceptionMessage: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

public struct StopStreamInputBodyMiddleware: Middleware {
    public let id: String = "StopStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStreamInput>
    public typealias MOutput = OperationOutput<StopStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStreamOutputError>
}

extension StopStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopStreamInput(channelArn: \(String(describing: channelArn)))"}
}

extension StopStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
    }
}

public struct StopStreamInputHeadersMiddleware: Middleware {
    public let id: String = "StopStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStreamInput>
    public typealias MOutput = OperationOutput<StopStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStreamOutputError>
}

public struct StopStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "StopStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<StopStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopStreamInput>
    public typealias MOutput = OperationOutput<StopStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopStreamOutputError>
}

public struct StopStreamInput: Equatable {
    /// <p>ARN of the channel for which the stream is to be stopped.</p>
    public let channelArn: String?

    public init (
        channelArn: String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct StopStreamInputBody: Equatable {
    public let channelArn: String?
}

extension StopStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension StopStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamUnavailable" : self = .streamUnavailable(try StreamUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopStreamOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case streamUnavailable(StreamUnavailable)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopStreamOutputResponse()"}
}

extension StopStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopStreamOutputResponse: Equatable {

    public init() {}
}

struct StopStreamOutputResponseBody: Equatable {
}

extension StopStreamOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Stream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case health
        case playbackUrl
        case startTime
        case state
        case viewerCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let health = health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let playbackUrl = playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if viewerCount != 0 {
            try encodeContainer.encode(viewerCount, forKey: .viewerCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(StreamState.self, forKey: .state)
        state = stateDecoded
        let healthDecoded = try containerValues.decodeIfPresent(StreamHealth.self, forKey: .health)
        health = healthDecoded
        let viewerCountDecoded = try containerValues.decode(Int.self, forKey: .viewerCount)
        viewerCount = viewerCountDecoded
    }
}

extension Stream: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Stream(channelArn: \(String(describing: channelArn)), health: \(String(describing: health)), playbackUrl: \(String(describing: playbackUrl)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), viewerCount: \(String(describing: viewerCount)))"}
}

/// <p>Specifies a live video stream that has been ingested and distributed.</p>
public struct Stream: Equatable {
    /// <p>Channel ARN for the stream.</p>
    public let channelArn: String?
    /// <p>The stream’s health.</p>
    public let health: StreamHealth?
    /// <p>URL of the master playlist, required by the video player to play the HLS stream.</p>
    public let playbackUrl: String?
    /// <p>ISO-8601 formatted timestamp of the stream’s start.</p>
    public let startTime: Date?
    /// <p>The stream’s state.</p>
    public let state: StreamState?
    /// <p>Number of current viewers of the stream. A value of -1 indicates that the request timed
    ///       out; in this case, retry.</p>
    public let viewerCount: Int

    public init (
        channelArn: String? = nil,
        health: StreamHealth? = nil,
        playbackUrl: String? = nil,
        startTime: Date? = nil,
        state: StreamState? = nil,
        viewerCount: Int = 0
    )
    {
        self.channelArn = channelArn
        self.health = health
        self.playbackUrl = playbackUrl
        self.startTime = startTime
        self.state = state
        self.viewerCount = viewerCount
    }
}

public enum StreamHealth {
    case starving
    case streamhealthy
    case unknown
    case sdkUnknown(String)
}

extension StreamHealth : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamHealth] {
        return [
            .starving,
            .streamhealthy,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .starving: return "STARVING"
        case .streamhealthy: return "HEALTHY"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamHealth(rawValue: rawValue) ?? StreamHealth.sdkUnknown(rawValue)
    }
}

extension StreamKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case channelArn
        case tags
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StreamKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamKey(arn: \(String(describing: arn)), channelArn: \(String(describing: channelArn)), tags: \(String(describing: tags)), value: \(String(describing: value)))"}
}

/// <p>Object specifying a stream key.</p>
public struct StreamKey: Equatable {
    /// <p>Stream-key ARN.</p>
    public let arn: String?
    /// <p>Channel ARN for the stream.</p>
    public let channelArn: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?
    /// <p>Stream-key value.</p>
    public let value: String?

    public init (
        arn: String? = nil,
        channelArn: String? = nil,
        tags: [String:String]? = nil,
        value: String? = nil
    )
    {
        self.arn = arn
        self.channelArn = channelArn
        self.tags = tags
        self.value = value
    }
}

extension StreamKeySummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case channelArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StreamKeySummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamKeySummary(arn: \(String(describing: arn)), channelArn: \(String(describing: channelArn)), tags: \(String(describing: tags)))"}
}

/// <p>Summary information about a stream key.</p>
public struct StreamKeySummary: Equatable {
    /// <p>Stream-key ARN.</p>
    public let arn: String?
    /// <p>Channel ARN for the stream.</p>
    public let channelArn: String?
    /// <p>Array of 1-50 maps, each of the form <code>string:string (key:value)</code>.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        channelArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.channelArn = channelArn
        self.tags = tags
    }
}

public enum StreamState {
    case streamlive
    case streamoffline
    case sdkUnknown(String)
}

extension StreamState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamState] {
        return [
            .streamlive,
            .streamoffline,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .streamlive: return "LIVE"
        case .streamoffline: return "OFFLINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamState(rawValue: rawValue) ?? StreamState.sdkUnknown(rawValue)
    }
}

extension StreamSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelArn
        case health
        case startTime
        case state
        case viewerCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let health = health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if viewerCount != 0 {
            try encodeContainer.encode(viewerCount, forKey: .viewerCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(StreamState.self, forKey: .state)
        state = stateDecoded
        let healthDecoded = try containerValues.decodeIfPresent(StreamHealth.self, forKey: .health)
        health = healthDecoded
        let viewerCountDecoded = try containerValues.decode(Int.self, forKey: .viewerCount)
        viewerCount = viewerCountDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension StreamSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamSummary(channelArn: \(String(describing: channelArn)), health: \(String(describing: health)), startTime: \(String(describing: startTime)), state: \(String(describing: state)), viewerCount: \(String(describing: viewerCount)))"}
}

/// <p>Summary information about a stream.</p>
public struct StreamSummary: Equatable {
    /// <p>Channel ARN for the stream.</p>
    public let channelArn: String?
    /// <p>The stream’s health.</p>
    public let health: StreamHealth?
    /// <p>ISO-8601 formatted timestamp of the stream’s start.</p>
    public let startTime: Date?
    /// <p>The stream’s state.</p>
    public let state: StreamState?
    /// <p>Number of current viewers of the stream. A value of -1 indicates that the request timed
    ///       out; in this case, retry.</p>
    public let viewerCount: Int

    public init (
        channelArn: String? = nil,
        health: StreamHealth? = nil,
        startTime: Date? = nil,
        state: StreamState? = nil,
        viewerCount: Int = 0
    )
    {
        self.channelArn = channelArn
        self.health = health
        self.startTime = startTime
        self.state = state
        self.viewerCount = viewerCount
    }
}

extension StreamUnavailable: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamUnavailable(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension StreamUnavailable: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StreamUnavailableBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct StreamUnavailable: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The stream is temporarily unavailable.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct StreamUnavailableBody: Equatable {
    public let exceptionMessage: String?
}

extension StreamUnavailableBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>ARN of the resource for which tags are to be added or updated.</p>
    public let resourceArn: String?
    /// <p>Array of tags to be added or updated.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Request was denied due to request throttling.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let exceptionMessage: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>ARN of the resource for which tags are to be removed.</p>
    public let resourceArn: String?
    /// <p>Array of tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

extension UpdateChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChannelInput(arn: \(String(describing: arn)), authorized: \(String(describing: authorized)), latencyMode: \(String(describing: latencyMode)), name: \(String(describing: name)), recordingConfigurationArn: \(String(describing: recordingConfigurationArn)), type: \(String(describing: type)))"}
}

extension UpdateChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct UpdateChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateChannelInput>
    public typealias MOutput = OperationOutput<UpdateChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateChannelOutputError>
}

public struct UpdateChannelInput: Equatable {
    /// <p>ARN of the channel to be updated.</p>
    public let arn: String?
    /// <p>Whether the channel is private (enabled for playback authorization).</p>
    public let authorized: Bool
    /// <p>Channel latency mode. Use <code>NORMAL</code> to broadcast and deliver live video up to Full HD. Use
    ///       <code>LOW</code> for near-real-time interaction with viewers. (Note: In the Amazon IVS console,
    ///         <code>LOW</code> and <code>NORMAL</code> correspond to Ultra-low and Standard,
    ///       respectively.)</p>
    public let latencyMode: ChannelLatencyMode?
    /// <p>Channel name.</p>
    public let name: String?
    /// <p>Recording-configuration ARN. If this is set to an empty string, recording is disabled. A
    ///       value other than an empty string indicates that recording is enabled</p>
    public let recordingConfigurationArn: String?
    /// <p>Channel type, which determines the allowable resolution and bitrate. <i>If you
    ///         exceed the allowable resolution or bitrate, the stream probably will disconnect
    ///         immediately</i>. Valid values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>STANDARD</code>: Multiple qualities are generated from the original input, to
    ///           automatically give viewers the best experience for their devices and network conditions.
    ///           Vertical resolution can be up to 1080 and bitrate can be up to 8.5 Mbps.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BASIC</code>: Amazon IVS delivers the original input to viewers. The viewer’s
    ///           video-quality choice is limited to the original input. Vertical resolution can be up to
    ///           480 and bitrate can be up to 1.5 Mbps.</p>
    ///             </li>
    ///          </ul>
    public let type: ChannelType?

    public init (
        arn: String? = nil,
        authorized: Bool = false,
        latencyMode: ChannelLatencyMode? = nil,
        name: String? = nil,
        recordingConfigurationArn: String? = nil,
        type: ChannelType? = nil
    )
    {
        self.arn = arn
        self.authorized = authorized
        self.latencyMode = latencyMode
        self.name = name
        self.recordingConfigurationArn = recordingConfigurationArn
        self.type = type
    }
}

struct UpdateChannelInputBody: Equatable {
    public let arn: String?
    public let name: String?
    public let latencyMode: ChannelLatencyMode?
    public let type: ChannelType?
    public let authorized: Bool
    public let recordingConfigurationArn: String?
}

extension UpdateChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .type)
        type = typeDecoded
        let authorizedDecoded = try containerValues.decode(Bool.self, forKey: .authorized)
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
    }
}

extension UpdateChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateChannelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateChannelOutputResponse(channel: \(String(describing: channel)))"}
}

extension UpdateChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Equatable {
    /// <p>Object specifying a channel.</p>
    public let channel: Channel?

    public init (
        channel: Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct UpdateChannelOutputResponseBody: Equatable {
    public let channel: Channel?
}

extension UpdateChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channel
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(exceptionMessage: \(String(describing: exceptionMessage)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The input fails to satisfy the constraints specified by an AWS service.</p>
    public var exceptionMessage: String?

    public init (
        exceptionMessage: String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ValidationExceptionBody: Equatable {
    public let exceptionMessage: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}
