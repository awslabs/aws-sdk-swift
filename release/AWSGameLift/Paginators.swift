// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[DescribeFleetAttributesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFleetAttributesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetAttributesOutputResponse`
extension GameLiftClient {
    public func describeFleetAttributesPaginated(input: DescribeFleetAttributesInput) -> ClientRuntime.PaginatorSequence<DescribeFleetAttributesInput, DescribeFleetAttributesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetAttributesInput, DescribeFleetAttributesOutputResponse>(input: input, inputKey: \DescribeFleetAttributesInput.nextToken, outputKey: \DescribeFleetAttributesOutputResponse.nextToken, paginationFunction: self.describeFleetAttributes(input:))
    }
}

extension DescribeFleetAttributesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetAttributesInput {
        return DescribeFleetAttributesInput(
            fleetIds: self.fleetIds,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFleetAttributesPaginated`
/// to access the nested member `[GameLiftClientTypes.FleetAttributes]`
/// - Returns: `[GameLiftClientTypes.FleetAttributes]`
extension PaginatorSequence where Input == DescribeFleetAttributesInput, Output == DescribeFleetAttributesOutputResponse {
    public func fleetAttributes() async throws -> [GameLiftClientTypes.FleetAttributes] {
        return try await self.asyncCompactMap { item in item.fleetAttributes }
    }
}

/// Paginate over `[DescribeFleetCapacityOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFleetCapacityInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetCapacityOutputResponse`
extension GameLiftClient {
    public func describeFleetCapacityPaginated(input: DescribeFleetCapacityInput) -> ClientRuntime.PaginatorSequence<DescribeFleetCapacityInput, DescribeFleetCapacityOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetCapacityInput, DescribeFleetCapacityOutputResponse>(input: input, inputKey: \DescribeFleetCapacityInput.nextToken, outputKey: \DescribeFleetCapacityOutputResponse.nextToken, paginationFunction: self.describeFleetCapacity(input:))
    }
}

extension DescribeFleetCapacityInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetCapacityInput {
        return DescribeFleetCapacityInput(
            fleetIds: self.fleetIds,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFleetCapacityPaginated`
/// to access the nested member `[GameLiftClientTypes.FleetCapacity]`
/// - Returns: `[GameLiftClientTypes.FleetCapacity]`
extension PaginatorSequence where Input == DescribeFleetCapacityInput, Output == DescribeFleetCapacityOutputResponse {
    public func fleetCapacity() async throws -> [GameLiftClientTypes.FleetCapacity] {
        return try await self.asyncCompactMap { item in item.fleetCapacity }
    }
}

/// Paginate over `[DescribeFleetEventsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFleetEventsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetEventsOutputResponse`
extension GameLiftClient {
    public func describeFleetEventsPaginated(input: DescribeFleetEventsInput) -> ClientRuntime.PaginatorSequence<DescribeFleetEventsInput, DescribeFleetEventsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetEventsInput, DescribeFleetEventsOutputResponse>(input: input, inputKey: \DescribeFleetEventsInput.nextToken, outputKey: \DescribeFleetEventsOutputResponse.nextToken, paginationFunction: self.describeFleetEvents(input:))
    }
}

extension DescribeFleetEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetEventsInput {
        return DescribeFleetEventsInput(
            endTime: self.endTime,
            fleetId: self.fleetId,
            limit: self.limit,
            nextToken: token,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFleetEventsPaginated`
/// to access the nested member `[GameLiftClientTypes.Event]`
/// - Returns: `[GameLiftClientTypes.Event]`
extension PaginatorSequence where Input == DescribeFleetEventsInput, Output == DescribeFleetEventsOutputResponse {
    public func events() async throws -> [GameLiftClientTypes.Event] {
        return try await self.asyncCompactMap { item in item.events }
    }
}

/// Paginate over `[DescribeFleetLocationAttributesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFleetLocationAttributesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetLocationAttributesOutputResponse`
extension GameLiftClient {
    public func describeFleetLocationAttributesPaginated(input: DescribeFleetLocationAttributesInput) -> ClientRuntime.PaginatorSequence<DescribeFleetLocationAttributesInput, DescribeFleetLocationAttributesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetLocationAttributesInput, DescribeFleetLocationAttributesOutputResponse>(input: input, inputKey: \DescribeFleetLocationAttributesInput.nextToken, outputKey: \DescribeFleetLocationAttributesOutputResponse.nextToken, paginationFunction: self.describeFleetLocationAttributes(input:))
    }
}

extension DescribeFleetLocationAttributesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetLocationAttributesInput {
        return DescribeFleetLocationAttributesInput(
            fleetId: self.fleetId,
            limit: self.limit,
            locations: self.locations,
            nextToken: token
        )}
}

/// Paginate over `[DescribeFleetUtilizationOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeFleetUtilizationInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeFleetUtilizationOutputResponse`
extension GameLiftClient {
    public func describeFleetUtilizationPaginated(input: DescribeFleetUtilizationInput) -> ClientRuntime.PaginatorSequence<DescribeFleetUtilizationInput, DescribeFleetUtilizationOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeFleetUtilizationInput, DescribeFleetUtilizationOutputResponse>(input: input, inputKey: \DescribeFleetUtilizationInput.nextToken, outputKey: \DescribeFleetUtilizationOutputResponse.nextToken, paginationFunction: self.describeFleetUtilization(input:))
    }
}

extension DescribeFleetUtilizationInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeFleetUtilizationInput {
        return DescribeFleetUtilizationInput(
            fleetIds: self.fleetIds,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeFleetUtilizationPaginated`
/// to access the nested member `[GameLiftClientTypes.FleetUtilization]`
/// - Returns: `[GameLiftClientTypes.FleetUtilization]`
extension PaginatorSequence where Input == DescribeFleetUtilizationInput, Output == DescribeFleetUtilizationOutputResponse {
    public func fleetUtilization() async throws -> [GameLiftClientTypes.FleetUtilization] {
        return try await self.asyncCompactMap { item in item.fleetUtilization }
    }
}

/// Paginate over `[DescribeGameServerInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeGameServerInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeGameServerInstancesOutputResponse`
extension GameLiftClient {
    public func describeGameServerInstancesPaginated(input: DescribeGameServerInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeGameServerInstancesInput, DescribeGameServerInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeGameServerInstancesInput, DescribeGameServerInstancesOutputResponse>(input: input, inputKey: \DescribeGameServerInstancesInput.nextToken, outputKey: \DescribeGameServerInstancesOutputResponse.nextToken, paginationFunction: self.describeGameServerInstances(input:))
    }
}

extension DescribeGameServerInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGameServerInstancesInput {
        return DescribeGameServerInstancesInput(
            gameServerGroupName: self.gameServerGroupName,
            instanceIds: self.instanceIds,
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeGameServerInstancesPaginated`
/// to access the nested member `[GameLiftClientTypes.GameServerInstance]`
/// - Returns: `[GameLiftClientTypes.GameServerInstance]`
extension PaginatorSequence where Input == DescribeGameServerInstancesInput, Output == DescribeGameServerInstancesOutputResponse {
    public func gameServerInstances() async throws -> [GameLiftClientTypes.GameServerInstance] {
        return try await self.asyncCompactMap { item in item.gameServerInstances }
    }
}

/// Paginate over `[DescribeGameSessionDetailsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeGameSessionDetailsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeGameSessionDetailsOutputResponse`
extension GameLiftClient {
    public func describeGameSessionDetailsPaginated(input: DescribeGameSessionDetailsInput) -> ClientRuntime.PaginatorSequence<DescribeGameSessionDetailsInput, DescribeGameSessionDetailsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeGameSessionDetailsInput, DescribeGameSessionDetailsOutputResponse>(input: input, inputKey: \DescribeGameSessionDetailsInput.nextToken, outputKey: \DescribeGameSessionDetailsOutputResponse.nextToken, paginationFunction: self.describeGameSessionDetails(input:))
    }
}

extension DescribeGameSessionDetailsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGameSessionDetailsInput {
        return DescribeGameSessionDetailsInput(
            aliasId: self.aliasId,
            fleetId: self.fleetId,
            gameSessionId: self.gameSessionId,
            limit: self.limit,
            location: self.location,
            nextToken: token,
            statusFilter: self.statusFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeGameSessionDetailsPaginated`
/// to access the nested member `[GameLiftClientTypes.GameSessionDetail]`
/// - Returns: `[GameLiftClientTypes.GameSessionDetail]`
extension PaginatorSequence where Input == DescribeGameSessionDetailsInput, Output == DescribeGameSessionDetailsOutputResponse {
    public func gameSessionDetails() async throws -> [GameLiftClientTypes.GameSessionDetail] {
        return try await self.asyncCompactMap { item in item.gameSessionDetails }
    }
}

/// Paginate over `[DescribeGameSessionQueuesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeGameSessionQueuesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeGameSessionQueuesOutputResponse`
extension GameLiftClient {
    public func describeGameSessionQueuesPaginated(input: DescribeGameSessionQueuesInput) -> ClientRuntime.PaginatorSequence<DescribeGameSessionQueuesInput, DescribeGameSessionQueuesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeGameSessionQueuesInput, DescribeGameSessionQueuesOutputResponse>(input: input, inputKey: \DescribeGameSessionQueuesInput.nextToken, outputKey: \DescribeGameSessionQueuesOutputResponse.nextToken, paginationFunction: self.describeGameSessionQueues(input:))
    }
}

extension DescribeGameSessionQueuesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGameSessionQueuesInput {
        return DescribeGameSessionQueuesInput(
            limit: self.limit,
            names: self.names,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeGameSessionQueuesPaginated`
/// to access the nested member `[GameLiftClientTypes.GameSessionQueue]`
/// - Returns: `[GameLiftClientTypes.GameSessionQueue]`
extension PaginatorSequence where Input == DescribeGameSessionQueuesInput, Output == DescribeGameSessionQueuesOutputResponse {
    public func gameSessionQueues() async throws -> [GameLiftClientTypes.GameSessionQueue] {
        return try await self.asyncCompactMap { item in item.gameSessionQueues }
    }
}

/// Paginate over `[DescribeGameSessionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeGameSessionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeGameSessionsOutputResponse`
extension GameLiftClient {
    public func describeGameSessionsPaginated(input: DescribeGameSessionsInput) -> ClientRuntime.PaginatorSequence<DescribeGameSessionsInput, DescribeGameSessionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeGameSessionsInput, DescribeGameSessionsOutputResponse>(input: input, inputKey: \DescribeGameSessionsInput.nextToken, outputKey: \DescribeGameSessionsOutputResponse.nextToken, paginationFunction: self.describeGameSessions(input:))
    }
}

extension DescribeGameSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeGameSessionsInput {
        return DescribeGameSessionsInput(
            aliasId: self.aliasId,
            fleetId: self.fleetId,
            gameSessionId: self.gameSessionId,
            limit: self.limit,
            location: self.location,
            nextToken: token,
            statusFilter: self.statusFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeGameSessionsPaginated`
/// to access the nested member `[GameLiftClientTypes.GameSession]`
/// - Returns: `[GameLiftClientTypes.GameSession]`
extension PaginatorSequence where Input == DescribeGameSessionsInput, Output == DescribeGameSessionsOutputResponse {
    public func gameSessions() async throws -> [GameLiftClientTypes.GameSession] {
        return try await self.asyncCompactMap { item in item.gameSessions }
    }
}

/// Paginate over `[DescribeInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeInstancesOutputResponse`
extension GameLiftClient {
    public func describeInstancesPaginated(input: DescribeInstancesInput) -> ClientRuntime.PaginatorSequence<DescribeInstancesInput, DescribeInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeInstancesInput, DescribeInstancesOutputResponse>(input: input, inputKey: \DescribeInstancesInput.nextToken, outputKey: \DescribeInstancesOutputResponse.nextToken, paginationFunction: self.describeInstances(input:))
    }
}

extension DescribeInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeInstancesInput {
        return DescribeInstancesInput(
            fleetId: self.fleetId,
            instanceId: self.instanceId,
            limit: self.limit,
            location: self.location,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeInstancesPaginated`
/// to access the nested member `[GameLiftClientTypes.Instance]`
/// - Returns: `[GameLiftClientTypes.Instance]`
extension PaginatorSequence where Input == DescribeInstancesInput, Output == DescribeInstancesOutputResponse {
    public func instances() async throws -> [GameLiftClientTypes.Instance] {
        return try await self.asyncCompactMap { item in item.instances }
    }
}

/// Paginate over `[DescribeMatchmakingConfigurationsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMatchmakingConfigurationsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMatchmakingConfigurationsOutputResponse`
extension GameLiftClient {
    public func describeMatchmakingConfigurationsPaginated(input: DescribeMatchmakingConfigurationsInput) -> ClientRuntime.PaginatorSequence<DescribeMatchmakingConfigurationsInput, DescribeMatchmakingConfigurationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMatchmakingConfigurationsInput, DescribeMatchmakingConfigurationsOutputResponse>(input: input, inputKey: \DescribeMatchmakingConfigurationsInput.nextToken, outputKey: \DescribeMatchmakingConfigurationsOutputResponse.nextToken, paginationFunction: self.describeMatchmakingConfigurations(input:))
    }
}

extension DescribeMatchmakingConfigurationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMatchmakingConfigurationsInput {
        return DescribeMatchmakingConfigurationsInput(
            limit: self.limit,
            names: self.names,
            nextToken: token,
            ruleSetName: self.ruleSetName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMatchmakingConfigurationsPaginated`
/// to access the nested member `[GameLiftClientTypes.MatchmakingConfiguration]`
/// - Returns: `[GameLiftClientTypes.MatchmakingConfiguration]`
extension PaginatorSequence where Input == DescribeMatchmakingConfigurationsInput, Output == DescribeMatchmakingConfigurationsOutputResponse {
    public func configurations() async throws -> [GameLiftClientTypes.MatchmakingConfiguration] {
        return try await self.asyncCompactMap { item in item.configurations }
    }
}

/// Paginate over `[DescribeMatchmakingRuleSetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeMatchmakingRuleSetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeMatchmakingRuleSetsOutputResponse`
extension GameLiftClient {
    public func describeMatchmakingRuleSetsPaginated(input: DescribeMatchmakingRuleSetsInput) -> ClientRuntime.PaginatorSequence<DescribeMatchmakingRuleSetsInput, DescribeMatchmakingRuleSetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeMatchmakingRuleSetsInput, DescribeMatchmakingRuleSetsOutputResponse>(input: input, inputKey: \DescribeMatchmakingRuleSetsInput.nextToken, outputKey: \DescribeMatchmakingRuleSetsOutputResponse.nextToken, paginationFunction: self.describeMatchmakingRuleSets(input:))
    }
}

extension DescribeMatchmakingRuleSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeMatchmakingRuleSetsInput {
        return DescribeMatchmakingRuleSetsInput(
            limit: self.limit,
            names: self.names,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeMatchmakingRuleSetsPaginated`
/// to access the nested member `[GameLiftClientTypes.MatchmakingRuleSet]`
/// - Returns: `[GameLiftClientTypes.MatchmakingRuleSet]`
extension PaginatorSequence where Input == DescribeMatchmakingRuleSetsInput, Output == DescribeMatchmakingRuleSetsOutputResponse {
    public func ruleSets() async throws -> [GameLiftClientTypes.MatchmakingRuleSet] {
        return try await self.asyncCompactMap { item in item.ruleSets }
    }
}

/// Paginate over `[DescribePlayerSessionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribePlayerSessionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribePlayerSessionsOutputResponse`
extension GameLiftClient {
    public func describePlayerSessionsPaginated(input: DescribePlayerSessionsInput) -> ClientRuntime.PaginatorSequence<DescribePlayerSessionsInput, DescribePlayerSessionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribePlayerSessionsInput, DescribePlayerSessionsOutputResponse>(input: input, inputKey: \DescribePlayerSessionsInput.nextToken, outputKey: \DescribePlayerSessionsOutputResponse.nextToken, paginationFunction: self.describePlayerSessions(input:))
    }
}

extension DescribePlayerSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribePlayerSessionsInput {
        return DescribePlayerSessionsInput(
            gameSessionId: self.gameSessionId,
            limit: self.limit,
            nextToken: token,
            playerId: self.playerId,
            playerSessionId: self.playerSessionId,
            playerSessionStatusFilter: self.playerSessionStatusFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describePlayerSessionsPaginated`
/// to access the nested member `[GameLiftClientTypes.PlayerSession]`
/// - Returns: `[GameLiftClientTypes.PlayerSession]`
extension PaginatorSequence where Input == DescribePlayerSessionsInput, Output == DescribePlayerSessionsOutputResponse {
    public func playerSessions() async throws -> [GameLiftClientTypes.PlayerSession] {
        return try await self.asyncCompactMap { item in item.playerSessions }
    }
}

/// Paginate over `[DescribeScalingPoliciesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[DescribeScalingPoliciesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `DescribeScalingPoliciesOutputResponse`
extension GameLiftClient {
    public func describeScalingPoliciesPaginated(input: DescribeScalingPoliciesInput) -> ClientRuntime.PaginatorSequence<DescribeScalingPoliciesInput, DescribeScalingPoliciesOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeScalingPoliciesInput, DescribeScalingPoliciesOutputResponse>(input: input, inputKey: \DescribeScalingPoliciesInput.nextToken, outputKey: \DescribeScalingPoliciesOutputResponse.nextToken, paginationFunction: self.describeScalingPolicies(input:))
    }
}

extension DescribeScalingPoliciesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeScalingPoliciesInput {
        return DescribeScalingPoliciesInput(
            fleetId: self.fleetId,
            limit: self.limit,
            location: self.location,
            nextToken: token,
            statusFilter: self.statusFilter
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `describeScalingPoliciesPaginated`
/// to access the nested member `[GameLiftClientTypes.ScalingPolicy]`
/// - Returns: `[GameLiftClientTypes.ScalingPolicy]`
extension PaginatorSequence where Input == DescribeScalingPoliciesInput, Output == DescribeScalingPoliciesOutputResponse {
    public func scalingPolicies() async throws -> [GameLiftClientTypes.ScalingPolicy] {
        return try await self.asyncCompactMap { item in item.scalingPolicies }
    }
}

/// Paginate over `[ListAliasesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAliasesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAliasesOutputResponse`
extension GameLiftClient {
    public func listAliasesPaginated(input: ListAliasesInput) -> ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAliasesInput, ListAliasesOutputResponse>(input: input, inputKey: \ListAliasesInput.nextToken, outputKey: \ListAliasesOutputResponse.nextToken, paginationFunction: self.listAliases(input:))
    }
}

extension ListAliasesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAliasesInput {
        return ListAliasesInput(
            limit: self.limit,
            name: self.name,
            nextToken: token,
            routingStrategyType: self.routingStrategyType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAliasesPaginated`
/// to access the nested member `[GameLiftClientTypes.Alias]`
/// - Returns: `[GameLiftClientTypes.Alias]`
extension PaginatorSequence where Input == ListAliasesInput, Output == ListAliasesOutputResponse {
    public func aliases() async throws -> [GameLiftClientTypes.Alias] {
        return try await self.asyncCompactMap { item in item.aliases }
    }
}

/// Paginate over `[ListBuildsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListBuildsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListBuildsOutputResponse`
extension GameLiftClient {
    public func listBuildsPaginated(input: ListBuildsInput) -> ClientRuntime.PaginatorSequence<ListBuildsInput, ListBuildsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListBuildsInput, ListBuildsOutputResponse>(input: input, inputKey: \ListBuildsInput.nextToken, outputKey: \ListBuildsOutputResponse.nextToken, paginationFunction: self.listBuilds(input:))
    }
}

extension ListBuildsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListBuildsInput {
        return ListBuildsInput(
            limit: self.limit,
            nextToken: token,
            status: self.status
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listBuildsPaginated`
/// to access the nested member `[GameLiftClientTypes.Build]`
/// - Returns: `[GameLiftClientTypes.Build]`
extension PaginatorSequence where Input == ListBuildsInput, Output == ListBuildsOutputResponse {
    public func builds() async throws -> [GameLiftClientTypes.Build] {
        return try await self.asyncCompactMap { item in item.builds }
    }
}

/// Paginate over `[ListFleetsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListFleetsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListFleetsOutputResponse`
extension GameLiftClient {
    public func listFleetsPaginated(input: ListFleetsInput) -> ClientRuntime.PaginatorSequence<ListFleetsInput, ListFleetsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListFleetsInput, ListFleetsOutputResponse>(input: input, inputKey: \ListFleetsInput.nextToken, outputKey: \ListFleetsOutputResponse.nextToken, paginationFunction: self.listFleets(input:))
    }
}

extension ListFleetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListFleetsInput {
        return ListFleetsInput(
            buildId: self.buildId,
            limit: self.limit,
            nextToken: token,
            scriptId: self.scriptId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listFleetsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListFleetsInput, Output == ListFleetsOutputResponse {
    public func fleetIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.fleetIds }
    }
}

/// Paginate over `[ListGameServerGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListGameServerGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListGameServerGroupsOutputResponse`
extension GameLiftClient {
    public func listGameServerGroupsPaginated(input: ListGameServerGroupsInput) -> ClientRuntime.PaginatorSequence<ListGameServerGroupsInput, ListGameServerGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGameServerGroupsInput, ListGameServerGroupsOutputResponse>(input: input, inputKey: \ListGameServerGroupsInput.nextToken, outputKey: \ListGameServerGroupsOutputResponse.nextToken, paginationFunction: self.listGameServerGroups(input:))
    }
}

extension ListGameServerGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGameServerGroupsInput {
        return ListGameServerGroupsInput(
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listGameServerGroupsPaginated`
/// to access the nested member `[GameLiftClientTypes.GameServerGroup]`
/// - Returns: `[GameLiftClientTypes.GameServerGroup]`
extension PaginatorSequence where Input == ListGameServerGroupsInput, Output == ListGameServerGroupsOutputResponse {
    public func gameServerGroups() async throws -> [GameLiftClientTypes.GameServerGroup] {
        return try await self.asyncCompactMap { item in item.gameServerGroups }
    }
}

/// Paginate over `[ListGameServersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListGameServersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListGameServersOutputResponse`
extension GameLiftClient {
    public func listGameServersPaginated(input: ListGameServersInput) -> ClientRuntime.PaginatorSequence<ListGameServersInput, ListGameServersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListGameServersInput, ListGameServersOutputResponse>(input: input, inputKey: \ListGameServersInput.nextToken, outputKey: \ListGameServersOutputResponse.nextToken, paginationFunction: self.listGameServers(input:))
    }
}

extension ListGameServersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListGameServersInput {
        return ListGameServersInput(
            gameServerGroupName: self.gameServerGroupName,
            limit: self.limit,
            nextToken: token,
            sortOrder: self.sortOrder
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listGameServersPaginated`
/// to access the nested member `[GameLiftClientTypes.GameServer]`
/// - Returns: `[GameLiftClientTypes.GameServer]`
extension PaginatorSequence where Input == ListGameServersInput, Output == ListGameServersOutputResponse {
    public func gameServers() async throws -> [GameLiftClientTypes.GameServer] {
        return try await self.asyncCompactMap { item in item.gameServers }
    }
}

/// Paginate over `[ListScriptsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListScriptsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListScriptsOutputResponse`
extension GameLiftClient {
    public func listScriptsPaginated(input: ListScriptsInput) -> ClientRuntime.PaginatorSequence<ListScriptsInput, ListScriptsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListScriptsInput, ListScriptsOutputResponse>(input: input, inputKey: \ListScriptsInput.nextToken, outputKey: \ListScriptsOutputResponse.nextToken, paginationFunction: self.listScripts(input:))
    }
}

extension ListScriptsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListScriptsInput {
        return ListScriptsInput(
            limit: self.limit,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listScriptsPaginated`
/// to access the nested member `[GameLiftClientTypes.Script]`
/// - Returns: `[GameLiftClientTypes.Script]`
extension PaginatorSequence where Input == ListScriptsInput, Output == ListScriptsOutputResponse {
    public func scripts() async throws -> [GameLiftClientTypes.Script] {
        return try await self.asyncCompactMap { item in item.scripts }
    }
}

/// Paginate over `[SearchGameSessionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[SearchGameSessionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `SearchGameSessionsOutputResponse`
extension GameLiftClient {
    public func searchGameSessionsPaginated(input: SearchGameSessionsInput) -> ClientRuntime.PaginatorSequence<SearchGameSessionsInput, SearchGameSessionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<SearchGameSessionsInput, SearchGameSessionsOutputResponse>(input: input, inputKey: \SearchGameSessionsInput.nextToken, outputKey: \SearchGameSessionsOutputResponse.nextToken, paginationFunction: self.searchGameSessions(input:))
    }
}

extension SearchGameSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> SearchGameSessionsInput {
        return SearchGameSessionsInput(
            aliasId: self.aliasId,
            filterExpression: self.filterExpression,
            fleetId: self.fleetId,
            limit: self.limit,
            location: self.location,
            nextToken: token,
            sortExpression: self.sortExpression
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `searchGameSessionsPaginated`
/// to access the nested member `[GameLiftClientTypes.GameSession]`
/// - Returns: `[GameLiftClientTypes.GameSession]`
extension PaginatorSequence where Input == SearchGameSessionsInput, Output == SearchGameSessionsOutputResponse {
    public func gameSessions() async throws -> [GameLiftClientTypes.GameSession] {
        return try await self.asyncCompactMap { item in item.gameSessions }
    }
}
