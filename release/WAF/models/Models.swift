// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActivatedRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case excludedRules = "ExcludedRules"
        case overrideAction = "OverrideAction"
        case priority = "Priority"
        case ruleId = "RuleId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let excludedRules = excludedRules {
            var excludedRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludedRules)
            for excludedrules0 in excludedRules {
                try excludedRulesContainer.encode(excludedrules0)
            }
        }
        if let overrideAction = overrideAction {
            try encodeContainer.encode(overrideAction, forKey: .overrideAction)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(WafAction.self, forKey: .action)
        action = actionDecoded
        let overrideActionDecoded = try containerValues.decodeIfPresent(WafOverrideAction.self, forKey: .overrideAction)
        overrideAction = overrideActionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WafRuleType.self, forKey: .type)
        type = typeDecoded
        let excludedRulesContainer = try containerValues.decodeIfPresent([ExcludedRule?].self, forKey: .excludedRules)
        var excludedRulesDecoded0:[ExcludedRule]? = nil
        if let excludedRulesContainer = excludedRulesContainer {
            excludedRulesDecoded0 = [ExcludedRule]()
            for structure0 in excludedRulesContainer {
                if let structure0 = structure0 {
                    excludedRulesDecoded0?.append(structure0)
                }
            }
        }
        excludedRules = excludedRulesDecoded0
    }
}

extension ActivatedRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivatedRule(action: \(String(describing: action)), excludedRules: \(String(describing: excludedRules)), overrideAction: \(String(describing: overrideAction)), priority: \(String(describing: priority)), ruleId: \(String(describing: ruleId)), type: \(String(describing: type)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>The <code>ActivatedRule</code> object in an <a>UpdateWebACL</a> request specifies a <code>Rule</code> that you want to insert or delete,
/// 			the priority of the <code>Rule</code> in the <code>WebACL</code>, and the action that you want AWS WAF to take when a web request matches the <code>Rule</code>
/// 			(<code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>).</p>
/// 		       <p>To specify whether to insert or delete a <code>Rule</code>, use the <code>Action</code> parameter in the <a>WebACLUpdate</a> data type.</p>
public struct ActivatedRule: Equatable {
    /// <p>Specifies the action that CloudFront or AWS WAF takes when a web request matches the conditions in the <code>Rule</code>.
    /// 			Valid values for <code>Action</code> include the following:</p>
    /// 			      <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW</code>: CloudFront responds with the requested object.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BLOCK</code>: CloudFront responds with an HTTP 403 (Forbidden) status code.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COUNT</code>: AWS WAF increments a counter of requests that match the conditions in the rule and then continues to
    /// 					inspect the web request based on the remaining rules in the web ACL. </p>
    ///             </li>
    ///          </ul>
    /// 	        <p>
    ///             <code>ActivatedRule|OverrideAction</code> applies only when updating or adding a
    ///             <code>RuleGroup</code> to a <code>WebACL</code>. In this
    ///          case,
    ///          you do not use <code>ActivatedRule|Action</code>. For all other update requests,
    ///             <code>ActivatedRule|Action</code> is used instead of
    ///             <code>ActivatedRule|OverrideAction</code>.</p>
    public let action: WafAction?
    /// <p>An array of rules to exclude from a rule group. This is applicable only when the <code>ActivatedRule</code> refers to a <code>RuleGroup</code>.</p>
    ///          <p>Sometimes it is necessary to troubleshoot rule groups that are blocking traffic
    ///          unexpectedly (false positives). One troubleshooting technique is to identify the specific
    ///          rule within the rule group that is blocking the legitimate traffic and then disable
    ///          (exclude) that particular rule. You can exclude rules from both your own rule groups and
    ///          AWS Marketplace rule groups that have been associated with a web ACL.</p>
    ///          <p>Specifying <code>ExcludedRules</code> does not remove those rules from the rule group.
    ///          Rather, it changes the action for the rules to <code>COUNT</code>. Therefore, requests that
    ///          match an <code>ExcludedRule</code> are counted but not blocked. The <code>RuleGroup</code>
    ///          owner will receive COUNT metrics for each <code>ExcludedRule</code>.</p>
    ///          <p>If you want to exclude rules from a rule group that is already associated with a web ACL, perform the following steps:</p>
    ///          <ol>
    ///             <li>
    ///                <p>Use the AWS WAF logs to identify the IDs of the rules that you want to exclude.
    ///                For more information about the logs, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/logging.html">Logging Web ACL Traffic
    ///                   Information</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Submit an <a>UpdateWebACL</a> request that has two actions:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>The first action
    ///                      deletes
    ///                      the existing rule group from the web ACL. That is, in the <a>UpdateWebACL</a> request, the first <code>Updates:Action</code>
    ///                      should be <code>DELETE</code> and <code>Updates:ActivatedRule:RuleId</code>
    ///                      should be the rule group that contains the rules that you want to
    ///                      exclude.</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>The second action
    ///                      inserts
    ///                      the same rule group back in, but specifying the rules to exclude. That is, the
    ///                      second <code>Updates:Action</code> should be <code>INSERT</code>,
    ///                         <code>Updates:ActivatedRule:RuleId</code> should be the rule group that you
    ///                      just removed, and <code>ExcludedRules</code> should contain the rules that you
    ///                      want to exclude.</p>
    ///                   </li>
    ///                </ul>
    ///
    ///             </li>
    ///          </ol>
    public let excludedRules: [ExcludedRule]?
    /// <p>Use the <code>OverrideAction</code> to test your <code>RuleGroup</code>.</p>
    ///          <p>Any rule in a <code>RuleGroup</code> can potentially block a request. If you set the <code>OverrideAction</code> to <code>None</code>, the <code>RuleGroup</code> will block a request if any individual rule in the <code>RuleGroup</code> matches the request and is configured to block that request. However if you first want to test the <code>RuleGroup</code>, set the  <code>OverrideAction</code> to <code>Count</code>. The <code>RuleGroup</code> will then override any block action specified by individual rules contained within the group. Instead of blocking matching requests, those requests will be counted. You can view a record of counted requests using  <a>GetSampledRequests</a>. </p>
    /// 	        <p>
    ///             <code>ActivatedRule|OverrideAction</code> applies only when updating or adding a <code>RuleGroup</code> to a <code>WebACL</code>. In this case you do not use <code>ActivatedRule|Action</code>.  For all other update requests, <code>ActivatedRule|Action</code> is used instead of <code>ActivatedRule|OverrideAction</code>.</p>
    public let overrideAction: WafOverrideAction?
    /// <p>Specifies the order in which the <code>Rules</code> in a <code>WebACL</code> are evaluated. Rules with a lower value for
    /// 			<code>Priority</code> are evaluated before <code>Rules</code> with a higher value. The value must be a unique integer. If you add multiple
    /// 			<code>Rules</code> to a <code>WebACL</code>, the values don't need to be consecutive.</p>
    public let priority: Int?
    /// <p>The <code>RuleId</code> for a <code>Rule</code>. You use <code>RuleId</code> to get more information about a <code>Rule</code> (see <a>GetRule</a>),
    /// 			update a <code>Rule</code> (see <a>UpdateRule</a>), insert a <code>Rule</code> into a <code>WebACL</code> or delete a
    /// 			one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>Rule</code> from AWS WAF (see <a>DeleteRule</a>).</p>
    /// 		       <p>
    ///             <code>RuleId</code> is returned by <a>CreateRule</a> and by <a>ListRules</a>.</p>
    public let ruleId: String?
    /// <p>The rule type, either <code>REGULAR</code>, as defined by <a>Rule</a>, <code>RATE_BASED</code>, as defined by <a>RateBasedRule</a>, or <code>GROUP</code>, as defined by <a>RuleGroup</a>. The default is REGULAR. Although this field is optional, be aware that if you try to add a RATE_BASED rule to a web ACL without setting the type, the  <a>UpdateWebACL</a> request will fail because the request tries to add a REGULAR rule with the specified ID, which does not exist. 		
    /// 			</p>
    public let type: WafRuleType?

    public init (
        action: WafAction? = nil,
        excludedRules: [ExcludedRule]? = nil,
        overrideAction: WafOverrideAction? = nil,
        priority: Int? = nil,
        ruleId: String? = nil,
        type: WafRuleType? = nil
    )
    {
        self.action = action
        self.excludedRules = excludedRules
        self.overrideAction = overrideAction
        self.priority = priority
        self.ruleId = ruleId
        self.type = type
    }
}

extension ByteMatchSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case byteMatchSetId = "ByteMatchSetId"
        case byteMatchTuples = "ByteMatchTuples"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byteMatchSetId = byteMatchSetId {
            try encodeContainer.encode(byteMatchSetId, forKey: .byteMatchSetId)
        }
        if let byteMatchTuples = byteMatchTuples {
            var byteMatchTuplesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .byteMatchTuples)
            for bytematchtuples0 in byteMatchTuples {
                try byteMatchTuplesContainer.encode(bytematchtuples0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .byteMatchSetId)
        byteMatchSetId = byteMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let byteMatchTuplesContainer = try containerValues.decodeIfPresent([ByteMatchTuple?].self, forKey: .byteMatchTuples)
        var byteMatchTuplesDecoded0:[ByteMatchTuple]? = nil
        if let byteMatchTuplesContainer = byteMatchTuplesContainer {
            byteMatchTuplesDecoded0 = [ByteMatchTuple]()
            for structure0 in byteMatchTuplesContainer {
                if let structure0 = structure0 {
                    byteMatchTuplesDecoded0?.append(structure0)
                }
            }
        }
        byteMatchTuples = byteMatchTuplesDecoded0
    }
}

extension ByteMatchSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ByteMatchSet(byteMatchSetId: \(String(describing: byteMatchSetId)), byteMatchTuples: \(String(describing: byteMatchTuples)), name: \(String(describing: name)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>In a <a>GetByteMatchSet</a> request, <code>ByteMatchSet</code> is a complex type that contains the <code>ByteMatchSetId</code> and
/// 			<code>Name</code> of a <code>ByteMatchSet</code>, and the values that you specified when you updated the <code>ByteMatchSet</code>. </p>
/// 		       <p>A complex type that contains <code>ByteMatchTuple</code> objects, which specify the parts of web requests that you
/// 			want AWS WAF to inspect and the values that you want AWS WAF to search for. If a <code>ByteMatchSet</code> contains more than one
/// 			<code>ByteMatchTuple</code> object, a request needs to match the settings in only one <code>ByteMatchTuple</code>
/// 			to be considered a match.</p>
public struct ByteMatchSet: Equatable {
    /// <p>The <code>ByteMatchSetId</code> for a <code>ByteMatchSet</code>. You use <code>ByteMatchSetId</code> to get information about a
    /// 			<code>ByteMatchSet</code> (see <a>GetByteMatchSet</a>), update a <code>ByteMatchSet</code> (see <a>UpdateByteMatchSet</a>),
    /// 			insert a <code>ByteMatchSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and
    /// 			delete a <code>ByteMatchSet</code> from AWS WAF (see <a>DeleteByteMatchSet</a>).</p>
    /// 		       <p>
    ///             <code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by <a>ListByteMatchSets</a>.</p>
    public let byteMatchSetId: String?
    /// <p>Specifies the bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to search for in web requests, the location in requests that you want AWS WAF to search, and other settings.</p>
    public let byteMatchTuples: [ByteMatchTuple]?
    /// <p>A friendly name or description of the <a>ByteMatchSet</a>. You can't change <code>Name</code> after you create a <code>ByteMatchSet</code>.</p>
    public let name: String?

    public init (
        byteMatchSetId: String? = nil,
        byteMatchTuples: [ByteMatchTuple]? = nil,
        name: String? = nil
    )
    {
        self.byteMatchSetId = byteMatchSetId
        self.byteMatchTuples = byteMatchTuples
        self.name = name
    }
}

extension ByteMatchSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case byteMatchSetId = "ByteMatchSetId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byteMatchSetId = byteMatchSetId {
            try encodeContainer.encode(byteMatchSetId, forKey: .byteMatchSetId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .byteMatchSetId)
        byteMatchSetId = byteMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ByteMatchSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ByteMatchSetSummary(byteMatchSetId: \(String(describing: byteMatchSetId)), name: \(String(describing: name)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Returned by <a>ListByteMatchSets</a>. Each <code>ByteMatchSetSummary</code> object includes the <code>Name</code> and
/// 			<code>ByteMatchSetId</code> for one <a>ByteMatchSet</a>.</p>
public struct ByteMatchSetSummary: Equatable {
    /// <p>The <code>ByteMatchSetId</code> for a <code>ByteMatchSet</code>. You use <code>ByteMatchSetId</code> to get information about a <code>ByteMatchSet</code>,
    /// 			update a <code>ByteMatchSet</code>, remove a <code>ByteMatchSet</code> from a <code>Rule</code>, and delete a <code>ByteMatchSet</code> from AWS WAF.</p>
    /// 		       <p>
    ///             <code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by <a>ListByteMatchSets</a>.</p>
    public let byteMatchSetId: String?
    /// <p>A friendly name or description of the <a>ByteMatchSet</a>. You can't change <code>Name</code> after you create a <code>ByteMatchSet</code>.</p>
    public let name: String?

    public init (
        byteMatchSetId: String? = nil,
        name: String? = nil
    )
    {
        self.byteMatchSetId = byteMatchSetId
        self.name = name
    }
}

extension ByteMatchSetUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case byteMatchTuple = "ByteMatchTuple"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let byteMatchTuple = byteMatchTuple {
            try encodeContainer.encode(byteMatchTuple, forKey: .byteMatchTuple)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let byteMatchTupleDecoded = try containerValues.decodeIfPresent(ByteMatchTuple.self, forKey: .byteMatchTuple)
        byteMatchTuple = byteMatchTupleDecoded
    }
}

extension ByteMatchSetUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ByteMatchSetUpdate(action: \(String(describing: action)), byteMatchTuple: \(String(describing: byteMatchTuple)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>In an <a>UpdateByteMatchSet</a> request, <code>ByteMatchSetUpdate</code> specifies whether to insert or delete a
/// 			<a>ByteMatchTuple</a> and includes the settings for the <code>ByteMatchTuple</code>.</p>
public struct ByteMatchSetUpdate: Equatable {
    /// <p>Specifies whether to insert or delete a <a>ByteMatchTuple</a>.</p>
    public let action: ChangeAction?
    /// <p>Information about the part of a web request that you want AWS WAF to inspect and the value that you want AWS WAF to search for.
    /// 			If you specify <code>DELETE</code> for the value of <code>Action</code>, the <code>ByteMatchTuple</code> values must
    /// 			exactly match the values in the <code>ByteMatchTuple</code> that you want to delete from the <code>ByteMatchSet</code>.</p>
    public let byteMatchTuple: ByteMatchTuple?

    public init (
        action: ChangeAction? = nil,
        byteMatchTuple: ByteMatchTuple? = nil
    )
    {
        self.action = action
        self.byteMatchTuple = byteMatchTuple
    }
}

extension ByteMatchTuple: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldToMatch = "FieldToMatch"
        case positionalConstraint = "PositionalConstraint"
        case targetString = "TargetString"
        case textTransformation = "TextTransformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if let positionalConstraint = positionalConstraint {
            try encodeContainer.encode(positionalConstraint.rawValue, forKey: .positionalConstraint)
        }
        if let targetString = targetString {
            try encodeContainer.encode(targetString.base64EncodedString(), forKey: .targetString)
        }
        if let textTransformation = textTransformation {
            try encodeContainer.encode(textTransformation.rawValue, forKey: .textTransformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let targetStringDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .targetString)
        targetString = targetStringDecoded
        let textTransformationDecoded = try containerValues.decodeIfPresent(TextTransformation.self, forKey: .textTransformation)
        textTransformation = textTransformationDecoded
        let positionalConstraintDecoded = try containerValues.decodeIfPresent(PositionalConstraint.self, forKey: .positionalConstraint)
        positionalConstraint = positionalConstraintDecoded
    }
}

extension ByteMatchTuple: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ByteMatchTuple(fieldToMatch: \(String(describing: fieldToMatch)), positionalConstraint: \(String(describing: positionalConstraint)), targetString: \(String(describing: targetString)), textTransformation: \(String(describing: textTransformation)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>The bytes (typically a string that corresponds with ASCII characters) that you want AWS WAF to search for in web requests, the location in requests that you want AWS WAF to search, and other settings.</p>
public struct ByteMatchTuple: Equatable {
    /// <p>The part of a web request that you want AWS WAF to search, such as a specified header or a query string. For more information, see
    /// 			<a>FieldToMatch</a>.</p>
    public let fieldToMatch: FieldToMatch?
    /// <p>Within the portion of a web request that you want to search (for example, in the query string, if any), specify where you want AWS WAF to search. Valid values include the following:</p>
    /// 		       <p>
    ///             <b>CONTAINS</b>
    ///          </p>
    /// 		       <p>The specified part of the web request must include the value of <code>TargetString</code>, but the location doesn't matter.</p>		
    /// 		       <p>
    ///             <b>CONTAINS_WORD</b>
    ///          </p>
    /// 		       <p>The specified part of the web request must include the value of <code>TargetString</code>, and
    /// 			<code>TargetString</code> must contain only alphanumeric characters or underscore (A-Z, a-z, 0-9, or _). In addition,
    /// 			<code>TargetString</code> must be a word, which means one of the following:</p>
    /// 			      <ul>
    ///             <li>
    ///                <p>
    ///                   <code>TargetString</code> exactly matches the value of the specified part of the web request, such as the value of a
    /// 					header.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TargetString</code> is at the beginning of the specified part of the web request and is followed by a character
    /// 					other than an alphanumeric character or underscore (_), for example, <code>BadBot;</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TargetString</code> is at the end of the specified part of the web request and is preceded by a character
    /// 					other than an alphanumeric character or underscore (_), for example, <code>;BadBot</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TargetString</code> is in the middle of the specified part of the web request and is preceded and followed
    /// 					by characters other than alphanumeric characters or underscore (_), for example, <code>-BadBot;</code>.</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>
    ///             <b>EXACTLY</b>
    ///          </p>
    /// 		       <p>The value of the specified part of the web request must exactly match the value of <code>TargetString</code>.</p>
    /// 		       <p>
    ///             <b>STARTS_WITH</b>
    ///          </p>
    /// 		       <p>The value of <code>TargetString</code> must appear at the beginning of the specified part of the web request.</p>		
    /// 		       <p>
    ///             <b>ENDS_WITH</b>
    ///          </p>
    /// 		       <p>The value of <code>TargetString</code> must appear at the end of the specified part of the web request.</p>
    public let positionalConstraint: PositionalConstraint?
    /// <p>The value that you want AWS WAF to search for. AWS WAF searches for the specified string in the part of web requests that you
    /// 			specified in <code>FieldToMatch</code>. The maximum length of the value is 50 bytes.</p>
    /// 		       <p>Valid values depend on the values that you specified for <code>FieldToMatch</code>:</p>		
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HEADER</code>: The value that you want AWS WAF to search for in the request header that you specified in
    /// 				<a>FieldToMatch</a>, for example, the value of the <code>User-Agent</code> or <code>Referer</code> header.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>METHOD</code>: The HTTP method, which indicates the type of operation specified in the request.
    /// 				CloudFront supports the following methods: <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>,
    /// 				<code>PATCH</code>, <code>POST</code>, and <code>PUT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>QUERY_STRING</code>: The value that you want AWS WAF to search for in the query string, which is the part
    /// 				of a URL that appears after a <code>?</code> character.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>URI</code>: The value that you want AWS WAF to search for in the part of a URL that identifies a resource,
    /// 				for example, <code>/images/daily-ad.jpg</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BODY</code>: The part of a request that contains any additional data that you want to send to your web server
    /// 				as the HTTP request body, such as data from a form. The request body immediately follows the request headers.
    /// 				Note that only the first <code>8192</code> bytes of the request body are forwarded to AWS WAF for inspection.
    /// 				To allow or block requests based on the length of the body, you can create a size constraint set.
    /// 				For more information, see <a>CreateSizeConstraintSet</a>. </p>
    ///             </li>
    ///             <li>
    /// 		             <p>
    /// 		                <code>SINGLE_QUERY_ARG</code>: The parameter in the query string that you will inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The maximum length for <code>SINGLE_QUERY_ARG</code> is 30 characters.</p>
    /// 		          </li>
    ///             <li>
    /// 		             <p>
    ///                   <code>ALL_QUERY_ARGS</code>: Similar to <code>SINGLE_QUERY_ARG</code>, but instead of
    ///                inspecting a single parameter, AWS WAF inspects all parameters within the query
    ///                string for the value or regex pattern that you specify in
    ///                <code>TargetString</code>.</p>
    /// 		          </li>
    ///          </ul>
    /// 		
    /// 		       <p>If <code>TargetString</code> includes alphabetic characters A-Z and a-z, note that the value is case sensitive.</p>
    /// 		       <p>
    ///             <b>If you're using the AWS WAF API</b>
    ///          </p>
    /// 		       <p>Specify a base64-encoded version of the value. The maximum length of the value before you base64-encode it is 50 bytes.</p>
    /// 		       <p>For example, suppose the value of <code>Type</code> is <code>HEADER</code> and the
    ///          value of <code>Data</code> is <code>User-Agent</code>. If you want to search the
    ///             <code>User-Agent</code> header for the value <code>BadBot</code>, you base64-encode
    ///             <code>BadBot</code> using MIME
    ///          base64-encoding
    ///          and include the resulting value, <code>QmFkQm90</code>, in the value of
    ///             <code>TargetString</code>.</p>
    /// 		       <p>
    ///             <b>If you're using the AWS CLI or one of the AWS SDKs</b>
    ///          </p>
    /// 		       <p>The value that you want AWS WAF to search for. The SDK automatically base64 encodes the value.</p>
    public let targetString: Data?
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
    /// 			If you specify a transformation, AWS WAF performs the transformation on <code>FieldToMatch</code> before inspecting it for a match.</p>
    ///          <p>You can only specify a single type of TextTransformation.</p>			
    /// 		       <p>
    ///             <b>CMD_LINE</b>
    ///          </p>
    /// 		       <p>When you're concerned that attackers are injecting an operating system command line
    ///          command and using unusual formatting to disguise some or all of the command, use this
    ///          option to perform the following transformations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Delete the following characters: \ " ' ^</p>
    ///             </li>
    ///             <li>
    ///                <p>Delete spaces before the following characters: / (</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace the following characters with a space: , ;</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace multiple spaces with one space</p>
    ///             </li>
    ///             <li>
    ///                <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 		       <p>
    ///             <b>COMPRESS_WHITE_SPACE</b>
    ///          </p>
    /// 		       <p>Use this option to replace the following characters with a space character (decimal 32):</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>\f, formfeed, decimal 12</p>
    ///             </li>
    ///             <li>
    ///                <p>\t, tab, decimal 9</p>
    ///             </li>
    ///             <li>
    ///                <p>\n, newline, decimal 10</p>
    ///             </li>
    ///             <li>
    ///                <p>\r, carriage return, decimal 13</p>
    ///             </li>
    ///             <li>
    ///                <p>\v, vertical tab, decimal 11</p>
    ///             </li>
    ///             <li>
    ///                <p>non-breaking space, decimal 160</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>		
    /// 		       <p>
    ///             <b>HTML_ENTITY_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs
    /// 			the following operations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)quot;</code> with <code>"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)gt;</code> with <code>></code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///          </ul>		
    /// 		       <p>
    ///             <b>LOWERCASE</b>
    ///          </p>
    /// 		       <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p>		
    /// 		       <p>
    ///             <b>URL_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to decode a URL-encoded value.</p>		
    /// 		       <p>
    ///             <b>NONE</b>
    ///          </p>
    /// 		       <p>Specify <code>NONE</code> if you don't want to perform any text transformations.</p>
    public let textTransformation: TextTransformation?

    public init (
        fieldToMatch: FieldToMatch? = nil,
        positionalConstraint: PositionalConstraint? = nil,
        targetString: Data? = nil,
        textTransformation: TextTransformation? = nil
    )
    {
        self.fieldToMatch = fieldToMatch
        self.positionalConstraint = positionalConstraint
        self.targetString = targetString
        self.textTransformation = textTransformation
    }
}

public enum ChangeAction {
    case delete
    case insert
    case sdkUnknown(String)
}

extension ChangeAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeAction] {
        return [
            .delete,
            .insert,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delete: return "DELETE"
        case .insert: return "INSERT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeAction(rawValue: rawValue) ?? ChangeAction.sdkUnknown(rawValue)
    }
}

public enum ChangeTokenStatus {
    case insync
    case pending
    case provisioned
    case sdkUnknown(String)
}

extension ChangeTokenStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeTokenStatus] {
        return [
            .insync,
            .pending,
            .provisioned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .insync: return "INSYNC"
        case .pending: return "PENDING"
        case .provisioned: return "PROVISIONED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeTokenStatus(rawValue: rawValue) ?? ChangeTokenStatus.sdkUnknown(rawValue)
    }
}

public enum ComparisonOperator {
    case eq
    case ge
    case gt
    case le
    case lt
    case ne
    case sdkUnknown(String)
}

extension ComparisonOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComparisonOperator] {
        return [
            .eq,
            .ge,
            .gt,
            .le,
            .lt,
            .ne,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eq: return "EQ"
        case .ge: return "GE"
        case .gt: return "GT"
        case .le: return "LE"
        case .lt: return "LT"
        case .ne: return "NE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
    }
}

public struct CreateByteMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateByteMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateByteMatchSetInput>
    public typealias MOutput = OperationOutput<CreateByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateByteMatchSetOutputError>
}

extension CreateByteMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateByteMatchSetInput(changeToken: \(String(describing: changeToken)), name: \(String(describing: name)))"}
}

extension CreateByteMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateByteMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateByteMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateByteMatchSetInput>
    public typealias MOutput = OperationOutput<CreateByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateByteMatchSetOutputError>
}

public struct CreateByteMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateByteMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateByteMatchSetInput>
    public typealias MOutput = OperationOutput<CreateByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateByteMatchSetOutputError>
}

public struct CreateByteMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description of the <a>ByteMatchSet</a>. You can't change <code>Name</code> after you create a
    /// 			<code>ByteMatchSet</code>.</p>
    public let name: String?

    public init (
        changeToken: String? = nil,
        name: String? = nil
    )
    {
        self.changeToken = changeToken
        self.name = name
    }
}

struct CreateByteMatchSetInputBody: Equatable {
    public let name: String?
    public let changeToken: String?
}

extension CreateByteMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension CreateByteMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateByteMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateByteMatchSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateByteMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateByteMatchSetOutputResponse(byteMatchSet: \(String(describing: byteMatchSet)), changeToken: \(String(describing: changeToken)))"}
}

extension CreateByteMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateByteMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.byteMatchSet = output.byteMatchSet
            self.changeToken = output.changeToken
        } else {
            self.byteMatchSet = nil
            self.changeToken = nil
        }
    }
}

public struct CreateByteMatchSetOutputResponse: Equatable {
    /// <p>A <a>ByteMatchSet</a> that contains no <code>ByteMatchTuple</code> objects.</p>
    public let byteMatchSet: ByteMatchSet?
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateByteMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        byteMatchSet: ByteMatchSet? = nil,
        changeToken: String? = nil
    )
    {
        self.byteMatchSet = byteMatchSet
        self.changeToken = changeToken
    }
}

struct CreateByteMatchSetOutputResponseBody: Equatable {
    public let byteMatchSet: ByteMatchSet?
    public let changeToken: String?
}

extension CreateByteMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byteMatchSet = "ByteMatchSet"
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteMatchSetDecoded = try containerValues.decodeIfPresent(ByteMatchSet.self, forKey: .byteMatchSet)
        byteMatchSet = byteMatchSetDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateGeoMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateGeoMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGeoMatchSetInput>
    public typealias MOutput = OperationOutput<CreateGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGeoMatchSetOutputError>
}

extension CreateGeoMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGeoMatchSetInput(changeToken: \(String(describing: changeToken)), name: \(String(describing: name)))"}
}

extension CreateGeoMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateGeoMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGeoMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGeoMatchSetInput>
    public typealias MOutput = OperationOutput<CreateGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGeoMatchSetOutputError>
}

public struct CreateGeoMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGeoMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGeoMatchSetInput>
    public typealias MOutput = OperationOutput<CreateGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGeoMatchSetOutputError>
}

public struct CreateGeoMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description of the <a>GeoMatchSet</a>. You can't change <code>Name</code> after you create the <code>GeoMatchSet</code>.</p>
    public let name: String?

    public init (
        changeToken: String? = nil,
        name: String? = nil
    )
    {
        self.changeToken = changeToken
        self.name = name
    }
}

struct CreateGeoMatchSetInputBody: Equatable {
    public let name: String?
    public let changeToken: String?
}

extension CreateGeoMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension CreateGeoMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGeoMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGeoMatchSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGeoMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGeoMatchSetOutputResponse(changeToken: \(String(describing: changeToken)), geoMatchSet: \(String(describing: geoMatchSet)))"}
}

extension CreateGeoMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGeoMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.geoMatchSet = output.geoMatchSet
        } else {
            self.changeToken = nil
            self.geoMatchSet = nil
        }
    }
}

public struct CreateGeoMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateGeoMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>The <a>GeoMatchSet</a> returned in the <code>CreateGeoMatchSet</code> response. The <code>GeoMatchSet</code> contains no <code>GeoMatchConstraints</code>.</p>
    public let geoMatchSet: GeoMatchSet?

    public init (
        changeToken: String? = nil,
        geoMatchSet: GeoMatchSet? = nil
    )
    {
        self.changeToken = changeToken
        self.geoMatchSet = geoMatchSet
    }
}

struct CreateGeoMatchSetOutputResponseBody: Equatable {
    public let geoMatchSet: GeoMatchSet?
    public let changeToken: String?
}

extension CreateGeoMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case geoMatchSet = "GeoMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoMatchSetDecoded = try containerValues.decodeIfPresent(GeoMatchSet.self, forKey: .geoMatchSet)
        geoMatchSet = geoMatchSetDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateIPSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

extension CreateIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIPSetInput(changeToken: \(String(describing: changeToken)), name: \(String(describing: name)))"}
}

extension CreateIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

public struct CreateIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIPSetInput>
    public typealias MOutput = OperationOutput<CreateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIPSetOutputError>
}

public struct CreateIPSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description of the <a>IPSet</a>. You can't change <code>Name</code> after you create the <code>IPSet</code>.</p>
    public let name: String?

    public init (
        changeToken: String? = nil,
        name: String? = nil
    )
    {
        self.changeToken = changeToken
        self.name = name
    }
}

struct CreateIPSetInputBody: Equatable {
    public let name: String?
    public let changeToken: String?
}

extension CreateIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension CreateIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIPSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIPSetOutputResponse(changeToken: \(String(describing: changeToken)), iPSet: \(String(describing: iPSet)))"}
}

extension CreateIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIPSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.iPSet = output.iPSet
        } else {
            self.changeToken = nil
            self.iPSet = nil
        }
    }
}

public struct CreateIPSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateIPSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>The <a>IPSet</a> returned in the <code>CreateIPSet</code> response.</p>
    public let iPSet: IPSet?

    public init (
        changeToken: String? = nil,
        iPSet: IPSet? = nil
    )
    {
        self.changeToken = changeToken
        self.iPSet = iPSet
    }
}

struct CreateIPSetOutputResponseBody: Equatable {
    public let iPSet: IPSet?
    public let changeToken: String?
}

extension CreateIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case iPSet = "IPSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetDecoded = try containerValues.decodeIfPresent(IPSet.self, forKey: .iPSet)
        iPSet = iPSetDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateRateBasedRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateRateBasedRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRateBasedRuleInput>
    public typealias MOutput = OperationOutput<CreateRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRateBasedRuleOutputError>
}

extension CreateRateBasedRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRateBasedRuleInput(changeToken: \(String(describing: changeToken)), metricName: \(String(describing: metricName)), name: \(String(describing: name)), rateKey: \(String(describing: rateKey)), rateLimit: \(String(describing: rateLimit)), tags: \(String(describing: tags)))"}
}

extension CreateRateBasedRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case metricName = "MetricName"
        case name = "Name"
        case rateKey = "RateKey"
        case rateLimit = "RateLimit"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rateKey = rateKey {
            try encodeContainer.encode(rateKey.rawValue, forKey: .rateKey)
        }
        if rateLimit != 0 {
            try encodeContainer.encode(rateLimit, forKey: .rateLimit)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRateBasedRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRateBasedRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRateBasedRuleInput>
    public typealias MOutput = OperationOutput<CreateRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRateBasedRuleOutputError>
}

public struct CreateRateBasedRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRateBasedRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRateBasedRuleInput>
    public typealias MOutput = OperationOutput<CreateRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRateBasedRuleOutputError>
}

public struct CreateRateBasedRuleInput: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the
    ///             <code>CreateRateBasedRule</code> request. You can also use this value to query the
    ///          status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description for the metrics for this <code>RateBasedRule</code>.
    ///           The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    ///           whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change the name of the metric after you create the
    ///             <code>RateBasedRule</code>.</p>
    public let metricName: String?
    /// <p>A friendly name or description of the <a>RateBasedRule</a>. You can't
    ///          change the name of a <code>RateBasedRule</code> after you create it.</p>
    public let name: String?
    /// <p>The field that AWS WAF uses to determine if requests are likely arriving from a single
    ///          source and thus subject to rate monitoring. The only valid value for <code>RateKey</code>
    ///          is <code>IP</code>. <code>IP</code> indicates that requests that arrive from the same IP
    ///          address are subject to the <code>RateLimit</code> that is specified in
    ///          the <code>RateBasedRule</code>.</p>
    public let rateKey: RateKey?
    /// <p>The maximum number of requests, which have an identical value in the field that is
    ///          specified by <code>RateKey</code>, allowed in a five-minute period. If the number of
    ///          requests exceeds the <code>RateLimit</code> and the other predicates specified in the rule
    ///          are also met, AWS WAF triggers the action that is specified for this rule.</p>
    public let rateLimit: Int
    /// <p></p>
    public let tags: [Tag]?

    public init (
        changeToken: String? = nil,
        metricName: String? = nil,
        name: String? = nil,
        rateKey: RateKey? = nil,
        rateLimit: Int = 0,
        tags: [Tag]? = nil
    )
    {
        self.changeToken = changeToken
        self.metricName = metricName
        self.name = name
        self.rateKey = rateKey
        self.rateLimit = rateLimit
        self.tags = tags
    }
}

struct CreateRateBasedRuleInputBody: Equatable {
    public let name: String?
    public let metricName: String?
    public let rateKey: RateKey?
    public let rateLimit: Int
    public let changeToken: String?
    public let tags: [Tag]?
}

extension CreateRateBasedRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case metricName = "MetricName"
        case name = "Name"
        case rateKey = "RateKey"
        case rateLimit = "RateLimit"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let rateKeyDecoded = try containerValues.decodeIfPresent(RateKey.self, forKey: .rateKey)
        rateKey = rateKeyDecoded
        let rateLimitDecoded = try containerValues.decode(Int.self, forKey: .rateLimit)
        rateLimit = rateLimitDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRateBasedRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRateBasedRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFBadRequestException" : self = .wAFBadRequestException(try WAFBadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRateBasedRuleOutputError: Equatable {
    case wAFBadRequestException(WAFBadRequestException)
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRateBasedRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRateBasedRuleOutputResponse(changeToken: \(String(describing: changeToken)), rule: \(String(describing: rule)))"}
}

extension CreateRateBasedRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRateBasedRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.rule = output.rule
        } else {
            self.changeToken = nil
            self.rule = nil
        }
    }
}

public struct CreateRateBasedRuleOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the
    ///             <code>CreateRateBasedRule</code> request. You can also use this value to query the
    ///          status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>The <a>RateBasedRule</a>
    ///          that is returned in the <code>CreateRateBasedRule</code> response.</p>
    public let rule: RateBasedRule?

    public init (
        changeToken: String? = nil,
        rule: RateBasedRule? = nil
    )
    {
        self.changeToken = changeToken
        self.rule = rule
    }
}

struct CreateRateBasedRuleOutputResponseBody: Equatable {
    public let rule: RateBasedRule?
    public let changeToken: String?
}

extension CreateRateBasedRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case rule = "Rule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(RateBasedRule.self, forKey: .rule)
        rule = ruleDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateRegexMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateRegexMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexMatchSetInput>
    public typealias MOutput = OperationOutput<CreateRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexMatchSetOutputError>
}

extension CreateRegexMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegexMatchSetInput(changeToken: \(String(describing: changeToken)), name: \(String(describing: name)))"}
}

extension CreateRegexMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateRegexMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRegexMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexMatchSetInput>
    public typealias MOutput = OperationOutput<CreateRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexMatchSetOutputError>
}

public struct CreateRegexMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRegexMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexMatchSetInput>
    public typealias MOutput = OperationOutput<CreateRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexMatchSetOutputError>
}

public struct CreateRegexMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description of the <a>RegexMatchSet</a>. You can't change <code>Name</code> after you create a
    /// 			<code>RegexMatchSet</code>.</p>
    public let name: String?

    public init (
        changeToken: String? = nil,
        name: String? = nil
    )
    {
        self.changeToken = changeToken
        self.name = name
    }
}

struct CreateRegexMatchSetInputBody: Equatable {
    public let name: String?
    public let changeToken: String?
}

extension CreateRegexMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension CreateRegexMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRegexMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRegexMatchSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRegexMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegexMatchSetOutputResponse(changeToken: \(String(describing: changeToken)), regexMatchSet: \(String(describing: regexMatchSet)))"}
}

extension CreateRegexMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRegexMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.regexMatchSet = output.regexMatchSet
        } else {
            self.changeToken = nil
            self.regexMatchSet = nil
        }
    }
}

public struct CreateRegexMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateRegexMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>A <a>RegexMatchSet</a> that contains no <code>RegexMatchTuple</code> objects.</p>
    public let regexMatchSet: RegexMatchSet?

    public init (
        changeToken: String? = nil,
        regexMatchSet: RegexMatchSet? = nil
    )
    {
        self.changeToken = changeToken
        self.regexMatchSet = regexMatchSet
    }
}

struct CreateRegexMatchSetOutputResponseBody: Equatable {
    public let regexMatchSet: RegexMatchSet?
    public let changeToken: String?
}

extension CreateRegexMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexMatchSet = "RegexMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexMatchSetDecoded = try containerValues.decodeIfPresent(RegexMatchSet.self, forKey: .regexMatchSet)
        regexMatchSet = regexMatchSetDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateRegexPatternSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateRegexPatternSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<CreateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexPatternSetOutputError>
}

extension CreateRegexPatternSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegexPatternSetInput(changeToken: \(String(describing: changeToken)), name: \(String(describing: name)))"}
}

extension CreateRegexPatternSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateRegexPatternSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRegexPatternSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<CreateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexPatternSetOutputError>
}

public struct CreateRegexPatternSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRegexPatternSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<CreateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRegexPatternSetOutputError>
}

public struct CreateRegexPatternSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description of the <a>RegexPatternSet</a>. You can't change <code>Name</code> after you create a
    /// 			<code>RegexPatternSet</code>.</p>
    public let name: String?

    public init (
        changeToken: String? = nil,
        name: String? = nil
    )
    {
        self.changeToken = changeToken
        self.name = name
    }
}

struct CreateRegexPatternSetInputBody: Equatable {
    public let name: String?
    public let changeToken: String?
}

extension CreateRegexPatternSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension CreateRegexPatternSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRegexPatternSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRegexPatternSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRegexPatternSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRegexPatternSetOutputResponse(changeToken: \(String(describing: changeToken)), regexPatternSet: \(String(describing: regexPatternSet)))"}
}

extension CreateRegexPatternSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRegexPatternSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.regexPatternSet = output.regexPatternSet
        } else {
            self.changeToken = nil
            self.regexPatternSet = nil
        }
    }
}

public struct CreateRegexPatternSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateRegexPatternSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>A <a>RegexPatternSet</a> that contains no objects.</p>
    public let regexPatternSet: RegexPatternSet?

    public init (
        changeToken: String? = nil,
        regexPatternSet: RegexPatternSet? = nil
    )
    {
        self.changeToken = changeToken
        self.regexPatternSet = regexPatternSet
    }
}

struct CreateRegexPatternSetOutputResponseBody: Equatable {
    public let regexPatternSet: RegexPatternSet?
    public let changeToken: String?
}

extension CreateRegexPatternSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexPatternSet = "RegexPatternSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexPatternSetDecoded = try containerValues.decodeIfPresent(RegexPatternSet.self, forKey: .regexPatternSet)
        regexPatternSet = regexPatternSetDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

extension CreateRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleGroupInput(changeToken: \(String(describing: changeToken)), metricName: \(String(describing: metricName)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case metricName = "MetricName"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

public struct CreateRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

public struct CreateRuleGroupInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description for the metrics for this <code>RuleGroup</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    ///          whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change the name of the metric after you create the <code>RuleGroup</code>.</p>
    public let metricName: String?
    /// <p>A friendly name or description of the <a>RuleGroup</a>. You can't change <code>Name</code> after you create a
    ///          <code>RuleGroup</code>.</p>
    public let name: String?
    /// <p></p>
    public let tags: [Tag]?

    public init (
        changeToken: String? = nil,
        metricName: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.changeToken = changeToken
        self.metricName = metricName
        self.name = name
        self.tags = tags
    }
}

struct CreateRuleGroupInputBody: Equatable {
    public let name: String?
    public let metricName: String?
    public let changeToken: String?
    public let tags: [Tag]?
}

extension CreateRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case metricName = "MetricName"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFBadRequestException" : self = .wAFBadRequestException(try WAFBadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleGroupOutputError: Equatable {
    case wAFBadRequestException(WAFBadRequestException)
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleGroupOutputResponse(changeToken: \(String(describing: changeToken)), ruleGroup: \(String(describing: ruleGroup)))"}
}

extension CreateRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.ruleGroup = output.ruleGroup
        } else {
            self.changeToken = nil
            self.ruleGroup = nil
        }
    }
}

public struct CreateRuleGroupOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateRuleGroup</code> request. You can also use this value
    ///          to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>An empty  <a>RuleGroup</a>.</p>
    public let ruleGroup: RuleGroup?

    public init (
        changeToken: String? = nil,
        ruleGroup: RuleGroup? = nil
    )
    {
        self.changeToken = changeToken
        self.ruleGroup = ruleGroup
    }
}

struct CreateRuleGroupOutputResponseBody: Equatable {
    public let ruleGroup: RuleGroup?
    public let changeToken: String?
}

extension CreateRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleGroup = "RuleGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupDecoded = try containerValues.decodeIfPresent(RuleGroup.self, forKey: .ruleGroup)
        ruleGroup = ruleGroupDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

extension CreateRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleInput(changeToken: \(String(describing: changeToken)), metricName: \(String(describing: metricName)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case metricName = "MetricName"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

public struct CreateRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

public struct CreateRuleInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description for the metrics for this <code>Rule</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    /// 	        whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change the name of the metric after you create the
    ///             <code>Rule</code>.</p>
    public let metricName: String?
    /// <p>A friendly name or description of the <a>Rule</a>. You can't change the name of a <code>Rule</code> after you create it.</p>
    public let name: String?
    /// <p></p>
    public let tags: [Tag]?

    public init (
        changeToken: String? = nil,
        metricName: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.changeToken = changeToken
        self.metricName = metricName
        self.name = name
        self.tags = tags
    }
}

struct CreateRuleInputBody: Equatable {
    public let name: String?
    public let metricName: String?
    public let changeToken: String?
    public let tags: [Tag]?
}

extension CreateRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case metricName = "MetricName"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFBadRequestException" : self = .wAFBadRequestException(try WAFBadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleOutputError: Equatable {
    case wAFBadRequestException(WAFBadRequestException)
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleOutputResponse(changeToken: \(String(describing: changeToken)), rule: \(String(describing: rule)))"}
}

extension CreateRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.rule = output.rule
        } else {
            self.changeToken = nil
            self.rule = nil
        }
    }
}

public struct CreateRuleOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateRule</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>The <a>Rule</a> returned in the <code>CreateRule</code> response.</p>
    public let rule: Rule?

    public init (
        changeToken: String? = nil,
        rule: Rule? = nil
    )
    {
        self.changeToken = changeToken
        self.rule = rule
    }
}

struct CreateRuleOutputResponseBody: Equatable {
    public let rule: Rule?
    public let changeToken: String?
}

extension CreateRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case rule = "Rule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Rule.self, forKey: .rule)
        rule = ruleDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateSizeConstraintSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateSizeConstraintSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<CreateSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSizeConstraintSetOutputError>
}

extension CreateSizeConstraintSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSizeConstraintSetInput(changeToken: \(String(describing: changeToken)), name: \(String(describing: name)))"}
}

extension CreateSizeConstraintSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateSizeConstraintSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSizeConstraintSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<CreateSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSizeConstraintSetOutputError>
}

public struct CreateSizeConstraintSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSizeConstraintSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<CreateSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSizeConstraintSetOutputError>
}

public struct CreateSizeConstraintSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description of the <a>SizeConstraintSet</a>. You can't change <code>Name</code> after you create a
    /// 			<code>SizeConstraintSet</code>.</p>
    public let name: String?

    public init (
        changeToken: String? = nil,
        name: String? = nil
    )
    {
        self.changeToken = changeToken
        self.name = name
    }
}

struct CreateSizeConstraintSetInputBody: Equatable {
    public let name: String?
    public let changeToken: String?
}

extension CreateSizeConstraintSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension CreateSizeConstraintSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSizeConstraintSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSizeConstraintSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSizeConstraintSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSizeConstraintSetOutputResponse(changeToken: \(String(describing: changeToken)), sizeConstraintSet: \(String(describing: sizeConstraintSet)))"}
}

extension CreateSizeConstraintSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSizeConstraintSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.sizeConstraintSet = output.sizeConstraintSet
        } else {
            self.changeToken = nil
            self.sizeConstraintSet = nil
        }
    }
}

public struct CreateSizeConstraintSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateSizeConstraintSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>A <a>SizeConstraintSet</a> that contains no <code>SizeConstraint</code> objects.</p>
    public let sizeConstraintSet: SizeConstraintSet?

    public init (
        changeToken: String? = nil,
        sizeConstraintSet: SizeConstraintSet? = nil
    )
    {
        self.changeToken = changeToken
        self.sizeConstraintSet = sizeConstraintSet
    }
}

struct CreateSizeConstraintSetOutputResponseBody: Equatable {
    public let sizeConstraintSet: SizeConstraintSet?
    public let changeToken: String?
}

extension CreateSizeConstraintSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sizeConstraintSet = "SizeConstraintSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeConstraintSetDecoded = try containerValues.decodeIfPresent(SizeConstraintSet.self, forKey: .sizeConstraintSet)
        sizeConstraintSet = sizeConstraintSetDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateSqlInjectionMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateSqlInjectionMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<CreateSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSqlInjectionMatchSetOutputError>
}

extension CreateSqlInjectionMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSqlInjectionMatchSetInput(changeToken: \(String(describing: changeToken)), name: \(String(describing: name)))"}
}

extension CreateSqlInjectionMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateSqlInjectionMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSqlInjectionMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<CreateSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSqlInjectionMatchSetOutputError>
}

public struct CreateSqlInjectionMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSqlInjectionMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<CreateSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSqlInjectionMatchSetOutputError>
}

/// <p>A request to create a <a>SqlInjectionMatchSet</a>.</p>
public struct CreateSqlInjectionMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description for the <a>SqlInjectionMatchSet</a> that you're creating. You can't change <code>Name</code>
    /// 			after you create the <code>SqlInjectionMatchSet</code>.</p>
    public let name: String?

    public init (
        changeToken: String? = nil,
        name: String? = nil
    )
    {
        self.changeToken = changeToken
        self.name = name
    }
}

struct CreateSqlInjectionMatchSetInputBody: Equatable {
    public let name: String?
    public let changeToken: String?
}

extension CreateSqlInjectionMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension CreateSqlInjectionMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSqlInjectionMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSqlInjectionMatchSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSqlInjectionMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSqlInjectionMatchSetOutputResponse(changeToken: \(String(describing: changeToken)), sqlInjectionMatchSet: \(String(describing: sqlInjectionMatchSet)))"}
}

extension CreateSqlInjectionMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSqlInjectionMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.sqlInjectionMatchSet = output.sqlInjectionMatchSet
        } else {
            self.changeToken = nil
            self.sqlInjectionMatchSet = nil
        }
    }
}

/// <p>The response to a <code>CreateSqlInjectionMatchSet</code> request.</p>
public struct CreateSqlInjectionMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateSqlInjectionMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>A <a>SqlInjectionMatchSet</a>.</p>
    public let sqlInjectionMatchSet: SqlInjectionMatchSet?

    public init (
        changeToken: String? = nil,
        sqlInjectionMatchSet: SqlInjectionMatchSet? = nil
    )
    {
        self.changeToken = changeToken
        self.sqlInjectionMatchSet = sqlInjectionMatchSet
    }
}

struct CreateSqlInjectionMatchSetOutputResponseBody: Equatable {
    public let sqlInjectionMatchSet: SqlInjectionMatchSet?
    public let changeToken: String?
}

extension CreateSqlInjectionMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sqlInjectionMatchSet = "SqlInjectionMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlInjectionMatchSetDecoded = try containerValues.decodeIfPresent(SqlInjectionMatchSet.self, forKey: .sqlInjectionMatchSet)
        sqlInjectionMatchSet = sqlInjectionMatchSetDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateWebACLInputBodyMiddleware: Middleware {
    public let id: String = "CreateWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLInput>
    public typealias MOutput = OperationOutput<CreateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLOutputError>
}

extension CreateWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebACLInput(changeToken: \(String(describing: changeToken)), defaultAction: \(String(describing: defaultAction)), metricName: \(String(describing: metricName)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case defaultAction = "DefaultAction"
        case metricName = "MetricName"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLInput>
    public typealias MOutput = OperationOutput<CreateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLOutputError>
}

public struct CreateWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLInput>
    public typealias MOutput = OperationOutput<CreateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLOutputError>
}

public struct CreateWebACLInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The action that you want  AWS WAF to take when a request doesn't match the criteria specified in any of the <code>Rule</code>
    /// 			objects that are associated with the <code>WebACL</code>.</p>
    public let defaultAction: WafAction?
    /// <p>A friendly name or description for the metrics for this <code>WebACL</code>.The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    /// 	        whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change <code>MetricName</code> after you create the
    ///             <code>WebACL</code>.</p>
    public let metricName: String?
    /// <p>A friendly name or description of the <a>WebACL</a>. You can't change <code>Name</code> after you create the <code>WebACL</code>.</p>
    public let name: String?
    /// <p></p>
    public let tags: [Tag]?

    public init (
        changeToken: String? = nil,
        defaultAction: WafAction? = nil,
        metricName: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.changeToken = changeToken
        self.defaultAction = defaultAction
        self.metricName = metricName
        self.name = name
        self.tags = tags
    }
}

struct CreateWebACLInputBody: Equatable {
    public let name: String?
    public let metricName: String?
    public let defaultAction: WafAction?
    public let changeToken: String?
    public let tags: [Tag]?
}

extension CreateWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case defaultAction = "DefaultAction"
        case metricName = "MetricName"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(WafAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateWebACLMigrationStackInputBodyMiddleware: Middleware {
    public let id: String = "CreateWebACLMigrationStackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLMigrationStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLMigrationStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLMigrationStackInput>
    public typealias MOutput = OperationOutput<CreateWebACLMigrationStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLMigrationStackOutputError>
}

extension CreateWebACLMigrationStackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebACLMigrationStackInput(ignoreUnsupportedType: \(String(describing: ignoreUnsupportedType)), s3BucketName: \(String(describing: s3BucketName)), webACLId: \(String(describing: webACLId)))"}
}

extension CreateWebACLMigrationStackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ignoreUnsupportedType = "IgnoreUnsupportedType"
        case s3BucketName = "S3BucketName"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignoreUnsupportedType = ignoreUnsupportedType {
            try encodeContainer.encode(ignoreUnsupportedType, forKey: .ignoreUnsupportedType)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let webACLId = webACLId {
            try encodeContainer.encode(webACLId, forKey: .webACLId)
        }
    }
}

public struct CreateWebACLMigrationStackInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWebACLMigrationStackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLMigrationStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLMigrationStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLMigrationStackInput>
    public typealias MOutput = OperationOutput<CreateWebACLMigrationStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLMigrationStackOutputError>
}

public struct CreateWebACLMigrationStackInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWebACLMigrationStackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebACLMigrationStackInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebACLMigrationStackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebACLMigrationStackInput>
    public typealias MOutput = OperationOutput<CreateWebACLMigrationStackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebACLMigrationStackOutputError>
}

public struct CreateWebACLMigrationStackInput: Equatable {
    /// <p>Indicates whether to exclude entities that can't be migrated or to stop the migration.
    ///            Set this to true to ignore unsupported entities in the web ACL during the migration. Otherwise, if AWS WAF encounters unsupported
    ///            entities, it stops the process and throws an exception. </p>
    public let ignoreUnsupportedType: Bool?
    /// <p>The name of the Amazon S3 bucket to store the CloudFormation template in. The S3 bucket must be
    ///            configured as follows for the migration:  </p>
    ///          <ul>
    ///             <li>
    ///                <p>The bucket name must start with <code>aws-waf-migration-</code>. For example, <code>aws-waf-migration-my-web-acl</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>The bucket must be in the Region where you are deploying the template. For example, for a web ACL in us-west-2, you must use an Amazon S3 bucket in us-west-2 and you must deploy the template stack to us-west-2. </p>
    ///             </li>
    ///             <li>
    ///                <p>The bucket policies must permit the migration process to write data. For listings of the
    ///        bucket policies, see the Examples section. </p>
    ///            </li>
    ///          </ul>
    public let s3BucketName: String?
    /// <p>The UUID of the WAF Classic web ACL that you want to migrate to WAF v2.</p>
    public let webACLId: String?

    public init (
        ignoreUnsupportedType: Bool? = nil,
        s3BucketName: String? = nil,
        webACLId: String? = nil
    )
    {
        self.ignoreUnsupportedType = ignoreUnsupportedType
        self.s3BucketName = s3BucketName
        self.webACLId = webACLId
    }
}

struct CreateWebACLMigrationStackInputBody: Equatable {
    public let webACLId: String?
    public let s3BucketName: String?
    public let ignoreUnsupportedType: Bool?
}

extension CreateWebACLMigrationStackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ignoreUnsupportedType = "IgnoreUnsupportedType"
        case s3BucketName = "S3BucketName"
        case webACLId = "WebACLId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let ignoreUnsupportedTypeDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ignoreUnsupportedType)
        ignoreUnsupportedType = ignoreUnsupportedTypeDecoded
    }
}

extension CreateWebACLMigrationStackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWebACLMigrationStackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFEntityMigrationException" : self = .wAFEntityMigrationException(try WAFEntityMigrationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWebACLMigrationStackOutputError: Equatable {
    case wAFEntityMigrationException(WAFEntityMigrationException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWebACLMigrationStackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebACLMigrationStackOutputResponse(s3ObjectUrl: \(String(describing: s3ObjectUrl)))"}
}

extension CreateWebACLMigrationStackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWebACLMigrationStackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.s3ObjectUrl = output.s3ObjectUrl
        } else {
            self.s3ObjectUrl = nil
        }
    }
}

public struct CreateWebACLMigrationStackOutputResponse: Equatable {
    /// <p>The URL of the template created in Amazon S3. </p>
    public let s3ObjectUrl: String?

    public init (
        s3ObjectUrl: String? = nil
    )
    {
        self.s3ObjectUrl = s3ObjectUrl
    }
}

struct CreateWebACLMigrationStackOutputResponseBody: Equatable {
    public let s3ObjectUrl: String?
}

extension CreateWebACLMigrationStackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3ObjectUrl = "S3ObjectUrl"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3ObjectUrl)
        s3ObjectUrl = s3ObjectUrlDecoded
    }
}

extension CreateWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFBadRequestException" : self = .wAFBadRequestException(try WAFBadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWebACLOutputError: Equatable {
    case wAFBadRequestException(WAFBadRequestException)
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebACLOutputResponse(changeToken: \(String(describing: changeToken)), webACL: \(String(describing: webACL)))"}
}

extension CreateWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWebACLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.webACL = output.webACL
        } else {
            self.changeToken = nil
            self.webACL = nil
        }
    }
}

public struct CreateWebACLOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateWebACL</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>The <a>WebACL</a> returned in the <code>CreateWebACL</code> response.</p>
    public let webACL: WebACL?

    public init (
        changeToken: String? = nil,
        webACL: WebACL? = nil
    )
    {
        self.changeToken = changeToken
        self.webACL = webACL
    }
}

struct CreateWebACLOutputResponseBody: Equatable {
    public let webACL: WebACL?
    public let changeToken: String?
}

extension CreateWebACLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case webACL = "WebACL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLDecoded = try containerValues.decodeIfPresent(WebACL.self, forKey: .webACL)
        webACL = webACLDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct CreateXssMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateXssMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateXssMatchSetInput>
    public typealias MOutput = OperationOutput<CreateXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateXssMatchSetOutputError>
}

extension CreateXssMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateXssMatchSetInput(changeToken: \(String(describing: changeToken)), name: \(String(describing: name)))"}
}

extension CreateXssMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateXssMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateXssMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateXssMatchSetInput>
    public typealias MOutput = OperationOutput<CreateXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateXssMatchSetOutputError>
}

public struct CreateXssMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateXssMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateXssMatchSetInput>
    public typealias MOutput = OperationOutput<CreateXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateXssMatchSetOutputError>
}

/// <p>A request to create an <a>XssMatchSet</a>.</p>
public struct CreateXssMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A friendly name or description for the <a>XssMatchSet</a> that you're creating. You can't change <code>Name</code>
    /// 			after you create the <code>XssMatchSet</code>.</p>
    public let name: String?

    public init (
        changeToken: String? = nil,
        name: String? = nil
    )
    {
        self.changeToken = changeToken
        self.name = name
    }
}

struct CreateXssMatchSetInputBody: Equatable {
    public let name: String?
    public let changeToken: String?
}

extension CreateXssMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension CreateXssMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateXssMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateXssMatchSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateXssMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateXssMatchSetOutputResponse(changeToken: \(String(describing: changeToken)), xssMatchSet: \(String(describing: xssMatchSet)))"}
}

extension CreateXssMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateXssMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
            self.xssMatchSet = output.xssMatchSet
        } else {
            self.changeToken = nil
            self.xssMatchSet = nil
        }
    }
}

/// <p>The response to a <code>CreateXssMatchSet</code> request.</p>
public struct CreateXssMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>CreateXssMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?
    /// <p>An <a>XssMatchSet</a>.</p>
    public let xssMatchSet: XssMatchSet?

    public init (
        changeToken: String? = nil,
        xssMatchSet: XssMatchSet? = nil
    )
    {
        self.changeToken = changeToken
        self.xssMatchSet = xssMatchSet
    }
}

struct CreateXssMatchSetOutputResponseBody: Equatable {
    public let xssMatchSet: XssMatchSet?
    public let changeToken: String?
}

extension CreateXssMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case xssMatchSet = "XssMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xssMatchSetDecoded = try containerValues.decodeIfPresent(XssMatchSet.self, forKey: .xssMatchSet)
        xssMatchSet = xssMatchSetDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteByteMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteByteMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteByteMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteByteMatchSetOutputError>
}

extension DeleteByteMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteByteMatchSetInput(byteMatchSetId: \(String(describing: byteMatchSetId)), changeToken: \(String(describing: changeToken)))"}
}

extension DeleteByteMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case byteMatchSetId = "ByteMatchSetId"
        case changeToken = "ChangeToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byteMatchSetId = byteMatchSetId {
            try encodeContainer.encode(byteMatchSetId, forKey: .byteMatchSetId)
        }
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
    }
}

public struct DeleteByteMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteByteMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteByteMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteByteMatchSetOutputError>
}

public struct DeleteByteMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteByteMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteByteMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteByteMatchSetOutputError>
}

public struct DeleteByteMatchSetInput: Equatable {
    /// <p>The <code>ByteMatchSetId</code> of the <a>ByteMatchSet</a> that you want to delete. <code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by
    /// 			<a>ListByteMatchSets</a>.</p>
    public let byteMatchSetId: String?
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?

    public init (
        byteMatchSetId: String? = nil,
        changeToken: String? = nil
    )
    {
        self.byteMatchSetId = byteMatchSetId
        self.changeToken = changeToken
    }
}

struct DeleteByteMatchSetInputBody: Equatable {
    public let byteMatchSetId: String?
    public let changeToken: String?
}

extension DeleteByteMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byteMatchSetId = "ByteMatchSetId"
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .byteMatchSetId)
        byteMatchSetId = byteMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteByteMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteByteMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteByteMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteByteMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteByteMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteByteMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteByteMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteByteMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteByteMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteByteMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteByteMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteGeoMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGeoMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGeoMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGeoMatchSetOutputError>
}

extension DeleteGeoMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGeoMatchSetInput(changeToken: \(String(describing: changeToken)), geoMatchSetId: \(String(describing: geoMatchSetId)))"}
}

extension DeleteGeoMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case geoMatchSetId = "GeoMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let geoMatchSetId = geoMatchSetId {
            try encodeContainer.encode(geoMatchSetId, forKey: .geoMatchSetId)
        }
    }
}

public struct DeleteGeoMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGeoMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGeoMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGeoMatchSetOutputError>
}

public struct DeleteGeoMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGeoMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGeoMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGeoMatchSetOutputError>
}

public struct DeleteGeoMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>GeoMatchSetID</code> of the <a>GeoMatchSet</a> that you want to delete. <code>GeoMatchSetId</code> is returned by <a>CreateGeoMatchSet</a> and by
    /// 			<a>ListGeoMatchSets</a>.</p>
    public let geoMatchSetId: String?

    public init (
        changeToken: String? = nil,
        geoMatchSetId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.geoMatchSetId = geoMatchSetId
    }
}

struct DeleteGeoMatchSetInputBody: Equatable {
    public let geoMatchSetId: String?
    public let changeToken: String?
}

extension DeleteGeoMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case geoMatchSetId = "GeoMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .geoMatchSetId)
        geoMatchSetId = geoMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteGeoMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGeoMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGeoMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGeoMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGeoMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteGeoMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteGeoMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteGeoMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteGeoMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteGeoMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteGeoMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteIPSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIPSetInput>
    public typealias MOutput = OperationOutput<DeleteIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIPSetOutputError>
}

extension DeleteIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIPSetInput(changeToken: \(String(describing: changeToken)), iPSetId: \(String(describing: iPSetId)))"}
}

extension DeleteIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case iPSetId = "IPSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let iPSetId = iPSetId {
            try encodeContainer.encode(iPSetId, forKey: .iPSetId)
        }
    }
}

public struct DeleteIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIPSetInput>
    public typealias MOutput = OperationOutput<DeleteIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIPSetOutputError>
}

public struct DeleteIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIPSetInput>
    public typealias MOutput = OperationOutput<DeleteIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIPSetOutputError>
}

public struct DeleteIPSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>IPSetId</code> of the <a>IPSet</a> that you want to delete. <code>IPSetId</code> is returned by <a>CreateIPSet</a> and by
    /// 			<a>ListIPSets</a>.</p>
    public let iPSetId: String?

    public init (
        changeToken: String? = nil,
        iPSetId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.iPSetId = iPSetId
    }
}

struct DeleteIPSetInputBody: Equatable {
    public let iPSetId: String?
    public let changeToken: String?
}

extension DeleteIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case iPSetId = "IPSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPSetId)
        iPSetId = iPSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIPSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIPSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteIPSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteIPSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteIPSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteIPSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteLoggingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoggingConfigurationOutputError>
}

extension DeleteLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoggingConfigurationInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeleteLoggingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeleteLoggingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoggingConfigurationOutputError>
}

public struct DeleteLoggingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoggingConfigurationOutputError>
}

public struct DeleteLoggingConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the web ACL from which you want to delete the <a>LoggingConfiguration</a>.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteLoggingConfigurationInputBody: Equatable {
    public let resourceArn: String?
}

extension DeleteLoggingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteLoggingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLoggingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoggingConfigurationOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoggingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoggingConfigurationOutputResponse()"}
}

extension DeleteLoggingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoggingConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeleteLoggingConfigurationOutputResponseBody: Equatable {
}

extension DeleteLoggingConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePermissionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeletePermissionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionPolicyInput>
    public typealias MOutput = OperationOutput<DeletePermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionPolicyOutputError>
}

extension DeletePermissionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePermissionPolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeletePermissionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeletePermissionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePermissionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionPolicyInput>
    public typealias MOutput = OperationOutput<DeletePermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionPolicyOutputError>
}

public struct DeletePermissionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePermissionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePermissionPolicyInput>
    public typealias MOutput = OperationOutput<DeletePermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePermissionPolicyOutputError>
}

public struct DeletePermissionPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the RuleGroup from which you want to delete the policy.</p>
    ///          <p>The user making the request must be the owner of the RuleGroup.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeletePermissionPolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension DeletePermissionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeletePermissionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePermissionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePermissionPolicyOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePermissionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePermissionPolicyOutputResponse()"}
}

extension DeletePermissionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePermissionPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeletePermissionPolicyOutputResponseBody: Equatable {
}

extension DeletePermissionPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRateBasedRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRateBasedRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRateBasedRuleInput>
    public typealias MOutput = OperationOutput<DeleteRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRateBasedRuleOutputError>
}

extension DeleteRateBasedRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRateBasedRuleInput(changeToken: \(String(describing: changeToken)), ruleId: \(String(describing: ruleId)))"}
}

extension DeleteRateBasedRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }
}

public struct DeleteRateBasedRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRateBasedRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRateBasedRuleInput>
    public typealias MOutput = OperationOutput<DeleteRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRateBasedRuleOutputError>
}

public struct DeleteRateBasedRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRateBasedRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRateBasedRuleInput>
    public typealias MOutput = OperationOutput<DeleteRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRateBasedRuleOutputError>
}

public struct DeleteRateBasedRuleInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RuleId</code> of the <a>RateBasedRule</a> that you want to
    ///          delete. <code>RuleId</code> is returned by <a>CreateRateBasedRule</a> and by
    ///             <a>ListRateBasedRules</a>.</p>
    public let ruleId: String?

    public init (
        changeToken: String? = nil,
        ruleId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.ruleId = ruleId
    }
}

struct DeleteRateBasedRuleInputBody: Equatable {
    public let ruleId: String?
    public let changeToken: String?
}

extension DeleteRateBasedRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleId = "RuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteRateBasedRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRateBasedRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRateBasedRuleOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRateBasedRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRateBasedRuleOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteRateBasedRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRateBasedRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteRateBasedRuleOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the
    ///             <code>DeleteRateBasedRule</code> request. You can also use this value to query the
    ///          status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteRateBasedRuleOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteRateBasedRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteRegexMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRegexMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexMatchSetOutputError>
}

extension DeleteRegexMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegexMatchSetInput(changeToken: \(String(describing: changeToken)), regexMatchSetId: \(String(describing: regexMatchSetId)))"}
}

extension DeleteRegexMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexMatchSetId = "RegexMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let regexMatchSetId = regexMatchSetId {
            try encodeContainer.encode(regexMatchSetId, forKey: .regexMatchSetId)
        }
    }
}

public struct DeleteRegexMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRegexMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexMatchSetOutputError>
}

public struct DeleteRegexMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRegexMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexMatchSetOutputError>
}

public struct DeleteRegexMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RegexMatchSetId</code> of the <a>RegexMatchSet</a> that you want to delete. <code>RegexMatchSetId</code> is returned by <a>CreateRegexMatchSet</a> and by
    /// 			<a>ListRegexMatchSets</a>.</p>
    public let regexMatchSetId: String?

    public init (
        changeToken: String? = nil,
        regexMatchSetId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.regexMatchSetId = regexMatchSetId
    }
}

struct DeleteRegexMatchSetInputBody: Equatable {
    public let regexMatchSetId: String?
    public let changeToken: String?
}

extension DeleteRegexMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexMatchSetId = "RegexMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexMatchSetId)
        regexMatchSetId = regexMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteRegexMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegexMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegexMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegexMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegexMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteRegexMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRegexMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteRegexMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteRegexMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteRegexMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteRegexMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteRegexPatternSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRegexPatternSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexPatternSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexPatternSetOutputError>
}

extension DeleteRegexPatternSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegexPatternSetInput(changeToken: \(String(describing: changeToken)), regexPatternSetId: \(String(describing: regexPatternSetId)))"}
}

extension DeleteRegexPatternSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexPatternSetId = "RegexPatternSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let regexPatternSetId = regexPatternSetId {
            try encodeContainer.encode(regexPatternSetId, forKey: .regexPatternSetId)
        }
    }
}

public struct DeleteRegexPatternSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRegexPatternSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexPatternSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexPatternSetOutputError>
}

public struct DeleteRegexPatternSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRegexPatternSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRegexPatternSetInput>
    public typealias MOutput = OperationOutput<DeleteRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRegexPatternSetOutputError>
}

public struct DeleteRegexPatternSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RegexPatternSetId</code> of the <a>RegexPatternSet</a> that you want to delete. <code>RegexPatternSetId</code> is returned by <a>CreateRegexPatternSet</a> and by
    /// 			<a>ListRegexPatternSets</a>.</p>
    public let regexPatternSetId: String?

    public init (
        changeToken: String? = nil,
        regexPatternSetId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.regexPatternSetId = regexPatternSetId
    }
}

struct DeleteRegexPatternSetInputBody: Equatable {
    public let regexPatternSetId: String?
    public let changeToken: String?
}

extension DeleteRegexPatternSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexPatternSetId = "RegexPatternSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexPatternSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexPatternSetId)
        regexPatternSetId = regexPatternSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteRegexPatternSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegexPatternSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegexPatternSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegexPatternSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegexPatternSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteRegexPatternSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRegexPatternSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteRegexPatternSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteRegexPatternSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteRegexPatternSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteRegexPatternSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

extension DeleteRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleGroupInput(changeToken: \(String(describing: changeToken)), ruleGroupId: \(String(describing: ruleGroupId)))"}
}

extension DeleteRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleGroupId = "RuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let ruleGroupId = ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
    }
}

public struct DeleteRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

public struct DeleteRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

public struct DeleteRuleGroupInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RuleGroupId</code> of the <a>RuleGroup</a> that you want to delete. <code>RuleGroupId</code> is returned by <a>CreateRuleGroup</a> and by
    ///          <a>ListRuleGroups</a>.</p>
    public let ruleGroupId: String?

    public init (
        changeToken: String? = nil,
        ruleGroupId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.ruleGroupId = ruleGroupId
    }
}

struct DeleteRuleGroupInputBody: Equatable {
    public let ruleGroupId: String?
    public let changeToken: String?
}

extension DeleteRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleGroupId = "RuleGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleGroupOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleGroupOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteRuleGroupOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteRuleGroup</code> request. You can also use this value
    ///          to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteRuleGroupOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

extension DeleteRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleInput(changeToken: \(String(describing: changeToken)), ruleId: \(String(describing: ruleId)))"}
}

extension DeleteRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }
}

public struct DeleteRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RuleId</code> of the <a>Rule</a> that you want to delete. <code>RuleId</code> is returned by <a>CreateRule</a> and by
    /// 			<a>ListRules</a>.</p>
    public let ruleId: String?

    public init (
        changeToken: String? = nil,
        ruleId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.ruleId = ruleId
    }
}

struct DeleteRuleInputBody: Equatable {
    public let ruleId: String?
    public let changeToken: String?
}

extension DeleteRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleId = "RuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteRuleOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteRule</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteRuleOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteSizeConstraintSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSizeConstraintSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<DeleteSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSizeConstraintSetOutputError>
}

extension DeleteSizeConstraintSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSizeConstraintSetInput(changeToken: \(String(describing: changeToken)), sizeConstraintSetId: \(String(describing: sizeConstraintSetId)))"}
}

extension DeleteSizeConstraintSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sizeConstraintSetId = "SizeConstraintSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let sizeConstraintSetId = sizeConstraintSetId {
            try encodeContainer.encode(sizeConstraintSetId, forKey: .sizeConstraintSetId)
        }
    }
}

public struct DeleteSizeConstraintSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSizeConstraintSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<DeleteSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSizeConstraintSetOutputError>
}

public struct DeleteSizeConstraintSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSizeConstraintSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<DeleteSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSizeConstraintSetOutputError>
}

public struct DeleteSizeConstraintSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>SizeConstraintSetId</code> of the <a>SizeConstraintSet</a> that you want to delete. <code>SizeConstraintSetId</code>
    /// 			is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>
    public let sizeConstraintSetId: String?

    public init (
        changeToken: String? = nil,
        sizeConstraintSetId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.sizeConstraintSetId = sizeConstraintSetId
    }
}

struct DeleteSizeConstraintSetInputBody: Equatable {
    public let sizeConstraintSetId: String?
    public let changeToken: String?
}

extension DeleteSizeConstraintSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sizeConstraintSetId = "SizeConstraintSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeConstraintSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizeConstraintSetId)
        sizeConstraintSetId = sizeConstraintSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteSizeConstraintSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSizeConstraintSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSizeConstraintSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSizeConstraintSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSizeConstraintSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteSizeConstraintSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSizeConstraintSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteSizeConstraintSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteSizeConstraintSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteSizeConstraintSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteSizeConstraintSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteSqlInjectionMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSqlInjectionMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSqlInjectionMatchSetOutputError>
}

extension DeleteSqlInjectionMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSqlInjectionMatchSetInput(changeToken: \(String(describing: changeToken)), sqlInjectionMatchSetId: \(String(describing: sqlInjectionMatchSetId)))"}
}

extension DeleteSqlInjectionMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let sqlInjectionMatchSetId = sqlInjectionMatchSetId {
            try encodeContainer.encode(sqlInjectionMatchSetId, forKey: .sqlInjectionMatchSetId)
        }
    }
}

public struct DeleteSqlInjectionMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSqlInjectionMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSqlInjectionMatchSetOutputError>
}

public struct DeleteSqlInjectionMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSqlInjectionMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSqlInjectionMatchSetOutputError>
}

/// <p>A request to delete a <a>SqlInjectionMatchSet</a> from AWS WAF.</p>
public struct DeleteSqlInjectionMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>SqlInjectionMatchSetId</code> of the <a>SqlInjectionMatchSet</a> that you want to delete.
    /// 			<code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>
    public let sqlInjectionMatchSetId: String?

    public init (
        changeToken: String? = nil,
        sqlInjectionMatchSetId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
    }
}

struct DeleteSqlInjectionMatchSetInputBody: Equatable {
    public let sqlInjectionMatchSetId: String?
    public let changeToken: String?
}

extension DeleteSqlInjectionMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlInjectionMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlInjectionMatchSetId)
        sqlInjectionMatchSetId = sqlInjectionMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteSqlInjectionMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSqlInjectionMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSqlInjectionMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSqlInjectionMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSqlInjectionMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteSqlInjectionMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSqlInjectionMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

/// <p>The response to a request to delete a <a>SqlInjectionMatchSet</a> from AWS WAF.</p>
public struct DeleteSqlInjectionMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteSqlInjectionMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteSqlInjectionMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteSqlInjectionMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteWebACLInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebACLInput>
    public typealias MOutput = OperationOutput<DeleteWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebACLOutputError>
}

extension DeleteWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebACLInput(changeToken: \(String(describing: changeToken)), webACLId: \(String(describing: webACLId)))"}
}

extension DeleteWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let webACLId = webACLId {
            try encodeContainer.encode(webACLId, forKey: .webACLId)
        }
    }
}

public struct DeleteWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebACLInput>
    public typealias MOutput = OperationOutput<DeleteWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebACLOutputError>
}

public struct DeleteWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebACLInput>
    public typealias MOutput = OperationOutput<DeleteWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebACLOutputError>
}

public struct DeleteWebACLInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>WebACLId</code> of the <a>WebACL</a> that you want to delete. <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by
    /// 			<a>ListWebACLs</a>.</p>
    public let webACLId: String?

    public init (
        changeToken: String? = nil,
        webACLId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.webACLId = webACLId
    }
}

struct DeleteWebACLInputBody: Equatable {
    public let webACLId: String?
    public let changeToken: String?
}

extension DeleteWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case webACLId = "WebACLId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWebACLOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebACLOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteWebACLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct DeleteWebACLOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteWebACL</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteWebACLOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteWebACLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct DeleteXssMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteXssMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteXssMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteXssMatchSetOutputError>
}

extension DeleteXssMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteXssMatchSetInput(changeToken: \(String(describing: changeToken)), xssMatchSetId: \(String(describing: xssMatchSetId)))"}
}

extension DeleteXssMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case xssMatchSetId = "XssMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let xssMatchSetId = xssMatchSetId {
            try encodeContainer.encode(xssMatchSetId, forKey: .xssMatchSetId)
        }
    }
}

public struct DeleteXssMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteXssMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteXssMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteXssMatchSetOutputError>
}

public struct DeleteXssMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteXssMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteXssMatchSetInput>
    public typealias MOutput = OperationOutput<DeleteXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteXssMatchSetOutputError>
}

/// <p>A request to delete an <a>XssMatchSet</a> from AWS WAF.</p>
public struct DeleteXssMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>XssMatchSetId</code> of the <a>XssMatchSet</a> that you want to delete.
    /// 			<code>XssMatchSetId</code> is returned by <a>CreateXssMatchSet</a> and by <a>ListXssMatchSets</a>.</p>
    public let xssMatchSetId: String?

    public init (
        changeToken: String? = nil,
        xssMatchSetId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.xssMatchSetId = xssMatchSetId
    }
}

struct DeleteXssMatchSetInputBody: Equatable {
    public let xssMatchSetId: String?
    public let changeToken: String?
}

extension DeleteXssMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case xssMatchSetId = "XssMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xssMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .xssMatchSetId)
        xssMatchSetId = xssMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension DeleteXssMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteXssMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonEmptyEntityException" : self = .wAFNonEmptyEntityException(try WAFNonEmptyEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteXssMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonEmptyEntityException(WAFNonEmptyEntityException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteXssMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteXssMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension DeleteXssMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteXssMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

/// <p>The response to a request to delete an <a>XssMatchSet</a> from AWS WAF.</p>
public struct DeleteXssMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>DeleteXssMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct DeleteXssMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension DeleteXssMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension ExcludedRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension ExcludedRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExcludedRule(ruleId: \(String(describing: ruleId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>The rule to exclude from a rule group. This is applicable only when the
///             <code>ActivatedRule</code> refers to a <code>RuleGroup</code>. The rule must belong to
///          the <code>RuleGroup</code> that is specified by the <code>ActivatedRule</code>. </p>
public struct ExcludedRule: Equatable {
    /// <p>The unique identifier for the rule to exclude from the rule group.</p>
    public let ruleId: String?

    public init (
        ruleId: String? = nil
    )
    {
        self.ruleId = ruleId
    }
}

extension FieldToMatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MatchFieldType.self, forKey: .type)
        type = typeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
    }
}

extension FieldToMatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FieldToMatch(data: \(String(describing: data)), type: \(String(describing: type)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies where in a web request to look for <code>TargetString</code>.</p>
public struct FieldToMatch: Equatable {
    /// <p>When the value of <code>Type</code> is <code>HEADER</code>, enter the name of the header that you want AWS WAF to search,
    /// 			for example, <code>User-Agent</code> or <code>Referer</code>. The name of the header is not case sensitive.</p>
    /// 	        <p>When the value of <code>Type</code> is <code>SINGLE_QUERY_ARG</code>, enter the name of the parameter that you want AWS WAF to search,
    /// 	        for example, <code>UserName</code> or <code>SalesRegion</code>. The parameter name is not case sensitive.</p>
    /// 	        <p>If the value of <code>Type</code> is any other value, omit <code>Data</code>.</p>
    public let data: String?
    /// <p>The part of the web request that you want AWS WAF to search for a specified string. Parts of a request that you can search include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HEADER</code>: A specified request header, for example, the value of the <code>User-Agent</code> or <code>Referer</code> header.
    /// 				If you choose <code>HEADER</code> for the type, specify the name of the header in <code>Data</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>METHOD</code>: The HTTP method, which indicated the type of operation that the request is asking the origin to perform.
    /// 				Amazon CloudFront supports the following methods: <code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>,
    /// 				<code>POST</code>, and <code>PUT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>QUERY_STRING</code>: A query string, which is the part of a URL that appears after a <code>?</code> character, if any.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>URI</code>: The part of a web request that identifies a resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BODY</code>: The part of a request that contains any additional data that you want to send to your web server
    /// 				as the HTTP request body, such as data from a form. The request body immediately follows the request headers.
    /// 				Note that only the first <code>8192</code> bytes of the request body are forwarded to AWS WAF for inspection.
    /// 				To allow or block requests based on the length of the body, you can create a size constraint set.
    /// 				For more information, see <a>CreateSizeConstraintSet</a>. </p>
    ///             </li>
    ///             <li>
    /// 		             <p>
    /// 		                <code>SINGLE_QUERY_ARG</code>: The parameter in the query string that you will inspect, such as <i>UserName</i> or <i>SalesRegion</i>. The maximum length for <code>SINGLE_QUERY_ARG</code> is 30 characters.</p>
    /// 		          </li>
    ///             <li>
    /// 		             <p>
    /// 		                <code>ALL_QUERY_ARGS</code>: Similar to <code>SINGLE_QUERY_ARG</code>, but rather than inspecting a single parameter, AWS WAF will inspect all parameters within the query for the value or regex pattern that you specify in
    /// 		             <code>TargetString</code>.</p>
    /// 		          </li>
    ///          </ul>
    public let type: MatchFieldType?

    public init (
        data: String? = nil,
        type: MatchFieldType? = nil
    )
    {
        self.data = data
        self.type = type
    }
}

extension GeoMatchConstraint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value.rawValue, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(GeoMatchConstraintType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(GeoMatchConstraintValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension GeoMatchConstraint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoMatchConstraint(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>The country from which web requests originate that you want AWS WAF to search for.</p>
public struct GeoMatchConstraint: Equatable {
    /// <p>The type of geographical area you want AWS WAF to search for. Currently <code>Country</code> is the only valid value.</p>
    public let type: GeoMatchConstraintType?
    /// <p>The country that you want AWS WAF to search for.</p>
    public let value: GeoMatchConstraintValue?

    public init (
        type: GeoMatchConstraintType? = nil,
        value: GeoMatchConstraintValue? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum GeoMatchConstraintType {
    case country
    case sdkUnknown(String)
}

extension GeoMatchConstraintType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GeoMatchConstraintType] {
        return [
            .country,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .country: return "Country"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GeoMatchConstraintType(rawValue: rawValue) ?? GeoMatchConstraintType.sdkUnknown(rawValue)
    }
}

public enum GeoMatchConstraintValue {
    case ad
    case ae
    case af
    case ag
    case ai
    case al
    case am
    case ao
    case aq
    case ar
    case `as`
    case at
    case au
    case aw
    case ax
    case az
    case ba
    case bb
    case bd
    case be
    case bf
    case bg
    case bh
    case bi
    case bj
    case bl
    case bm
    case bn
    case bo
    case bq
    case br
    case bs
    case bt
    case bv
    case bw
    case by
    case bz
    case ca
    case cc
    case cd
    case cf
    case cg
    case ch
    case ci
    case ck
    case cl
    case cm
    case cn
    case co
    case cr
    case cu
    case cv
    case cw
    case cx
    case cy
    case cz
    case de
    case dj
    case dk
    case dm
    case `do`
    case dz
    case ec
    case ee
    case eg
    case eh
    case er
    case es
    case et
    case fi
    case fj
    case fk
    case fm
    case fo
    case fr
    case ga
    case gb
    case gd
    case ge
    case gf
    case gg
    case gh
    case gi
    case gl
    case gm
    case gn
    case gp
    case gq
    case gr
    case gs
    case gt
    case gu
    case gw
    case gy
    case hk
    case hm
    case hn
    case hr
    case ht
    case hu
    case id
    case ie
    case il
    case im
    case `in`
    case io
    case iq
    case ir
    case `is`
    case it
    case je
    case jm
    case jo
    case jp
    case ke
    case kg
    case kh
    case ki
    case km
    case kn
    case kp
    case kr
    case kw
    case ky
    case kz
    case la
    case lb
    case lc
    case li
    case lk
    case lr
    case ls
    case lt
    case lu
    case lv
    case ly
    case ma
    case mc
    case md
    case me
    case mf
    case mg
    case mh
    case mk
    case ml
    case mm
    case mn
    case mo
    case mp
    case mq
    case mr
    case ms
    case mt
    case mu
    case mv
    case mw
    case mx
    case my
    case mz
    case na
    case nc
    case ne
    case nf
    case ng
    case ni
    case nl
    case no
    case np
    case nr
    case nu
    case nz
    case om
    case pa
    case pe
    case pf
    case pg
    case ph
    case pk
    case pl
    case pm
    case pn
    case pr
    case ps
    case pt
    case pw
    case py
    case qa
    case re
    case ro
    case rs
    case ru
    case rw
    case sa
    case sb
    case sc
    case sd
    case se
    case sg
    case sh
    case si
    case sj
    case sk
    case sl
    case sm
    case sn
    case so
    case sr
    case ss
    case st
    case sv
    case sx
    case sy
    case sz
    case tc
    case td
    case tf
    case tg
    case th
    case tj
    case tk
    case tl
    case tm
    case tn
    case to
    case tr
    case tt
    case tv
    case tw
    case tz
    case ua
    case ug
    case um
    case us
    case uy
    case uz
    case va
    case vc
    case ve
    case vg
    case vi
    case vn
    case vu
    case wf
    case ws
    case ye
    case yt
    case za
    case zm
    case zw
    case sdkUnknown(String)
}

extension GeoMatchConstraintValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GeoMatchConstraintValue] {
        return [
            .ad,
            .ae,
            .af,
            .ag,
            .ai,
            .al,
            .am,
            .ao,
            .aq,
            .ar,
            .as,
            .at,
            .au,
            .aw,
            .ax,
            .az,
            .ba,
            .bb,
            .bd,
            .be,
            .bf,
            .bg,
            .bh,
            .bi,
            .bj,
            .bl,
            .bm,
            .bn,
            .bo,
            .bq,
            .br,
            .bs,
            .bt,
            .bv,
            .bw,
            .by,
            .bz,
            .ca,
            .cc,
            .cd,
            .cf,
            .cg,
            .ch,
            .ci,
            .ck,
            .cl,
            .cm,
            .cn,
            .co,
            .cr,
            .cu,
            .cv,
            .cw,
            .cx,
            .cy,
            .cz,
            .de,
            .dj,
            .dk,
            .dm,
            .do,
            .dz,
            .ec,
            .ee,
            .eg,
            .eh,
            .er,
            .es,
            .et,
            .fi,
            .fj,
            .fk,
            .fm,
            .fo,
            .fr,
            .ga,
            .gb,
            .gd,
            .ge,
            .gf,
            .gg,
            .gh,
            .gi,
            .gl,
            .gm,
            .gn,
            .gp,
            .gq,
            .gr,
            .gs,
            .gt,
            .gu,
            .gw,
            .gy,
            .hk,
            .hm,
            .hn,
            .hr,
            .ht,
            .hu,
            .id,
            .ie,
            .il,
            .im,
            .in,
            .io,
            .iq,
            .ir,
            .is,
            .it,
            .je,
            .jm,
            .jo,
            .jp,
            .ke,
            .kg,
            .kh,
            .ki,
            .km,
            .kn,
            .kp,
            .kr,
            .kw,
            .ky,
            .kz,
            .la,
            .lb,
            .lc,
            .li,
            .lk,
            .lr,
            .ls,
            .lt,
            .lu,
            .lv,
            .ly,
            .ma,
            .mc,
            .md,
            .me,
            .mf,
            .mg,
            .mh,
            .mk,
            .ml,
            .mm,
            .mn,
            .mo,
            .mp,
            .mq,
            .mr,
            .ms,
            .mt,
            .mu,
            .mv,
            .mw,
            .mx,
            .my,
            .mz,
            .na,
            .nc,
            .ne,
            .nf,
            .ng,
            .ni,
            .nl,
            .no,
            .np,
            .nr,
            .nu,
            .nz,
            .om,
            .pa,
            .pe,
            .pf,
            .pg,
            .ph,
            .pk,
            .pl,
            .pm,
            .pn,
            .pr,
            .ps,
            .pt,
            .pw,
            .py,
            .qa,
            .re,
            .ro,
            .rs,
            .ru,
            .rw,
            .sa,
            .sb,
            .sc,
            .sd,
            .se,
            .sg,
            .sh,
            .si,
            .sj,
            .sk,
            .sl,
            .sm,
            .sn,
            .so,
            .sr,
            .ss,
            .st,
            .sv,
            .sx,
            .sy,
            .sz,
            .tc,
            .td,
            .tf,
            .tg,
            .th,
            .tj,
            .tk,
            .tl,
            .tm,
            .tn,
            .to,
            .tr,
            .tt,
            .tv,
            .tw,
            .tz,
            .ua,
            .ug,
            .um,
            .us,
            .uy,
            .uz,
            .va,
            .vc,
            .ve,
            .vg,
            .vi,
            .vn,
            .vu,
            .wf,
            .ws,
            .ye,
            .yt,
            .za,
            .zm,
            .zw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ad: return "AD"
        case .ae: return "AE"
        case .af: return "AF"
        case .ag: return "AG"
        case .ai: return "AI"
        case .al: return "AL"
        case .am: return "AM"
        case .ao: return "AO"
        case .aq: return "AQ"
        case .ar: return "AR"
        case .as: return "AS"
        case .at: return "AT"
        case .au: return "AU"
        case .aw: return "AW"
        case .ax: return "AX"
        case .az: return "AZ"
        case .ba: return "BA"
        case .bb: return "BB"
        case .bd: return "BD"
        case .be: return "BE"
        case .bf: return "BF"
        case .bg: return "BG"
        case .bh: return "BH"
        case .bi: return "BI"
        case .bj: return "BJ"
        case .bl: return "BL"
        case .bm: return "BM"
        case .bn: return "BN"
        case .bo: return "BO"
        case .bq: return "BQ"
        case .br: return "BR"
        case .bs: return "BS"
        case .bt: return "BT"
        case .bv: return "BV"
        case .bw: return "BW"
        case .by: return "BY"
        case .bz: return "BZ"
        case .ca: return "CA"
        case .cc: return "CC"
        case .cd: return "CD"
        case .cf: return "CF"
        case .cg: return "CG"
        case .ch: return "CH"
        case .ci: return "CI"
        case .ck: return "CK"
        case .cl: return "CL"
        case .cm: return "CM"
        case .cn: return "CN"
        case .co: return "CO"
        case .cr: return "CR"
        case .cu: return "CU"
        case .cv: return "CV"
        case .cw: return "CW"
        case .cx: return "CX"
        case .cy: return "CY"
        case .cz: return "CZ"
        case .de: return "DE"
        case .dj: return "DJ"
        case .dk: return "DK"
        case .dm: return "DM"
        case .do: return "DO"
        case .dz: return "DZ"
        case .ec: return "EC"
        case .ee: return "EE"
        case .eg: return "EG"
        case .eh: return "EH"
        case .er: return "ER"
        case .es: return "ES"
        case .et: return "ET"
        case .fi: return "FI"
        case .fj: return "FJ"
        case .fk: return "FK"
        case .fm: return "FM"
        case .fo: return "FO"
        case .fr: return "FR"
        case .ga: return "GA"
        case .gb: return "GB"
        case .gd: return "GD"
        case .ge: return "GE"
        case .gf: return "GF"
        case .gg: return "GG"
        case .gh: return "GH"
        case .gi: return "GI"
        case .gl: return "GL"
        case .gm: return "GM"
        case .gn: return "GN"
        case .gp: return "GP"
        case .gq: return "GQ"
        case .gr: return "GR"
        case .gs: return "GS"
        case .gt: return "GT"
        case .gu: return "GU"
        case .gw: return "GW"
        case .gy: return "GY"
        case .hk: return "HK"
        case .hm: return "HM"
        case .hn: return "HN"
        case .hr: return "HR"
        case .ht: return "HT"
        case .hu: return "HU"
        case .id: return "ID"
        case .ie: return "IE"
        case .il: return "IL"
        case .im: return "IM"
        case .in: return "IN"
        case .io: return "IO"
        case .iq: return "IQ"
        case .ir: return "IR"
        case .is: return "IS"
        case .it: return "IT"
        case .je: return "JE"
        case .jm: return "JM"
        case .jo: return "JO"
        case .jp: return "JP"
        case .ke: return "KE"
        case .kg: return "KG"
        case .kh: return "KH"
        case .ki: return "KI"
        case .km: return "KM"
        case .kn: return "KN"
        case .kp: return "KP"
        case .kr: return "KR"
        case .kw: return "KW"
        case .ky: return "KY"
        case .kz: return "KZ"
        case .la: return "LA"
        case .lb: return "LB"
        case .lc: return "LC"
        case .li: return "LI"
        case .lk: return "LK"
        case .lr: return "LR"
        case .ls: return "LS"
        case .lt: return "LT"
        case .lu: return "LU"
        case .lv: return "LV"
        case .ly: return "LY"
        case .ma: return "MA"
        case .mc: return "MC"
        case .md: return "MD"
        case .me: return "ME"
        case .mf: return "MF"
        case .mg: return "MG"
        case .mh: return "MH"
        case .mk: return "MK"
        case .ml: return "ML"
        case .mm: return "MM"
        case .mn: return "MN"
        case .mo: return "MO"
        case .mp: return "MP"
        case .mq: return "MQ"
        case .mr: return "MR"
        case .ms: return "MS"
        case .mt: return "MT"
        case .mu: return "MU"
        case .mv: return "MV"
        case .mw: return "MW"
        case .mx: return "MX"
        case .my: return "MY"
        case .mz: return "MZ"
        case .na: return "NA"
        case .nc: return "NC"
        case .ne: return "NE"
        case .nf: return "NF"
        case .ng: return "NG"
        case .ni: return "NI"
        case .nl: return "NL"
        case .no: return "NO"
        case .np: return "NP"
        case .nr: return "NR"
        case .nu: return "NU"
        case .nz: return "NZ"
        case .om: return "OM"
        case .pa: return "PA"
        case .pe: return "PE"
        case .pf: return "PF"
        case .pg: return "PG"
        case .ph: return "PH"
        case .pk: return "PK"
        case .pl: return "PL"
        case .pm: return "PM"
        case .pn: return "PN"
        case .pr: return "PR"
        case .ps: return "PS"
        case .pt: return "PT"
        case .pw: return "PW"
        case .py: return "PY"
        case .qa: return "QA"
        case .re: return "RE"
        case .ro: return "RO"
        case .rs: return "RS"
        case .ru: return "RU"
        case .rw: return "RW"
        case .sa: return "SA"
        case .sb: return "SB"
        case .sc: return "SC"
        case .sd: return "SD"
        case .se: return "SE"
        case .sg: return "SG"
        case .sh: return "SH"
        case .si: return "SI"
        case .sj: return "SJ"
        case .sk: return "SK"
        case .sl: return "SL"
        case .sm: return "SM"
        case .sn: return "SN"
        case .so: return "SO"
        case .sr: return "SR"
        case .ss: return "SS"
        case .st: return "ST"
        case .sv: return "SV"
        case .sx: return "SX"
        case .sy: return "SY"
        case .sz: return "SZ"
        case .tc: return "TC"
        case .td: return "TD"
        case .tf: return "TF"
        case .tg: return "TG"
        case .th: return "TH"
        case .tj: return "TJ"
        case .tk: return "TK"
        case .tl: return "TL"
        case .tm: return "TM"
        case .tn: return "TN"
        case .to: return "TO"
        case .tr: return "TR"
        case .tt: return "TT"
        case .tv: return "TV"
        case .tw: return "TW"
        case .tz: return "TZ"
        case .ua: return "UA"
        case .ug: return "UG"
        case .um: return "UM"
        case .us: return "US"
        case .uy: return "UY"
        case .uz: return "UZ"
        case .va: return "VA"
        case .vc: return "VC"
        case .ve: return "VE"
        case .vg: return "VG"
        case .vi: return "VI"
        case .vn: return "VN"
        case .vu: return "VU"
        case .wf: return "WF"
        case .ws: return "WS"
        case .ye: return "YE"
        case .yt: return "YT"
        case .za: return "ZA"
        case .zm: return "ZM"
        case .zw: return "ZW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GeoMatchConstraintValue(rawValue: rawValue) ?? GeoMatchConstraintValue.sdkUnknown(rawValue)
    }
}

extension GeoMatchSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case geoMatchConstraints = "GeoMatchConstraints"
        case geoMatchSetId = "GeoMatchSetId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geoMatchConstraints = geoMatchConstraints {
            var geoMatchConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .geoMatchConstraints)
            for geomatchconstraints0 in geoMatchConstraints {
                try geoMatchConstraintsContainer.encode(geomatchconstraints0)
            }
        }
        if let geoMatchSetId = geoMatchSetId {
            try encodeContainer.encode(geoMatchSetId, forKey: .geoMatchSetId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .geoMatchSetId)
        geoMatchSetId = geoMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let geoMatchConstraintsContainer = try containerValues.decodeIfPresent([GeoMatchConstraint?].self, forKey: .geoMatchConstraints)
        var geoMatchConstraintsDecoded0:[GeoMatchConstraint]? = nil
        if let geoMatchConstraintsContainer = geoMatchConstraintsContainer {
            geoMatchConstraintsDecoded0 = [GeoMatchConstraint]()
            for structure0 in geoMatchConstraintsContainer {
                if let structure0 = structure0 {
                    geoMatchConstraintsDecoded0?.append(structure0)
                }
            }
        }
        geoMatchConstraints = geoMatchConstraintsDecoded0
    }
}

extension GeoMatchSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoMatchSet(geoMatchConstraints: \(String(describing: geoMatchConstraints)), geoMatchSetId: \(String(describing: geoMatchSetId)), name: \(String(describing: name)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>Contains one or more countries that AWS WAF will search for.</p>
public struct GeoMatchSet: Equatable {
    /// <p>An array of <a>GeoMatchConstraint</a> objects, which contain the country that you want AWS WAF to search for.</p>
    public let geoMatchConstraints: [GeoMatchConstraint]?
    /// <p>The <code>GeoMatchSetId</code> for an <code>GeoMatchSet</code>. You use <code>GeoMatchSetId</code> to get information about a
    /// 			<code>GeoMatchSet</code> (see <a>GeoMatchSet</a>), update a <code>GeoMatchSet</code> (see <a>UpdateGeoMatchSet</a>), insert a <code>GeoMatchSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>GeoMatchSet</code> from AWS WAF (see <a>DeleteGeoMatchSet</a>).</p>
    /// 		       <p>
    ///             <code>GeoMatchSetId</code> is returned by <a>CreateGeoMatchSet</a> and by <a>ListGeoMatchSets</a>.</p>
    public let geoMatchSetId: String?
    /// <p>A friendly name or description of the <a>GeoMatchSet</a>. You can't change the name of an <code>GeoMatchSet</code> after you create it.</p>
    public let name: String?

    public init (
        geoMatchConstraints: [GeoMatchConstraint]? = nil,
        geoMatchSetId: String? = nil,
        name: String? = nil
    )
    {
        self.geoMatchConstraints = geoMatchConstraints
        self.geoMatchSetId = geoMatchSetId
        self.name = name
    }
}

extension GeoMatchSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case geoMatchSetId = "GeoMatchSetId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geoMatchSetId = geoMatchSetId {
            try encodeContainer.encode(geoMatchSetId, forKey: .geoMatchSetId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .geoMatchSetId)
        geoMatchSetId = geoMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GeoMatchSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoMatchSetSummary(geoMatchSetId: \(String(describing: geoMatchSetId)), name: \(String(describing: name)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>Contains the identifier and the name of the <code>GeoMatchSet</code>.</p>
public struct GeoMatchSetSummary: Equatable {
    /// <p>The <code>GeoMatchSetId</code> for an <a>GeoMatchSet</a>. You can use <code>GeoMatchSetId</code> in a <a>GetGeoMatchSet</a> request to get detailed	information about an <a>GeoMatchSet</a>.</p>
    public let geoMatchSetId: String?
    /// <p>A friendly name or description of the <a>GeoMatchSet</a>. You can't change the name of an <code>GeoMatchSet</code> after you create it.</p>
    public let name: String?

    public init (
        geoMatchSetId: String? = nil,
        name: String? = nil
    )
    {
        self.geoMatchSetId = geoMatchSetId
        self.name = name
    }
}

extension GeoMatchSetUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case geoMatchConstraint = "GeoMatchConstraint"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let geoMatchConstraint = geoMatchConstraint {
            try encodeContainer.encode(geoMatchConstraint, forKey: .geoMatchConstraint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let geoMatchConstraintDecoded = try containerValues.decodeIfPresent(GeoMatchConstraint.self, forKey: .geoMatchConstraint)
        geoMatchConstraint = geoMatchConstraintDecoded
    }
}

extension GeoMatchSetUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeoMatchSetUpdate(action: \(String(describing: action)), geoMatchConstraint: \(String(describing: geoMatchConstraint)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>Specifies the type of update to perform to an <a>GeoMatchSet</a> with <a>UpdateGeoMatchSet</a>.</p>
public struct GeoMatchSetUpdate: Equatable {
    /// <p>Specifies whether to insert or delete a country with <a>UpdateGeoMatchSet</a>.</p>
    public let action: ChangeAction?
    /// <p>The country from which web requests originate that you want AWS WAF to search for.</p>
    public let geoMatchConstraint: GeoMatchConstraint?

    public init (
        action: ChangeAction? = nil,
        geoMatchConstraint: GeoMatchConstraint? = nil
    )
    {
        self.action = action
        self.geoMatchConstraint = geoMatchConstraint
    }
}

public struct GetByteMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "GetByteMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetByteMatchSetInput>
    public typealias MOutput = OperationOutput<GetByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetByteMatchSetOutputError>
}

extension GetByteMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetByteMatchSetInput(byteMatchSetId: \(String(describing: byteMatchSetId)))"}
}

extension GetByteMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case byteMatchSetId = "ByteMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byteMatchSetId = byteMatchSetId {
            try encodeContainer.encode(byteMatchSetId, forKey: .byteMatchSetId)
        }
    }
}

public struct GetByteMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetByteMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetByteMatchSetInput>
    public typealias MOutput = OperationOutput<GetByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetByteMatchSetOutputError>
}

public struct GetByteMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetByteMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetByteMatchSetInput>
    public typealias MOutput = OperationOutput<GetByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetByteMatchSetOutputError>
}

public struct GetByteMatchSetInput: Equatable {
    /// <p>The <code>ByteMatchSetId</code> of the <a>ByteMatchSet</a> that you want to get. <code>ByteMatchSetId</code> is returned by
    /// 			<a>CreateByteMatchSet</a> and by <a>ListByteMatchSets</a>.</p>
    public let byteMatchSetId: String?

    public init (
        byteMatchSetId: String? = nil
    )
    {
        self.byteMatchSetId = byteMatchSetId
    }
}

struct GetByteMatchSetInputBody: Equatable {
    public let byteMatchSetId: String?
}

extension GetByteMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byteMatchSetId = "ByteMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .byteMatchSetId)
        byteMatchSetId = byteMatchSetIdDecoded
    }
}

extension GetByteMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetByteMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetByteMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetByteMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetByteMatchSetOutputResponse(byteMatchSet: \(String(describing: byteMatchSet)))"}
}

extension GetByteMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetByteMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.byteMatchSet = output.byteMatchSet
        } else {
            self.byteMatchSet = nil
        }
    }
}

public struct GetByteMatchSetOutputResponse: Equatable {
    /// <p>Information about the <a>ByteMatchSet</a> that you specified in the <code>GetByteMatchSet</code> request. For more information, see the
    /// 			following topics:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ByteMatchSet</a>: Contains <code>ByteMatchSetId</code>, <code>ByteMatchTuples</code>, and <code>Name</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ByteMatchTuples</code>: Contains an array of <a>ByteMatchTuple</a> objects. Each <code>ByteMatchTuple</code>
    /// 				object contains <a>FieldToMatch</a>, <code>PositionalConstraint</code>, <code>TargetString</code>,
    /// 				and <code>TextTransformation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let byteMatchSet: ByteMatchSet?

    public init (
        byteMatchSet: ByteMatchSet? = nil
    )
    {
        self.byteMatchSet = byteMatchSet
    }
}

struct GetByteMatchSetOutputResponseBody: Equatable {
    public let byteMatchSet: ByteMatchSet?
}

extension GetByteMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byteMatchSet = "ByteMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteMatchSetDecoded = try containerValues.decodeIfPresent(ByteMatchSet.self, forKey: .byteMatchSet)
        byteMatchSet = byteMatchSetDecoded
    }
}

extension GetChangeTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChangeTokenInput()"}
}

extension GetChangeTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetChangeTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetChangeTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChangeTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChangeTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChangeTokenInput>
    public typealias MOutput = OperationOutput<GetChangeTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChangeTokenOutputError>
}

public struct GetChangeTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetChangeTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChangeTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChangeTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChangeTokenInput>
    public typealias MOutput = OperationOutput<GetChangeTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChangeTokenOutputError>
}

public struct GetChangeTokenInput: Equatable {

    public init() {}
}

struct GetChangeTokenInputBody: Equatable {
}

extension GetChangeTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetChangeTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChangeTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChangeTokenOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChangeTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChangeTokenOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension GetChangeTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetChangeTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct GetChangeTokenOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used in the request. Use this value in a <code>GetChangeTokenStatus</code> request
    /// 			to get the current status of the request. </p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct GetChangeTokenOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension GetChangeTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct GetChangeTokenStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetChangeTokenStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChangeTokenStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChangeTokenStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChangeTokenStatusInput>
    public typealias MOutput = OperationOutput<GetChangeTokenStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChangeTokenStatusOutputError>
}

extension GetChangeTokenStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChangeTokenStatusInput(changeToken: \(String(describing: changeToken)))"}
}

extension GetChangeTokenStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
    }
}

public struct GetChangeTokenStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetChangeTokenStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChangeTokenStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChangeTokenStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChangeTokenStatusInput>
    public typealias MOutput = OperationOutput<GetChangeTokenStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChangeTokenStatusOutputError>
}

public struct GetChangeTokenStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetChangeTokenStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChangeTokenStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChangeTokenStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChangeTokenStatusInput>
    public typealias MOutput = OperationOutput<GetChangeTokenStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChangeTokenStatusOutputError>
}

public struct GetChangeTokenStatusInput: Equatable {
    /// <p>The change token for which you want to get the status. This change token was previously returned in the <code>GetChangeToken</code> response.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct GetChangeTokenStatusInputBody: Equatable {
    public let changeToken: String?
}

extension GetChangeTokenStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension GetChangeTokenStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChangeTokenStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChangeTokenStatusOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChangeTokenStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChangeTokenStatusOutputResponse(changeTokenStatus: \(String(describing: changeTokenStatus)))"}
}

extension GetChangeTokenStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetChangeTokenStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeTokenStatus = output.changeTokenStatus
        } else {
            self.changeTokenStatus = nil
        }
    }
}

public struct GetChangeTokenStatusOutputResponse: Equatable {
    /// <p>The status of the change token.</p>
    public let changeTokenStatus: ChangeTokenStatus?

    public init (
        changeTokenStatus: ChangeTokenStatus? = nil
    )
    {
        self.changeTokenStatus = changeTokenStatus
    }
}

struct GetChangeTokenStatusOutputResponseBody: Equatable {
    public let changeTokenStatus: ChangeTokenStatus?
}

extension GetChangeTokenStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeTokenStatus = "ChangeTokenStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenStatusDecoded = try containerValues.decodeIfPresent(ChangeTokenStatus.self, forKey: .changeTokenStatus)
        changeTokenStatus = changeTokenStatusDecoded
    }
}

public struct GetGeoMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "GetGeoMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGeoMatchSetInput>
    public typealias MOutput = OperationOutput<GetGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGeoMatchSetOutputError>
}

extension GetGeoMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGeoMatchSetInput(geoMatchSetId: \(String(describing: geoMatchSetId)))"}
}

extension GetGeoMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case geoMatchSetId = "GeoMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let geoMatchSetId = geoMatchSetId {
            try encodeContainer.encode(geoMatchSetId, forKey: .geoMatchSetId)
        }
    }
}

public struct GetGeoMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetGeoMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGeoMatchSetInput>
    public typealias MOutput = OperationOutput<GetGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGeoMatchSetOutputError>
}

public struct GetGeoMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGeoMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGeoMatchSetInput>
    public typealias MOutput = OperationOutput<GetGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGeoMatchSetOutputError>
}

public struct GetGeoMatchSetInput: Equatable {
    /// <p>The <code>GeoMatchSetId</code> of the <a>GeoMatchSet</a> that you want to get. <code>GeoMatchSetId</code> is returned by <a>CreateGeoMatchSet</a> and by
    /// 			<a>ListGeoMatchSets</a>.</p>
    public let geoMatchSetId: String?

    public init (
        geoMatchSetId: String? = nil
    )
    {
        self.geoMatchSetId = geoMatchSetId
    }
}

struct GetGeoMatchSetInputBody: Equatable {
    public let geoMatchSetId: String?
}

extension GetGeoMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case geoMatchSetId = "GeoMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .geoMatchSetId)
        geoMatchSetId = geoMatchSetIdDecoded
    }
}

extension GetGeoMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGeoMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGeoMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGeoMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGeoMatchSetOutputResponse(geoMatchSet: \(String(describing: geoMatchSet)))"}
}

extension GetGeoMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGeoMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.geoMatchSet = output.geoMatchSet
        } else {
            self.geoMatchSet = nil
        }
    }
}

public struct GetGeoMatchSetOutputResponse: Equatable {
    /// <p>Information about the <a>GeoMatchSet</a> that you specified in the <code>GetGeoMatchSet</code> request. This includes the <code>Type</code>, which for a <code>GeoMatchContraint</code> is always <code>Country</code>, as well as the <code>Value</code>, which is the identifier for a specific country.</p>
    public let geoMatchSet: GeoMatchSet?

    public init (
        geoMatchSet: GeoMatchSet? = nil
    )
    {
        self.geoMatchSet = geoMatchSet
    }
}

struct GetGeoMatchSetOutputResponseBody: Equatable {
    public let geoMatchSet: GeoMatchSet?
}

extension GetGeoMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case geoMatchSet = "GeoMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoMatchSetDecoded = try containerValues.decodeIfPresent(GeoMatchSet.self, forKey: .geoMatchSet)
        geoMatchSet = geoMatchSetDecoded
    }
}

public struct GetIPSetInputBodyMiddleware: Middleware {
    public let id: String = "GetIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIPSetInput>
    public typealias MOutput = OperationOutput<GetIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIPSetOutputError>
}

extension GetIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIPSetInput(iPSetId: \(String(describing: iPSetId)))"}
}

extension GetIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iPSetId = "IPSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iPSetId = iPSetId {
            try encodeContainer.encode(iPSetId, forKey: .iPSetId)
        }
    }
}

public struct GetIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIPSetInput>
    public typealias MOutput = OperationOutput<GetIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIPSetOutputError>
}

public struct GetIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIPSetInput>
    public typealias MOutput = OperationOutput<GetIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIPSetOutputError>
}

public struct GetIPSetInput: Equatable {
    /// <p>The <code>IPSetId</code> of the <a>IPSet</a> that you want to get. <code>IPSetId</code> is returned by <a>CreateIPSet</a> and by
    /// 			<a>ListIPSets</a>.</p>
    public let iPSetId: String?

    public init (
        iPSetId: String? = nil
    )
    {
        self.iPSetId = iPSetId
    }
}

struct GetIPSetInputBody: Equatable {
    public let iPSetId: String?
}

extension GetIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iPSetId = "IPSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPSetId)
        iPSetId = iPSetIdDecoded
    }
}

extension GetIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIPSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIPSetOutputResponse(iPSet: \(String(describing: iPSet)))"}
}

extension GetIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIPSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iPSet = output.iPSet
        } else {
            self.iPSet = nil
        }
    }
}

public struct GetIPSetOutputResponse: Equatable {
    /// <p>Information about the <a>IPSet</a> that you specified in the <code>GetIPSet</code> request. For more information, see the
    /// 			following topics:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>IPSet</a>: Contains <code>IPSetDescriptors</code>, <code>IPSetId</code>, and <code>Name</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IPSetDescriptors</code>: Contains an array of <a>IPSetDescriptor</a> objects. Each <code>IPSetDescriptor</code>
    /// 				object contains <code>Type</code> and <code>Value</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let iPSet: IPSet?

    public init (
        iPSet: IPSet? = nil
    )
    {
        self.iPSet = iPSet
    }
}

struct GetIPSetOutputResponseBody: Equatable {
    public let iPSet: IPSet?
}

extension GetIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iPSet = "IPSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetDecoded = try containerValues.decodeIfPresent(IPSet.self, forKey: .iPSet)
        iPSet = iPSetDecoded
    }
}

public struct GetLoggingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "GetLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<GetLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggingConfigurationOutputError>
}

extension GetLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggingConfigurationInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetLoggingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetLoggingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<GetLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggingConfigurationOutputError>
}

public struct GetLoggingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<GetLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLoggingConfigurationOutputError>
}

public struct GetLoggingConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the web ACL for which you want to get the <a>LoggingConfiguration</a>.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetLoggingConfigurationInputBody: Equatable {
    public let resourceArn: String?
}

extension GetLoggingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetLoggingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLoggingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLoggingConfigurationOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLoggingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLoggingConfigurationOutputResponse(loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension GetLoggingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct GetLoggingConfigurationOutputResponse: Equatable {
    /// <p>The <a>LoggingConfiguration</a> for the specified web ACL.</p>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct GetLoggingConfigurationOutputResponseBody: Equatable {
    public let loggingConfiguration: LoggingConfiguration?
}

extension GetLoggingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

public struct GetPermissionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetPermissionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionPolicyInput>
    public typealias MOutput = OperationOutput<GetPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionPolicyOutputError>
}

extension GetPermissionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPermissionPolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension GetPermissionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct GetPermissionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPermissionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionPolicyInput>
    public typealias MOutput = OperationOutput<GetPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionPolicyOutputError>
}

public struct GetPermissionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPermissionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPermissionPolicyInput>
    public typealias MOutput = OperationOutput<GetPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPermissionPolicyOutputError>
}

public struct GetPermissionPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the RuleGroup for which you want to get the policy.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct GetPermissionPolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension GetPermissionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension GetPermissionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPermissionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPermissionPolicyOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPermissionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPermissionPolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension GetPermissionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPermissionPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetPermissionPolicyOutputResponse: Equatable {
    /// <p>The IAM policy attached to the specified RuleGroup.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct GetPermissionPolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension GetPermissionPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct GetRateBasedRuleInputBodyMiddleware: Middleware {
    public let id: String = "GetRateBasedRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedRuleInput>
    public typealias MOutput = OperationOutput<GetRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedRuleOutputError>
}

extension GetRateBasedRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRateBasedRuleInput(ruleId: \(String(describing: ruleId)))"}
}

extension GetRateBasedRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }
}

public struct GetRateBasedRuleInputHeadersMiddleware: Middleware {
    public let id: String = "GetRateBasedRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedRuleInput>
    public typealias MOutput = OperationOutput<GetRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedRuleOutputError>
}

public struct GetRateBasedRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRateBasedRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedRuleInput>
    public typealias MOutput = OperationOutput<GetRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedRuleOutputError>
}

public struct GetRateBasedRuleInput: Equatable {
    /// <p>The <code>RuleId</code> of the <a>RateBasedRule</a> that you want to get.
    ///             <code>RuleId</code> is returned by <a>CreateRateBasedRule</a> and by <a>ListRateBasedRules</a>.</p>
    public let ruleId: String?

    public init (
        ruleId: String? = nil
    )
    {
        self.ruleId = ruleId
    }
}

struct GetRateBasedRuleInputBody: Equatable {
    public let ruleId: String?
}

extension GetRateBasedRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleId = "RuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

public struct GetRateBasedRuleManagedKeysInputBodyMiddleware: Middleware {
    public let id: String = "GetRateBasedRuleManagedKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedRuleManagedKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedRuleManagedKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedRuleManagedKeysInput>
    public typealias MOutput = OperationOutput<GetRateBasedRuleManagedKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedRuleManagedKeysOutputError>
}

extension GetRateBasedRuleManagedKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRateBasedRuleManagedKeysInput(nextMarker: \(String(describing: nextMarker)), ruleId: \(String(describing: ruleId)))"}
}

extension GetRateBasedRuleManagedKeysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }
}

public struct GetRateBasedRuleManagedKeysInputHeadersMiddleware: Middleware {
    public let id: String = "GetRateBasedRuleManagedKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedRuleManagedKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedRuleManagedKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedRuleManagedKeysInput>
    public typealias MOutput = OperationOutput<GetRateBasedRuleManagedKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedRuleManagedKeysOutputError>
}

public struct GetRateBasedRuleManagedKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRateBasedRuleManagedKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRateBasedRuleManagedKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRateBasedRuleManagedKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRateBasedRuleManagedKeysInput>
    public typealias MOutput = OperationOutput<GetRateBasedRuleManagedKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRateBasedRuleManagedKeysOutputError>
}

public struct GetRateBasedRuleManagedKeysInput: Equatable {
    /// <p>A null value and not currently used. Do not include this in your request.</p>
    public let nextMarker: String?
    /// <p>The <code>RuleId</code> of the <a>RateBasedRule</a> for which you want to
    ///          get a list of <code>ManagedKeys</code>. <code>RuleId</code> is returned by <a>CreateRateBasedRule</a> and by <a>ListRateBasedRules</a>.</p>
    public let ruleId: String?

    public init (
        nextMarker: String? = nil,
        ruleId: String? = nil
    )
    {
        self.nextMarker = nextMarker
        self.ruleId = ruleId
    }
}

struct GetRateBasedRuleManagedKeysInputBody: Equatable {
    public let ruleId: String?
    public let nextMarker: String?
}

extension GetRateBasedRuleManagedKeysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case ruleId = "RuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension GetRateBasedRuleManagedKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRateBasedRuleManagedKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRateBasedRuleManagedKeysOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRateBasedRuleManagedKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRateBasedRuleManagedKeysOutputResponse(managedKeys: \(String(describing: managedKeys)), nextMarker: \(String(describing: nextMarker)))"}
}

extension GetRateBasedRuleManagedKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRateBasedRuleManagedKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.managedKeys = output.managedKeys
            self.nextMarker = output.nextMarker
        } else {
            self.managedKeys = nil
            self.nextMarker = nil
        }
    }
}

public struct GetRateBasedRuleManagedKeysOutputResponse: Equatable {
    /// <p>An array of IP addresses that currently are blocked by the specified <a>RateBasedRule</a>. </p>
    public let managedKeys: [String]?
    /// <p>A null value and not currently used.</p>
    public let nextMarker: String?

    public init (
        managedKeys: [String]? = nil,
        nextMarker: String? = nil
    )
    {
        self.managedKeys = managedKeys
        self.nextMarker = nextMarker
    }
}

struct GetRateBasedRuleManagedKeysOutputResponseBody: Equatable {
    public let managedKeys: [String]?
    public let nextMarker: String?
}

extension GetRateBasedRuleManagedKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case managedKeys = "ManagedKeys"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managedKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .managedKeys)
        var managedKeysDecoded0:[String]? = nil
        if let managedKeysContainer = managedKeysContainer {
            managedKeysDecoded0 = [String]()
            for string0 in managedKeysContainer {
                if let string0 = string0 {
                    managedKeysDecoded0?.append(string0)
                }
            }
        }
        managedKeys = managedKeysDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension GetRateBasedRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRateBasedRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRateBasedRuleOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRateBasedRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRateBasedRuleOutputResponse(rule: \(String(describing: rule)))"}
}

extension GetRateBasedRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRateBasedRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct GetRateBasedRuleOutputResponse: Equatable {
    /// <p>Information about the <a>RateBasedRule</a> that you specified in the
    ///             <code>GetRateBasedRule</code> request.</p>
    public let rule: RateBasedRule?

    public init (
        rule: RateBasedRule? = nil
    )
    {
        self.rule = rule
    }
}

struct GetRateBasedRuleOutputResponseBody: Equatable {
    public let rule: RateBasedRule?
}

extension GetRateBasedRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rule = "Rule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(RateBasedRule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

public struct GetRegexMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "GetRegexMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexMatchSetInput>
    public typealias MOutput = OperationOutput<GetRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexMatchSetOutputError>
}

extension GetRegexMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegexMatchSetInput(regexMatchSetId: \(String(describing: regexMatchSetId)))"}
}

extension GetRegexMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case regexMatchSetId = "RegexMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regexMatchSetId = regexMatchSetId {
            try encodeContainer.encode(regexMatchSetId, forKey: .regexMatchSetId)
        }
    }
}

public struct GetRegexMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetRegexMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexMatchSetInput>
    public typealias MOutput = OperationOutput<GetRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexMatchSetOutputError>
}

public struct GetRegexMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRegexMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexMatchSetInput>
    public typealias MOutput = OperationOutput<GetRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexMatchSetOutputError>
}

public struct GetRegexMatchSetInput: Equatable {
    /// <p>The <code>RegexMatchSetId</code> of the <a>RegexMatchSet</a> that you want to get. <code>RegexMatchSetId</code> is returned by
    /// 			<a>CreateRegexMatchSet</a> and by <a>ListRegexMatchSets</a>.</p>
    public let regexMatchSetId: String?

    public init (
        regexMatchSetId: String? = nil
    )
    {
        self.regexMatchSetId = regexMatchSetId
    }
}

struct GetRegexMatchSetInputBody: Equatable {
    public let regexMatchSetId: String?
}

extension GetRegexMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case regexMatchSetId = "RegexMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexMatchSetId)
        regexMatchSetId = regexMatchSetIdDecoded
    }
}

extension GetRegexMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegexMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegexMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegexMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegexMatchSetOutputResponse(regexMatchSet: \(String(describing: regexMatchSet)))"}
}

extension GetRegexMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRegexMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.regexMatchSet = output.regexMatchSet
        } else {
            self.regexMatchSet = nil
        }
    }
}

public struct GetRegexMatchSetOutputResponse: Equatable {
    /// <p>Information about the <a>RegexMatchSet</a> that you specified in the <code>GetRegexMatchSet</code> request. For more information, see <a>RegexMatchTuple</a>.</p>
    public let regexMatchSet: RegexMatchSet?

    public init (
        regexMatchSet: RegexMatchSet? = nil
    )
    {
        self.regexMatchSet = regexMatchSet
    }
}

struct GetRegexMatchSetOutputResponseBody: Equatable {
    public let regexMatchSet: RegexMatchSet?
}

extension GetRegexMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case regexMatchSet = "RegexMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexMatchSetDecoded = try containerValues.decodeIfPresent(RegexMatchSet.self, forKey: .regexMatchSet)
        regexMatchSet = regexMatchSetDecoded
    }
}

public struct GetRegexPatternSetInputBodyMiddleware: Middleware {
    public let id: String = "GetRegexPatternSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexPatternSetInput>
    public typealias MOutput = OperationOutput<GetRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexPatternSetOutputError>
}

extension GetRegexPatternSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegexPatternSetInput(regexPatternSetId: \(String(describing: regexPatternSetId)))"}
}

extension GetRegexPatternSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case regexPatternSetId = "RegexPatternSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regexPatternSetId = regexPatternSetId {
            try encodeContainer.encode(regexPatternSetId, forKey: .regexPatternSetId)
        }
    }
}

public struct GetRegexPatternSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetRegexPatternSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexPatternSetInput>
    public typealias MOutput = OperationOutput<GetRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexPatternSetOutputError>
}

public struct GetRegexPatternSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRegexPatternSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRegexPatternSetInput>
    public typealias MOutput = OperationOutput<GetRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRegexPatternSetOutputError>
}

public struct GetRegexPatternSetInput: Equatable {
    /// <p>The <code>RegexPatternSetId</code> of the <a>RegexPatternSet</a> that you want to get. <code>RegexPatternSetId</code> is returned by
    /// 			<a>CreateRegexPatternSet</a> and by <a>ListRegexPatternSets</a>.</p>
    public let regexPatternSetId: String?

    public init (
        regexPatternSetId: String? = nil
    )
    {
        self.regexPatternSetId = regexPatternSetId
    }
}

struct GetRegexPatternSetInputBody: Equatable {
    public let regexPatternSetId: String?
}

extension GetRegexPatternSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case regexPatternSetId = "RegexPatternSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexPatternSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexPatternSetId)
        regexPatternSetId = regexPatternSetIdDecoded
    }
}

extension GetRegexPatternSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegexPatternSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegexPatternSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegexPatternSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRegexPatternSetOutputResponse(regexPatternSet: \(String(describing: regexPatternSet)))"}
}

extension GetRegexPatternSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRegexPatternSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.regexPatternSet = output.regexPatternSet
        } else {
            self.regexPatternSet = nil
        }
    }
}

public struct GetRegexPatternSetOutputResponse: Equatable {
    /// <p>Information about the <a>RegexPatternSet</a> that you specified in the <code>GetRegexPatternSet</code> request, including the identifier of the pattern set and the regular expression patterns you want AWS WAF to search for. </p>
    public let regexPatternSet: RegexPatternSet?

    public init (
        regexPatternSet: RegexPatternSet? = nil
    )
    {
        self.regexPatternSet = regexPatternSet
    }
}

struct GetRegexPatternSetOutputResponseBody: Equatable {
    public let regexPatternSet: RegexPatternSet?
}

extension GetRegexPatternSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case regexPatternSet = "RegexPatternSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexPatternSetDecoded = try containerValues.decodeIfPresent(RegexPatternSet.self, forKey: .regexPatternSet)
        regexPatternSet = regexPatternSetDecoded
    }
}

public struct GetRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "GetRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleGroupInput>
    public typealias MOutput = OperationOutput<GetRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleGroupOutputError>
}

extension GetRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRuleGroupInput(ruleGroupId: \(String(describing: ruleGroupId)))"}
}

extension GetRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleGroupId = "RuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleGroupId = ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
    }
}

public struct GetRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "GetRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleGroupInput>
    public typealias MOutput = OperationOutput<GetRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleGroupOutputError>
}

public struct GetRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleGroupInput>
    public typealias MOutput = OperationOutput<GetRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleGroupOutputError>
}

public struct GetRuleGroupInput: Equatable {
    /// <p>The <code>RuleGroupId</code> of the <a>RuleGroup</a> that you want to get. <code>RuleGroupId</code> is returned by <a>CreateRuleGroup</a> and by
    ///          <a>ListRuleGroups</a>.</p>
    public let ruleGroupId: String?

    public init (
        ruleGroupId: String? = nil
    )
    {
        self.ruleGroupId = ruleGroupId
    }
}

struct GetRuleGroupInputBody: Equatable {
    public let ruleGroupId: String?
}

extension GetRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleGroupId = "RuleGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
    }
}

extension GetRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRuleGroupOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRuleGroupOutputResponse(ruleGroup: \(String(describing: ruleGroup)))"}
}

extension GetRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ruleGroup = output.ruleGroup
        } else {
            self.ruleGroup = nil
        }
    }
}

public struct GetRuleGroupOutputResponse: Equatable {
    /// <p>Information about the <a>RuleGroup</a> that you specified in the <code>GetRuleGroup</code> request. </p>
    public let ruleGroup: RuleGroup?

    public init (
        ruleGroup: RuleGroup? = nil
    )
    {
        self.ruleGroup = ruleGroup
    }
}

struct GetRuleGroupOutputResponseBody: Equatable {
    public let ruleGroup: RuleGroup?
}

extension GetRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleGroup = "RuleGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupDecoded = try containerValues.decodeIfPresent(RuleGroup.self, forKey: .ruleGroup)
        ruleGroup = ruleGroupDecoded
    }
}

public struct GetRuleInputBodyMiddleware: Middleware {
    public let id: String = "GetRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleInput>
    public typealias MOutput = OperationOutput<GetRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleOutputError>
}

extension GetRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRuleInput(ruleId: \(String(describing: ruleId)))"}
}

extension GetRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }
}

public struct GetRuleInputHeadersMiddleware: Middleware {
    public let id: String = "GetRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleInput>
    public typealias MOutput = OperationOutput<GetRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleOutputError>
}

public struct GetRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRuleInput>
    public typealias MOutput = OperationOutput<GetRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRuleOutputError>
}

public struct GetRuleInput: Equatable {
    /// <p>The <code>RuleId</code> of the <a>Rule</a> that you want to get. <code>RuleId</code> is returned by <a>CreateRule</a> and by
    /// 			<a>ListRules</a>.</p>
    public let ruleId: String?

    public init (
        ruleId: String? = nil
    )
    {
        self.ruleId = ruleId
    }
}

struct GetRuleInputBody: Equatable {
    public let ruleId: String?
}

extension GetRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleId = "RuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension GetRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRuleOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRuleOutputResponse(rule: \(String(describing: rule)))"}
}

extension GetRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct GetRuleOutputResponse: Equatable {
    /// <p>Information about the <a>Rule</a> that you specified in the <code>GetRule</code> request.
    /// 			For more information, see the following topics:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>Rule</a>: Contains <code>MetricName</code>, <code>Name</code>, an array of <code>Predicate</code> objects,
    /// 				and <code>RuleId</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>Predicate</a>: Each <code>Predicate</code> object contains <code>DataId</code>, <code>Negated</code>, and
    /// 				<code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let rule: Rule?

    public init (
        rule: Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct GetRuleOutputResponseBody: Equatable {
    public let rule: Rule?
}

extension GetRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rule = "Rule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

public struct GetSampledRequestsInputBodyMiddleware: Middleware {
    public let id: String = "GetSampledRequestsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampledRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampledRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampledRequestsInput>
    public typealias MOutput = OperationOutput<GetSampledRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampledRequestsOutputError>
}

extension GetSampledRequestsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSampledRequestsInput(maxItems: \(String(describing: maxItems)), ruleId: \(String(describing: ruleId)), timeWindow: \(String(describing: timeWindow)), webAclId: \(String(describing: webAclId)))"}
}

extension GetSampledRequestsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxItems = "MaxItems"
        case ruleId = "RuleId"
        case timeWindow = "TimeWindow"
        case webAclId = "WebAclId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxItems != 0 {
            try encodeContainer.encode(maxItems, forKey: .maxItems)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let timeWindow = timeWindow {
            try encodeContainer.encode(timeWindow, forKey: .timeWindow)
        }
        if let webAclId = webAclId {
            try encodeContainer.encode(webAclId, forKey: .webAclId)
        }
    }
}

public struct GetSampledRequestsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSampledRequestsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampledRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampledRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampledRequestsInput>
    public typealias MOutput = OperationOutput<GetSampledRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampledRequestsOutputError>
}

public struct GetSampledRequestsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSampledRequestsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSampledRequestsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSampledRequestsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSampledRequestsInput>
    public typealias MOutput = OperationOutput<GetSampledRequestsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSampledRequestsOutputError>
}

public struct GetSampledRequestsInput: Equatable {
    /// <p>The number of requests that you want AWS WAF to return from among the first 5,000 requests that your AWS resource received
    /// 			during the time range. If your resource received fewer requests than the value of <code>MaxItems</code>, <code>GetSampledRequests</code>
    /// 			returns information about all of them. </p>
    public let maxItems: Int
    /// <p>
    ///             <code>RuleId</code> is one of three values:</p>
    /// 			      <ul>
    ///             <li>
    /// 				           <p>The <code>RuleId</code> of the <code>Rule</code> or the <code>RuleGroupId</code> of the <code>RuleGroup</code> for which you want <code>GetSampledRequests</code> to return a sample of requests.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Default_Action</code>, which causes <code>GetSampledRequests</code> to return a sample of the requests that
    /// 					didn't match any of the rules in the specified <code>WebACL</code>.</p>
    ///             </li>
    ///          </ul>
    public let ruleId: String?
    /// <p>The start date and time and the end date and time of the range for which you want <code>GetSampledRequests</code> to return a
    ///                         sample of requests. You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special
    ///                         designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. You can specify any time range in the previous three hours.</p>
    public let timeWindow: TimeWindow?
    /// <p>The <code>WebACLId</code> of the <code>WebACL</code> for which you want <code>GetSampledRequests</code> to return a sample of requests.</p>
    public let webAclId: String?

    public init (
        maxItems: Int = 0,
        ruleId: String? = nil,
        timeWindow: TimeWindow? = nil,
        webAclId: String? = nil
    )
    {
        self.maxItems = maxItems
        self.ruleId = ruleId
        self.timeWindow = timeWindow
        self.webAclId = webAclId
    }
}

struct GetSampledRequestsInputBody: Equatable {
    public let webAclId: String?
    public let ruleId: String?
    public let timeWindow: TimeWindow?
    public let maxItems: Int
}

extension GetSampledRequestsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxItems = "MaxItems"
        case ruleId = "RuleId"
        case timeWindow = "TimeWindow"
        case webAclId = "WebAclId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webAclIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webAclId)
        webAclId = webAclIdDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let timeWindowDecoded = try containerValues.decodeIfPresent(TimeWindow.self, forKey: .timeWindow)
        timeWindow = timeWindowDecoded
        let maxItemsDecoded = try containerValues.decode(Int.self, forKey: .maxItems)
        maxItems = maxItemsDecoded
    }
}

extension GetSampledRequestsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSampledRequestsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSampledRequestsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSampledRequestsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSampledRequestsOutputResponse(populationSize: \(String(describing: populationSize)), sampledRequests: \(String(describing: sampledRequests)), timeWindow: \(String(describing: timeWindow)))"}
}

extension GetSampledRequestsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSampledRequestsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.populationSize = output.populationSize
            self.sampledRequests = output.sampledRequests
            self.timeWindow = output.timeWindow
        } else {
            self.populationSize = 0
            self.sampledRequests = nil
            self.timeWindow = nil
        }
    }
}

public struct GetSampledRequestsOutputResponse: Equatable {
    /// <p>The total number of requests from which <code>GetSampledRequests</code> got a sample of <code>MaxItems</code> requests.
    /// 			If <code>PopulationSize</code> is less than <code>MaxItems</code>, the sample includes every request that your AWS resource
    /// 			received during the specified time range.</p>
    public let populationSize: Int
    /// <p>A complex type that contains detailed information about each of the requests in the sample.</p>
    public let sampledRequests: [SampledHTTPRequest]?
    /// <p>Usually, <code>TimeWindow</code> is the time range that you specified in the <code>GetSampledRequests</code> request. However,
    /// 			if your AWS resource received more than 5,000 requests during the time range that you specified in the request,
    /// 			<code>GetSampledRequests</code> returns the time range for the first 5,000 requests. Times are in Coordinated Universal Time (UTC) format.</p>
    public let timeWindow: TimeWindow?

    public init (
        populationSize: Int = 0,
        sampledRequests: [SampledHTTPRequest]? = nil,
        timeWindow: TimeWindow? = nil
    )
    {
        self.populationSize = populationSize
        self.sampledRequests = sampledRequests
        self.timeWindow = timeWindow
    }
}

struct GetSampledRequestsOutputResponseBody: Equatable {
    public let sampledRequests: [SampledHTTPRequest]?
    public let populationSize: Int
    public let timeWindow: TimeWindow?
}

extension GetSampledRequestsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case populationSize = "PopulationSize"
        case sampledRequests = "SampledRequests"
        case timeWindow = "TimeWindow"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampledRequestsContainer = try containerValues.decodeIfPresent([SampledHTTPRequest?].self, forKey: .sampledRequests)
        var sampledRequestsDecoded0:[SampledHTTPRequest]? = nil
        if let sampledRequestsContainer = sampledRequestsContainer {
            sampledRequestsDecoded0 = [SampledHTTPRequest]()
            for structure0 in sampledRequestsContainer {
                if let structure0 = structure0 {
                    sampledRequestsDecoded0?.append(structure0)
                }
            }
        }
        sampledRequests = sampledRequestsDecoded0
        let populationSizeDecoded = try containerValues.decode(Int.self, forKey: .populationSize)
        populationSize = populationSizeDecoded
        let timeWindowDecoded = try containerValues.decodeIfPresent(TimeWindow.self, forKey: .timeWindow)
        timeWindow = timeWindowDecoded
    }
}

public struct GetSizeConstraintSetInputBodyMiddleware: Middleware {
    public let id: String = "GetSizeConstraintSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<GetSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSizeConstraintSetOutputError>
}

extension GetSizeConstraintSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSizeConstraintSetInput(sizeConstraintSetId: \(String(describing: sizeConstraintSetId)))"}
}

extension GetSizeConstraintSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sizeConstraintSetId = "SizeConstraintSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sizeConstraintSetId = sizeConstraintSetId {
            try encodeContainer.encode(sizeConstraintSetId, forKey: .sizeConstraintSetId)
        }
    }
}

public struct GetSizeConstraintSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetSizeConstraintSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<GetSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSizeConstraintSetOutputError>
}

public struct GetSizeConstraintSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSizeConstraintSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<GetSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSizeConstraintSetOutputError>
}

public struct GetSizeConstraintSetInput: Equatable {
    /// <p>The <code>SizeConstraintSetId</code> of the <a>SizeConstraintSet</a> that you want to get. <code>SizeConstraintSetId</code> is returned by
    /// 			<a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>
    public let sizeConstraintSetId: String?

    public init (
        sizeConstraintSetId: String? = nil
    )
    {
        self.sizeConstraintSetId = sizeConstraintSetId
    }
}

struct GetSizeConstraintSetInputBody: Equatable {
    public let sizeConstraintSetId: String?
}

extension GetSizeConstraintSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sizeConstraintSetId = "SizeConstraintSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeConstraintSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizeConstraintSetId)
        sizeConstraintSetId = sizeConstraintSetIdDecoded
    }
}

extension GetSizeConstraintSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSizeConstraintSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSizeConstraintSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSizeConstraintSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSizeConstraintSetOutputResponse(sizeConstraintSet: \(String(describing: sizeConstraintSet)))"}
}

extension GetSizeConstraintSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSizeConstraintSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sizeConstraintSet = output.sizeConstraintSet
        } else {
            self.sizeConstraintSet = nil
        }
    }
}

public struct GetSizeConstraintSetOutputResponse: Equatable {
    /// <p>Information about the <a>SizeConstraintSet</a> that you specified in the <code>GetSizeConstraintSet</code> request. For more information, see the
    /// 			following topics:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>SizeConstraintSet</a>: Contains <code>SizeConstraintSetId</code>, <code>SizeConstraints</code>, and <code>Name</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SizeConstraints</code>: Contains an array of <a>SizeConstraint</a> objects. Each <code>SizeConstraint</code>
    /// 				object contains <a>FieldToMatch</a>, <code>TextTransformation</code>, <code>ComparisonOperator</code>,
    /// 				and <code>Size</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let sizeConstraintSet: SizeConstraintSet?

    public init (
        sizeConstraintSet: SizeConstraintSet? = nil
    )
    {
        self.sizeConstraintSet = sizeConstraintSet
    }
}

struct GetSizeConstraintSetOutputResponseBody: Equatable {
    public let sizeConstraintSet: SizeConstraintSet?
}

extension GetSizeConstraintSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sizeConstraintSet = "SizeConstraintSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeConstraintSetDecoded = try containerValues.decodeIfPresent(SizeConstraintSet.self, forKey: .sizeConstraintSet)
        sizeConstraintSet = sizeConstraintSetDecoded
    }
}

public struct GetSqlInjectionMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "GetSqlInjectionMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<GetSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSqlInjectionMatchSetOutputError>
}

extension GetSqlInjectionMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSqlInjectionMatchSetInput(sqlInjectionMatchSetId: \(String(describing: sqlInjectionMatchSetId)))"}
}

extension GetSqlInjectionMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sqlInjectionMatchSetId = sqlInjectionMatchSetId {
            try encodeContainer.encode(sqlInjectionMatchSetId, forKey: .sqlInjectionMatchSetId)
        }
    }
}

public struct GetSqlInjectionMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetSqlInjectionMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<GetSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSqlInjectionMatchSetOutputError>
}

public struct GetSqlInjectionMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSqlInjectionMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<GetSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSqlInjectionMatchSetOutputError>
}

/// <p>A request to get a <a>SqlInjectionMatchSet</a>.</p>
public struct GetSqlInjectionMatchSetInput: Equatable {
    /// <p>The <code>SqlInjectionMatchSetId</code> of the <a>SqlInjectionMatchSet</a> that you want to get. <code>SqlInjectionMatchSetId</code>
    /// 			is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>
    public let sqlInjectionMatchSetId: String?

    public init (
        sqlInjectionMatchSetId: String? = nil
    )
    {
        self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
    }
}

struct GetSqlInjectionMatchSetInputBody: Equatable {
    public let sqlInjectionMatchSetId: String?
}

extension GetSqlInjectionMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlInjectionMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlInjectionMatchSetId)
        sqlInjectionMatchSetId = sqlInjectionMatchSetIdDecoded
    }
}

extension GetSqlInjectionMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSqlInjectionMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSqlInjectionMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSqlInjectionMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSqlInjectionMatchSetOutputResponse(sqlInjectionMatchSet: \(String(describing: sqlInjectionMatchSet)))"}
}

extension GetSqlInjectionMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSqlInjectionMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.sqlInjectionMatchSet = output.sqlInjectionMatchSet
        } else {
            self.sqlInjectionMatchSet = nil
        }
    }
}

/// <p>The response to a <a>GetSqlInjectionMatchSet</a> request.</p>
public struct GetSqlInjectionMatchSetOutputResponse: Equatable {
    /// <p>Information about the <a>SqlInjectionMatchSet</a> that you specified in the <code>GetSqlInjectionMatchSet</code> request.
    /// 			For more information, see the following topics:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>SqlInjectionMatchSet</a>: Contains <code>Name</code>, <code>SqlInjectionMatchSetId</code>, and an array of
    /// 				<code>SqlInjectionMatchTuple</code> objects</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>SqlInjectionMatchTuple</a>: Each <code>SqlInjectionMatchTuple</code> object contains <code>FieldToMatch</code> and
    /// 				<code>TextTransformation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let sqlInjectionMatchSet: SqlInjectionMatchSet?

    public init (
        sqlInjectionMatchSet: SqlInjectionMatchSet? = nil
    )
    {
        self.sqlInjectionMatchSet = sqlInjectionMatchSet
    }
}

struct GetSqlInjectionMatchSetOutputResponseBody: Equatable {
    public let sqlInjectionMatchSet: SqlInjectionMatchSet?
}

extension GetSqlInjectionMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sqlInjectionMatchSet = "SqlInjectionMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlInjectionMatchSetDecoded = try containerValues.decodeIfPresent(SqlInjectionMatchSet.self, forKey: .sqlInjectionMatchSet)
        sqlInjectionMatchSet = sqlInjectionMatchSetDecoded
    }
}

public struct GetWebACLInputBodyMiddleware: Middleware {
    public let id: String = "GetWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLInput>
    public typealias MOutput = OperationOutput<GetWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLOutputError>
}

extension GetWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWebACLInput(webACLId: \(String(describing: webACLId)))"}
}

extension GetWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let webACLId = webACLId {
            try encodeContainer.encode(webACLId, forKey: .webACLId)
        }
    }
}

public struct GetWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "GetWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLInput>
    public typealias MOutput = OperationOutput<GetWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLOutputError>
}

public struct GetWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWebACLInput>
    public typealias MOutput = OperationOutput<GetWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWebACLOutputError>
}

public struct GetWebACLInput: Equatable {
    /// <p>The <code>WebACLId</code> of the <a>WebACL</a> that you want to get. <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by
    /// 			<a>ListWebACLs</a>.</p>
    public let webACLId: String?

    public init (
        webACLId: String? = nil
    )
    {
        self.webACLId = webACLId
    }
}

struct GetWebACLInputBody: Equatable {
    public let webACLId: String?
}

extension GetWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webACLId = "WebACLId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
    }
}

extension GetWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWebACLOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWebACLOutputResponse(webACL: \(String(describing: webACL)))"}
}

extension GetWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWebACLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webACL = output.webACL
        } else {
            self.webACL = nil
        }
    }
}

public struct GetWebACLOutputResponse: Equatable {
    /// <p>Information about the <a>WebACL</a> that you specified in the <code>GetWebACL</code> request.
    /// 			For more information, see the following topics:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>WebACL</a>: Contains <code>DefaultAction</code>, <code>MetricName</code>, <code>Name</code>, an array of
    /// 				<code>Rule</code> objects, and <code>WebACLId</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DefaultAction</code> (Data type is <a>WafAction</a>): Contains <code>Type</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Rules</code>: Contains an array of <code>ActivatedRule</code> objects, which contain <code>Action</code>,
    /// 				<code>Priority</code>, and <code>RuleId</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Action</code>: Contains <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let webACL: WebACL?

    public init (
        webACL: WebACL? = nil
    )
    {
        self.webACL = webACL
    }
}

struct GetWebACLOutputResponseBody: Equatable {
    public let webACL: WebACL?
}

extension GetWebACLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webACL = "WebACL"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLDecoded = try containerValues.decodeIfPresent(WebACL.self, forKey: .webACL)
        webACL = webACLDecoded
    }
}

public struct GetXssMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "GetXssMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetXssMatchSetInput>
    public typealias MOutput = OperationOutput<GetXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetXssMatchSetOutputError>
}

extension GetXssMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetXssMatchSetInput(xssMatchSetId: \(String(describing: xssMatchSetId)))"}
}

extension GetXssMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case xssMatchSetId = "XssMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let xssMatchSetId = xssMatchSetId {
            try encodeContainer.encode(xssMatchSetId, forKey: .xssMatchSetId)
        }
    }
}

public struct GetXssMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetXssMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetXssMatchSetInput>
    public typealias MOutput = OperationOutput<GetXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetXssMatchSetOutputError>
}

public struct GetXssMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetXssMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetXssMatchSetInput>
    public typealias MOutput = OperationOutput<GetXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetXssMatchSetOutputError>
}

/// <p>A request to get an <a>XssMatchSet</a>.</p>
public struct GetXssMatchSetInput: Equatable {
    /// <p>The <code>XssMatchSetId</code> of the <a>XssMatchSet</a> that you want to get. <code>XssMatchSetId</code>
    /// 			is returned by <a>CreateXssMatchSet</a> and by <a>ListXssMatchSets</a>.</p>
    public let xssMatchSetId: String?

    public init (
        xssMatchSetId: String? = nil
    )
    {
        self.xssMatchSetId = xssMatchSetId
    }
}

struct GetXssMatchSetInputBody: Equatable {
    public let xssMatchSetId: String?
}

extension GetXssMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case xssMatchSetId = "XssMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xssMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .xssMatchSetId)
        xssMatchSetId = xssMatchSetIdDecoded
    }
}

extension GetXssMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetXssMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetXssMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetXssMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetXssMatchSetOutputResponse(xssMatchSet: \(String(describing: xssMatchSet)))"}
}

extension GetXssMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetXssMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.xssMatchSet = output.xssMatchSet
        } else {
            self.xssMatchSet = nil
        }
    }
}

/// <p>The response to a <a>GetXssMatchSet</a> request.</p>
public struct GetXssMatchSetOutputResponse: Equatable {
    /// <p>Information about the <a>XssMatchSet</a> that you specified in the <code>GetXssMatchSet</code> request.
    /// 			For more information, see the following topics:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>XssMatchSet</a>: Contains <code>Name</code>, <code>XssMatchSetId</code>, and an array of
    /// 				<code>XssMatchTuple</code> objects</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>XssMatchTuple</a>: Each <code>XssMatchTuple</code> object contains <code>FieldToMatch</code> and
    /// 				<code>TextTransformation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let xssMatchSet: XssMatchSet?

    public init (
        xssMatchSet: XssMatchSet? = nil
    )
    {
        self.xssMatchSet = xssMatchSet
    }
}

struct GetXssMatchSetOutputResponseBody: Equatable {
    public let xssMatchSet: XssMatchSet?
}

extension GetXssMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case xssMatchSet = "XssMatchSet"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xssMatchSetDecoded = try containerValues.decodeIfPresent(XssMatchSet.self, forKey: .xssMatchSet)
        xssMatchSet = xssMatchSetDecoded
    }
}

extension HTTPHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension HTTPHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HTTPHeader(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>The response from a <a>GetSampledRequests</a> request includes an <code>HTTPHeader</code> complex type that
/// 			appears as <code>Headers</code> in the response syntax. <code>HTTPHeader</code> contains the names and values of
/// 			all of the headers that appear in one of the web requests that were returned by <code>GetSampledRequests</code>. </p>
public struct HTTPHeader: Equatable {
    /// <p>The name of one of the headers in the sampled web request.</p>
    public let name: String?
    /// <p>The value of one of the headers in the sampled web request.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension HTTPRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientIP = "ClientIP"
        case country = "Country"
        case hTTPVersion = "HTTPVersion"
        case headers = "Headers"
        case method = "Method"
        case uRI = "URI"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientIP = clientIP {
            try encodeContainer.encode(clientIP, forKey: .clientIP)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let hTTPVersion = hTTPVersion {
            try encodeContainer.encode(hTTPVersion, forKey: .hTTPVersion)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for httpheaders0 in headers {
                try headersContainer.encode(httpheaders0)
            }
        }
        if let method = method {
            try encodeContainer.encode(method, forKey: .method)
        }
        if let uRI = uRI {
            try encodeContainer.encode(uRI, forKey: .uRI)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIPDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientIP)
        clientIP = clientIPDecoded
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRI)
        uRI = uRIDecoded
        let methodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .method)
        method = methodDecoded
        let hTTPVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hTTPVersion)
        hTTPVersion = hTTPVersionDecoded
        let headersContainer = try containerValues.decodeIfPresent([HTTPHeader?].self, forKey: .headers)
        var headersDecoded0:[HTTPHeader]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [HTTPHeader]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
    }
}

extension HTTPRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HTTPRequest(clientIP: \(String(describing: clientIP)), country: \(String(describing: country)), hTTPVersion: \(String(describing: hTTPVersion)), headers: \(String(describing: headers)), method: \(String(describing: method)), uRI: \(String(describing: uRI)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>The response from a <a>GetSampledRequests</a> request includes an <code>HTTPRequest</code> complex type that
/// 			appears as <code>Request</code> in the response syntax. <code>HTTPRequest</code> contains information about
/// 			one of the web requests that were returned by <code>GetSampledRequests</code>. </p>
public struct HTTPRequest: Equatable {
    /// <p>The IP address that the request originated from. If the <code>WebACL</code> is associated with a CloudFront distribution,
    /// 			this is the value of one of the following fields in CloudFront access logs:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>c-ip</code>, if the viewer did not use an HTTP proxy or a load balancer to send the request</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>x-forwarded-for</code>, if the viewer did use an HTTP proxy or a load balancer to send the request</p>
    ///             </li>
    ///          </ul>
    public let clientIP: String?
    /// <p>The two-letter country code for the country that the request originated from. For a current list of country codes,
    /// 			see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 alpha-2</a>.</p>
    public let country: String?
    /// <p>The HTTP version specified in the sampled web request, for example, <code>HTTP/1.1</code>.</p>
    public let hTTPVersion: String?
    /// <p>A complex type that contains two values for each header in the sampled web request: the name of the header and the value of the header.</p>
    public let headers: [HTTPHeader]?
    /// <p>The HTTP method specified in the sampled web request. CloudFront supports the following methods: <code>DELETE</code>,
    /// 			<code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>PATCH</code>, <code>POST</code>, and <code>PUT</code>. </p>
    public let method: String?
    /// <p>The part of a web request that identifies the resource, for example, <code>/images/daily-ad.jpg</code>.</p>
    public let uRI: String?

    public init (
        clientIP: String? = nil,
        country: String? = nil,
        hTTPVersion: String? = nil,
        headers: [HTTPHeader]? = nil,
        method: String? = nil,
        uRI: String? = nil
    )
    {
        self.clientIP = clientIP
        self.country = country
        self.hTTPVersion = hTTPVersion
        self.headers = headers
        self.method = method
        self.uRI = uRI
    }
}

extension IPSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iPSetDescriptors = "IPSetDescriptors"
        case iPSetId = "IPSetId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iPSetDescriptors = iPSetDescriptors {
            var iPSetDescriptorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .iPSetDescriptors)
            for ipsetdescriptors0 in iPSetDescriptors {
                try iPSetDescriptorsContainer.encode(ipsetdescriptors0)
            }
        }
        if let iPSetId = iPSetId {
            try encodeContainer.encode(iPSetId, forKey: .iPSetId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPSetId)
        iPSetId = iPSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let iPSetDescriptorsContainer = try containerValues.decodeIfPresent([IPSetDescriptor?].self, forKey: .iPSetDescriptors)
        var iPSetDescriptorsDecoded0:[IPSetDescriptor]? = nil
        if let iPSetDescriptorsContainer = iPSetDescriptorsContainer {
            iPSetDescriptorsDecoded0 = [IPSetDescriptor]()
            for structure0 in iPSetDescriptorsContainer {
                if let structure0 = structure0 {
                    iPSetDescriptorsDecoded0?.append(structure0)
                }
            }
        }
        iPSetDescriptors = iPSetDescriptorsDecoded0
    }
}

extension IPSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSet(iPSetDescriptors: \(String(describing: iPSetDescriptors)), iPSetId: \(String(describing: iPSetId)), name: \(String(describing: name)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 	        <p>Contains one or more IP addresses or blocks of IP addresses specified in Classless Inter-Domain Routing (CIDR) notation. AWS WAF supports IPv4 address ranges: /8 and any range between /16 through /32.  AWS WAF supports IPv6 address ranges: /24, /32, /48, /56, /64, and /128.</p>
/// 	        <p>To specify an individual IP address, you specify the four-part IP address followed by a
///             <code>/32</code>, for example, 192.0.2.0/32. To block a range of IP addresses, you can
///          specify /8 or any range between /16 through /32 (for IPv4) or /24, /32, /48, /56, /64, or
///          /128 (for IPv6). For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
///             Inter-Domain Routing</a>. </p>
public struct IPSet: Equatable {
    /// <p>The IP address type (<code>IPV4</code> or <code>IPV6</code>) and the IP address range (in CIDR notation) that web requests originate from.
    /// 			If the <code>WebACL</code> is associated with a CloudFront distribution and the viewer did not use an HTTP proxy or a load balancer to send the request, this is the value of the c-ip field in the CloudFront access logs.</p>
    public let iPSetDescriptors: [IPSetDescriptor]?
    /// <p>The <code>IPSetId</code> for an <code>IPSet</code>. You use <code>IPSetId</code> to get information about an
    /// 			<code>IPSet</code> (see <a>GetIPSet</a>), update an <code>IPSet</code> (see <a>UpdateIPSet</a>),
    /// 			insert an <code>IPSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and
    /// 			delete an <code>IPSet</code> from AWS WAF (see <a>DeleteIPSet</a>).</p>
    /// 		       <p>
    ///             <code>IPSetId</code> is returned by <a>CreateIPSet</a> and by <a>ListIPSets</a>.</p>
    public let iPSetId: String?
    /// <p>A friendly name or description of the <a>IPSet</a>. You can't change the name of an <code>IPSet</code> after you create it.</p>
    public let name: String?

    public init (
        iPSetDescriptors: [IPSetDescriptor]? = nil,
        iPSetId: String? = nil,
        name: String? = nil
    )
    {
        self.iPSetDescriptors = iPSetDescriptors
        self.iPSetId = iPSetId
        self.name = name
    }
}

extension IPSetDescriptor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(IPSetDescriptorType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension IPSetDescriptor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSetDescriptor(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies the IP address type (<code>IPV4</code> or <code>IPV6</code>) and the IP address range (in CIDR format) that web requests originate from.</p>
public struct IPSetDescriptor: Equatable {
    /// <p>Specify <code>IPV4</code> or <code>IPV6</code>.</p>
    public let type: IPSetDescriptorType?
    /// <p>Specify an IPv4 address by using CIDR notation. For example:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure AWS WAF to allow, block, or count requests that originated from IP addresses from 192.0.2.0 to 192.0.2.255, specify
    /// 				<code>192.0.2.0/24</code>.</p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 	        <p>For more information about CIDR notation, see the Wikipedia entry
    /// 	      <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless Inter-Domain Routing</a>.</p>
    /// 	        <p>Specify an IPv6 address by using CIDR notation. For example:</p>
    /// 	        <ul>
    ///             <li>
    /// 	              <p>To configure AWS WAF to allow, block, or count requests that originated from the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify <code>1111:0000:0000:0000:0000:0000:0000:0111/128</code>.</p>
    /// 	           </li>
    ///             <li>
    /// 	              <p>To configure AWS WAF to allow, block, or count requests that originated from IP addresses 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify <code>1111:0000:0000:0000:0000:0000:0000:0000/64</code>.</p>
    /// 	           </li>
    ///          </ul>
    public let value: String?

    public init (
        type: IPSetDescriptorType? = nil,
        value: String? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum IPSetDescriptorType {
    case ipv4
    case ipv6
    case sdkUnknown(String)
}

extension IPSetDescriptorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IPSetDescriptorType] {
        return [
            .ipv4,
            .ipv6,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ipv4: return "IPV4"
        case .ipv6: return "IPV6"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IPSetDescriptorType(rawValue: rawValue) ?? IPSetDescriptorType.sdkUnknown(rawValue)
    }
}

extension IPSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iPSetId = "IPSetId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iPSetId = iPSetId {
            try encodeContainer.encode(iPSetId, forKey: .iPSetId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPSetId)
        iPSetId = iPSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IPSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSetSummary(iPSetId: \(String(describing: iPSetId)), name: \(String(describing: name)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Contains the identifier and the name of the <code>IPSet</code>.</p>
public struct IPSetSummary: Equatable {
    /// <p>The <code>IPSetId</code> for an <a>IPSet</a>. You can use <code>IPSetId</code> in a <a>GetIPSet</a> request to get detailed
    /// 			information about an <a>IPSet</a>.</p>
    public let iPSetId: String?
    /// <p>A friendly name or description of the <a>IPSet</a>. You can't change the name of an <code>IPSet</code> after you create it.</p>
    public let name: String?

    public init (
        iPSetId: String? = nil,
        name: String? = nil
    )
    {
        self.iPSetId = iPSetId
        self.name = name
    }
}

extension IPSetUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case iPSetDescriptor = "IPSetDescriptor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let iPSetDescriptor = iPSetDescriptor {
            try encodeContainer.encode(iPSetDescriptor, forKey: .iPSetDescriptor)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let iPSetDescriptorDecoded = try containerValues.decodeIfPresent(IPSetDescriptor.self, forKey: .iPSetDescriptor)
        iPSetDescriptor = iPSetDescriptorDecoded
    }
}

extension IPSetUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSetUpdate(action: \(String(describing: action)), iPSetDescriptor: \(String(describing: iPSetDescriptor)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies the type of update to perform to an <a>IPSet</a> with <a>UpdateIPSet</a>.</p>
public struct IPSetUpdate: Equatable {
    /// <p>Specifies whether to insert or delete an IP address with <a>UpdateIPSet</a>.</p>
    public let action: ChangeAction?
    /// <p>The IP address type (<code>IPV4</code> or <code>IPV6</code>) and the IP address range (in CIDR notation) that web requests originate from.</p>
    public let iPSetDescriptor: IPSetDescriptor?

    public init (
        action: ChangeAction? = nil,
        iPSetDescriptor: IPSetDescriptor? = nil
    )
    {
        self.action = action
        self.iPSetDescriptor = iPSetDescriptor
    }
}

public struct ListActivatedRulesInRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "ListActivatedRulesInRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActivatedRulesInRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActivatedRulesInRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActivatedRulesInRuleGroupInput>
    public typealias MOutput = OperationOutput<ListActivatedRulesInRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActivatedRulesInRuleGroupOutputError>
}

extension ListActivatedRulesInRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActivatedRulesInRuleGroupInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), ruleGroupId: \(String(describing: ruleGroupId)))"}
}

extension ListActivatedRulesInRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case ruleGroupId = "RuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let ruleGroupId = ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
    }
}

public struct ListActivatedRulesInRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ListActivatedRulesInRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActivatedRulesInRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActivatedRulesInRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActivatedRulesInRuleGroupInput>
    public typealias MOutput = OperationOutput<ListActivatedRulesInRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActivatedRulesInRuleGroupOutputError>
}

public struct ListActivatedRulesInRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ListActivatedRulesInRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActivatedRulesInRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActivatedRulesInRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActivatedRulesInRuleGroupInput>
    public typealias MOutput = OperationOutput<ListActivatedRulesInRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActivatedRulesInRuleGroupOutputError>
}

public struct ListActivatedRulesInRuleGroupInput: Equatable {
    /// <p>Specifies the number of <code>ActivatedRules</code> that you want AWS WAF to return for this request. If you have more <code>ActivatedRules</code> than the number that you specify for <code>Limit</code>, the response includes a
    ///          <code>NextMarker</code> value that you can use to get another batch of <code>ActivatedRules</code>.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>ActivatedRules</code> than the value of <code>Limit</code>,
    ///          AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>ActivatedRules</code>.
    ///          For the second and subsequent <code>ListActivatedRulesInRuleGroup</code> requests, specify the value of <code>NextMarker</code>
    ///          from the previous response to get information about another batch of <code>ActivatedRules</code>.</p>
    public let nextMarker: String?
    /// <p>The <code>RuleGroupId</code> of the <a>RuleGroup</a> for which you want to get a list of <a>ActivatedRule</a> objects.</p>
    public let ruleGroupId: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil,
        ruleGroupId: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.ruleGroupId = ruleGroupId
    }
}

struct ListActivatedRulesInRuleGroupInputBody: Equatable {
    public let ruleGroupId: String?
    public let nextMarker: String?
    public let limit: Int
}

extension ListActivatedRulesInRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case ruleGroupId = "RuleGroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListActivatedRulesInRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActivatedRulesInRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActivatedRulesInRuleGroupOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActivatedRulesInRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActivatedRulesInRuleGroupOutputResponse(activatedRules: \(String(describing: activatedRules)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListActivatedRulesInRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListActivatedRulesInRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.activatedRules = output.activatedRules
            self.nextMarker = output.nextMarker
        } else {
            self.activatedRules = nil
            self.nextMarker = nil
        }
    }
}

public struct ListActivatedRulesInRuleGroupOutputResponse: Equatable {
    /// <p>An array of <code>ActivatedRules</code> objects.</p>
    public let activatedRules: [ActivatedRule]?
    /// <p>If you have more <code>ActivatedRules</code> than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>ActivatedRules</code>, submit another <code>ListActivatedRulesInRuleGroup</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?

    public init (
        activatedRules: [ActivatedRule]? = nil,
        nextMarker: String? = nil
    )
    {
        self.activatedRules = activatedRules
        self.nextMarker = nextMarker
    }
}

struct ListActivatedRulesInRuleGroupOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let activatedRules: [ActivatedRule]?
}

extension ListActivatedRulesInRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activatedRules = "ActivatedRules"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let activatedRulesContainer = try containerValues.decodeIfPresent([ActivatedRule?].self, forKey: .activatedRules)
        var activatedRulesDecoded0:[ActivatedRule]? = nil
        if let activatedRulesContainer = activatedRulesContainer {
            activatedRulesDecoded0 = [ActivatedRule]()
            for structure0 in activatedRulesContainer {
                if let structure0 = structure0 {
                    activatedRulesDecoded0?.append(structure0)
                }
            }
        }
        activatedRules = activatedRulesDecoded0
    }
}

public struct ListByteMatchSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListByteMatchSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListByteMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListByteMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListByteMatchSetsInput>
    public typealias MOutput = OperationOutput<ListByteMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListByteMatchSetsOutputError>
}

extension ListByteMatchSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListByteMatchSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListByteMatchSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListByteMatchSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListByteMatchSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListByteMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListByteMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListByteMatchSetsInput>
    public typealias MOutput = OperationOutput<ListByteMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListByteMatchSetsOutputError>
}

public struct ListByteMatchSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListByteMatchSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListByteMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListByteMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListByteMatchSetsInput>
    public typealias MOutput = OperationOutput<ListByteMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListByteMatchSetsOutputError>
}

public struct ListByteMatchSetsInput: Equatable {
    /// <p>Specifies the number of <code>ByteMatchSet</code> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>ByteMatchSets</code> objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>ByteMatchSet</code> objects.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>ByteMatchSets</code> than the value of <code>Limit</code>,
    /// 			AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>ByteMatchSets</code>.
    /// 			For the second and subsequent <code>ListByteMatchSets</code> requests, specify the value of <code>NextMarker</code>
    /// 			from the previous response to get information about another batch of <code>ByteMatchSets</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListByteMatchSetsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListByteMatchSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListByteMatchSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListByteMatchSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListByteMatchSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListByteMatchSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListByteMatchSetsOutputResponse(byteMatchSets: \(String(describing: byteMatchSets)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListByteMatchSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListByteMatchSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.byteMatchSets = output.byteMatchSets
            self.nextMarker = output.nextMarker
        } else {
            self.byteMatchSets = nil
            self.nextMarker = nil
        }
    }
}

public struct ListByteMatchSetsOutputResponse: Equatable {
    /// <p>An array of <a>ByteMatchSetSummary</a> objects.</p>
    public let byteMatchSets: [ByteMatchSetSummary]?
    /// <p>If you have more <code>ByteMatchSet</code> objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more <code>ByteMatchSet</code> objects, submit another
    /// 			<code>ListByteMatchSets</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?

    public init (
        byteMatchSets: [ByteMatchSetSummary]? = nil,
        nextMarker: String? = nil
    )
    {
        self.byteMatchSets = byteMatchSets
        self.nextMarker = nextMarker
    }
}

struct ListByteMatchSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let byteMatchSets: [ByteMatchSetSummary]?
}

extension ListByteMatchSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byteMatchSets = "ByteMatchSets"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let byteMatchSetsContainer = try containerValues.decodeIfPresent([ByteMatchSetSummary?].self, forKey: .byteMatchSets)
        var byteMatchSetsDecoded0:[ByteMatchSetSummary]? = nil
        if let byteMatchSetsContainer = byteMatchSetsContainer {
            byteMatchSetsDecoded0 = [ByteMatchSetSummary]()
            for structure0 in byteMatchSetsContainer {
                if let structure0 = structure0 {
                    byteMatchSetsDecoded0?.append(structure0)
                }
            }
        }
        byteMatchSets = byteMatchSetsDecoded0
    }
}

public struct ListGeoMatchSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListGeoMatchSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGeoMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGeoMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGeoMatchSetsInput>
    public typealias MOutput = OperationOutput<ListGeoMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGeoMatchSetsOutputError>
}

extension ListGeoMatchSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGeoMatchSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListGeoMatchSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListGeoMatchSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGeoMatchSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGeoMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGeoMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGeoMatchSetsInput>
    public typealias MOutput = OperationOutput<ListGeoMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGeoMatchSetsOutputError>
}

public struct ListGeoMatchSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGeoMatchSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGeoMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGeoMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGeoMatchSetsInput>
    public typealias MOutput = OperationOutput<ListGeoMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGeoMatchSetsOutputError>
}

public struct ListGeoMatchSetsInput: Equatable {
    /// <p>Specifies the number of <code>GeoMatchSet</code> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>GeoMatchSet</code> objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>GeoMatchSet</code> objects.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>GeoMatchSet</code>s than the value of <code>Limit</code>,
    /// 			AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>GeoMatchSet</code> objects.
    /// 			For the second and subsequent <code>ListGeoMatchSets</code> requests, specify the value of <code>NextMarker</code>
    /// 			from the previous response to get information about another batch of <code>GeoMatchSet</code> objects.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListGeoMatchSetsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListGeoMatchSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListGeoMatchSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGeoMatchSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGeoMatchSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGeoMatchSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGeoMatchSetsOutputResponse(geoMatchSets: \(String(describing: geoMatchSets)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListGeoMatchSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGeoMatchSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.geoMatchSets = output.geoMatchSets
            self.nextMarker = output.nextMarker
        } else {
            self.geoMatchSets = nil
            self.nextMarker = nil
        }
    }
}

public struct ListGeoMatchSetsOutputResponse: Equatable {
    /// <p>An array of <a>GeoMatchSetSummary</a> objects.</p>
    public let geoMatchSets: [GeoMatchSetSummary]?
    /// <p>If you have more <code>GeoMatchSet</code> objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more <code>GeoMatchSet</code> objects, submit another
    /// 			<code>ListGeoMatchSets</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?

    public init (
        geoMatchSets: [GeoMatchSetSummary]? = nil,
        nextMarker: String? = nil
    )
    {
        self.geoMatchSets = geoMatchSets
        self.nextMarker = nextMarker
    }
}

struct ListGeoMatchSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let geoMatchSets: [GeoMatchSetSummary]?
}

extension ListGeoMatchSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case geoMatchSets = "GeoMatchSets"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let geoMatchSetsContainer = try containerValues.decodeIfPresent([GeoMatchSetSummary?].self, forKey: .geoMatchSets)
        var geoMatchSetsDecoded0:[GeoMatchSetSummary]? = nil
        if let geoMatchSetsContainer = geoMatchSetsContainer {
            geoMatchSetsDecoded0 = [GeoMatchSetSummary]()
            for structure0 in geoMatchSetsContainer {
                if let structure0 = structure0 {
                    geoMatchSetsDecoded0?.append(structure0)
                }
            }
        }
        geoMatchSets = geoMatchSetsDecoded0
    }
}

public struct ListIPSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListIPSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIPSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIPSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIPSetsInput>
    public typealias MOutput = OperationOutput<ListIPSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIPSetsOutputError>
}

extension ListIPSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIPSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListIPSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListIPSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIPSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIPSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIPSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIPSetsInput>
    public typealias MOutput = OperationOutput<ListIPSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIPSetsOutputError>
}

public struct ListIPSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIPSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIPSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIPSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIPSetsInput>
    public typealias MOutput = OperationOutput<ListIPSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIPSetsOutputError>
}

public struct ListIPSetsInput: Equatable {
    /// <p>Specifies the number of <code>IPSet</code> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>IPSet</code> objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>IPSet</code> objects.</p>
    public let limit: Int
    /// <p>AWS WAF returns a <code>NextMarker</code> value in the response that allows you to
    ///          list another group of <code>IPSets</code>. For the second and subsequent
    ///             <code>ListIPSets</code> requests, specify the value of <code>NextMarker</code> from the
    ///          previous response to get information about another batch of <code>IPSets</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListIPSetsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListIPSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListIPSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIPSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIPSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIPSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIPSetsOutputResponse(iPSets: \(String(describing: iPSets)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListIPSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIPSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iPSets = output.iPSets
            self.nextMarker = output.nextMarker
        } else {
            self.iPSets = nil
            self.nextMarker = nil
        }
    }
}

public struct ListIPSetsOutputResponse: Equatable {
    /// <p>An array of <a>IPSetSummary</a> objects.</p>
    public let iPSets: [IPSetSummary]?
    /// <p>To list more <code>IPSet</code> objects, submit another <code>ListIPSets</code>
    ///          request, and in the next request use the <code>NextMarker</code> response value as the
    ///             <code>NextMarker</code> value.</p>
    public let nextMarker: String?

    public init (
        iPSets: [IPSetSummary]? = nil,
        nextMarker: String? = nil
    )
    {
        self.iPSets = iPSets
        self.nextMarker = nextMarker
    }
}

struct ListIPSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let iPSets: [IPSetSummary]?
}

extension ListIPSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iPSets = "IPSets"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let iPSetsContainer = try containerValues.decodeIfPresent([IPSetSummary?].self, forKey: .iPSets)
        var iPSetsDecoded0:[IPSetSummary]? = nil
        if let iPSetsContainer = iPSetsContainer {
            iPSetsDecoded0 = [IPSetSummary]()
            for structure0 in iPSetsContainer {
                if let structure0 = structure0 {
                    iPSetsDecoded0?.append(structure0)
                }
            }
        }
        iPSets = iPSetsDecoded0
    }
}

public struct ListLoggingConfigurationsInputBodyMiddleware: Middleware {
    public let id: String = "ListLoggingConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLoggingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggingConfigurationsOutputError>
}

extension ListLoggingConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLoggingConfigurationsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListLoggingConfigurationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListLoggingConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLoggingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLoggingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggingConfigurationsOutputError>
}

public struct ListLoggingConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLoggingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLoggingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLoggingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLoggingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListLoggingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLoggingConfigurationsOutputError>
}

public struct ListLoggingConfigurationsInput: Equatable {
    /// <p>Specifies the number of <code>LoggingConfigurations</code> that you want AWS WAF to return for this request. If you have more <code>LoggingConfigurations</code> than the number that you specify for <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can use to get another batch of <code>LoggingConfigurations</code>.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>LoggingConfigurations</code> than the value of <code>Limit</code>,
    /// 			AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>LoggingConfigurations</code>.
    /// 			For the second and subsequent <code>ListLoggingConfigurations</code> requests, specify the value of <code>NextMarker</code>
    /// 			from the previous response to get information about another batch of <code>ListLoggingConfigurations</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListLoggingConfigurationsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListLoggingConfigurationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListLoggingConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLoggingConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLoggingConfigurationsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLoggingConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLoggingConfigurationsOutputResponse(loggingConfigurations: \(String(describing: loggingConfigurations)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListLoggingConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLoggingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingConfigurations = output.loggingConfigurations
            self.nextMarker = output.nextMarker
        } else {
            self.loggingConfigurations = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLoggingConfigurationsOutputResponse: Equatable {
    /// <p>An array of <a>LoggingConfiguration</a> objects.</p>
    public let loggingConfigurations: [LoggingConfiguration]?
    /// <p>If you have more <code>LoggingConfigurations</code> than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>LoggingConfigurations</code>, submit another <code>ListLoggingConfigurations</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?

    public init (
        loggingConfigurations: [LoggingConfiguration]? = nil,
        nextMarker: String? = nil
    )
    {
        self.loggingConfigurations = loggingConfigurations
        self.nextMarker = nextMarker
    }
}

struct ListLoggingConfigurationsOutputResponseBody: Equatable {
    public let loggingConfigurations: [LoggingConfiguration]?
    public let nextMarker: String?
}

extension ListLoggingConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingConfigurations = "LoggingConfigurations"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationsContainer = try containerValues.decodeIfPresent([LoggingConfiguration?].self, forKey: .loggingConfigurations)
        var loggingConfigurationsDecoded0:[LoggingConfiguration]? = nil
        if let loggingConfigurationsContainer = loggingConfigurationsContainer {
            loggingConfigurationsDecoded0 = [LoggingConfiguration]()
            for structure0 in loggingConfigurationsContainer {
                if let structure0 = structure0 {
                    loggingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        loggingConfigurations = loggingConfigurationsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct ListRateBasedRulesInputBodyMiddleware: Middleware {
    public let id: String = "ListRateBasedRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRateBasedRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRateBasedRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRateBasedRulesInput>
    public typealias MOutput = OperationOutput<ListRateBasedRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRateBasedRulesOutputError>
}

extension ListRateBasedRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRateBasedRulesInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListRateBasedRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListRateBasedRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRateBasedRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRateBasedRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRateBasedRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRateBasedRulesInput>
    public typealias MOutput = OperationOutput<ListRateBasedRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRateBasedRulesOutputError>
}

public struct ListRateBasedRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRateBasedRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRateBasedRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRateBasedRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRateBasedRulesInput>
    public typealias MOutput = OperationOutput<ListRateBasedRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRateBasedRulesOutputError>
}

public struct ListRateBasedRulesInput: Equatable {
    /// <p>Specifies the number of <code>Rules</code> that you want AWS WAF to return for this
    ///          request. If you have more <code>Rules</code> than the number that you specify for
    ///             <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can
    ///          use to get another batch of <code>Rules</code>.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>Rules</code>
    ///          than the value of <code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the
    ///          response that allows you to list another group of <code>Rules</code>. For the second and
    ///          subsequent <code>ListRateBasedRules</code> requests, specify the value of
    ///             <code>NextMarker</code> from the previous response to get information about another
    ///          batch of <code>Rules</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListRateBasedRulesInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListRateBasedRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRateBasedRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRateBasedRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRateBasedRulesOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRateBasedRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRateBasedRulesOutputResponse(nextMarker: \(String(describing: nextMarker)), rules: \(String(describing: rules)))"}
}

extension ListRateBasedRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRateBasedRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.rules = output.rules
        } else {
            self.nextMarker = nil
            self.rules = nil
        }
    }
}

public struct ListRateBasedRulesOutputResponse: Equatable {
    /// <p>If you have more <code>Rules</code> than the number that you specified for
    ///             <code>Limit</code> in the request, the response includes a <code>NextMarker</code>
    ///          value. To list more <code>Rules</code>, submit another <code>ListRateBasedRules</code>
    ///          request, and specify the <code>NextMarker</code> value from the response in the
    ///             <code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>RuleSummary</a> objects.</p>
    public let rules: [RuleSummary]?

    public init (
        nextMarker: String? = nil,
        rules: [RuleSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.rules = rules
    }
}

struct ListRateBasedRulesOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let rules: [RuleSummary]?
}

extension ListRateBasedRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let rulesContainer = try containerValues.decodeIfPresent([RuleSummary?].self, forKey: .rules)
        var rulesDecoded0:[RuleSummary]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [RuleSummary]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

public struct ListRegexMatchSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListRegexMatchSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexMatchSetsInput>
    public typealias MOutput = OperationOutput<ListRegexMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexMatchSetsOutputError>
}

extension ListRegexMatchSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegexMatchSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListRegexMatchSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListRegexMatchSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRegexMatchSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexMatchSetsInput>
    public typealias MOutput = OperationOutput<ListRegexMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexMatchSetsOutputError>
}

public struct ListRegexMatchSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRegexMatchSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexMatchSetsInput>
    public typealias MOutput = OperationOutput<ListRegexMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexMatchSetsOutputError>
}

public struct ListRegexMatchSetsInput: Equatable {
    /// <p>Specifies the number of <code>RegexMatchSet</code> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>RegexMatchSet</code> objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>RegexMatchSet</code> objects.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>RegexMatchSet</code> objects than the value of <code>Limit</code>,
    /// 			AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>ByteMatchSets</code>.
    /// 			For the second and subsequent <code>ListRegexMatchSets</code> requests, specify the value of <code>NextMarker</code>
    /// 			from the previous response to get information about another batch of <code>RegexMatchSet</code> objects.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListRegexMatchSetsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListRegexMatchSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRegexMatchSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRegexMatchSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRegexMatchSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegexMatchSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegexMatchSetsOutputResponse(nextMarker: \(String(describing: nextMarker)), regexMatchSets: \(String(describing: regexMatchSets)))"}
}

extension ListRegexMatchSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRegexMatchSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.regexMatchSets = output.regexMatchSets
        } else {
            self.nextMarker = nil
            self.regexMatchSets = nil
        }
    }
}

public struct ListRegexMatchSetsOutputResponse: Equatable {
    /// <p>If you have more <code>RegexMatchSet</code> objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more <code>RegexMatchSet</code> objects, submit another
    /// 			<code>ListRegexMatchSets</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>RegexMatchSetSummary</a> objects.</p>
    public let regexMatchSets: [RegexMatchSetSummary]?

    public init (
        nextMarker: String? = nil,
        regexMatchSets: [RegexMatchSetSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.regexMatchSets = regexMatchSets
    }
}

struct ListRegexMatchSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let regexMatchSets: [RegexMatchSetSummary]?
}

extension ListRegexMatchSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case regexMatchSets = "RegexMatchSets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let regexMatchSetsContainer = try containerValues.decodeIfPresent([RegexMatchSetSummary?].self, forKey: .regexMatchSets)
        var regexMatchSetsDecoded0:[RegexMatchSetSummary]? = nil
        if let regexMatchSetsContainer = regexMatchSetsContainer {
            regexMatchSetsDecoded0 = [RegexMatchSetSummary]()
            for structure0 in regexMatchSetsContainer {
                if let structure0 = structure0 {
                    regexMatchSetsDecoded0?.append(structure0)
                }
            }
        }
        regexMatchSets = regexMatchSetsDecoded0
    }
}

public struct ListRegexPatternSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListRegexPatternSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexPatternSetsInput>
    public typealias MOutput = OperationOutput<ListRegexPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexPatternSetsOutputError>
}

extension ListRegexPatternSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegexPatternSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListRegexPatternSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListRegexPatternSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRegexPatternSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexPatternSetsInput>
    public typealias MOutput = OperationOutput<ListRegexPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexPatternSetsOutputError>
}

public struct ListRegexPatternSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRegexPatternSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRegexPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRegexPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRegexPatternSetsInput>
    public typealias MOutput = OperationOutput<ListRegexPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRegexPatternSetsOutputError>
}

public struct ListRegexPatternSetsInput: Equatable {
    /// <p>Specifies the number of <code>RegexPatternSet</code> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>RegexPatternSet</code> objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>RegexPatternSet</code> objects.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>RegexPatternSet</code> objects than the value of <code>Limit</code>,
    /// 			AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>RegexPatternSet</code> objects.
    /// 			For the second and subsequent <code>ListRegexPatternSets</code> requests, specify the value of <code>NextMarker</code>
    /// 			from the previous response to get information about another batch of <code>RegexPatternSet</code> objects.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListRegexPatternSetsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListRegexPatternSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRegexPatternSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRegexPatternSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRegexPatternSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRegexPatternSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRegexPatternSetsOutputResponse(nextMarker: \(String(describing: nextMarker)), regexPatternSets: \(String(describing: regexPatternSets)))"}
}

extension ListRegexPatternSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRegexPatternSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.regexPatternSets = output.regexPatternSets
        } else {
            self.nextMarker = nil
            self.regexPatternSets = nil
        }
    }
}

public struct ListRegexPatternSetsOutputResponse: Equatable {
    /// <p>If you have more <code>RegexPatternSet</code> objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more <code>RegexPatternSet</code> objects, submit another
    /// 			<code>ListRegexPatternSets</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>RegexPatternSetSummary</a> objects.</p>
    public let regexPatternSets: [RegexPatternSetSummary]?

    public init (
        nextMarker: String? = nil,
        regexPatternSets: [RegexPatternSetSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.regexPatternSets = regexPatternSets
    }
}

struct ListRegexPatternSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let regexPatternSets: [RegexPatternSetSummary]?
}

extension ListRegexPatternSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case regexPatternSets = "RegexPatternSets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let regexPatternSetsContainer = try containerValues.decodeIfPresent([RegexPatternSetSummary?].self, forKey: .regexPatternSets)
        var regexPatternSetsDecoded0:[RegexPatternSetSummary]? = nil
        if let regexPatternSetsContainer = regexPatternSetsContainer {
            regexPatternSetsDecoded0 = [RegexPatternSetSummary]()
            for structure0 in regexPatternSetsContainer {
                if let structure0 = structure0 {
                    regexPatternSetsDecoded0?.append(structure0)
                }
            }
        }
        regexPatternSets = regexPatternSetsDecoded0
    }
}

public struct ListRuleGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

extension ListRuleGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRuleGroupsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListRuleGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListRuleGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

public struct ListRuleGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

public struct ListRuleGroupsInput: Equatable {
    /// <p>Specifies the number of <code>RuleGroups</code> that you want AWS WAF to return for this request. If you have more <code>RuleGroups</code> than the number that you specify for <code>Limit</code>, the response includes a <code>NextMarker</code> value that you can use to get another batch of <code>RuleGroups</code>.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>RuleGroups</code> than the value of <code>Limit</code>,
    ///          AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>RuleGroups</code>.
    ///          For the second and subsequent <code>ListRuleGroups</code> requests, specify the value of <code>NextMarker</code>
    ///          from the previous response to get information about another batch of <code>RuleGroups</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListRuleGroupsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListRuleGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRuleGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRuleGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRuleGroupsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRuleGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRuleGroupsOutputResponse(nextMarker: \(String(describing: nextMarker)), ruleGroups: \(String(describing: ruleGroups)))"}
}

extension ListRuleGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRuleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.ruleGroups = output.ruleGroups
        } else {
            self.nextMarker = nil
            self.ruleGroups = nil
        }
    }
}

public struct ListRuleGroupsOutputResponse: Equatable {
    /// <p>If you have more <code>RuleGroups</code> than the number that you specified for <code>Limit</code> in the request, the response includes a <code>NextMarker</code> value. To list more <code>RuleGroups</code>, submit another <code>ListRuleGroups</code> request, and specify the <code>NextMarker</code> value from the response in the <code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>RuleGroup</a> objects.</p>
    public let ruleGroups: [RuleGroupSummary]?

    public init (
        nextMarker: String? = nil,
        ruleGroups: [RuleGroupSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.ruleGroups = ruleGroups
    }
}

struct ListRuleGroupsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let ruleGroups: [RuleGroupSummary]?
}

extension ListRuleGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case ruleGroups = "RuleGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let ruleGroupsContainer = try containerValues.decodeIfPresent([RuleGroupSummary?].self, forKey: .ruleGroups)
        var ruleGroupsDecoded0:[RuleGroupSummary]? = nil
        if let ruleGroupsContainer = ruleGroupsContainer {
            ruleGroupsDecoded0 = [RuleGroupSummary]()
            for structure0 in ruleGroupsContainer {
                if let structure0 = structure0 {
                    ruleGroupsDecoded0?.append(structure0)
                }
            }
        }
        ruleGroups = ruleGroupsDecoded0
    }
}

public struct ListRulesInputBodyMiddleware: Middleware {
    public let id: String = "ListRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesInput>
    public typealias MOutput = OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesOutputError>
}

extension ListRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRulesInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesInput>
    public typealias MOutput = OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesOutputError>
}

public struct ListRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesInput>
    public typealias MOutput = OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesOutputError>
}

public struct ListRulesInput: Equatable {
    /// <p>Specifies the number of <code>Rules</code> that you want AWS WAF to return for this request. If you have more 			<code>Rules</code> than the number that you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>Rules</code>.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>Rules</code> than the value of <code>Limit</code>,
    /// 			AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>Rules</code>.
    /// 			For the second and subsequent <code>ListRules</code> requests, specify the value of <code>NextMarker</code>
    /// 			from the previous response to get information about another batch of <code>Rules</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListRulesInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRulesOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRulesOutputResponse(nextMarker: \(String(describing: nextMarker)), rules: \(String(describing: rules)))"}
}

extension ListRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.rules = output.rules
        } else {
            self.nextMarker = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutputResponse: Equatable {
    /// <p>If you have more <code>Rules</code> than the number that you specified for <code>Limit</code> in the request, 			the response includes a <code>NextMarker</code> value. To list more <code>Rules</code>, submit another
    /// 			<code>ListRules</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>RuleSummary</a> objects.</p>
    public let rules: [RuleSummary]?

    public init (
        nextMarker: String? = nil,
        rules: [RuleSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.rules = rules
    }
}

struct ListRulesOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let rules: [RuleSummary]?
}

extension ListRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let rulesContainer = try containerValues.decodeIfPresent([RuleSummary?].self, forKey: .rules)
        var rulesDecoded0:[RuleSummary]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [RuleSummary]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

public struct ListSizeConstraintSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListSizeConstraintSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSizeConstraintSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSizeConstraintSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSizeConstraintSetsInput>
    public typealias MOutput = OperationOutput<ListSizeConstraintSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSizeConstraintSetsOutputError>
}

extension ListSizeConstraintSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSizeConstraintSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListSizeConstraintSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListSizeConstraintSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSizeConstraintSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSizeConstraintSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSizeConstraintSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSizeConstraintSetsInput>
    public typealias MOutput = OperationOutput<ListSizeConstraintSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSizeConstraintSetsOutputError>
}

public struct ListSizeConstraintSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSizeConstraintSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSizeConstraintSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSizeConstraintSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSizeConstraintSetsInput>
    public typealias MOutput = OperationOutput<ListSizeConstraintSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSizeConstraintSetsOutputError>
}

public struct ListSizeConstraintSetsInput: Equatable {
    /// <p>Specifies the number of <code>SizeConstraintSet</code> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>SizeConstraintSets</code> objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>SizeConstraintSet</code> objects.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>SizeConstraintSets</code> than the value of <code>Limit</code>,
    /// 			AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of <code>SizeConstraintSets</code>.
    /// 			For the second and subsequent <code>ListSizeConstraintSets</code> requests, specify the value of <code>NextMarker</code> 			from the previous response to get information about another batch of <code>SizeConstraintSets</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListSizeConstraintSetsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListSizeConstraintSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListSizeConstraintSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSizeConstraintSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSizeConstraintSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSizeConstraintSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSizeConstraintSetsOutputResponse(nextMarker: \(String(describing: nextMarker)), sizeConstraintSets: \(String(describing: sizeConstraintSets)))"}
}

extension ListSizeConstraintSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSizeConstraintSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.sizeConstraintSets = output.sizeConstraintSets
        } else {
            self.nextMarker = nil
            self.sizeConstraintSets = nil
        }
    }
}

public struct ListSizeConstraintSetsOutputResponse: Equatable {
    /// <p>If you have more <code>SizeConstraintSet</code> objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more <code>SizeConstraintSet</code> objects, submit another
    /// 			<code>ListSizeConstraintSets</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>SizeConstraintSetSummary</a> objects.</p>
    public let sizeConstraintSets: [SizeConstraintSetSummary]?

    public init (
        nextMarker: String? = nil,
        sizeConstraintSets: [SizeConstraintSetSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.sizeConstraintSets = sizeConstraintSets
    }
}

struct ListSizeConstraintSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let sizeConstraintSets: [SizeConstraintSetSummary]?
}

extension ListSizeConstraintSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case sizeConstraintSets = "SizeConstraintSets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let sizeConstraintSetsContainer = try containerValues.decodeIfPresent([SizeConstraintSetSummary?].self, forKey: .sizeConstraintSets)
        var sizeConstraintSetsDecoded0:[SizeConstraintSetSummary]? = nil
        if let sizeConstraintSetsContainer = sizeConstraintSetsContainer {
            sizeConstraintSetsDecoded0 = [SizeConstraintSetSummary]()
            for structure0 in sizeConstraintSetsContainer {
                if let structure0 = structure0 {
                    sizeConstraintSetsDecoded0?.append(structure0)
                }
            }
        }
        sizeConstraintSets = sizeConstraintSetsDecoded0
    }
}

public struct ListSqlInjectionMatchSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListSqlInjectionMatchSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSqlInjectionMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSqlInjectionMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSqlInjectionMatchSetsInput>
    public typealias MOutput = OperationOutput<ListSqlInjectionMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSqlInjectionMatchSetsOutputError>
}

extension ListSqlInjectionMatchSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSqlInjectionMatchSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListSqlInjectionMatchSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListSqlInjectionMatchSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSqlInjectionMatchSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSqlInjectionMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSqlInjectionMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSqlInjectionMatchSetsInput>
    public typealias MOutput = OperationOutput<ListSqlInjectionMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSqlInjectionMatchSetsOutputError>
}

public struct ListSqlInjectionMatchSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSqlInjectionMatchSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSqlInjectionMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSqlInjectionMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSqlInjectionMatchSetsInput>
    public typealias MOutput = OperationOutput<ListSqlInjectionMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSqlInjectionMatchSetsOutputError>
}

/// <p>A request to list the <a>SqlInjectionMatchSet</a> objects created by the current AWS account.</p>
public struct ListSqlInjectionMatchSetsInput: Equatable {
    /// <p>Specifies the number of <a>SqlInjectionMatchSet</a> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>SqlInjectionMatchSet</code> objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>Rules</code>.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <a>SqlInjectionMatchSet</a> objects than the value of
    /// 			<code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of
    /// 			<code>SqlInjectionMatchSets</code>. For the second and subsequent <code>ListSqlInjectionMatchSets</code> requests, specify the
    /// 			value of <code>NextMarker</code> from the previous response to get information about another batch of <code>SqlInjectionMatchSets</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListSqlInjectionMatchSetsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListSqlInjectionMatchSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListSqlInjectionMatchSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSqlInjectionMatchSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSqlInjectionMatchSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSqlInjectionMatchSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSqlInjectionMatchSetsOutputResponse(nextMarker: \(String(describing: nextMarker)), sqlInjectionMatchSets: \(String(describing: sqlInjectionMatchSets)))"}
}

extension ListSqlInjectionMatchSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSqlInjectionMatchSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.sqlInjectionMatchSets = output.sqlInjectionMatchSets
        } else {
            self.nextMarker = nil
            self.sqlInjectionMatchSets = nil
        }
    }
}

/// <p>The response to a <a>ListSqlInjectionMatchSets</a> request.</p>
public struct ListSqlInjectionMatchSetsOutputResponse: Equatable {
    /// <p>If you have more <a>SqlInjectionMatchSet</a> objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more <code>SqlInjectionMatchSet</code> objects, submit another
    /// 			<code>ListSqlInjectionMatchSets</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>SqlInjectionMatchSetSummary</a> objects.</p>
    public let sqlInjectionMatchSets: [SqlInjectionMatchSetSummary]?

    public init (
        nextMarker: String? = nil,
        sqlInjectionMatchSets: [SqlInjectionMatchSetSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.sqlInjectionMatchSets = sqlInjectionMatchSets
    }
}

struct ListSqlInjectionMatchSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let sqlInjectionMatchSets: [SqlInjectionMatchSetSummary]?
}

extension ListSqlInjectionMatchSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case sqlInjectionMatchSets = "SqlInjectionMatchSets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let sqlInjectionMatchSetsContainer = try containerValues.decodeIfPresent([SqlInjectionMatchSetSummary?].self, forKey: .sqlInjectionMatchSets)
        var sqlInjectionMatchSetsDecoded0:[SqlInjectionMatchSetSummary]? = nil
        if let sqlInjectionMatchSetsContainer = sqlInjectionMatchSetsContainer {
            sqlInjectionMatchSetsDecoded0 = [SqlInjectionMatchSetSummary]()
            for structure0 in sqlInjectionMatchSetsContainer {
                if let structure0 = structure0 {
                    sqlInjectionMatchSetsDecoded0?.append(structure0)
                }
            }
        }
        sqlInjectionMatchSets = sqlInjectionMatchSetsDecoded0
    }
}

public struct ListSubscribedRuleGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListSubscribedRuleGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscribedRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscribedRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscribedRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListSubscribedRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscribedRuleGroupsOutputError>
}

extension ListSubscribedRuleGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscribedRuleGroupsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListSubscribedRuleGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListSubscribedRuleGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSubscribedRuleGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscribedRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscribedRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscribedRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListSubscribedRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscribedRuleGroupsOutputError>
}

public struct ListSubscribedRuleGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSubscribedRuleGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSubscribedRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSubscribedRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSubscribedRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListSubscribedRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSubscribedRuleGroupsOutputError>
}

public struct ListSubscribedRuleGroupsInput: Equatable {
    /// <p>Specifies the number of subscribed rule groups that you want AWS WAF to return for this request. If you have more
    /// 			objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of objects.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>ByteMatchSets</code>subscribed rule groups than the value of <code>Limit</code>,
    /// 			AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of subscribed rule groups.
    /// 			For the second and subsequent <code>ListSubscribedRuleGroupsRequest</code> requests, specify the value of <code>NextMarker</code>
    /// 			from the previous response to get information about another batch of subscribed rule groups.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListSubscribedRuleGroupsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListSubscribedRuleGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListSubscribedRuleGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSubscribedRuleGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSubscribedRuleGroupsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSubscribedRuleGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSubscribedRuleGroupsOutputResponse(nextMarker: \(String(describing: nextMarker)), ruleGroups: \(String(describing: ruleGroups)))"}
}

extension ListSubscribedRuleGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSubscribedRuleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.ruleGroups = output.ruleGroups
        } else {
            self.nextMarker = nil
            self.ruleGroups = nil
        }
    }
}

public struct ListSubscribedRuleGroupsOutputResponse: Equatable {
    /// <p>If you have more objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more objects, submit another
    /// 			<code>ListSubscribedRuleGroups</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>RuleGroup</a> objects.</p>
    public let ruleGroups: [SubscribedRuleGroupSummary]?

    public init (
        nextMarker: String? = nil,
        ruleGroups: [SubscribedRuleGroupSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.ruleGroups = ruleGroups
    }
}

struct ListSubscribedRuleGroupsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let ruleGroups: [SubscribedRuleGroupSummary]?
}

extension ListSubscribedRuleGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case ruleGroups = "RuleGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let ruleGroupsContainer = try containerValues.decodeIfPresent([SubscribedRuleGroupSummary?].self, forKey: .ruleGroups)
        var ruleGroupsDecoded0:[SubscribedRuleGroupSummary]? = nil
        if let ruleGroupsContainer = ruleGroupsContainer {
            ruleGroupsDecoded0 = [SubscribedRuleGroupSummary]()
            for structure0 in ruleGroupsContainer {
                if let structure0 = structure0 {
                    ruleGroupsDecoded0?.append(structure0)
                }
            }
        }
        ruleGroups = ruleGroupsDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)), resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p></p>
    public let limit: Int
    /// <p></p>
    public let nextMarker: String?
    /// <p></p>
    public let resourceARN: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil,
        resourceARN: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFBadRequestException" : self = .wAFBadRequestException(try WAFBadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case wAFBadRequestException(WAFBadRequestException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextMarker: \(String(describing: nextMarker)), tagInfoForResource: \(String(describing: tagInfoForResource)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.tagInfoForResource = output.tagInfoForResource
        } else {
            self.nextMarker = nil
            self.tagInfoForResource = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p></p>
    public let nextMarker: String?
    /// <p></p>
    public let tagInfoForResource: TagInfoForResource?

    public init (
        nextMarker: String? = nil,
        tagInfoForResource: TagInfoForResource? = nil
    )
    {
        self.nextMarker = nextMarker
        self.tagInfoForResource = tagInfoForResource
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let tagInfoForResource: TagInfoForResource?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case tagInfoForResource = "TagInfoForResource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let tagInfoForResourceDecoded = try containerValues.decodeIfPresent(TagInfoForResource.self, forKey: .tagInfoForResource)
        tagInfoForResource = tagInfoForResourceDecoded
    }
}

public struct ListWebACLsInputBodyMiddleware: Middleware {
    public let id: String = "ListWebACLsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebACLsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebACLsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebACLsInput>
    public typealias MOutput = OperationOutput<ListWebACLsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebACLsOutputError>
}

extension ListWebACLsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebACLsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListWebACLsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListWebACLsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWebACLsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebACLsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebACLsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebACLsInput>
    public typealias MOutput = OperationOutput<ListWebACLsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebACLsOutputError>
}

public struct ListWebACLsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWebACLsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebACLsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebACLsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebACLsInput>
    public typealias MOutput = OperationOutput<ListWebACLsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebACLsOutputError>
}

public struct ListWebACLsInput: Equatable {
    /// <p>Specifies the number of <code>WebACL</code> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>WebACL</code> objects than the number that you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>WebACL</code> objects.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <code>WebACL</code> objects than the number that you specify
    /// 			for <code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of
    /// 			<code>WebACL</code> objects. For the second and subsequent <code>ListWebACLs</code> requests, specify the value of <code>NextMarker</code>
    /// 			from the previous response to get information about another batch of <code>WebACL</code> objects.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListWebACLsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListWebACLsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListWebACLsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebACLsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebACLsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebACLsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebACLsOutputResponse(nextMarker: \(String(describing: nextMarker)), webACLs: \(String(describing: webACLs)))"}
}

extension ListWebACLsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWebACLsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.webACLs = output.webACLs
        } else {
            self.nextMarker = nil
            self.webACLs = nil
        }
    }
}

public struct ListWebACLsOutputResponse: Equatable {
    /// <p>If you have more <code>WebACL</code> objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more <code>WebACL</code> objects, submit another
    /// 			<code>ListWebACLs</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>WebACLSummary</a> objects.</p>
    public let webACLs: [WebACLSummary]?

    public init (
        nextMarker: String? = nil,
        webACLs: [WebACLSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.webACLs = webACLs
    }
}

struct ListWebACLsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let webACLs: [WebACLSummary]?
}

extension ListWebACLsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case webACLs = "WebACLs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let webACLsContainer = try containerValues.decodeIfPresent([WebACLSummary?].self, forKey: .webACLs)
        var webACLsDecoded0:[WebACLSummary]? = nil
        if let webACLsContainer = webACLsContainer {
            webACLsDecoded0 = [WebACLSummary]()
            for structure0 in webACLsContainer {
                if let structure0 = structure0 {
                    webACLsDecoded0?.append(structure0)
                }
            }
        }
        webACLs = webACLsDecoded0
    }
}

public struct ListXssMatchSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListXssMatchSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListXssMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListXssMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListXssMatchSetsInput>
    public typealias MOutput = OperationOutput<ListXssMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListXssMatchSetsOutputError>
}

extension ListXssMatchSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListXssMatchSetsInput(limit: \(String(describing: limit)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListXssMatchSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextMarker = nextMarker {
            try encodeContainer.encode(nextMarker, forKey: .nextMarker)
        }
    }
}

public struct ListXssMatchSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListXssMatchSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListXssMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListXssMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListXssMatchSetsInput>
    public typealias MOutput = OperationOutput<ListXssMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListXssMatchSetsOutputError>
}

public struct ListXssMatchSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListXssMatchSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListXssMatchSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListXssMatchSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListXssMatchSetsInput>
    public typealias MOutput = OperationOutput<ListXssMatchSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListXssMatchSetsOutputError>
}

/// <p>A request to list the <a>XssMatchSet</a> objects created by the current AWS account.</p>
public struct ListXssMatchSetsInput: Equatable {
    /// <p>Specifies the number of <a>XssMatchSet</a> objects that you want AWS WAF to return for this request. If you have more
    /// 			<code>XssMatchSet</code> objects than the number you specify for <code>Limit</code>, the response includes a
    /// 			<code>NextMarker</code> value that you can use to get another batch of <code>Rules</code>.</p>
    public let limit: Int
    /// <p>If you specify a value for <code>Limit</code> and you have more <a>XssMatchSet</a> objects than the value of
    /// 			<code>Limit</code>, AWS WAF returns a <code>NextMarker</code> value in the response that allows you to list another group of
    /// 			<code>XssMatchSets</code>. For the second and subsequent <code>ListXssMatchSets</code> requests, specify the
    /// 			value of <code>NextMarker</code> from the previous response to get information about another batch of <code>XssMatchSets</code>.</p>
    public let nextMarker: String?

    public init (
        limit: Int = 0,
        nextMarker: String? = nil
    )
    {
        self.limit = limit
        self.nextMarker = nextMarker
    }
}

struct ListXssMatchSetsInputBody: Equatable {
    public let nextMarker: String?
    public let limit: Int
}

extension ListXssMatchSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let limitDecoded = try containerValues.decode(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListXssMatchSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListXssMatchSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListXssMatchSetsOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListXssMatchSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListXssMatchSetsOutputResponse(nextMarker: \(String(describing: nextMarker)), xssMatchSets: \(String(describing: xssMatchSets)))"}
}

extension ListXssMatchSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListXssMatchSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.xssMatchSets = output.xssMatchSets
        } else {
            self.nextMarker = nil
            self.xssMatchSets = nil
        }
    }
}

/// <p>The response to a <a>ListXssMatchSets</a> request.</p>
public struct ListXssMatchSetsOutputResponse: Equatable {
    /// <p>If you have more <a>XssMatchSet</a> objects than the number that you specified for <code>Limit</code> in the request,
    /// 			the response includes a <code>NextMarker</code> value. To list more <code>XssMatchSet</code> objects, submit another
    /// 			<code>ListXssMatchSets</code> request, and specify the <code>NextMarker</code> value from the response in the
    /// 			<code>NextMarker</code> value in the next request.</p>
    public let nextMarker: String?
    /// <p>An array of <a>XssMatchSetSummary</a> objects.</p>
    public let xssMatchSets: [XssMatchSetSummary]?

    public init (
        nextMarker: String? = nil,
        xssMatchSets: [XssMatchSetSummary]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.xssMatchSets = xssMatchSets
    }
}

struct ListXssMatchSetsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let xssMatchSets: [XssMatchSetSummary]?
}

extension ListXssMatchSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case xssMatchSets = "XssMatchSets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let xssMatchSetsContainer = try containerValues.decodeIfPresent([XssMatchSetSummary?].self, forKey: .xssMatchSets)
        var xssMatchSetsDecoded0:[XssMatchSetSummary]? = nil
        if let xssMatchSetsContainer = xssMatchSetsContainer {
            xssMatchSetsDecoded0 = [XssMatchSetSummary]()
            for structure0 in xssMatchSetsContainer {
                if let structure0 = structure0 {
                    xssMatchSetsDecoded0?.append(structure0)
                }
            }
        }
        xssMatchSets = xssMatchSetsDecoded0
    }
}

extension LoggingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logDestinationConfigs = "LogDestinationConfigs"
        case redactedFields = "RedactedFields"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logDestinationConfigs = logDestinationConfigs {
            var logDestinationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logDestinationConfigs)
            for logdestinationconfigs0 in logDestinationConfigs {
                try logDestinationConfigsContainer.encode(logdestinationconfigs0)
            }
        }
        if let redactedFields = redactedFields {
            var redactedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redactedFields)
            for redactedfields0 in redactedFields {
                try redactedFieldsContainer.encode(redactedfields0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let logDestinationConfigsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logDestinationConfigs)
        var logDestinationConfigsDecoded0:[String]? = nil
        if let logDestinationConfigsContainer = logDestinationConfigsContainer {
            logDestinationConfigsDecoded0 = [String]()
            for string0 in logDestinationConfigsContainer {
                if let string0 = string0 {
                    logDestinationConfigsDecoded0?.append(string0)
                }
            }
        }
        logDestinationConfigs = logDestinationConfigsDecoded0
        let redactedFieldsContainer = try containerValues.decodeIfPresent([FieldToMatch?].self, forKey: .redactedFields)
        var redactedFieldsDecoded0:[FieldToMatch]? = nil
        if let redactedFieldsContainer = redactedFieldsContainer {
            redactedFieldsDecoded0 = [FieldToMatch]()
            for structure0 in redactedFieldsContainer {
                if let structure0 = structure0 {
                    redactedFieldsDecoded0?.append(structure0)
                }
            }
        }
        redactedFields = redactedFieldsDecoded0
    }
}

extension LoggingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfiguration(logDestinationConfigs: \(String(describing: logDestinationConfigs)), redactedFields: \(String(describing: redactedFields)), resourceArn: \(String(describing: resourceArn)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>The Amazon Kinesis Data Firehose, <code>RedactedFields</code>
///          information, and the web ACL Amazon Resource Name (ARN).</p>
public struct LoggingConfiguration: Equatable {
    /// <p>An array of Amazon Kinesis Data Firehose ARNs.</p>
    public let logDestinationConfigs: [String]?
    /// <p>The parts of the request that you want redacted from the logs. For
    ///          example,
    ///          if you redact the cookie field, the cookie field in the firehose will be
    ///             <code>xxx</code>. </p>
    public let redactedFields: [FieldToMatch]?
    /// <p>The Amazon Resource Name (ARN) of the web ACL that you want to associate with
    ///             <code>LogDestinationConfigs</code>.</p>
    public let resourceArn: String?

    public init (
        logDestinationConfigs: [String]? = nil,
        redactedFields: [FieldToMatch]? = nil,
        resourceArn: String? = nil
    )
    {
        self.logDestinationConfigs = logDestinationConfigs
        self.redactedFields = redactedFields
        self.resourceArn = resourceArn
    }
}

public enum MatchFieldType {
    case allQueryArgs
    case body
    case header
    case method
    case queryString
    case singleQueryArg
    case uri
    case sdkUnknown(String)
}

extension MatchFieldType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MatchFieldType] {
        return [
            .allQueryArgs,
            .body,
            .header,
            .method,
            .queryString,
            .singleQueryArg,
            .uri,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allQueryArgs: return "ALL_QUERY_ARGS"
        case .body: return "BODY"
        case .header: return "HEADER"
        case .method: return "METHOD"
        case .queryString: return "QUERY_STRING"
        case .singleQueryArg: return "SINGLE_QUERY_ARG"
        case .uri: return "URI"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MatchFieldType(rawValue: rawValue) ?? MatchFieldType.sdkUnknown(rawValue)
    }
}

public enum MigrationErrorType {
    case entityNotFound
    case entityNotSupported
    case s3BucketInvalidRegion
    case s3BucketNotAccessible
    case s3BucketNotFound
    case s3BucketNoPermission
    case s3InternalError
    case sdkUnknown(String)
}

extension MigrationErrorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MigrationErrorType] {
        return [
            .entityNotFound,
            .entityNotSupported,
            .s3BucketInvalidRegion,
            .s3BucketNotAccessible,
            .s3BucketNotFound,
            .s3BucketNoPermission,
            .s3InternalError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .entityNotFound: return "ENTITY_NOT_FOUND"
        case .entityNotSupported: return "ENTITY_NOT_SUPPORTED"
        case .s3BucketInvalidRegion: return "S3_BUCKET_INVALID_REGION"
        case .s3BucketNotAccessible: return "S3_BUCKET_NOT_ACCESSIBLE"
        case .s3BucketNotFound: return "S3_BUCKET_NOT_FOUND"
        case .s3BucketNoPermission: return "S3_BUCKET_NO_PERMISSION"
        case .s3InternalError: return "S3_INTERNAL_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MigrationErrorType(rawValue: rawValue) ?? MigrationErrorType.sdkUnknown(rawValue)
    }
}

public enum ParameterExceptionField {
    case byteMatchFieldType
    case byteMatchPositionalConstraint
    case byteMatchTextTransformation
    case changeAction
    case geoMatchLocationType
    case geoMatchLocationValue
    case ipsetType
    case nextMarker
    case predicateType
    case rateKey
    case resourceArn
    case ruleType
    case sizeConstraintComparisonOperator
    case sqlInjectionMatchFieldType
    case tags
    case tagKeys
    case wafAction
    case wafOverrideAction
    case sdkUnknown(String)
}

extension ParameterExceptionField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParameterExceptionField] {
        return [
            .byteMatchFieldType,
            .byteMatchPositionalConstraint,
            .byteMatchTextTransformation,
            .changeAction,
            .geoMatchLocationType,
            .geoMatchLocationValue,
            .ipsetType,
            .nextMarker,
            .predicateType,
            .rateKey,
            .resourceArn,
            .ruleType,
            .sizeConstraintComparisonOperator,
            .sqlInjectionMatchFieldType,
            .tags,
            .tagKeys,
            .wafAction,
            .wafOverrideAction,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .byteMatchFieldType: return "BYTE_MATCH_FIELD_TYPE"
        case .byteMatchPositionalConstraint: return "BYTE_MATCH_POSITIONAL_CONSTRAINT"
        case .byteMatchTextTransformation: return "BYTE_MATCH_TEXT_TRANSFORMATION"
        case .changeAction: return "CHANGE_ACTION"
        case .geoMatchLocationType: return "GEO_MATCH_LOCATION_TYPE"
        case .geoMatchLocationValue: return "GEO_MATCH_LOCATION_VALUE"
        case .ipsetType: return "IPSET_TYPE"
        case .nextMarker: return "NEXT_MARKER"
        case .predicateType: return "PREDICATE_TYPE"
        case .rateKey: return "RATE_KEY"
        case .resourceArn: return "RESOURCE_ARN"
        case .ruleType: return "RULE_TYPE"
        case .sizeConstraintComparisonOperator: return "SIZE_CONSTRAINT_COMPARISON_OPERATOR"
        case .sqlInjectionMatchFieldType: return "SQL_INJECTION_MATCH_FIELD_TYPE"
        case .tags: return "TAGS"
        case .tagKeys: return "TAG_KEYS"
        case .wafAction: return "WAF_ACTION"
        case .wafOverrideAction: return "WAF_OVERRIDE_ACTION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParameterExceptionField(rawValue: rawValue) ?? ParameterExceptionField.sdkUnknown(rawValue)
    }
}

public enum ParameterExceptionReason {
    case illegalArgument
    case illegalCombination
    case invalidOption
    case invalidTagKey
    case sdkUnknown(String)
}

extension ParameterExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParameterExceptionReason] {
        return [
            .illegalArgument,
            .illegalCombination,
            .invalidOption,
            .invalidTagKey,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .illegalArgument: return "ILLEGAL_ARGUMENT"
        case .illegalCombination: return "ILLEGAL_COMBINATION"
        case .invalidOption: return "INVALID_OPTION"
        case .invalidTagKey: return "INVALID_TAG_KEY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParameterExceptionReason(rawValue: rawValue) ?? ParameterExceptionReason.sdkUnknown(rawValue)
    }
}

public enum PositionalConstraint {
    case contains
    case containsWord
    case endsWith
    case exactly
    case startsWith
    case sdkUnknown(String)
}

extension PositionalConstraint : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PositionalConstraint] {
        return [
            .contains,
            .containsWord,
            .endsWith,
            .exactly,
            .startsWith,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "CONTAINS"
        case .containsWord: return "CONTAINS_WORD"
        case .endsWith: return "ENDS_WITH"
        case .exactly: return "EXACTLY"
        case .startsWith: return "STARTS_WITH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PositionalConstraint(rawValue: rawValue) ?? PositionalConstraint.sdkUnknown(rawValue)
    }
}

extension Predicate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataId = "DataId"
        case negated = "Negated"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataId = dataId {
            try encodeContainer.encode(dataId, forKey: .dataId)
        }
        if let negated = negated {
            try encodeContainer.encode(negated, forKey: .negated)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let negatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .negated)
        negated = negatedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(PredicateType.self, forKey: .type)
        type = typeDecoded
        let dataIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataId)
        dataId = dataIdDecoded
    }
}

extension Predicate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Predicate(dataId: \(String(describing: dataId)), negated: \(String(describing: negated)), type: \(String(describing: type)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 	        <p>Specifies the <a>ByteMatchSet</a>, <a>IPSet</a>, <a>SqlInjectionMatchSet</a>, <a>XssMatchSet</a>, <a>RegexMatchSet</a>,  <a>GeoMatchSet</a>, and <a>SizeConstraintSet</a> objects
/// 			that you want to add to a <code>Rule</code> and, for each object, indicates whether you want to negate the settings, for example, requests that do
/// 			NOT originate from the IP address 192.0.2.44. </p>
public struct Predicate: Equatable {
    /// <p>A unique identifier for a predicate in a <code>Rule</code>, such as <code>ByteMatchSetId</code> or <code>IPSetId</code>.
    /// 			The ID is returned by the corresponding <code>Create</code> or <code>List</code> command.</p>
    public let dataId: String?
    /// <p>Set <code>Negated</code> to <code>False</code> if you want AWS WAF to allow, block, or count requests based on the settings in the
    /// 		       specified <a>ByteMatchSet</a>, <a>IPSet</a>, <a>SqlInjectionMatchSet</a>, <a>XssMatchSet</a>, <a>RegexMatchSet</a>,  <a>GeoMatchSet</a>,  or <a>SizeConstraintSet</a>.
    /// 			For example, if an <code>IPSet</code> includes the IP address <code>192.0.2.44</code>, AWS WAF will allow or block requests based on that IP address.</p>
    /// 		       <p>Set <code>Negated</code> to <code>True</code> if you want AWS WAF to allow or block a request based on the negation
    /// 		       of the settings in the <a>ByteMatchSet</a>, <a>IPSet</a>, <a>SqlInjectionMatchSet</a>, <a>XssMatchSet</a>, <a>RegexMatchSet</a>,  <a>GeoMatchSet</a>, or <a>SizeConstraintSet</a>.
    /// 			For example, if an <code>IPSet</code> includes the IP address <code>192.0.2.44</code>, AWS WAF will allow, block, or count requests based on
    /// 			all IP addresses <i>except</i>
    ///             <code>192.0.2.44</code>.</p>
    public let negated: Bool?
    /// <p>The type of predicate in a <code>Rule</code>, such as <code>ByteMatch</code> or <code>IPSet</code>.</p>
    public let type: PredicateType?

    public init (
        dataId: String? = nil,
        negated: Bool? = nil,
        type: PredicateType? = nil
    )
    {
        self.dataId = dataId
        self.negated = negated
        self.type = type
    }
}

public enum PredicateType {
    case byteMatch
    case geoMatch
    case ipMatch
    case regexMatch
    case sizeConstraint
    case sqlInjectionMatch
    case xssMatch
    case sdkUnknown(String)
}

extension PredicateType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PredicateType] {
        return [
            .byteMatch,
            .geoMatch,
            .ipMatch,
            .regexMatch,
            .sizeConstraint,
            .sqlInjectionMatch,
            .xssMatch,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .byteMatch: return "ByteMatch"
        case .geoMatch: return "GeoMatch"
        case .ipMatch: return "IPMatch"
        case .regexMatch: return "RegexMatch"
        case .sizeConstraint: return "SizeConstraint"
        case .sqlInjectionMatch: return "SqlInjectionMatch"
        case .xssMatch: return "XssMatch"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PredicateType(rawValue: rawValue) ?? PredicateType.sdkUnknown(rawValue)
    }
}

public struct PutLoggingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "PutLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<PutLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingConfigurationOutputError>
}

extension PutLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingConfigurationInput(loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension PutLoggingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
    }
}

public struct PutLoggingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "PutLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<PutLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingConfigurationOutputError>
}

public struct PutLoggingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "PutLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<PutLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<PutLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutLoggingConfigurationOutputError>
}

public struct PutLoggingConfigurationInput: Equatable {
    /// <p>The Amazon Kinesis Data Firehose that contains the inspected traffic
    ///          information, the redacted fields details, and the Amazon Resource Name (ARN) of the web ACL
    ///          to monitor.</p>
    ///          <note>
    ///             <p>When specifying <code>Type</code> in <code>RedactedFields</code>, you must use one of
    ///             the following values: <code>URI</code>, <code>QUERY_STRING</code>, <code>HEADER</code>,
    ///             or <code>METHOD</code>.</p>
    ///          </note>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutLoggingConfigurationInputBody: Equatable {
    public let loggingConfiguration: LoggingConfiguration?
}

extension PutLoggingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension PutLoggingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFServiceLinkedRoleErrorException" : self = .wAFServiceLinkedRoleErrorException(try WAFServiceLinkedRoleErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLoggingConfigurationOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFServiceLinkedRoleErrorException(WAFServiceLinkedRoleErrorException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutLoggingConfigurationOutputResponse(loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension PutLoggingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.loggingConfiguration = nil
        }
    }
}

public struct PutLoggingConfigurationOutputResponse: Equatable {
    /// <p>The <a>LoggingConfiguration</a> that you submitted in the request.</p>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.loggingConfiguration = loggingConfiguration
    }
}

struct PutLoggingConfigurationOutputResponseBody: Equatable {
    public let loggingConfiguration: LoggingConfiguration?
}

extension PutLoggingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

public struct PutPermissionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutPermissionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionPolicyInput>
    public typealias MOutput = OperationOutput<PutPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionPolicyOutputError>
}

extension PutPermissionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPermissionPolicyInput(policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)))"}
}

extension PutPermissionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct PutPermissionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutPermissionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionPolicyInput>
    public typealias MOutput = OperationOutput<PutPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionPolicyOutputError>
}

public struct PutPermissionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPermissionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionPolicyInput>
    public typealias MOutput = OperationOutput<PutPermissionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionPolicyOutputError>
}

public struct PutPermissionPolicyInput: Equatable {
    /// <p>The policy to attach to the specified RuleGroup.</p>
    public let policy: String?
    /// <p>The Amazon Resource Name (ARN) of the RuleGroup to which you want to attach the policy.</p>
    public let resourceArn: String?

    public init (
        policy: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutPermissionPolicyInputBody: Equatable {
    public let resourceArn: String?
    public let policy: String?
}

extension PutPermissionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutPermissionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPermissionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidPermissionPolicyException" : self = .wAFInvalidPermissionPolicyException(try WAFInvalidPermissionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPermissionPolicyOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidPermissionPolicyException(WAFInvalidPermissionPolicyException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPermissionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPermissionPolicyOutputResponse()"}
}

extension PutPermissionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutPermissionPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutPermissionPolicyOutputResponseBody: Equatable {
}

extension PutPermissionPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RateBasedRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case matchPredicates = "MatchPredicates"
        case metricName = "MetricName"
        case name = "Name"
        case rateKey = "RateKey"
        case rateLimit = "RateLimit"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let matchPredicates = matchPredicates {
            var matchPredicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchPredicates)
            for predicates0 in matchPredicates {
                try matchPredicatesContainer.encode(predicates0)
            }
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rateKey = rateKey {
            try encodeContainer.encode(rateKey.rawValue, forKey: .rateKey)
        }
        if rateLimit != 0 {
            try encodeContainer.encode(rateLimit, forKey: .rateLimit)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let matchPredicatesContainer = try containerValues.decodeIfPresent([Predicate?].self, forKey: .matchPredicates)
        var matchPredicatesDecoded0:[Predicate]? = nil
        if let matchPredicatesContainer = matchPredicatesContainer {
            matchPredicatesDecoded0 = [Predicate]()
            for structure0 in matchPredicatesContainer {
                if let structure0 = structure0 {
                    matchPredicatesDecoded0?.append(structure0)
                }
            }
        }
        matchPredicates = matchPredicatesDecoded0
        let rateKeyDecoded = try containerValues.decodeIfPresent(RateKey.self, forKey: .rateKey)
        rateKey = rateKeyDecoded
        let rateLimitDecoded = try containerValues.decode(Int.self, forKey: .rateLimit)
        rateLimit = rateLimitDecoded
    }
}

extension RateBasedRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RateBasedRule(matchPredicates: \(String(describing: matchPredicates)), metricName: \(String(describing: metricName)), name: \(String(describing: name)), rateKey: \(String(describing: rateKey)), rateLimit: \(String(describing: rateLimit)), ruleId: \(String(describing: ruleId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>A <code>RateBasedRule</code> is identical to a regular <a>Rule</a>, with
///          one addition: a <code>RateBasedRule</code> counts the number of requests that arrive from a
///          specified IP address every five minutes. For example, based on recent requests that you've
///          seen from an attacker, you might create a <code>RateBasedRule</code> that includes the
///          following conditions: </p>
///          <ul>
///             <li>
///                <p>The requests come from 192.0.2.44.</p>
///             </li>
///             <li>
///                <p>They contain the value <code>BadBot</code> in the <code>User-Agent</code>
///                header.</p>
///             </li>
///          </ul>
///          <p>In the rule, you also define the rate limit as 1,000.</p>
///          <p>Requests that meet both of these conditions and exceed 1,000 requests every five
///          minutes trigger the rule's action (block or count), which is defined in the web
///          ACL.</p>
public struct RateBasedRule: Equatable {
    /// <p>The <code>Predicates</code> object contains one <code>Predicate</code> element for
    ///          each <a>ByteMatchSet</a>, <a>IPSet</a>, or <a>SqlInjectionMatchSet</a> object that you want to include in a
    ///             <code>RateBasedRule</code>.</p>
    public let matchPredicates: [Predicate]?
    /// <p>A friendly name or description for the metrics for a <code>RateBasedRule</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    ///          whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change the name of the metric after you create the
    ///             <code>RateBasedRule</code>.</p>
    public let metricName: String?
    /// <p>A friendly name or description for a <code>RateBasedRule</code>. You can't change the
    ///          name of a <code>RateBasedRule</code> after you create it.</p>
    public let name: String?
    /// <p>The field that AWS WAF uses to determine if requests are likely arriving from single
    ///          source and thus subject to rate monitoring. The only valid value for <code>RateKey</code>
    ///          is <code>IP</code>. <code>IP</code> indicates that requests arriving from the same IP
    ///          address are subject to the <code>RateLimit</code> that is specified in the
    ///             <code>RateBasedRule</code>.</p>
    public let rateKey: RateKey?
    /// <p>The maximum number of requests, which have an identical value in the field specified
    ///          by the <code>RateKey</code>, allowed in a five-minute period. If the number of requests
    ///          exceeds the <code>RateLimit</code> and the other predicates specified in the rule are also
    ///          met, AWS WAF triggers the action that is specified for this rule.</p>
    public let rateLimit: Int
    /// <p>A unique identifier for a <code>RateBasedRule</code>. You use <code>RuleId</code> to
    ///          get more information about a <code>RateBasedRule</code> (see <a>GetRateBasedRule</a>), update a <code>RateBasedRule</code> (see <a>UpdateRateBasedRule</a>), insert a <code>RateBasedRule</code> into a
    ///             <code>WebACL</code> or delete one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>RateBasedRule</code> from AWS WAF (see <a>DeleteRateBasedRule</a>).</p>
    public let ruleId: String?

    public init (
        matchPredicates: [Predicate]? = nil,
        metricName: String? = nil,
        name: String? = nil,
        rateKey: RateKey? = nil,
        rateLimit: Int = 0,
        ruleId: String? = nil
    )
    {
        self.matchPredicates = matchPredicates
        self.metricName = metricName
        self.name = name
        self.rateKey = rateKey
        self.rateLimit = rateLimit
        self.ruleId = ruleId
    }
}

public enum RateKey {
    case ip
    case sdkUnknown(String)
}

extension RateKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RateKey] {
        return [
            .ip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ip: return "IP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RateKey(rawValue: rawValue) ?? RateKey.sdkUnknown(rawValue)
    }
}

extension RegexMatchSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case regexMatchSetId = "RegexMatchSetId"
        case regexMatchTuples = "RegexMatchTuples"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regexMatchSetId = regexMatchSetId {
            try encodeContainer.encode(regexMatchSetId, forKey: .regexMatchSetId)
        }
        if let regexMatchTuples = regexMatchTuples {
            var regexMatchTuplesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regexMatchTuples)
            for regexmatchtuples0 in regexMatchTuples {
                try regexMatchTuplesContainer.encode(regexmatchtuples0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexMatchSetId)
        regexMatchSetId = regexMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let regexMatchTuplesContainer = try containerValues.decodeIfPresent([RegexMatchTuple?].self, forKey: .regexMatchTuples)
        var regexMatchTuplesDecoded0:[RegexMatchTuple]? = nil
        if let regexMatchTuplesContainer = regexMatchTuplesContainer {
            regexMatchTuplesDecoded0 = [RegexMatchTuple]()
            for structure0 in regexMatchTuplesContainer {
                if let structure0 = structure0 {
                    regexMatchTuplesDecoded0?.append(structure0)
                }
            }
        }
        regexMatchTuples = regexMatchTuplesDecoded0
    }
}

extension RegexMatchSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexMatchSet(name: \(String(describing: name)), regexMatchSetId: \(String(describing: regexMatchSetId)), regexMatchTuples: \(String(describing: regexMatchTuples)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>In a <a>GetRegexMatchSet</a> request, <code>RegexMatchSet</code> is a complex type that contains the <code>RegexMatchSetId</code> and
/// 			<code>Name</code> of a <code>RegexMatchSet</code>, and the values that you specified when you updated the <code>RegexMatchSet</code>.</p>
///          <p> The values are contained in a <code>RegexMatchTuple</code> object, which specify the parts of web requests that you want AWS WAF to inspect and the values that you want AWS WAF to search for. If a <code>RegexMatchSet</code> contains more than one
/// 			<code>RegexMatchTuple</code> object, a request needs to match the settings in only one <code>ByteMatchTuple</code>
/// 			to be considered a match.</p>
public struct RegexMatchSet: Equatable {
    /// <p>A friendly name or description of the <a>RegexMatchSet</a>. You can't change <code>Name</code> after you create a
    /// 			<code>RegexMatchSet</code>.</p>
    public let name: String?
    /// <p>The <code>RegexMatchSetId</code> for a <code>RegexMatchSet</code>. You use <code>RegexMatchSetId</code> to get information about a
    /// 			<code>RegexMatchSet</code> (see <a>GetRegexMatchSet</a>), update a <code>RegexMatchSet</code> (see <a>UpdateRegexMatchSet</a>),
    /// 			insert a <code>RegexMatchSet</code> into a <code>Rule</code> or delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and
    /// 			delete a <code>RegexMatchSet</code> from AWS WAF (see <a>DeleteRegexMatchSet</a>).</p>
    /// 		       <p>
    ///             <code>RegexMatchSetId</code> is returned by <a>CreateRegexMatchSet</a> and by <a>ListRegexMatchSets</a>.</p>
    public let regexMatchSetId: String?
    /// <p>Contains an array of <a>RegexMatchTuple</a> objects. Each <code>RegexMatchTuple</code>
    /// 				object contains: </p>
    /// 		       <ul>
    ///             <li>
    ///                <p>The part of a web request that you want AWS WAF to inspect, such as a query string or the value of the <code>User-Agent</code> header. </p>
    ///             </li>
    ///             <li>
    ///                <p>The identifier of the pattern (a regular expression) that you want AWS WAF to look for. For more information, see <a>RegexPatternSet</a>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Whether to perform any conversions on the request, such as converting it to lowercase, before inspecting it for the specified string.</p>
    /// 			         </li>
    ///          </ul>
    public let regexMatchTuples: [RegexMatchTuple]?

    public init (
        name: String? = nil,
        regexMatchSetId: String? = nil,
        regexMatchTuples: [RegexMatchTuple]? = nil
    )
    {
        self.name = name
        self.regexMatchSetId = regexMatchSetId
        self.regexMatchTuples = regexMatchTuples
    }
}

extension RegexMatchSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case regexMatchSetId = "RegexMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regexMatchSetId = regexMatchSetId {
            try encodeContainer.encode(regexMatchSetId, forKey: .regexMatchSetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexMatchSetId)
        regexMatchSetId = regexMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension RegexMatchSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexMatchSetSummary(name: \(String(describing: name)), regexMatchSetId: \(String(describing: regexMatchSetId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>Returned by <a>ListRegexMatchSets</a>. Each <code>RegexMatchSetSummary</code> object includes the <code>Name</code> and
/// 			<code>RegexMatchSetId</code> for one <a>RegexMatchSet</a>.</p>
public struct RegexMatchSetSummary: Equatable {
    /// <p>A friendly name or description of the <a>RegexMatchSet</a>. You can't change <code>Name</code> after you create a <code>RegexMatchSet</code>.</p>
    public let name: String?
    /// <p>The <code>RegexMatchSetId</code> for a <code>RegexMatchSet</code>. You use <code>RegexMatchSetId</code> to get information about a <code>RegexMatchSet</code>,
    /// 			update a <code>RegexMatchSet</code>, remove a <code>RegexMatchSet</code> from a <code>Rule</code>, and delete a <code>RegexMatchSet</code> from AWS WAF.</p>
    /// 		       <p>
    ///             <code>RegexMatchSetId</code> is returned by <a>CreateRegexMatchSet</a> and by <a>ListRegexMatchSets</a>.</p>
    public let regexMatchSetId: String?

    public init (
        name: String? = nil,
        regexMatchSetId: String? = nil
    )
    {
        self.name = name
        self.regexMatchSetId = regexMatchSetId
    }
}

extension RegexMatchSetUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case regexMatchTuple = "RegexMatchTuple"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let regexMatchTuple = regexMatchTuple {
            try encodeContainer.encode(regexMatchTuple, forKey: .regexMatchTuple)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let regexMatchTupleDecoded = try containerValues.decodeIfPresent(RegexMatchTuple.self, forKey: .regexMatchTuple)
        regexMatchTuple = regexMatchTupleDecoded
    }
}

extension RegexMatchSetUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexMatchSetUpdate(action: \(String(describing: action)), regexMatchTuple: \(String(describing: regexMatchTuple)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>In an <a>UpdateRegexMatchSet</a> request, <code>RegexMatchSetUpdate</code> specifies whether to insert or delete a
///          <a>RegexMatchTuple</a> and includes the settings for the <code>RegexMatchTuple</code>.</p>
public struct RegexMatchSetUpdate: Equatable {
    /// <p>Specifies whether to insert or delete a <a>RegexMatchTuple</a>.</p>
    public let action: ChangeAction?
    /// <p>Information about the part of a web request that you want AWS WAF to inspect and the identifier of the regular expression (regex) pattern that you want AWS WAF to search for.
    ///          If you specify <code>DELETE</code> for the value of <code>Action</code>, the <code>RegexMatchTuple</code> values must
    ///          exactly match the values in the <code>RegexMatchTuple</code> that you want to delete from the <code>RegexMatchSet</code>.</p>
    public let regexMatchTuple: RegexMatchTuple?

    public init (
        action: ChangeAction? = nil,
        regexMatchTuple: RegexMatchTuple? = nil
    )
    {
        self.action = action
        self.regexMatchTuple = regexMatchTuple
    }
}

extension RegexMatchTuple: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldToMatch = "FieldToMatch"
        case regexPatternSetId = "RegexPatternSetId"
        case textTransformation = "TextTransformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if let regexPatternSetId = regexPatternSetId {
            try encodeContainer.encode(regexPatternSetId, forKey: .regexPatternSetId)
        }
        if let textTransformation = textTransformation {
            try encodeContainer.encode(textTransformation.rawValue, forKey: .textTransformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let textTransformationDecoded = try containerValues.decodeIfPresent(TextTransformation.self, forKey: .textTransformation)
        textTransformation = textTransformationDecoded
        let regexPatternSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexPatternSetId)
        regexPatternSetId = regexPatternSetIdDecoded
    }
}

extension RegexMatchTuple: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexMatchTuple(fieldToMatch: \(String(describing: fieldToMatch)), regexPatternSetId: \(String(describing: regexPatternSetId)), textTransformation: \(String(describing: textTransformation)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>The regular expression pattern that you want AWS WAF to search for in web requests, the location in requests that you want AWS WAF to search, and other settings. Each <code>RegexMatchTuple</code> object contains: </p>
/// 		       <ul>
///             <li>
///                <p>The part of a web request that you want AWS WAF to inspect, such as a query string or the value of the <code>User-Agent</code> header. </p>
///             </li>
///             <li>
///                <p>The identifier of the pattern (a regular expression) that you want AWS WAF to look for. For more information, see <a>RegexPatternSet</a>. </p>
///             </li>
///             <li>
///                <p>Whether to perform any conversions on the request, such as converting it to lowercase, before inspecting it for the specified string.</p>
/// 			         </li>
///          </ul>
public struct RegexMatchTuple: Equatable {
    /// <p>Specifies where in a web request to look for the <code>RegexPatternSet</code>.</p>
    public let fieldToMatch: FieldToMatch?
    /// <p>The <code>RegexPatternSetId</code> for a <code>RegexPatternSet</code>. You use <code>RegexPatternSetId</code> to get information about a
    /// 			<code>RegexPatternSet</code> (see <a>GetRegexPatternSet</a>), update a <code>RegexPatternSet</code> (see <a>UpdateRegexPatternSet</a>),
    /// 			insert a <code>RegexPatternSet</code> into a <code>RegexMatchSet</code> or delete one from a <code>RegexMatchSet</code> (see <a>UpdateRegexMatchSet</a>), and
    /// 			delete an <code>RegexPatternSet</code> from AWS WAF (see <a>DeleteRegexPatternSet</a>).</p>
    /// 		       <p>
    /// 		          <code>RegexPatternSetId</code> is returned by <a>CreateRegexPatternSet</a> and by <a>ListRegexPatternSets</a>.</p>
    public let regexPatternSetId: String?
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
    /// 			If you specify a transformation, AWS WAF performs the transformation on <code>RegexPatternSet</code> before inspecting a request for a match.</p>	
    ///          <p>You can only specify a single type of TextTransformation.</p>			
    /// 		       <p>
    ///             <b>CMD_LINE</b>
    ///          </p>
    /// 		       <p>When you're concerned that attackers are injecting an operating system commandline command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Delete the following characters: \ " ' ^</p>
    ///             </li>
    ///             <li>
    ///                <p>Delete spaces before the following characters: / (</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace the following characters with a space: , ;</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace multiple spaces with one space</p>
    ///             </li>
    ///             <li>
    ///                <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p>
    ///             </li>
    ///          </ul>
    /// 		
    /// 		       <p>
    ///             <b>COMPRESS_WHITE_SPACE</b>
    ///          </p>
    /// 		       <p>Use this option to replace the following characters with a space character (decimal 32):</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>\f, formfeed, decimal 12</p>
    ///             </li>
    ///             <li>
    ///                <p>\t, tab, decimal 9</p>
    ///             </li>
    ///             <li>
    ///                <p>\n, newline, decimal 10</p>
    ///             </li>
    ///             <li>
    ///                <p>\r, carriage return, decimal 13</p>
    ///             </li>
    ///             <li>
    ///                <p>\v, vertical tab, decimal 11</p>
    ///             </li>
    ///             <li>
    ///                <p>non-breaking space, decimal 160</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>		
    /// 		       <p>
    ///             <b>HTML_ENTITY_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs
    /// 			the following operations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)quot;</code> with <code>"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)gt;</code> with <code>></code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///          </ul>		
    /// 		       <p>
    ///             <b>LOWERCASE</b>
    ///          </p>
    /// 		       <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p>		
    /// 		       <p>
    ///             <b>URL_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to decode a URL-encoded value.</p>		
    /// 		       <p>
    ///             <b>NONE</b>
    ///          </p>
    /// 		       <p>Specify <code>NONE</code> if you don't want to perform any text transformations.</p>
    public let textTransformation: TextTransformation?

    public init (
        fieldToMatch: FieldToMatch? = nil,
        regexPatternSetId: String? = nil,
        textTransformation: TextTransformation? = nil
    )
    {
        self.fieldToMatch = fieldToMatch
        self.regexPatternSetId = regexPatternSetId
        self.textTransformation = textTransformation
    }
}

extension RegexPatternSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case regexPatternSetId = "RegexPatternSetId"
        case regexPatternStrings = "RegexPatternStrings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regexPatternSetId = regexPatternSetId {
            try encodeContainer.encode(regexPatternSetId, forKey: .regexPatternSetId)
        }
        if let regexPatternStrings = regexPatternStrings {
            var regexPatternStringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regexPatternStrings)
            for regexpatternstrings0 in regexPatternStrings {
                try regexPatternStringsContainer.encode(regexpatternstrings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexPatternSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexPatternSetId)
        regexPatternSetId = regexPatternSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let regexPatternStringsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .regexPatternStrings)
        var regexPatternStringsDecoded0:[String]? = nil
        if let regexPatternStringsContainer = regexPatternStringsContainer {
            regexPatternStringsDecoded0 = [String]()
            for string0 in regexPatternStringsContainer {
                if let string0 = string0 {
                    regexPatternStringsDecoded0?.append(string0)
                }
            }
        }
        regexPatternStrings = regexPatternStringsDecoded0
    }
}

extension RegexPatternSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexPatternSet(name: \(String(describing: name)), regexPatternSetId: \(String(describing: regexPatternSetId)), regexPatternStrings: \(String(describing: regexPatternStrings)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>The <code>RegexPatternSet</code> specifies the regular expression (regex) pattern that you want AWS WAF to search for, such as <code>B[a@]dB[o0]t</code>. You can then configure AWS WAF to reject those requests.</p>
public struct RegexPatternSet: Equatable {
    /// <p>A friendly name or description of the <a>RegexPatternSet</a>. You can't change <code>Name</code> after you create a <code>RegexPatternSet</code>.</p>
    public let name: String?
    /// <p>The identifier for the <code>RegexPatternSet</code>. You use <code>RegexPatternSetId</code> to get information about a <code>RegexPatternSet</code>,
    ///          update a <code>RegexPatternSet</code>, remove a <code>RegexPatternSet</code> from a <code>RegexMatchSet</code>, and delete a <code>RegexPatternSet</code> from AWS WAF.</p>
    ///          <p>
    ///             <code>RegexMatchSetId</code> is returned by <a>CreateRegexPatternSet</a> and by <a>ListRegexPatternSets</a>.</p>
    public let regexPatternSetId: String?
    /// <p>Specifies the regular expression (regex) patterns that you want AWS WAF to search for, such as <code>B[a@]dB[o0]t</code>.</p>
    public let regexPatternStrings: [String]?

    public init (
        name: String? = nil,
        regexPatternSetId: String? = nil,
        regexPatternStrings: [String]? = nil
    )
    {
        self.name = name
        self.regexPatternSetId = regexPatternSetId
        self.regexPatternStrings = regexPatternStrings
    }
}

extension RegexPatternSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case regexPatternSetId = "RegexPatternSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regexPatternSetId = regexPatternSetId {
            try encodeContainer.encode(regexPatternSetId, forKey: .regexPatternSetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexPatternSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexPatternSetId)
        regexPatternSetId = regexPatternSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension RegexPatternSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexPatternSetSummary(name: \(String(describing: name)), regexPatternSetId: \(String(describing: regexPatternSetId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>Returned by <a>ListRegexPatternSets</a>. Each <code>RegexPatternSetSummary</code> object includes the <code>Name</code> and
///          <code>RegexPatternSetId</code> for one <a>RegexPatternSet</a>.</p>
public struct RegexPatternSetSummary: Equatable {
    /// <p>A friendly name or description of the <a>RegexPatternSet</a>. You can't change <code>Name</code> after you create a <code>RegexPatternSet</code>.</p>
    public let name: String?
    /// <p>The <code>RegexPatternSetId</code> for a <code>RegexPatternSet</code>. You use <code>RegexPatternSetId</code> to get information about a <code>RegexPatternSet</code>,
    ///          update a <code>RegexPatternSet</code>, remove a <code>RegexPatternSet</code> from a <code>RegexMatchSet</code>, and delete a <code>RegexPatternSet</code> from AWS WAF.</p>
    ///          <p>
    ///             <code>RegexPatternSetId</code> is returned by <a>CreateRegexPatternSet</a> and by <a>ListRegexPatternSets</a>.</p>
    public let regexPatternSetId: String?

    public init (
        name: String? = nil,
        regexPatternSetId: String? = nil
    )
    {
        self.name = name
        self.regexPatternSetId = regexPatternSetId
    }
}

extension RegexPatternSetUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case regexPatternString = "RegexPatternString"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let regexPatternString = regexPatternString {
            try encodeContainer.encode(regexPatternString, forKey: .regexPatternString)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let regexPatternStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexPatternString)
        regexPatternString = regexPatternStringDecoded
    }
}

extension RegexPatternSetUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegexPatternSetUpdate(action: \(String(describing: action)), regexPatternString: \(String(describing: regexPatternString)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>In an <a>UpdateRegexPatternSet</a> request, <code>RegexPatternSetUpdate</code> specifies whether to insert or delete a
///          <code>RegexPatternString</code> and includes the settings for the <code>RegexPatternString</code>.</p>
public struct RegexPatternSetUpdate: Equatable {
    /// <p>Specifies whether to insert or delete a <code>RegexPatternString</code>.</p>
    public let action: ChangeAction?
    /// <p>Specifies the regular expression (regex) pattern that you want AWS WAF to search for, such as <code>B[a@]dB[o0]t</code>.</p>
    public let regexPatternString: String?

    public init (
        action: ChangeAction? = nil,
        regexPatternString: String? = nil
    )
    {
        self.action = action
        self.regexPatternString = regexPatternString
    }
}

extension Rule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricName = "MetricName"
        case name = "Name"
        case predicates = "Predicates"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let predicates = predicates {
            var predicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predicates)
            for predicates0 in predicates {
                try predicatesContainer.encode(predicates0)
            }
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let predicatesContainer = try containerValues.decodeIfPresent([Predicate?].self, forKey: .predicates)
        var predicatesDecoded0:[Predicate]? = nil
        if let predicatesContainer = predicatesContainer {
            predicatesDecoded0 = [Predicate]()
            for structure0 in predicatesContainer {
                if let structure0 = structure0 {
                    predicatesDecoded0?.append(structure0)
                }
            }
        }
        predicates = predicatesDecoded0
    }
}

extension Rule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Rule(metricName: \(String(describing: metricName)), name: \(String(describing: name)), predicates: \(String(describing: predicates)), ruleId: \(String(describing: ruleId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>A combination of <a>ByteMatchSet</a>, <a>IPSet</a>, and/or <a>SqlInjectionMatchSet</a> objects that identify the web requests that you
/// 			want to allow, block, or count. For example, you might create a <code>Rule</code> that includes the following predicates:</p>
/// 		       <ul>
///             <li>
///                <p>An <code>IPSet</code> that causes AWS WAF to search for web requests that originate from the IP address <code>192.0.2.44</code>
///                </p>
///             </li>
///             <li>
///                <p>A <code>ByteMatchSet</code> that causes AWS WAF to search for web requests for which the value of the <code>User-Agent</code>
/// 				header is <code>BadBot</code>.</p>
///             </li>
///          </ul>
/// 		       <p>To match the settings in this <code>Rule</code>, a request must originate from <code>192.0.2.44</code> AND include a <code>User-Agent</code>
/// 			header for which the value is <code>BadBot</code>.</p>
public struct Rule: Equatable {
    /// <p>A friendly name or description for the metrics for this <code>Rule</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    ///          whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change <code>MetricName</code> after you create the <code>Rule</code>.</p>
    public let metricName: String?
    /// <p>The friendly name or description for the <code>Rule</code>. You can't change the name of a <code>Rule</code> after you create it.</p>
    public let name: String?
    /// <p>The <code>Predicates</code> object contains one <code>Predicate</code> element for each <a>ByteMatchSet</a>, <a>IPSet</a>, or
    /// 			<a>SqlInjectionMatchSet</a> object that you want to include in a <code>Rule</code>.</p>
    public let predicates: [Predicate]?
    /// <p>A unique identifier for a <code>Rule</code>. You use <code>RuleId</code> to get more information about a <code>Rule</code> (see <a>GetRule</a>),
    /// 			update a <code>Rule</code> (see <a>UpdateRule</a>), insert a <code>Rule</code> into a <code>WebACL</code> or delete a
    /// 			one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>Rule</code> from AWS WAF (see <a>DeleteRule</a>).</p>
    /// 		       <p>
    ///             <code>RuleId</code> is returned by <a>CreateRule</a> and by <a>ListRules</a>.</p>
    public let ruleId: String?

    public init (
        metricName: String? = nil,
        name: String? = nil,
        predicates: [Predicate]? = nil,
        ruleId: String? = nil
    )
    {
        self.metricName = metricName
        self.name = name
        self.predicates = predicates
        self.ruleId = ruleId
    }
}

extension RuleGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricName = "MetricName"
        case name = "Name"
        case ruleGroupId = "RuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ruleGroupId = ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
    }
}

extension RuleGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroup(metricName: \(String(describing: metricName)), name: \(String(describing: name)), ruleGroupId: \(String(describing: ruleGroupId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>A collection of predefined rules that you can add to a web ACL.</p>
/// 	        <p>Rule groups are subject to the following limits:</p>
/// 	        <ul>
///             <li>
///                <p>Three rule groups per account. You can request an increase to this limit by contacting customer support.</p>
///             </li>
///             <li>
///                <p>One rule group per web ACL.</p>
///             </li>
///             <li>
///                <p>Ten rules per rule group.</p>
///             </li>
///          </ul>
public struct RuleGroup: Equatable {
    /// <p>A friendly name or description for the metrics for this <code>RuleGroup</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    ///          whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change the name of the metric after you create the <code>RuleGroup</code>.</p>
    public let metricName: String?
    /// <p>The friendly name or description for the <code>RuleGroup</code>. You can't change the name of a <code>RuleGroup</code> after you create it.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>RuleGroup</code>. You use <code>RuleGroupId</code> to get more information about a <code>RuleGroup</code> (see <a>GetRuleGroup</a>),
    ///          update a <code>RuleGroup</code> (see <a>UpdateRuleGroup</a>), insert a <code>RuleGroup</code> into a <code>WebACL</code> or delete a
    ///          one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>RuleGroup</code> from AWS WAF (see <a>DeleteRuleGroup</a>).</p>
    ///          <p>
    ///             <code>RuleGroupId</code> is returned by <a>CreateRuleGroup</a> and by <a>ListRuleGroups</a>.</p>
    public let ruleGroupId: String?

    public init (
        metricName: String? = nil,
        name: String? = nil,
        ruleGroupId: String? = nil
    )
    {
        self.metricName = metricName
        self.name = name
        self.ruleGroupId = ruleGroupId
    }
}

extension RuleGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case ruleGroupId = "RuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ruleGroupId = ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension RuleGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroupSummary(name: \(String(describing: name)), ruleGroupId: \(String(describing: ruleGroupId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>Contains the identifier and the friendly name or description of the <code>RuleGroup</code>.</p>
public struct RuleGroupSummary: Equatable {
    /// <p>A friendly name or description of the <a>RuleGroup</a>. You can't change the name of a <code>RuleGroup</code> after you create it.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>RuleGroup</code>. You use <code>RuleGroupId</code> to get more information about a <code>RuleGroup</code> (see <a>GetRuleGroup</a>),
    ///          update a <code>RuleGroup</code> (see <a>UpdateRuleGroup</a>), insert a <code>RuleGroup</code> into a <code>WebACL</code> or delete
    ///          one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>RuleGroup</code> from AWS WAF (see <a>DeleteRuleGroup</a>).</p>
    ///          <p>
    ///             <code>RuleGroupId</code> is returned by <a>CreateRuleGroup</a> and by <a>ListRuleGroups</a>.</p>
    public let ruleGroupId: String?

    public init (
        name: String? = nil,
        ruleGroupId: String? = nil
    )
    {
        self.name = name
        self.ruleGroupId = ruleGroupId
    }
}

extension RuleGroupUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case activatedRule = "ActivatedRule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let activatedRule = activatedRule {
            try encodeContainer.encode(activatedRule, forKey: .activatedRule)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let activatedRuleDecoded = try containerValues.decodeIfPresent(ActivatedRule.self, forKey: .activatedRule)
        activatedRule = activatedRuleDecoded
    }
}

extension RuleGroupUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroupUpdate(action: \(String(describing: action)), activatedRule: \(String(describing: activatedRule)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>Specifies an <code>ActivatedRule</code> and indicates whether you want to add it to a
///          <code>RuleGroup</code> or delete it from a <code>RuleGroup</code>.</p>
public struct RuleGroupUpdate: Equatable {
    /// <p>Specify <code>INSERT</code> to add an <code>ActivatedRule</code> to a <code>RuleGroup</code>. Use <code>DELETE</code> to remove an
    ///          <code>ActivatedRule</code> from a <code>RuleGroup</code>.</p>
    public let action: ChangeAction?
    /// <p>The <code>ActivatedRule</code> object specifies a <code>Rule</code> that you want to insert or delete,
    ///          the priority of the <code>Rule</code> in the <code>WebACL</code>, and the action that you want AWS WAF to take when a web request matches the <code>Rule</code>
    ///          (<code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>).</p>
    public let activatedRule: ActivatedRule?

    public init (
        action: ChangeAction? = nil,
        activatedRule: ActivatedRule? = nil
    )
    {
        self.action = action
        self.activatedRule = activatedRule
    }
}

extension RuleSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case ruleId = "RuleId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension RuleSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleSummary(name: \(String(describing: name)), ruleId: \(String(describing: ruleId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Contains the identifier and the friendly name or description of the <code>Rule</code>.</p>
public struct RuleSummary: Equatable {
    /// <p>A friendly name or description of the <a>Rule</a>. You can't change the name of a <code>Rule</code> after you create it.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>Rule</code>. You use <code>RuleId</code> to get more information about a <code>Rule</code> (see <a>GetRule</a>),
    /// 			update a <code>Rule</code> (see <a>UpdateRule</a>), insert a <code>Rule</code> into a <code>WebACL</code> or delete
    /// 			one from a <code>WebACL</code> (see <a>UpdateWebACL</a>), or delete a <code>Rule</code> from AWS WAF (see <a>DeleteRule</a>).</p>
    /// 		       <p>
    ///             <code>RuleId</code> is returned by <a>CreateRule</a> and by <a>ListRules</a>.</p>
    public let ruleId: String?

    public init (
        name: String? = nil,
        ruleId: String? = nil
    )
    {
        self.name = name
        self.ruleId = ruleId
    }
}

extension RuleUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case predicate = "Predicate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let predicate = predicate {
            try encodeContainer.encode(predicate, forKey: .predicate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let predicateDecoded = try containerValues.decodeIfPresent(Predicate.self, forKey: .predicate)
        predicate = predicateDecoded
    }
}

extension RuleUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleUpdate(action: \(String(describing: action)), predicate: \(String(describing: predicate)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies a <code>Predicate</code> (such as an <code>IPSet</code>) and indicates whether you want to add it to a
/// 			<code>Rule</code> or delete it from a <code>Rule</code>.</p>
public struct RuleUpdate: Equatable {
    /// <p>Specify <code>INSERT</code> to add a <code>Predicate</code> to a <code>Rule</code>. Use <code>DELETE</code> to remove a
    /// 			<code>Predicate</code> from a <code>Rule</code>.</p>
    public let action: ChangeAction?
    /// <p>The ID of the <code>Predicate</code> (such as an <code>IPSet</code>) that you want to add to a <code>Rule</code>.</p>
    public let predicate: Predicate?

    public init (
        action: ChangeAction? = nil,
        predicate: Predicate? = nil
    )
    {
        self.action = action
        self.predicate = predicate
    }
}

extension SampledHTTPRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case request = "Request"
        case ruleWithinRuleGroup = "RuleWithinRuleGroup"
        case timestamp = "Timestamp"
        case weight = "Weight"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let request = request {
            try encodeContainer.encode(request, forKey: .request)
        }
        if let ruleWithinRuleGroup = ruleWithinRuleGroup {
            try encodeContainer.encode(ruleWithinRuleGroup, forKey: .ruleWithinRuleGroup)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if weight != 0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(HTTPRequest.self, forKey: .request)
        request = requestDecoded
        let weightDecoded = try containerValues.decode(Int.self, forKey: .weight)
        weight = weightDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let ruleWithinRuleGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleWithinRuleGroup)
        ruleWithinRuleGroup = ruleWithinRuleGroupDecoded
    }
}

extension SampledHTTPRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SampledHTTPRequest(action: \(String(describing: action)), request: \(String(describing: request)), ruleWithinRuleGroup: \(String(describing: ruleWithinRuleGroup)), timestamp: \(String(describing: timestamp)), weight: \(String(describing: weight)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>The response from a <a>GetSampledRequests</a> request includes a <code>SampledHTTPRequests</code> complex type that
/// 			appears as <code>SampledRequests</code> in the response syntax. <code>SampledHTTPRequests</code> contains one
/// 			<code>SampledHTTPRequest</code> object for each web request that is returned by <code>GetSampledRequests</code>.</p>
public struct SampledHTTPRequest: Equatable {
    /// <p>The action for the <code>Rule</code> that the request matched: <code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p>
    public let action: String?
    /// <p>A complex type that contains detailed information about the request.</p>
    public let request: HTTPRequest?
    /// <p>This value is returned if the <code>GetSampledRequests</code>  request specifies the ID of a <code>RuleGroup</code> rather than the ID of an individual rule. <code>RuleWithinRuleGroup</code> is the rule within the specified <code>RuleGroup</code> that matched the request listed in the response.</p>
    public let ruleWithinRuleGroup: String?
    /// <p>The time at which AWS WAF received the request from your AWS resource, in Unix time format (in seconds).</p>
    public let timestamp: Date?
    /// <p>A value that indicates how one result in the response relates proportionally to other results in the response.
    /// 			A result that has a weight of <code>2</code> represents roughly twice as many CloudFront web requests as a result
    /// 			that has a weight of <code>1</code>.</p>
    public let weight: Int

    public init (
        action: String? = nil,
        request: HTTPRequest? = nil,
        ruleWithinRuleGroup: String? = nil,
        timestamp: Date? = nil,
        weight: Int = 0
    )
    {
        self.action = action
        self.request = request
        self.ruleWithinRuleGroup = ruleWithinRuleGroup
        self.timestamp = timestamp
        self.weight = weight
    }
}

extension SizeConstraint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case fieldToMatch = "FieldToMatch"
        case size = "Size"
        case textTransformation = "TextTransformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let textTransformation = textTransformation {
            try encodeContainer.encode(textTransformation.rawValue, forKey: .textTransformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let textTransformationDecoded = try containerValues.decodeIfPresent(TextTransformation.self, forKey: .textTransformation)
        textTransformation = textTransformationDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension SizeConstraint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SizeConstraint(comparisonOperator: \(String(describing: comparisonOperator)), fieldToMatch: \(String(describing: fieldToMatch)), size: \(String(describing: size)), textTransformation: \(String(describing: textTransformation)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies a constraint on the size of a part of the web request. AWS WAF uses the <code>Size</code>, <code>ComparisonOperator</code>, and <code>FieldToMatch</code> to build
/// 			an expression in the form of "<code>Size</code>
///             <code>ComparisonOperator</code> size in bytes of <code>FieldToMatch</code>". If that expression is true, the
/// 			<code>SizeConstraint</code> is considered to match.</p>
public struct SizeConstraint: Equatable {
    /// <p>The type of comparison you want AWS WAF to perform. AWS WAF uses this in combination with the provided <code>Size</code> and <code>FieldToMatch</code>
    /// 			to build an expression in the form of "<code>Size</code>
    ///             <code>ComparisonOperator</code> size in bytes of <code>FieldToMatch</code>". If that expression
    /// 			is true, the <code>SizeConstraint</code> is considered to match.</p>
    /// 		       <p>
    ///             <b>EQ</b>: Used to test if the <code>Size</code> is equal to the size of the <code>FieldToMatch</code>
    ///          </p>
    /// 		       <p>
    ///             <b>NE</b>: Used to test if the <code>Size</code> is not equal to the size of the <code>FieldToMatch</code>
    ///          </p>
    /// 		       <p>
    ///             <b>LE</b>: Used to test if the <code>Size</code> is less than or equal to the size of the <code>FieldToMatch</code>
    ///          </p>
    /// 		       <p>
    ///             <b>LT</b>: Used to test if the <code>Size</code> is strictly less than the size of the <code>FieldToMatch</code>
    ///          </p>
    /// 		       <p>
    ///             <b>GE</b>: Used to test if the <code>Size</code> is greater than or equal to the size of the <code>FieldToMatch</code>
    ///          </p>
    /// 		       <p>
    ///             <b>GT</b>: Used to test if the <code>Size</code> is strictly greater than the size of the <code>FieldToMatch</code>
    ///          </p>
    public let comparisonOperator: ComparisonOperator?
    /// <p>Specifies where in a web request to look for the size constraint.</p>
    public let fieldToMatch: FieldToMatch?
    /// <p>The size in bytes that you want AWS WAF to compare against the size of the specified <code>FieldToMatch</code>. AWS WAF uses this in combination
    /// 			with <code>ComparisonOperator</code> and <code>FieldToMatch</code> to build an expression in the form of "<code>Size</code>
    ///             <code>ComparisonOperator</code> size
    /// 			in bytes of <code>FieldToMatch</code>". If that expression is true, the <code>SizeConstraint</code> is considered to match.</p>
    /// 		       <p>Valid values for size are 0 - 21474836480 bytes (0 - 20 GB).</p>
    /// 		       <p>If you specify <code>URI</code> for the value of <code>Type</code>, the / in the URI counts as one character.
    /// 			For example, the URI <code>/logo.jpg</code> is nine characters long.</p>
    public let size: Int
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
    /// 			If you specify a transformation, AWS WAF performs the transformation on <code>FieldToMatch</code> before inspecting it for a match.</p>
    ///          <p>You can only specify a single type of TextTransformation.</p>			
    /// 		       <p>Note that if you choose <code>BODY</code> for the value of <code>Type</code>, you must choose <code>NONE</code> for <code>TextTransformation</code>
    /// 			because CloudFront forwards only the first 8192 bytes for inspection. </p>		
    /// 		       <p>
    ///             <b>NONE</b>
    ///          </p>
    /// 		       <p>Specify <code>NONE</code> if you don't want to perform any text transformations.</p>		
    /// 		       <p>
    ///             <b>CMD_LINE</b>
    ///          </p>
    /// 		       <p>When you're concerned that attackers are injecting an operating system command line command and using unusual formatting to disguise some or all of the command, use this option to perform the following transformations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Delete the following characters: \ " ' ^</p>
    ///             </li>
    ///             <li>
    ///                <p>Delete spaces before the following characters: / (</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace the following characters with a space: , ;</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace multiple spaces with one space</p>
    ///             </li>
    ///             <li>
    ///                <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p>
    ///             </li>
    ///          </ul>		
    /// 		       <p>
    ///             <b>COMPRESS_WHITE_SPACE</b>
    ///          </p>
    /// 		       <p>Use this option to replace the following characters with a space character (decimal 32):</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>\f, formfeed, decimal 12</p>
    ///             </li>
    ///             <li>
    ///                <p>\t, tab, decimal 9</p>
    ///             </li>
    ///             <li>
    ///                <p>\n, newline, decimal 10</p>
    ///             </li>
    ///             <li>
    ///                <p>\r, carriage return, decimal 13</p>
    ///             </li>
    ///             <li>
    ///                <p>\v, vertical tab, decimal 11</p>
    ///             </li>
    ///             <li>
    ///                <p>non-breaking space, decimal 160</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>		
    /// 		       <p>
    ///             <b>HTML_ENTITY_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs
    /// 			the following operations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)quot;</code> with <code>"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)gt;</code> with <code>></code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///          </ul>		
    /// 		       <p>
    ///             <b>LOWERCASE</b>
    ///          </p>
    /// 		       <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p>		
    /// 		       <p>
    ///             <b>URL_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to decode a URL-encoded value.</p>
    public let textTransformation: TextTransformation?

    public init (
        comparisonOperator: ComparisonOperator? = nil,
        fieldToMatch: FieldToMatch? = nil,
        size: Int = 0,
        textTransformation: TextTransformation? = nil
    )
    {
        self.comparisonOperator = comparisonOperator
        self.fieldToMatch = fieldToMatch
        self.size = size
        self.textTransformation = textTransformation
    }
}

extension SizeConstraintSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sizeConstraintSetId = "SizeConstraintSetId"
        case sizeConstraints = "SizeConstraints"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sizeConstraintSetId = sizeConstraintSetId {
            try encodeContainer.encode(sizeConstraintSetId, forKey: .sizeConstraintSetId)
        }
        if let sizeConstraints = sizeConstraints {
            var sizeConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sizeConstraints)
            for sizeconstraints0 in sizeConstraints {
                try sizeConstraintsContainer.encode(sizeconstraints0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeConstraintSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizeConstraintSetId)
        sizeConstraintSetId = sizeConstraintSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sizeConstraintsContainer = try containerValues.decodeIfPresent([SizeConstraint?].self, forKey: .sizeConstraints)
        var sizeConstraintsDecoded0:[SizeConstraint]? = nil
        if let sizeConstraintsContainer = sizeConstraintsContainer {
            sizeConstraintsDecoded0 = [SizeConstraint]()
            for structure0 in sizeConstraintsContainer {
                if let structure0 = structure0 {
                    sizeConstraintsDecoded0?.append(structure0)
                }
            }
        }
        sizeConstraints = sizeConstraintsDecoded0
    }
}

extension SizeConstraintSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SizeConstraintSet(name: \(String(describing: name)), sizeConstraintSetId: \(String(describing: sizeConstraintSetId)), sizeConstraints: \(String(describing: sizeConstraints)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>A complex type that contains <code>SizeConstraint</code> objects, which specify the parts of web requests that you
/// 			want AWS WAF to inspect the size of. If a <code>SizeConstraintSet</code> contains more than one <code>SizeConstraint</code>
/// 			object, a request only needs to match one constraint to be considered a match.</p>
public struct SizeConstraintSet: Equatable {
    /// <p>The name, if any, of the <code>SizeConstraintSet</code>.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>SizeConstraintSet</code>. You use <code>SizeConstraintSetId</code> to get information about a
    /// 			<code>SizeConstraintSet</code> (see <a>GetSizeConstraintSet</a>), update a <code>SizeConstraintSet</code>
    /// 			(see <a>UpdateSizeConstraintSet</a>), insert a <code>SizeConstraintSet</code> into a <code>Rule</code> or
    /// 			delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>SizeConstraintSet</code> from AWS WAF
    /// 			(see <a>DeleteSizeConstraintSet</a>).</p>
    /// 		       <p>
    ///             <code>SizeConstraintSetId</code> is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>
    public let sizeConstraintSetId: String?
    /// <p>Specifies the parts of web requests that you want to inspect the size of.</p>
    public let sizeConstraints: [SizeConstraint]?

    public init (
        name: String? = nil,
        sizeConstraintSetId: String? = nil,
        sizeConstraints: [SizeConstraint]? = nil
    )
    {
        self.name = name
        self.sizeConstraintSetId = sizeConstraintSetId
        self.sizeConstraints = sizeConstraints
    }
}

extension SizeConstraintSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sizeConstraintSetId = "SizeConstraintSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sizeConstraintSetId = sizeConstraintSetId {
            try encodeContainer.encode(sizeConstraintSetId, forKey: .sizeConstraintSetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeConstraintSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizeConstraintSetId)
        sizeConstraintSetId = sizeConstraintSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SizeConstraintSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SizeConstraintSetSummary(name: \(String(describing: name)), sizeConstraintSetId: \(String(describing: sizeConstraintSetId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>The <code>Id</code> and <code>Name</code> of a <code>SizeConstraintSet</code>.</p>
public struct SizeConstraintSetSummary: Equatable {
    /// <p>The name of the <code>SizeConstraintSet</code>, if any.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>SizeConstraintSet</code>. You use <code>SizeConstraintSetId</code> to get information about a
    /// 			<code>SizeConstraintSet</code> (see <a>GetSizeConstraintSet</a>), update a <code>SizeConstraintSet</code>
    /// 			(see <a>UpdateSizeConstraintSet</a>), insert a <code>SizeConstraintSet</code> into a <code>Rule</code> or
    /// 			delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>SizeConstraintSet</code> from AWS WAF
    /// 			(see <a>DeleteSizeConstraintSet</a>).</p>
    /// 		       <p>
    ///             <code>SizeConstraintSetId</code> is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>
    public let sizeConstraintSetId: String?

    public init (
        name: String? = nil,
        sizeConstraintSetId: String? = nil
    )
    {
        self.name = name
        self.sizeConstraintSetId = sizeConstraintSetId
    }
}

extension SizeConstraintSetUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case sizeConstraint = "SizeConstraint"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let sizeConstraint = sizeConstraint {
            try encodeContainer.encode(sizeConstraint, forKey: .sizeConstraint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let sizeConstraintDecoded = try containerValues.decodeIfPresent(SizeConstraint.self, forKey: .sizeConstraint)
        sizeConstraint = sizeConstraintDecoded
    }
}

extension SizeConstraintSetUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SizeConstraintSetUpdate(action: \(String(describing: action)), sizeConstraint: \(String(describing: sizeConstraint)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies the part of a web request that you want to inspect the size of and indicates whether you want to
/// 			add the specification to a <a>SizeConstraintSet</a> or delete it from a <code>SizeConstraintSet</code>.</p>
public struct SizeConstraintSetUpdate: Equatable {
    /// <p>Specify <code>INSERT</code> to add a <a>SizeConstraintSetUpdate</a> to a <a>SizeConstraintSet</a>.
    /// 			Use <code>DELETE</code> to remove a <code>SizeConstraintSetUpdate</code> from a <code>SizeConstraintSet</code>.</p>
    public let action: ChangeAction?
    /// <p>Specifies a constraint on the size of a part of the web request. AWS WAF uses the <code>Size</code>, <code>ComparisonOperator</code>, and <code>FieldToMatch</code> to build
    /// 			an expression in the form of "<code>Size</code>
    ///             <code>ComparisonOperator</code> size in bytes of <code>FieldToMatch</code>". If that expression is true, the
    /// 			<code>SizeConstraint</code> is considered to match.</p>
    public let sizeConstraint: SizeConstraint?

    public init (
        action: ChangeAction? = nil,
        sizeConstraint: SizeConstraint? = nil
    )
    {
        self.action = action
        self.sizeConstraint = sizeConstraint
    }
}

extension SqlInjectionMatchSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
        case sqlInjectionMatchTuples = "SqlInjectionMatchTuples"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlInjectionMatchSetId = sqlInjectionMatchSetId {
            try encodeContainer.encode(sqlInjectionMatchSetId, forKey: .sqlInjectionMatchSetId)
        }
        if let sqlInjectionMatchTuples = sqlInjectionMatchTuples {
            var sqlInjectionMatchTuplesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sqlInjectionMatchTuples)
            for sqlinjectionmatchtuples0 in sqlInjectionMatchTuples {
                try sqlInjectionMatchTuplesContainer.encode(sqlinjectionmatchtuples0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlInjectionMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlInjectionMatchSetId)
        sqlInjectionMatchSetId = sqlInjectionMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let sqlInjectionMatchTuplesContainer = try containerValues.decodeIfPresent([SqlInjectionMatchTuple?].self, forKey: .sqlInjectionMatchTuples)
        var sqlInjectionMatchTuplesDecoded0:[SqlInjectionMatchTuple]? = nil
        if let sqlInjectionMatchTuplesContainer = sqlInjectionMatchTuplesContainer {
            sqlInjectionMatchTuplesDecoded0 = [SqlInjectionMatchTuple]()
            for structure0 in sqlInjectionMatchTuplesContainer {
                if let structure0 = structure0 {
                    sqlInjectionMatchTuplesDecoded0?.append(structure0)
                }
            }
        }
        sqlInjectionMatchTuples = sqlInjectionMatchTuplesDecoded0
    }
}

extension SqlInjectionMatchSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlInjectionMatchSet(name: \(String(describing: name)), sqlInjectionMatchSetId: \(String(describing: sqlInjectionMatchSetId)), sqlInjectionMatchTuples: \(String(describing: sqlInjectionMatchTuples)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>A complex type that contains <code>SqlInjectionMatchTuple</code> objects, which specify the parts of web requests that you
/// 			want AWS WAF to inspect for snippets of malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header. If a
/// 			<code>SqlInjectionMatchSet</code> contains more than one <code>SqlInjectionMatchTuple</code> object, a request needs to
/// 			include snippets of SQL code in only one of the specified parts of the request to be considered a match.</p>
public struct SqlInjectionMatchSet: Equatable {
    /// <p>The name, if any, of the <code>SqlInjectionMatchSet</code>.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>SqlInjectionMatchSet</code>. You use <code>SqlInjectionMatchSetId</code> to get information about a
    /// 			<code>SqlInjectionMatchSet</code> (see <a>GetSqlInjectionMatchSet</a>), update a <code>SqlInjectionMatchSet</code>
    /// 			(see <a>UpdateSqlInjectionMatchSet</a>), insert a <code>SqlInjectionMatchSet</code> into a <code>Rule</code> or
    /// 			delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>SqlInjectionMatchSet</code> from AWS WAF
    /// 			(see <a>DeleteSqlInjectionMatchSet</a>).</p>
    /// 		       <p>
    ///             <code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>
    public let sqlInjectionMatchSetId: String?
    /// <p>Specifies the parts of web requests that you want to inspect for snippets of malicious SQL code.</p>
    public let sqlInjectionMatchTuples: [SqlInjectionMatchTuple]?

    public init (
        name: String? = nil,
        sqlInjectionMatchSetId: String? = nil,
        sqlInjectionMatchTuples: [SqlInjectionMatchTuple]? = nil
    )
    {
        self.name = name
        self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
        self.sqlInjectionMatchTuples = sqlInjectionMatchTuples
    }
}

extension SqlInjectionMatchSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sqlInjectionMatchSetId = sqlInjectionMatchSetId {
            try encodeContainer.encode(sqlInjectionMatchSetId, forKey: .sqlInjectionMatchSetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlInjectionMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlInjectionMatchSetId)
        sqlInjectionMatchSetId = sqlInjectionMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SqlInjectionMatchSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlInjectionMatchSetSummary(name: \(String(describing: name)), sqlInjectionMatchSetId: \(String(describing: sqlInjectionMatchSetId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>The <code>Id</code> and <code>Name</code> of a <code>SqlInjectionMatchSet</code>.</p>
public struct SqlInjectionMatchSetSummary: Equatable {
    /// <p>The name of the <code>SqlInjectionMatchSet</code>, if any, specified by <code>Id</code>.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>SqlInjectionMatchSet</code>. You use <code>SqlInjectionMatchSetId</code> to get information about a
    /// 			<code>SqlInjectionMatchSet</code> (see <a>GetSqlInjectionMatchSet</a>), update a <code>SqlInjectionMatchSet</code>
    /// 			(see <a>UpdateSqlInjectionMatchSet</a>), insert a <code>SqlInjectionMatchSet</code> into a <code>Rule</code> or
    /// 			delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete a <code>SqlInjectionMatchSet</code> from AWS WAF
    /// 			(see <a>DeleteSqlInjectionMatchSet</a>).</p>
    /// 		       <p>
    ///             <code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>
    public let sqlInjectionMatchSetId: String?

    public init (
        name: String? = nil,
        sqlInjectionMatchSetId: String? = nil
    )
    {
        self.name = name
        self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
    }
}

extension SqlInjectionMatchSetUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case sqlInjectionMatchTuple = "SqlInjectionMatchTuple"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let sqlInjectionMatchTuple = sqlInjectionMatchTuple {
            try encodeContainer.encode(sqlInjectionMatchTuple, forKey: .sqlInjectionMatchTuple)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let sqlInjectionMatchTupleDecoded = try containerValues.decodeIfPresent(SqlInjectionMatchTuple.self, forKey: .sqlInjectionMatchTuple)
        sqlInjectionMatchTuple = sqlInjectionMatchTupleDecoded
    }
}

extension SqlInjectionMatchSetUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlInjectionMatchSetUpdate(action: \(String(describing: action)), sqlInjectionMatchTuple: \(String(describing: sqlInjectionMatchTuple)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies the part of a web request that you want to inspect for snippets of malicious SQL code and indicates whether you want to
/// 			add the specification to a <a>SqlInjectionMatchSet</a> or delete it from a <code>SqlInjectionMatchSet</code>.</p>
public struct SqlInjectionMatchSetUpdate: Equatable {
    /// <p>Specify <code>INSERT</code> to add a <a>SqlInjectionMatchSetUpdate</a> to a <a>SqlInjectionMatchSet</a>.
    /// 			Use <code>DELETE</code> to remove a <code>SqlInjectionMatchSetUpdate</code> from a <code>SqlInjectionMatchSet</code>.</p>
    public let action: ChangeAction?
    /// <p>Specifies the part of a web request that you want AWS WAF to inspect for snippets of malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header.</p>
    public let sqlInjectionMatchTuple: SqlInjectionMatchTuple?

    public init (
        action: ChangeAction? = nil,
        sqlInjectionMatchTuple: SqlInjectionMatchTuple? = nil
    )
    {
        self.action = action
        self.sqlInjectionMatchTuple = sqlInjectionMatchTuple
    }
}

extension SqlInjectionMatchTuple: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldToMatch = "FieldToMatch"
        case textTransformation = "TextTransformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if let textTransformation = textTransformation {
            try encodeContainer.encode(textTransformation.rawValue, forKey: .textTransformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let textTransformationDecoded = try containerValues.decodeIfPresent(TextTransformation.self, forKey: .textTransformation)
        textTransformation = textTransformationDecoded
    }
}

extension SqlInjectionMatchTuple: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqlInjectionMatchTuple(fieldToMatch: \(String(describing: fieldToMatch)), textTransformation: \(String(describing: textTransformation)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies the part of a web request that you want AWS WAF to inspect for snippets of malicious SQL code and, if you want AWS WAF to inspect a header, the name of the header.</p>
public struct SqlInjectionMatchTuple: Equatable {
    /// <p>Specifies where in a web request to look for snippets of malicious SQL code.</p>
    public let fieldToMatch: FieldToMatch?
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
    /// 			If you specify a transformation, AWS WAF performs the transformation on <code>FieldToMatch</code> before inspecting it for a match.</p>
    ///          <p>You can only specify a single type of TextTransformation.</p>			
    /// 		       <p>
    ///             <b>CMD_LINE</b>
    ///          </p>
    /// 		       <p>When you're concerned that attackers are injecting an operating system command line
    ///          command and using unusual formatting to disguise some or all of the command, use this
    ///          option to perform the following transformations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Delete the following characters: \ " ' ^</p>
    ///             </li>
    ///             <li>
    ///                <p>Delete spaces before the following characters: / (</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace the following characters with a space: , ;</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace multiple spaces with one space</p>
    ///             </li>
    ///             <li>
    ///                <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p>
    ///             </li>
    ///          </ul>		
    /// 		       <p>
    ///             <b>COMPRESS_WHITE_SPACE</b>
    ///          </p>
    /// 		       <p>Use this option to replace the following characters with a space character (decimal 32):</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>\f, formfeed, decimal 12</p>
    ///             </li>
    ///             <li>
    ///                <p>\t, tab, decimal 9</p>
    ///             </li>
    ///             <li>
    ///                <p>\n, newline, decimal 10</p>
    ///             </li>
    ///             <li>
    ///                <p>\r, carriage return, decimal 13</p>
    ///             </li>
    ///             <li>
    ///                <p>\v, vertical tab, decimal 11</p>
    ///             </li>
    ///             <li>
    ///                <p>non-breaking space, decimal 160</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>		
    /// 		       <p>
    ///             <b>HTML_ENTITY_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs
    /// 			the following operations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)quot;</code> with <code>"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)gt;</code> with <code>></code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///          </ul>		
    /// 		       <p>
    ///             <b>LOWERCASE</b>
    ///          </p>
    /// 		       <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p>		
    /// 		       <p>
    ///             <b>URL_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to decode a URL-encoded value.</p>		
    /// 		       <p>
    ///             <b>NONE</b>
    ///          </p>
    /// 		       <p>Specify <code>NONE</code> if you don't want to perform any text transformations.</p>
    public let textTransformation: TextTransformation?

    public init (
        fieldToMatch: FieldToMatch? = nil,
        textTransformation: TextTransformation? = nil
    )
    {
        self.fieldToMatch = fieldToMatch
        self.textTransformation = textTransformation
    }
}

extension SubscribedRuleGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricName = "MetricName"
        case name = "Name"
        case ruleGroupId = "RuleGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ruleGroupId = ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
    }
}

extension SubscribedRuleGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribedRuleGroupSummary(metricName: \(String(describing: metricName)), name: \(String(describing: name)), ruleGroupId: \(String(describing: ruleGroupId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>A summary of the rule groups you are subscribed to.</p>
public struct SubscribedRuleGroupSummary: Equatable {
    /// <p>A friendly name or description for the metrics for this <code>RuleGroup</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    ///          whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change the name of the metric after you create the <code>RuleGroup</code>.</p>
    public let metricName: String?
    /// <p>A friendly name or description of the <code>RuleGroup</code>. You can't change the name of a <code>RuleGroup</code> after you create it.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>RuleGroup</code>.</p>
    public let ruleGroupId: String?

    public init (
        metricName: String? = nil,
        name: String? = nil,
        ruleGroupId: String? = nil
    )
    {
        self.metricName = metricName
        self.name = name
        self.ruleGroupId = ruleGroupId
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///         <p>A tag associated with an AWS resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing. For example, you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each AWS resource, up to 50 tags for a resource.</p>
///         <p>Tagging is only available through the API, SDKs, and CLI. You can't manage or view tags through the AWS WAF Classic console. You can tag the AWS resources that you manage through AWS WAF Classic: web ACLs, rule groups, and rules.  </p>
public struct Tag: Equatable {
    /// <p></p>
    public let key: String?
    /// <p></p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagInfoForResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagList = "TagList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagList = tagList {
            var tagListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagList)
            for taglist0 in tagList {
                try tagListContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension TagInfoForResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagInfoForResource(resourceARN: \(String(describing: resourceARN)), tagList: \(String(describing: tagList)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///         <p>Information for a tag associated with an AWS resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing. For example, you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each AWS resource, up to 50 tags for a resource.</p>
///         <p>Tagging is only available through the API, SDKs, and CLI. You can't manage or view tags through the AWS WAF Classic console. You can tag the AWS resources that you manage through AWS WAF Classic: web ACLs, rule groups, and rules.  </p>
public struct TagInfoForResource: Equatable {
    /// <p></p>
    public let resourceARN: String?
    /// <p></p>
    public let tagList: [Tag]?

    public init (
        resourceARN: String? = nil,
        tagList: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagList = tagList
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p></p>
    public let resourceARN: String?
    /// <p></p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFBadRequestException" : self = .wAFBadRequestException(try WAFBadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case wAFBadRequestException(WAFBadRequestException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TextTransformation {
    case cmdLine
    case compressWhiteSpace
    case htmlEntityDecode
    case lowercase
    case `none`
    case urlDecode
    case sdkUnknown(String)
}

extension TextTransformation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TextTransformation] {
        return [
            .cmdLine,
            .compressWhiteSpace,
            .htmlEntityDecode,
            .lowercase,
            .none,
            .urlDecode,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cmdLine: return "CMD_LINE"
        case .compressWhiteSpace: return "COMPRESS_WHITE_SPACE"
        case .htmlEntityDecode: return "HTML_ENTITY_DECODE"
        case .lowercase: return "LOWERCASE"
        case .none: return "NONE"
        case .urlDecode: return "URL_DECODE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TextTransformation(rawValue: rawValue) ?? TextTransformation.sdkUnknown(rawValue)
    }
}

extension TimeWindow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension TimeWindow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimeWindow(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>In a <a>GetSampledRequests</a> request, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range
/// 			for which you want AWS WAF to return a sample of web requests.</p>
///                     <p>You must specify the times in Coordinated Universal Time (UTC) format. UTC format includes the special
///                         designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>. </p>
/// 		       <p>In a <a>GetSampledRequests</a> response, the <code>StartTime</code> and <code>EndTime</code> objects specify the time range
/// 			for which AWS WAF actually returned a sample of web requests. AWS WAF gets the specified number of requests from among the first
/// 			5,000 requests that your AWS resource receives during the specified time period. If your resource receives more than 5,000
/// 			requests during that period, AWS WAF stops sampling after the 5,000th request. In that case, <code>EndTime</code>
/// 			is the time that AWS WAF received the 5,000th request. </p>
public struct TimeWindow: Equatable {
    /// <p>The end of the time range from which you want <code>GetSampledRequests</code> to return a sample of the
    ///                   requests that your AWS resource received. You must specify the date and time in Coordinated Universal Time (UTC) format.
    ///                   UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>.
    ///                       You can specify any time range in the previous three hours.</p>
    public let endTime: Date?
    /// <p>The beginning of the time range from which you want <code>GetSampledRequests</code> to return a sample of the
    ///                   requests that your AWS resource received. You must specify the date and time in Coordinated Universal Time (UTC) format.
    ///                   UTC format includes the special designator, <code>Z</code>. For example, <code>"2016-09-27T14:50Z"</code>.
    ///                       You can specify any time range in the previous three hours.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p></p>
    public let resourceARN: String?
    /// <p></p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFBadRequestException" : self = .wAFBadRequestException(try WAFBadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationException" : self = .wAFTagOperationException(try WAFTagOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFTagOperationInternalErrorException" : self = .wAFTagOperationInternalErrorException(try WAFTagOperationInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case wAFBadRequestException(WAFBadRequestException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFTagOperationException(WAFTagOperationException)
    case wAFTagOperationInternalErrorException(WAFTagOperationInternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateByteMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateByteMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateByteMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateByteMatchSetOutputError>
}

extension UpdateByteMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateByteMatchSetInput(byteMatchSetId: \(String(describing: byteMatchSetId)), changeToken: \(String(describing: changeToken)), updates: \(String(describing: updates)))"}
}

extension UpdateByteMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case byteMatchSetId = "ByteMatchSetId"
        case changeToken = "ChangeToken"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byteMatchSetId = byteMatchSetId {
            try encodeContainer.encode(byteMatchSetId, forKey: .byteMatchSetId)
        }
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for bytematchsetupdates0 in updates {
                try updatesContainer.encode(bytematchsetupdates0)
            }
        }
    }
}

public struct UpdateByteMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateByteMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateByteMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateByteMatchSetOutputError>
}

public struct UpdateByteMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateByteMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateByteMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateByteMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateByteMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateByteMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateByteMatchSetOutputError>
}

public struct UpdateByteMatchSetInput: Equatable {
    /// <p>The <code>ByteMatchSetId</code> of the <a>ByteMatchSet</a> that you want to update. <code>ByteMatchSetId</code> is returned by <a>CreateByteMatchSet</a> and by
    /// 			<a>ListByteMatchSets</a>.</p>
    public let byteMatchSetId: String?
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>An array of <code>ByteMatchSetUpdate</code> objects that you want to insert into or delete from a <a>ByteMatchSet</a>.
    /// 			For more information, see the applicable data types:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>ByteMatchSetUpdate</a>: Contains <code>Action</code> and <code>ByteMatchTuple</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>ByteMatchTuple</a>: Contains <code>FieldToMatch</code>, <code>PositionalConstraint</code>, <code>TargetString</code>,
    /// 				and <code>TextTransformation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let updates: [ByteMatchSetUpdate]?

    public init (
        byteMatchSetId: String? = nil,
        changeToken: String? = nil,
        updates: [ByteMatchSetUpdate]? = nil
    )
    {
        self.byteMatchSetId = byteMatchSetId
        self.changeToken = changeToken
        self.updates = updates
    }
}

struct UpdateByteMatchSetInputBody: Equatable {
    public let byteMatchSetId: String?
    public let changeToken: String?
    public let updates: [ByteMatchSetUpdate]?
}

extension UpdateByteMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case byteMatchSetId = "ByteMatchSetId"
        case changeToken = "ChangeToken"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .byteMatchSetId)
        byteMatchSetId = byteMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([ByteMatchSetUpdate?].self, forKey: .updates)
        var updatesDecoded0:[ByteMatchSetUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [ByteMatchSetUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension UpdateByteMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateByteMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateByteMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateByteMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateByteMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateByteMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateByteMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateByteMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateByteMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateByteMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateByteMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateGeoMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGeoMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGeoMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGeoMatchSetOutputError>
}

extension UpdateGeoMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGeoMatchSetInput(changeToken: \(String(describing: changeToken)), geoMatchSetId: \(String(describing: geoMatchSetId)), updates: \(String(describing: updates)))"}
}

extension UpdateGeoMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case geoMatchSetId = "GeoMatchSetId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let geoMatchSetId = geoMatchSetId {
            try encodeContainer.encode(geoMatchSetId, forKey: .geoMatchSetId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for geomatchsetupdates0 in updates {
                try updatesContainer.encode(geomatchsetupdates0)
            }
        }
    }
}

public struct UpdateGeoMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGeoMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGeoMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGeoMatchSetOutputError>
}

public struct UpdateGeoMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGeoMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGeoMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGeoMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGeoMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateGeoMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGeoMatchSetOutputError>
}

public struct UpdateGeoMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>GeoMatchSetId</code> of the <a>GeoMatchSet</a> that you want to update. <code>GeoMatchSetId</code> is returned by <a>CreateGeoMatchSet</a> and by
    /// 			<a>ListGeoMatchSets</a>.</p>
    public let geoMatchSetId: String?
    /// <p>An array of <code>GeoMatchSetUpdate</code> objects that you want to insert into or delete from an <a>GeoMatchSet</a>.
    /// 			For more information, see the applicable data types:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>GeoMatchSetUpdate</a>: Contains <code>Action</code> and <code>GeoMatchConstraint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>GeoMatchConstraint</a>: Contains <code>Type</code> and <code>Value</code>
    ///                </p>
    /// 			            <p>You can have only one <code>Type</code> and <code>Value</code> per <code>GeoMatchConstraint</code>. To add multiple countries, include multiple <code>GeoMatchSetUpdate</code> objects in your request.</p>
    ///             </li>
    ///          </ul>
    public let updates: [GeoMatchSetUpdate]?

    public init (
        changeToken: String? = nil,
        geoMatchSetId: String? = nil,
        updates: [GeoMatchSetUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.geoMatchSetId = geoMatchSetId
        self.updates = updates
    }
}

struct UpdateGeoMatchSetInputBody: Equatable {
    public let geoMatchSetId: String?
    public let changeToken: String?
    public let updates: [GeoMatchSetUpdate]?
}

extension UpdateGeoMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case geoMatchSetId = "GeoMatchSetId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let geoMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .geoMatchSetId)
        geoMatchSetId = geoMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([GeoMatchSetUpdate?].self, forKey: .updates)
        var updatesDecoded0:[GeoMatchSetUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [GeoMatchSetUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension UpdateGeoMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGeoMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGeoMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGeoMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGeoMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateGeoMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGeoMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateGeoMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateGeoMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateGeoMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateGeoMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateIPSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

extension UpdateIPSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIPSetInput(changeToken: \(String(describing: changeToken)), iPSetId: \(String(describing: iPSetId)), updates: \(String(describing: updates)))"}
}

extension UpdateIPSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case iPSetId = "IPSetId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let iPSetId = iPSetId {
            try encodeContainer.encode(iPSetId, forKey: .iPSetId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for ipsetupdates0 in updates {
                try updatesContainer.encode(ipsetupdates0)
            }
        }
    }
}

public struct UpdateIPSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

public struct UpdateIPSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIPSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIPSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIPSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIPSetInput>
    public typealias MOutput = OperationOutput<UpdateIPSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIPSetOutputError>
}

public struct UpdateIPSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>IPSetId</code> of the <a>IPSet</a> that you want to update. <code>IPSetId</code> is returned by <a>CreateIPSet</a> and by
    /// 			<a>ListIPSets</a>.</p>
    public let iPSetId: String?
    /// <p>An array of <code>IPSetUpdate</code> objects that you want to insert into or delete from an <a>IPSet</a>.
    /// 			For more information, see the applicable data types:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>IPSetUpdate</a>: Contains <code>Action</code> and <code>IPSetDescriptor</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>IPSetDescriptor</a>: Contains <code>Type</code> and <code>Value</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    /// 	        <p>You can insert a maximum of 1000 addresses in a single request.</p>
    public let updates: [IPSetUpdate]?

    public init (
        changeToken: String? = nil,
        iPSetId: String? = nil,
        updates: [IPSetUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.iPSetId = iPSetId
        self.updates = updates
    }
}

struct UpdateIPSetInputBody: Equatable {
    public let iPSetId: String?
    public let changeToken: String?
    public let updates: [IPSetUpdate]?
}

extension UpdateIPSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case iPSetId = "IPSetId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPSetId)
        iPSetId = iPSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([IPSetUpdate?].self, forKey: .updates)
        var updatesDecoded0:[IPSetUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [IPSetUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension UpdateIPSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIPSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIPSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIPSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIPSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateIPSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIPSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateIPSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateIPSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateIPSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateIPSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateRateBasedRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRateBasedRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRateBasedRuleInput>
    public typealias MOutput = OperationOutput<UpdateRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRateBasedRuleOutputError>
}

extension UpdateRateBasedRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRateBasedRuleInput(changeToken: \(String(describing: changeToken)), rateLimit: \(String(describing: rateLimit)), ruleId: \(String(describing: ruleId)), updates: \(String(describing: updates)))"}
}

extension UpdateRateBasedRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case rateLimit = "RateLimit"
        case ruleId = "RuleId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if rateLimit != 0 {
            try encodeContainer.encode(rateLimit, forKey: .rateLimit)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for ruleupdates0 in updates {
                try updatesContainer.encode(ruleupdates0)
            }
        }
    }
}

public struct UpdateRateBasedRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRateBasedRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRateBasedRuleInput>
    public typealias MOutput = OperationOutput<UpdateRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRateBasedRuleOutputError>
}

public struct UpdateRateBasedRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRateBasedRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRateBasedRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRateBasedRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRateBasedRuleInput>
    public typealias MOutput = OperationOutput<UpdateRateBasedRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRateBasedRuleOutputError>
}

public struct UpdateRateBasedRuleInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The maximum number of requests, which have an identical value in the field specified by the <code>RateKey</code>, allowed in a
    ///          five-minute period. If the number of requests exceeds the <code>RateLimit</code> and the other
    ///          predicates specified in the rule are also met,
    ///          AWS WAF triggers the action that is specified for this rule.</p>
    public let rateLimit: Int
    /// <p>The <code>RuleId</code> of the <code>RateBasedRule</code> that you want to update.
    ///             <code>RuleId</code> is returned by <code>CreateRateBasedRule</code> and by <a>ListRateBasedRules</a>.</p>
    public let ruleId: String?
    /// <p>An array of <code>RuleUpdate</code> objects that you want to insert into or delete
    ///          from a <a>RateBasedRule</a>. </p>
    public let updates: [RuleUpdate]?

    public init (
        changeToken: String? = nil,
        rateLimit: Int = 0,
        ruleId: String? = nil,
        updates: [RuleUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.rateLimit = rateLimit
        self.ruleId = ruleId
        self.updates = updates
    }
}

struct UpdateRateBasedRuleInputBody: Equatable {
    public let ruleId: String?
    public let changeToken: String?
    public let updates: [RuleUpdate]?
    public let rateLimit: Int
}

extension UpdateRateBasedRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case rateLimit = "RateLimit"
        case ruleId = "RuleId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([RuleUpdate?].self, forKey: .updates)
        var updatesDecoded0:[RuleUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [RuleUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
        let rateLimitDecoded = try containerValues.decode(Int.self, forKey: .rateLimit)
        rateLimit = rateLimitDecoded
    }
}

extension UpdateRateBasedRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRateBasedRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRateBasedRuleOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRateBasedRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRateBasedRuleOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateRateBasedRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRateBasedRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateRateBasedRuleOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the
    ///             <code>UpdateRateBasedRule</code> request. You can also use this value to query the
    ///          status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateRateBasedRuleOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateRateBasedRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateRegexMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRegexMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexMatchSetOutputError>
}

extension UpdateRegexMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegexMatchSetInput(changeToken: \(String(describing: changeToken)), regexMatchSetId: \(String(describing: regexMatchSetId)), updates: \(String(describing: updates)))"}
}

extension UpdateRegexMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexMatchSetId = "RegexMatchSetId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let regexMatchSetId = regexMatchSetId {
            try encodeContainer.encode(regexMatchSetId, forKey: .regexMatchSetId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for regexmatchsetupdates0 in updates {
                try updatesContainer.encode(regexmatchsetupdates0)
            }
        }
    }
}

public struct UpdateRegexMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRegexMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexMatchSetOutputError>
}

public struct UpdateRegexMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRegexMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexMatchSetOutputError>
}

public struct UpdateRegexMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RegexMatchSetId</code> of the <a>RegexMatchSet</a> that you want to update. <code>RegexMatchSetId</code> is returned by <a>CreateRegexMatchSet</a> and by
    /// 			<a>ListRegexMatchSets</a>.</p>
    public let regexMatchSetId: String?
    /// <p>An array of <code>RegexMatchSetUpdate</code> objects that you want to insert into or delete from a <a>RegexMatchSet</a>.
    /// 			For more information, see <a>RegexMatchTuple</a>.</p>
    public let updates: [RegexMatchSetUpdate]?

    public init (
        changeToken: String? = nil,
        regexMatchSetId: String? = nil,
        updates: [RegexMatchSetUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.regexMatchSetId = regexMatchSetId
        self.updates = updates
    }
}

struct UpdateRegexMatchSetInputBody: Equatable {
    public let regexMatchSetId: String?
    public let updates: [RegexMatchSetUpdate]?
    public let changeToken: String?
}

extension UpdateRegexMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexMatchSetId = "RegexMatchSetId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexMatchSetId)
        regexMatchSetId = regexMatchSetIdDecoded
        let updatesContainer = try containerValues.decodeIfPresent([RegexMatchSetUpdate?].self, forKey: .updates)
        var updatesDecoded0:[RegexMatchSetUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [RegexMatchSetUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension UpdateRegexMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegexMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFDisallowedNameException" : self = .wAFDisallowedNameException(try WAFDisallowedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRegexMatchSetOutputError: Equatable {
    case wAFDisallowedNameException(WAFDisallowedNameException)
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegexMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegexMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateRegexMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRegexMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateRegexMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateRegexMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateRegexMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateRegexMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateRegexPatternSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRegexPatternSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexPatternSetOutputError>
}

extension UpdateRegexPatternSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegexPatternSetInput(changeToken: \(String(describing: changeToken)), regexPatternSetId: \(String(describing: regexPatternSetId)), updates: \(String(describing: updates)))"}
}

extension UpdateRegexPatternSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexPatternSetId = "RegexPatternSetId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let regexPatternSetId = regexPatternSetId {
            try encodeContainer.encode(regexPatternSetId, forKey: .regexPatternSetId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for regexpatternsetupdates0 in updates {
                try updatesContainer.encode(regexpatternsetupdates0)
            }
        }
    }
}

public struct UpdateRegexPatternSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRegexPatternSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexPatternSetOutputError>
}

public struct UpdateRegexPatternSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRegexPatternSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRegexPatternSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRegexPatternSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRegexPatternSetInput>
    public typealias MOutput = OperationOutput<UpdateRegexPatternSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRegexPatternSetOutputError>
}

public struct UpdateRegexPatternSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RegexPatternSetId</code> of the <a>RegexPatternSet</a> that you want to update. <code>RegexPatternSetId</code> is returned by <a>CreateRegexPatternSet</a> and by
    /// 			<a>ListRegexPatternSets</a>.</p>
    public let regexPatternSetId: String?
    /// <p>An array of <code>RegexPatternSetUpdate</code> objects that you want to insert into or delete from a <a>RegexPatternSet</a>.</p>
    public let updates: [RegexPatternSetUpdate]?

    public init (
        changeToken: String? = nil,
        regexPatternSetId: String? = nil,
        updates: [RegexPatternSetUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.regexPatternSetId = regexPatternSetId
        self.updates = updates
    }
}

struct UpdateRegexPatternSetInputBody: Equatable {
    public let regexPatternSetId: String?
    public let updates: [RegexPatternSetUpdate]?
    public let changeToken: String?
}

extension UpdateRegexPatternSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case regexPatternSetId = "RegexPatternSetId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regexPatternSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regexPatternSetId)
        regexPatternSetId = regexPatternSetIdDecoded
        let updatesContainer = try containerValues.decodeIfPresent([RegexPatternSetUpdate?].self, forKey: .updates)
        var updatesDecoded0:[RegexPatternSetUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [RegexPatternSetUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension UpdateRegexPatternSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRegexPatternSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidRegexPatternException" : self = .wAFInvalidRegexPatternException(try WAFInvalidRegexPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRegexPatternSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidRegexPatternException(WAFInvalidRegexPatternException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRegexPatternSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRegexPatternSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateRegexPatternSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRegexPatternSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateRegexPatternSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateRegexPatternSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateRegexPatternSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateRegexPatternSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

extension UpdateRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleGroupInput(changeToken: \(String(describing: changeToken)), ruleGroupId: \(String(describing: ruleGroupId)), updates: \(String(describing: updates)))"}
}

extension UpdateRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleGroupId = "RuleGroupId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let ruleGroupId = ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for rulegroupupdates0 in updates {
                try updatesContainer.encode(rulegroupupdates0)
            }
        }
    }
}

public struct UpdateRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

public struct UpdateRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

public struct UpdateRuleGroupInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RuleGroupId</code> of the <a>RuleGroup</a> that you want to update. <code>RuleGroupId</code> is returned by <a>CreateRuleGroup</a> and by
    ///          <a>ListRuleGroups</a>.</p>
    public let ruleGroupId: String?
    /// <p>An array of <code>RuleGroupUpdate</code> objects that you want to insert into or delete from a
    ///          <a>RuleGroup</a>.</p>
    /// 		       <p>You can only insert <code>REGULAR</code> rules into a rule group.</p>
    /// 		       <p>
    ///             <code>ActivatedRule|OverrideAction</code> applies only when updating or adding a <code>RuleGroup</code> to a <code>WebACL</code>. In this case you do not use <code>ActivatedRule|Action</code>.  For all other update requests, <code>ActivatedRule|Action</code> is used instead of <code>ActivatedRule|OverrideAction</code>.</p>
    public let updates: [RuleGroupUpdate]?

    public init (
        changeToken: String? = nil,
        ruleGroupId: String? = nil,
        updates: [RuleGroupUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.ruleGroupId = ruleGroupId
        self.updates = updates
    }
}

struct UpdateRuleGroupInputBody: Equatable {
    public let ruleGroupId: String?
    public let updates: [RuleGroupUpdate]?
    public let changeToken: String?
}

extension UpdateRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleGroupId = "RuleGroupId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let updatesContainer = try containerValues.decodeIfPresent([RuleGroupUpdate?].self, forKey: .updates)
        var updatesDecoded0:[RuleGroupUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [RuleGroupUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension UpdateRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleGroupOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleGroupOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateRuleGroupOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateRuleGroup</code> request. You can also use this value
    ///          to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateRuleGroupOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleInput>
    public typealias MOutput = OperationOutput<UpdateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleOutputError>
}

extension UpdateRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleInput(changeToken: \(String(describing: changeToken)), ruleId: \(String(describing: ruleId)), updates: \(String(describing: updates)))"}
}

extension UpdateRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleId = "RuleId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let ruleId = ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for ruleupdates0 in updates {
                try updatesContainer.encode(ruleupdates0)
            }
        }
    }
}

public struct UpdateRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleInput>
    public typealias MOutput = OperationOutput<UpdateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleOutputError>
}

public struct UpdateRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleInput>
    public typealias MOutput = OperationOutput<UpdateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleOutputError>
}

public struct UpdateRuleInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>RuleId</code> of the <code>Rule</code> that you want to update. <code>RuleId</code> is returned by
    /// 			<code>CreateRule</code> and by <a>ListRules</a>.</p>
    public let ruleId: String?
    /// <p>An array of <code>RuleUpdate</code> objects that you want to insert into or delete from a
    /// 			<a>Rule</a>. For more information, see the applicable data types:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>RuleUpdate</a>: Contains <code>Action</code> and <code>Predicate</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>Predicate</a>: Contains <code>DataId</code>, <code>Negated</code>, and <code>Type</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let updates: [RuleUpdate]?

    public init (
        changeToken: String? = nil,
        ruleId: String? = nil,
        updates: [RuleUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.ruleId = ruleId
        self.updates = updates
    }
}

struct UpdateRuleInputBody: Equatable {
    public let ruleId: String?
    public let changeToken: String?
    public let updates: [RuleUpdate]?
}

extension UpdateRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case ruleId = "RuleId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([RuleUpdate?].self, forKey: .updates)
        var updatesDecoded0:[RuleUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [RuleUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension UpdateRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateRuleOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateRule</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateRuleOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateSizeConstraintSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSizeConstraintSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<UpdateSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSizeConstraintSetOutputError>
}

extension UpdateSizeConstraintSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSizeConstraintSetInput(changeToken: \(String(describing: changeToken)), sizeConstraintSetId: \(String(describing: sizeConstraintSetId)), updates: \(String(describing: updates)))"}
}

extension UpdateSizeConstraintSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sizeConstraintSetId = "SizeConstraintSetId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let sizeConstraintSetId = sizeConstraintSetId {
            try encodeContainer.encode(sizeConstraintSetId, forKey: .sizeConstraintSetId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for sizeconstraintsetupdates0 in updates {
                try updatesContainer.encode(sizeconstraintsetupdates0)
            }
        }
    }
}

public struct UpdateSizeConstraintSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSizeConstraintSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<UpdateSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSizeConstraintSetOutputError>
}

public struct UpdateSizeConstraintSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSizeConstraintSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSizeConstraintSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSizeConstraintSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSizeConstraintSetInput>
    public typealias MOutput = OperationOutput<UpdateSizeConstraintSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSizeConstraintSetOutputError>
}

public struct UpdateSizeConstraintSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>SizeConstraintSetId</code> of the <a>SizeConstraintSet</a> that you want to update. <code>SizeConstraintSetId</code>
    /// 			is returned by <a>CreateSizeConstraintSet</a> and by <a>ListSizeConstraintSets</a>.</p>
    public let sizeConstraintSetId: String?
    /// <p>An array of <code>SizeConstraintSetUpdate</code> objects that you want to insert into or delete from a <a>SizeConstraintSet</a>.
    /// 			For more information, see the applicable data types:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>SizeConstraintSetUpdate</a>: Contains <code>Action</code> and <code>SizeConstraint</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>SizeConstraint</a>: Contains <code>FieldToMatch</code>, <code>TextTransformation</code>, <code>ComparisonOperator</code>,
    /// 				and <code>Size</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let updates: [SizeConstraintSetUpdate]?

    public init (
        changeToken: String? = nil,
        sizeConstraintSetId: String? = nil,
        updates: [SizeConstraintSetUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.sizeConstraintSetId = sizeConstraintSetId
        self.updates = updates
    }
}

struct UpdateSizeConstraintSetInputBody: Equatable {
    public let sizeConstraintSetId: String?
    public let changeToken: String?
    public let updates: [SizeConstraintSetUpdate]?
}

extension UpdateSizeConstraintSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sizeConstraintSetId = "SizeConstraintSetId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeConstraintSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sizeConstraintSetId)
        sizeConstraintSetId = sizeConstraintSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([SizeConstraintSetUpdate?].self, forKey: .updates)
        var updatesDecoded0:[SizeConstraintSetUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [SizeConstraintSetUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension UpdateSizeConstraintSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSizeConstraintSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSizeConstraintSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSizeConstraintSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSizeConstraintSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateSizeConstraintSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSizeConstraintSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateSizeConstraintSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateSizeConstraintSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateSizeConstraintSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateSizeConstraintSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateSqlInjectionMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSqlInjectionMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSqlInjectionMatchSetOutputError>
}

extension UpdateSqlInjectionMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSqlInjectionMatchSetInput(changeToken: \(String(describing: changeToken)), sqlInjectionMatchSetId: \(String(describing: sqlInjectionMatchSetId)), updates: \(String(describing: updates)))"}
}

extension UpdateSqlInjectionMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
        case updates = "Updates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let sqlInjectionMatchSetId = sqlInjectionMatchSetId {
            try encodeContainer.encode(sqlInjectionMatchSetId, forKey: .sqlInjectionMatchSetId)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for sqlinjectionmatchsetupdates0 in updates {
                try updatesContainer.encode(sqlinjectionmatchsetupdates0)
            }
        }
    }
}

public struct UpdateSqlInjectionMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSqlInjectionMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSqlInjectionMatchSetOutputError>
}

public struct UpdateSqlInjectionMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSqlInjectionMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSqlInjectionMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSqlInjectionMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSqlInjectionMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateSqlInjectionMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSqlInjectionMatchSetOutputError>
}

/// <p>A request to update a <a>SqlInjectionMatchSet</a>.</p>
public struct UpdateSqlInjectionMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>The <code>SqlInjectionMatchSetId</code> of the <code>SqlInjectionMatchSet</code> that you want to update.
    /// 			<code>SqlInjectionMatchSetId</code> is returned by <a>CreateSqlInjectionMatchSet</a> and by <a>ListSqlInjectionMatchSets</a>.</p>
    public let sqlInjectionMatchSetId: String?
    /// <p>An array of <code>SqlInjectionMatchSetUpdate</code> objects that you want to insert into or delete from a
    /// 			<a>SqlInjectionMatchSet</a>. For more information, see the applicable data types:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>SqlInjectionMatchSetUpdate</a>: Contains <code>Action</code> and <code>SqlInjectionMatchTuple</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>SqlInjectionMatchTuple</a>: Contains <code>FieldToMatch</code> and <code>TextTransformation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let updates: [SqlInjectionMatchSetUpdate]?

    public init (
        changeToken: String? = nil,
        sqlInjectionMatchSetId: String? = nil,
        updates: [SqlInjectionMatchSetUpdate]? = nil
    )
    {
        self.changeToken = changeToken
        self.sqlInjectionMatchSetId = sqlInjectionMatchSetId
        self.updates = updates
    }
}

struct UpdateSqlInjectionMatchSetInputBody: Equatable {
    public let sqlInjectionMatchSetId: String?
    public let changeToken: String?
    public let updates: [SqlInjectionMatchSetUpdate]?
}

extension UpdateSqlInjectionMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case sqlInjectionMatchSetId = "SqlInjectionMatchSetId"
        case updates = "Updates"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlInjectionMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sqlInjectionMatchSetId)
        sqlInjectionMatchSetId = sqlInjectionMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([SqlInjectionMatchSetUpdate?].self, forKey: .updates)
        var updatesDecoded0:[SqlInjectionMatchSetUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [SqlInjectionMatchSetUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension UpdateSqlInjectionMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSqlInjectionMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSqlInjectionMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSqlInjectionMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSqlInjectionMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateSqlInjectionMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSqlInjectionMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

/// <p>The response to an <a>UpdateSqlInjectionMatchSets</a> request.</p>
public struct UpdateSqlInjectionMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateSqlInjectionMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateSqlInjectionMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateSqlInjectionMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateWebACLInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWebACLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebACLInput>
    public typealias MOutput = OperationOutput<UpdateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebACLOutputError>
}

extension UpdateWebACLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWebACLInput(changeToken: \(String(describing: changeToken)), defaultAction: \(String(describing: defaultAction)), updates: \(String(describing: updates)), webACLId: \(String(describing: webACLId)))"}
}

extension UpdateWebACLInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case defaultAction = "DefaultAction"
        case updates = "Updates"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for webaclupdates0 in updates {
                try updatesContainer.encode(webaclupdates0)
            }
        }
        if let webACLId = webACLId {
            try encodeContainer.encode(webACLId, forKey: .webACLId)
        }
    }
}

public struct UpdateWebACLInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWebACLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebACLInput>
    public typealias MOutput = OperationOutput<UpdateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebACLOutputError>
}

public struct UpdateWebACLInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWebACLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWebACLInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWebACLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWebACLInput>
    public typealias MOutput = OperationOutput<UpdateWebACLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWebACLOutputError>
}

public struct UpdateWebACLInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>A default action for the web ACL, either ALLOW or BLOCK. AWS WAF performs the default
    ///          action if a request doesn't match the criteria in any of the rules in a web ACL.</p>
    public let defaultAction: WafAction?
    /// <p>An array of updates to make to the <a>WebACL</a>.</p>		
    /// 		       <p>An array of <code>WebACLUpdate</code> objects that you want to insert into or delete from a
    /// 			<a>WebACL</a>. For more information, see the applicable data types:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>WebACLUpdate</a>: Contains <code>Action</code> and <code>ActivatedRule</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>ActivatedRule</a>: Contains <code>Action</code>,
    ///                   <code>OverrideAction</code>, <code>Priority</code>, <code>RuleId</code>, and
    ///                   <code>Type</code>. <code>ActivatedRule|OverrideAction</code> applies only when
    ///                updating or adding a <code>RuleGroup</code> to a <code>WebACL</code>. In this
    ///                case,
    ///                you do not use <code>ActivatedRule|Action</code>. For all other update requests,
    ///                   <code>ActivatedRule|Action</code> is used instead of
    ///                   <code>ActivatedRule|OverrideAction</code>. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>WafAction</a>: Contains <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let updates: [WebACLUpdate]?
    /// <p>The <code>WebACLId</code> of the <a>WebACL</a> that you want to update. <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by
    /// 			<a>ListWebACLs</a>.</p>
    public let webACLId: String?

    public init (
        changeToken: String? = nil,
        defaultAction: WafAction? = nil,
        updates: [WebACLUpdate]? = nil,
        webACLId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.defaultAction = defaultAction
        self.updates = updates
        self.webACLId = webACLId
    }
}

struct UpdateWebACLInputBody: Equatable {
    public let webACLId: String?
    public let changeToken: String?
    public let updates: [WebACLUpdate]?
    public let defaultAction: WafAction?
}

extension UpdateWebACLInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case defaultAction = "DefaultAction"
        case updates = "Updates"
        case webACLId = "WebACLId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([WebACLUpdate?].self, forKey: .updates)
        var updatesDecoded0:[WebACLUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [WebACLUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
        let defaultActionDecoded = try containerValues.decodeIfPresent(WafAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
    }
}

extension UpdateWebACLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWebACLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFReferencedItemException" : self = .wAFReferencedItemException(try WAFReferencedItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFSubscriptionNotFoundException" : self = .wAFSubscriptionNotFoundException(try WAFSubscriptionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWebACLOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFReferencedItemException(WAFReferencedItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case wAFSubscriptionNotFoundException(WAFSubscriptionNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWebACLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWebACLOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateWebACLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateWebACLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

public struct UpdateWebACLOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateWebACL</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateWebACLOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateWebACLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

public struct UpdateXssMatchSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateXssMatchSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateXssMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateXssMatchSetOutputError>
}

extension UpdateXssMatchSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateXssMatchSetInput(changeToken: \(String(describing: changeToken)), updates: \(String(describing: updates)), xssMatchSetId: \(String(describing: xssMatchSetId)))"}
}

extension UpdateXssMatchSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case updates = "Updates"
        case xssMatchSetId = "XssMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeToken = changeToken {
            try encodeContainer.encode(changeToken, forKey: .changeToken)
        }
        if let updates = updates {
            var updatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updates)
            for xssmatchsetupdates0 in updates {
                try updatesContainer.encode(xssmatchsetupdates0)
            }
        }
        if let xssMatchSetId = xssMatchSetId {
            try encodeContainer.encode(xssMatchSetId, forKey: .xssMatchSetId)
        }
    }
}

public struct UpdateXssMatchSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateXssMatchSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateXssMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateXssMatchSetOutputError>
}

public struct UpdateXssMatchSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateXssMatchSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateXssMatchSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateXssMatchSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateXssMatchSetInput>
    public typealias MOutput = OperationOutput<UpdateXssMatchSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateXssMatchSetOutputError>
}

/// <p>A request to update an <a>XssMatchSet</a>.</p>
public struct UpdateXssMatchSetInput: Equatable {
    /// <p>The value returned by the most recent call to <a>GetChangeToken</a>.</p>
    public let changeToken: String?
    /// <p>An array of <code>XssMatchSetUpdate</code> objects that you want to insert into or
    ///          delete from an
    ///          <a>XssMatchSet</a>. For more information, see the applicable data
    ///          types:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <a>XssMatchSetUpdate</a>: Contains <code>Action</code> and <code>XssMatchTuple</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>XssMatchTuple</a>: Contains <code>FieldToMatch</code> and <code>TextTransformation</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <a>FieldToMatch</a>: Contains <code>Data</code> and <code>Type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let updates: [XssMatchSetUpdate]?
    /// <p>The <code>XssMatchSetId</code> of the <code>XssMatchSet</code> that you want to update.
    /// 			<code>XssMatchSetId</code> is returned by <a>CreateXssMatchSet</a> and by <a>ListXssMatchSets</a>.</p>
    public let xssMatchSetId: String?

    public init (
        changeToken: String? = nil,
        updates: [XssMatchSetUpdate]? = nil,
        xssMatchSetId: String? = nil
    )
    {
        self.changeToken = changeToken
        self.updates = updates
        self.xssMatchSetId = xssMatchSetId
    }
}

struct UpdateXssMatchSetInputBody: Equatable {
    public let xssMatchSetId: String?
    public let changeToken: String?
    public let updates: [XssMatchSetUpdate]?
}

extension UpdateXssMatchSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
        case updates = "Updates"
        case xssMatchSetId = "XssMatchSetId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xssMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .xssMatchSetId)
        xssMatchSetId = xssMatchSetIdDecoded
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
        let updatesContainer = try containerValues.decodeIfPresent([XssMatchSetUpdate?].self, forKey: .updates)
        var updatesDecoded0:[XssMatchSetUpdate]? = nil
        if let updatesContainer = updatesContainer {
            updatesDecoded0 = [XssMatchSetUpdate]()
            for structure0 in updatesContainer {
                if let structure0 = structure0 {
                    updatesDecoded0?.append(structure0)
                }
            }
        }
        updates = updatesDecoded0
    }
}

extension UpdateXssMatchSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateXssMatchSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "WAFInternalErrorException" : self = .wAFInternalErrorException(try WAFInternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidAccountException" : self = .wAFInvalidAccountException(try WAFInvalidAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidOperationException" : self = .wAFInvalidOperationException(try WAFInvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFInvalidParameterException" : self = .wAFInvalidParameterException(try WAFInvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFLimitsExceededException" : self = .wAFLimitsExceededException(try WAFLimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentContainerException" : self = .wAFNonexistentContainerException(try WAFNonexistentContainerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFNonexistentItemException" : self = .wAFNonexistentItemException(try WAFNonexistentItemException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WAFStaleDataException" : self = .wAFStaleDataException(try WAFStaleDataException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateXssMatchSetOutputError: Equatable {
    case wAFInternalErrorException(WAFInternalErrorException)
    case wAFInvalidAccountException(WAFInvalidAccountException)
    case wAFInvalidOperationException(WAFInvalidOperationException)
    case wAFInvalidParameterException(WAFInvalidParameterException)
    case wAFLimitsExceededException(WAFLimitsExceededException)
    case wAFNonexistentContainerException(WAFNonexistentContainerException)
    case wAFNonexistentItemException(WAFNonexistentItemException)
    case wAFStaleDataException(WAFStaleDataException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateXssMatchSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateXssMatchSetOutputResponse(changeToken: \(String(describing: changeToken)))"}
}

extension UpdateXssMatchSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateXssMatchSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeToken = output.changeToken
        } else {
            self.changeToken = nil
        }
    }
}

/// <p>The response to an <a>UpdateXssMatchSets</a> request.</p>
public struct UpdateXssMatchSetOutputResponse: Equatable {
    /// <p>The <code>ChangeToken</code> that you used to submit the <code>UpdateXssMatchSet</code> request. You can also use this value
    /// 			to query the status of the request. For more information, see <a>GetChangeTokenStatus</a>.</p>
    public let changeToken: String?

    public init (
        changeToken: String? = nil
    )
    {
        self.changeToken = changeToken
    }
}

struct UpdateXssMatchSetOutputResponseBody: Equatable {
    public let changeToken: String?
}

extension UpdateXssMatchSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeToken = "ChangeToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeToken)
        changeToken = changeTokenDecoded
    }
}

extension WAFBadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFBadRequestException(message: \(String(describing: message)))"}
}

extension WAFBadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFBadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct WAFBadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFBadRequestExceptionBody: Equatable {
    public let message: String?
}

extension WAFBadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFDisallowedNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFDisallowedNameException(message: \(String(describing: message)))"}
}

extension WAFDisallowedNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFDisallowedNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The name specified is invalid.</p>
public struct WAFDisallowedNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFDisallowedNameExceptionBody: Equatable {
    public let message: String?
}

extension WAFDisallowedNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFEntityMigrationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFEntityMigrationException(migrationErrorReason: \(String(describing: migrationErrorReason)), migrationErrorType: \(String(describing: migrationErrorType)), message: \(String(describing: message)))"}
}

extension WAFEntityMigrationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFEntityMigrationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.migrationErrorReason = output.migrationErrorReason
            self.migrationErrorType = output.migrationErrorType
        } else {
            self.migrationErrorReason = nil
            self.migrationErrorType = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed due to a problem with the migration. The failure cause is provided in the exception, in the <code>MigrationErrorType</code>: </p>
///          <ul>
///             <li>
///                <p>
///                   <code>ENTITY_NOT_SUPPORTED</code> - The web ACL has an unsupported entity but the <code>IgnoreUnsupportedType</code> is not set to true.</p>
///             </li>
///             <li>
///                <p>
///                   <code>ENTITY_NOT_FOUND</code> - The web ACL doesn't exist.  </p>
///             </li>
///             <li>
///                <p>
///                   <code>S3_BUCKET_NO_PERMISSION</code> - You don't have permission to perform the <code>PutObject</code> action to the specified Amazon S3 bucket.</p>
///             </li>
///             <li>
///                <p>
///                   <code>S3_BUCKET_NOT_ACCESSIBLE</code> - The bucket policy doesn't allow AWS WAF to perform the <code>PutObject</code> action in the bucket.</p>
///             </li>
///             <li>
///                <p>
///                   <code>S3_BUCKET_NOT_FOUND</code> - The S3 bucket doesn't exist. </p>
///             </li>
///             <li>
///                <p>
///                   <code>S3_BUCKET_INVALID_REGION</code> - The S3 bucket is not in the same Region as the web ACL.</p>
///             </li>
///             <li>
///                <p>
///                   <code>S3_INTERNAL_ERROR</code> - AWS WAF failed to create the template in the S3 bucket for another reason.</p>
///             </li>
///          </ul>
public struct WAFEntityMigrationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var migrationErrorReason: String?
    public var migrationErrorType: MigrationErrorType?

    public init (
        message: String? = nil,
        migrationErrorReason: String? = nil,
        migrationErrorType: MigrationErrorType? = nil
    )
    {
        self.message = message
        self.migrationErrorReason = migrationErrorReason
        self.migrationErrorType = migrationErrorType
    }
}

struct WAFEntityMigrationExceptionBody: Equatable {
    public let message: String?
    public let migrationErrorType: MigrationErrorType?
    public let migrationErrorReason: String?
}

extension WAFEntityMigrationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case migrationErrorReason = "MigrationErrorReason"
        case migrationErrorType = "MigrationErrorType"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let migrationErrorTypeDecoded = try containerValues.decodeIfPresent(MigrationErrorType.self, forKey: .migrationErrorType)
        migrationErrorType = migrationErrorTypeDecoded
        let migrationErrorReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .migrationErrorReason)
        migrationErrorReason = migrationErrorReasonDecoded
    }
}

extension WAFInternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInternalErrorException(message: \(String(describing: message)))"}
}

extension WAFInternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because of a system problem, even though the request was valid. Retry your request.</p>
public struct WAFInternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFInternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension WAFInternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFInvalidAccountException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidAccountException()"}
}

extension WAFInvalidAccountException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because you tried to create, update, or delete an object by using an invalid account identifier.</p>
public struct WAFInvalidAccountException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}

extension WAFInvalidOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidOperationException(message: \(String(describing: message)))"}
}

extension WAFInvalidOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInvalidOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because there was nothing to do. For example:</p>
/// 			      <ul>
///             <li>
///                <p>You tried to remove a <code>Rule</code> from a <code>WebACL</code>, but the <code>Rule</code> isn't in the specified <code>WebACL</code>.</p>
///             </li>
///             <li>
///                <p>You tried to remove an IP address from an <code>IPSet</code>, but the IP address isn't in the specified <code>IPSet</code>.</p>
///             </li>
///             <li>
///                <p>You tried to remove a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code>
/// 					isn't in the specified <code>WebACL</code>.</p>
///             </li>
///             <li>
///                <p>You tried to add a <code>Rule</code> to a <code>WebACL</code>, but the <code>Rule</code> already exists in the
/// 					specified <code>WebACL</code>.</p>
///             </li>
///             <li>
///                <p>You tried to add a <code>ByteMatchTuple</code> to a <code>ByteMatchSet</code>, but the <code>ByteMatchTuple</code>
///                already exists in the specified <code>WebACL</code>.</p>
///             </li>
///          </ul>
public struct WAFInvalidOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFInvalidOperationExceptionBody: Equatable {
    public let message: String?
}

extension WAFInvalidOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFInvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidParameterException(field: \(String(describing: field)), parameter: \(String(describing: parameter)), reason: \(String(describing: reason)))"}
}

extension WAFInvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.field = output.field
            self.parameter = output.parameter
            self.reason = output.reason
        } else {
            self.field = nil
            self.parameter = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because AWS WAF didn't recognize a parameter in the request. For example:</p>
/// 			      <ul>
///             <li>
///                <p>You specified an invalid parameter name.</p>
///             </li>
///             <li>
///                <p>You specified an invalid value.</p>
///             </li>
///             <li>
///                <p>You tried to update an object (<code>ByteMatchSet</code>, <code>IPSet</code>, <code>Rule</code>, or <code>WebACL</code>)
/// 					using an action other than <code>INSERT</code> or <code>DELETE</code>.</p>
///             </li>
///             <li>
///                <p>You tried to create a <code>WebACL</code> with a <code>DefaultAction</code>
///                   <code>Type</code> other than
/// 					<code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p>
///             </li>
///             <li>
/// 		 	           <p>You tried to create a <code>RateBasedRule</code> with a <code>RateKey</code> value other than <code>IP</code>.</p>
/// 		          </li>
///             <li>
///                <p>You tried to update a <code>WebACL</code> with a <code>WafAction</code>
///                   <code>Type</code> other than
/// 					<code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>.</p>
///             </li>
///             <li>
///                <p>You tried to update a <code>ByteMatchSet</code> with a <code>FieldToMatch</code>
///                   <code>Type</code> other than
/// 					HEADER, METHOD, QUERY_STRING, URI, or BODY.</p>
///             </li>
///             <li>
///                <p>You tried to update a <code>ByteMatchSet</code> with a <code>Field</code> of <code>HEADER</code>
/// 					but no value for <code>Data</code>.</p>
///             </li>
///             <li>
/// 			   		       <p>Your request references an ARN that is malformed, or corresponds to a resource with which a web ACL cannot be associated.</p>
/// 			   	     </li>
///          </ul>
public struct WAFInvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var field: ParameterExceptionField?
    public var parameter: String?
    public var reason: ParameterExceptionReason?

    public init (
        field: ParameterExceptionField? = nil,
        parameter: String? = nil,
        reason: ParameterExceptionReason? = nil
    )
    {
        self.field = field
        self.parameter = parameter
        self.reason = reason
    }
}

struct WAFInvalidParameterExceptionBody: Equatable {
    public let field: ParameterExceptionField?
    public let parameter: String?
    public let reason: ParameterExceptionReason?
}

extension WAFInvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case field
        case parameter
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(ParameterExceptionField.self, forKey: .field)
        field = fieldDecoded
        let parameterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameter)
        parameter = parameterDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ParameterExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension WAFInvalidPermissionPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidPermissionPolicyException(message: \(String(describing: message)))"}
}

extension WAFInvalidPermissionPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInvalidPermissionPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because the specified policy is not in the proper format. </p>
///          <p>The policy is subject to the following restrictions:</p>
///          <ul>
///             <li>
///                <p>You can attach only one policy with each <code>PutPermissionPolicy</code> request.</p>
///             </li>
///             <li>
///                <p>The policy must include an <code>Effect</code>, <code>Action</code> and <code>Principal</code>. </p>
///             </li>
///             <li>
///
///                <p>
///                   <code>Effect</code> must specify <code>Allow</code>.</p>
///             </li>
///             <li>
///                <p>The <code>Action</code> in the policy must be <code>waf:UpdateWebACL</code>, <code>waf-regional:UpdateWebACL</code>, <code>waf:GetRuleGroup</code> and <code>waf-regional:GetRuleGroup</code> . Any extra or wildcard actions in the policy will be rejected.</p>
///             </li>
///             <li>
///                <p>The policy cannot include a <code>Resource</code> parameter.</p>
///             </li>
///             <li>
///                <p>The ARN in the request must be a valid WAF RuleGroup ARN and the RuleGroup must exist in the same region.</p>
///             </li>
///             <li>
///                <p>The user making the request must be the owner of the RuleGroup.</p>
///             </li>
///             <li>
///                <p>Your policy must be composed using IAM Policy version 2012-10-17.</p>
///             </li>
///          </ul>
public struct WAFInvalidPermissionPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFInvalidPermissionPolicyExceptionBody: Equatable {
    public let message: String?
}

extension WAFInvalidPermissionPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFInvalidRegexPatternException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFInvalidRegexPatternException(message: \(String(describing: message)))"}
}

extension WAFInvalidRegexPatternException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFInvalidRegexPatternExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The regular expression (regex) you specified in <code>RegexPatternString</code> is invalid.</p>
public struct WAFInvalidRegexPatternException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFInvalidRegexPatternExceptionBody: Equatable {
    public let message: String?
}

extension WAFInvalidRegexPatternExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFLimitsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFLimitsExceededException(message: \(String(describing: message)))"}
}

extension WAFLimitsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFLimitsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation exceeds a resource limit, for example, the maximum number of <code>WebACL</code> objects that you can create
/// 			for an AWS account. For more information, see
/// 			<a href="https://docs.aws.amazon.com/waf/latest/developerguide/limits.html">Limits</a> in the <i>AWS WAF Developer Guide</i>.</p>
public struct WAFLimitsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFLimitsExceededExceptionBody: Equatable {
    public let message: String?
}

extension WAFLimitsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFNonEmptyEntityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFNonEmptyEntityException(message: \(String(describing: message)))"}
}

extension WAFNonEmptyEntityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFNonEmptyEntityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because you tried to delete an object that isn't empty. For example:</p>
/// 		       <ul>
///             <li>
///                <p>You tried to delete a <code>WebACL</code> that still contains one or more <code>Rule</code> objects.</p>
///             </li>
///             <li>
///                <p>You tried to delete a <code>Rule</code> that still contains one or more <code>ByteMatchSet</code> objects
/// 				or other predicates.</p>
///             </li>
///             <li>
///                <p>You tried to delete a <code>ByteMatchSet</code> that contains one or more <code>ByteMatchTuple</code> objects.</p>
///             </li>
///             <li>
///                <p>You tried to delete an <code>IPSet</code> that references one or more IP addresses.</p>
///             </li>
///          </ul>
public struct WAFNonEmptyEntityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFNonEmptyEntityExceptionBody: Equatable {
    public let message: String?
}

extension WAFNonEmptyEntityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFNonexistentContainerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFNonexistentContainerException(message: \(String(describing: message)))"}
}

extension WAFNonexistentContainerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFNonexistentContainerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because you tried to add an object to or delete an object from another object that doesn't exist. For example:</p>
/// 		       <ul>
///             <li>
///                <p>You tried to add a <code>Rule</code> to or delete a <code>Rule</code> from a <code>WebACL</code> that doesn't exist.</p>
///             </li>
///             <li>
///                <p>You tried to add a <code>ByteMatchSet</code> to or delete a <code>ByteMatchSet</code> from a <code>Rule</code> that doesn't exist.</p>
///             </li>
///             <li>
///                <p>You tried to add an IP address to or delete an IP address from an <code>IPSet</code> that doesn't exist.</p>
///             </li>
///             <li>
///                <p>You tried to add a <code>ByteMatchTuple</code> to or delete a <code>ByteMatchTuple</code> from a <code>ByteMatchSet</code>
/// 				that doesn't exist.</p>
///             </li>
///          </ul>
public struct WAFNonexistentContainerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFNonexistentContainerExceptionBody: Equatable {
    public let message: String?
}

extension WAFNonexistentContainerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFNonexistentItemException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFNonexistentItemException(message: \(String(describing: message)))"}
}

extension WAFNonexistentItemException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFNonexistentItemExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because the referenced object doesn't exist.</p>
public struct WAFNonexistentItemException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFNonexistentItemExceptionBody: Equatable {
    public let message: String?
}

extension WAFNonexistentItemExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFReferencedItemException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFReferencedItemException(message: \(String(describing: message)))"}
}

extension WAFReferencedItemException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFReferencedItemExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because you tried to delete an object that is still in use. For example:</p>
/// 		       <ul>
///             <li>
///                <p>You tried to delete a <code>ByteMatchSet</code> that is still referenced by a <code>Rule</code>.</p>
///             </li>
///             <li>
///                <p>You tried to delete a <code>Rule</code> that is still referenced by a <code>WebACL</code>.</p>
///             </li>
///          </ul>
public struct WAFReferencedItemException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFReferencedItemExceptionBody: Equatable {
    public let message: String?
}

extension WAFReferencedItemExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFServiceLinkedRoleErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFServiceLinkedRoleErrorException(message: \(String(describing: message)))"}
}

extension WAFServiceLinkedRoleErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFServiceLinkedRoleErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS WAF is not able to access the service linked role. This can be caused by a previous <code>PutLoggingConfiguration</code> request, which can lock the service linked role for about 20 seconds. Please try your request again. The service linked role can also be locked by a previous <code>DeleteServiceLinkedRole</code> request, which can lock the role for 15 minutes or more. If you recently made a <code>DeleteServiceLinkedRole</code>, wait at least 15 minutes and try the request again. If you receive this same exception again, you will have to wait additional time until the role is unlocked.</p>
public struct WAFServiceLinkedRoleErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFServiceLinkedRoleErrorExceptionBody: Equatable {
    public let message: String?
}

extension WAFServiceLinkedRoleErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFStaleDataException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFStaleDataException(message: \(String(describing: message)))"}
}

extension WAFStaleDataException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFStaleDataExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because you tried to create, update, or delete an object by using a change token that has already been used.</p>
public struct WAFStaleDataException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFStaleDataExceptionBody: Equatable {
    public let message: String?
}

extension WAFStaleDataExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFSubscriptionNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFSubscriptionNotFoundException(message: \(String(describing: message)))"}
}

extension WAFSubscriptionNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFSubscriptionNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subscription does not exist.</p>
public struct WAFSubscriptionNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFSubscriptionNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension WAFSubscriptionNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFTagOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFTagOperationException(message: \(String(describing: message)))"}
}

extension WAFTagOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFTagOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct WAFTagOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFTagOperationExceptionBody: Equatable {
    public let message: String?
}

extension WAFTagOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WAFTagOperationInternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WAFTagOperationInternalErrorException(message: \(String(describing: message)))"}
}

extension WAFTagOperationInternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: WAFTagOperationInternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct WAFTagOperationInternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct WAFTagOperationInternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension WAFTagOperationInternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WafAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WafActionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WafAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WafAction(type: \(String(describing: type)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>For the action that is associated with a rule in a <code>WebACL</code>, specifies the action that you want AWS WAF to perform when a
/// 			web request matches all of the conditions in a rule. For the default action in a <code>WebACL</code>, specifies the action that you want
/// 			AWS WAF to take when a web request doesn't match all of the conditions in any of the rules in a <code>WebACL</code>. </p>
public struct WafAction: Equatable {
    /// <p>Specifies how you want AWS WAF to respond to requests that match the settings in a <code>Rule</code>. Valid settings include the following:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ALLOW</code>: AWS WAF allows requests</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BLOCK</code>: AWS WAF blocks requests</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COUNT</code>: AWS WAF increments a counter of the requests that match all of the conditions in the rule.
    /// 				AWS WAF then continues to inspect the web request based on the remaining rules in the web ACL. You can't specify <code>COUNT</code>
    /// 				for the default action for a <code>WebACL</code>.</p>
    ///             </li>
    ///          </ul>
    public let type: WafActionType?

    public init (
        type: WafActionType? = nil
    )
    {
        self.type = type
    }
}

public enum WafActionType {
    case allow
    case block
    case count
    case sdkUnknown(String)
}

extension WafActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WafActionType] {
        return [
            .allow,
            .block,
            .count,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .block: return "BLOCK"
        case .count: return "COUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WafActionType(rawValue: rawValue) ?? WafActionType.sdkUnknown(rawValue)
    }
}

extension WafOverrideAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WafOverrideActionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WafOverrideAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WafOverrideAction(type: \(String(describing: type)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
///          <p>The action to take if any rule within the <code>RuleGroup</code> matches a request. </p>
public struct WafOverrideAction: Equatable {
    /// <p>
    ///             <code>COUNT</code> overrides the action specified by the individual rule within a <code>RuleGroup</code> . If set to <code>NONE</code>, the rule's action will take place.</p>
    public let type: WafOverrideActionType?

    public init (
        type: WafOverrideActionType? = nil
    )
    {
        self.type = type
    }
}

public enum WafOverrideActionType {
    case count
    case `none`
    case sdkUnknown(String)
}

extension WafOverrideActionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WafOverrideActionType] {
        return [
            .count,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .count: return "COUNT"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WafOverrideActionType(rawValue: rawValue) ?? WafOverrideActionType.sdkUnknown(rawValue)
    }
}

public enum WafRuleType {
    case group
    case rateBased
    case regular
    case sdkUnknown(String)
}

extension WafRuleType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WafRuleType] {
        return [
            .group,
            .rateBased,
            .regular,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .group: return "GROUP"
        case .rateBased: return "RATE_BASED"
        case .regular: return "REGULAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WafRuleType(rawValue: rawValue) ?? WafRuleType.sdkUnknown(rawValue)
    }
}

extension WebACL: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultAction = "DefaultAction"
        case metricName = "MetricName"
        case name = "Name"
        case rules = "Rules"
        case webACLArn = "WebACLArn"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAction = defaultAction {
            try encodeContainer.encode(defaultAction, forKey: .defaultAction)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for activatedrules0 in rules {
                try rulesContainer.encode(activatedrules0)
            }
        }
        if let webACLArn = webACLArn {
            try encodeContainer.encode(webACLArn, forKey: .webACLArn)
        }
        if let webACLId = webACLId {
            try encodeContainer.encode(webACLId, forKey: .webACLId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let defaultActionDecoded = try containerValues.decodeIfPresent(WafAction.self, forKey: .defaultAction)
        defaultAction = defaultActionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([ActivatedRule?].self, forKey: .rules)
        var rulesDecoded0:[ActivatedRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [ActivatedRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let webACLArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLArn)
        webACLArn = webACLArnDecoded
    }
}

extension WebACL: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebACL(defaultAction: \(String(describing: defaultAction)), metricName: \(String(describing: metricName)), name: \(String(describing: name)), rules: \(String(describing: rules)), webACLArn: \(String(describing: webACLArn)), webACLId: \(String(describing: webACLId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Contains the <code>Rules</code> that identify the requests that you want to allow, block, or count. In a <code>WebACL</code>, you also specify a
/// 			default action (<code>ALLOW</code> or <code>BLOCK</code>), and the action for each <code>Rule</code> that you add to a
/// 			<code>WebACL</code>, for example, block requests from specified IP addresses or block requests from specified referrers.
/// 			You also associate the <code>WebACL</code> with a CloudFront distribution to identify the requests that you want AWS WAF to filter.
/// 			If you add more than one <code>Rule</code> to a <code>WebACL</code>, a request needs to match only one of the specifications
/// 			to be allowed, blocked, or counted. For more information, see <a>UpdateWebACL</a>.</p>
public struct WebACL: Equatable {
    /// <p>The action to perform if none of the <code>Rules</code> contained in the <code>WebACL</code> match. The action is specified by the
    /// 			<a>WafAction</a> object.</p>
    public let defaultAction: WafAction?
    /// <p>A friendly name or description for the metrics for this <code>WebACL</code>. The name can contain only alphanumeric characters (A-Z, a-z, 0-9), with maximum length 128 and minimum length one. It can't contain
    ///          whitespace or metric names reserved for AWS WAF, including "All" and "Default_Action." You can't change <code>MetricName</code> after you create the <code>WebACL</code>.</p>
    public let metricName: String?
    /// <p>A friendly name or description of the <code>WebACL</code>. You can't change the name of a <code>WebACL</code> after you create it.</p>
    public let name: String?
    /// <p>An array that contains the action for each <code>Rule</code> in a <code>WebACL</code>, the priority of the <code>Rule</code>,
    /// 			and the ID of the <code>Rule</code>.</p>
    public let rules: [ActivatedRule]?
    /// <p>Tha Amazon Resource Name (ARN) of the web ACL.</p>
    public let webACLArn: String?
    /// <p>A unique identifier for a <code>WebACL</code>. You use <code>WebACLId</code> to get information about a <code>WebACL</code>
    /// 			(see <a>GetWebACL</a>), update a <code>WebACL</code> (see <a>UpdateWebACL</a>), and delete a <code>WebACL</code> from AWS WAF
    /// 			(see <a>DeleteWebACL</a>).</p>
    /// 		       <p>
    ///             <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>
    public let webACLId: String?

    public init (
        defaultAction: WafAction? = nil,
        metricName: String? = nil,
        name: String? = nil,
        rules: [ActivatedRule]? = nil,
        webACLArn: String? = nil,
        webACLId: String? = nil
    )
    {
        self.defaultAction = defaultAction
        self.metricName = metricName
        self.name = name
        self.rules = rules
        self.webACLArn = webACLArn
        self.webACLId = webACLId
    }
}

extension WebACLSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case webACLId = "WebACLId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let webACLId = webACLId {
            try encodeContainer.encode(webACLId, forKey: .webACLId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webACLIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webACLId)
        webACLId = webACLIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WebACLSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebACLSummary(name: \(String(describing: name)), webACLId: \(String(describing: webACLId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Contains the identifier and the name or description of the <a>WebACL</a>.</p>
public struct WebACLSummary: Equatable {
    /// <p>A friendly name or description of the <a>WebACL</a>. You can't change the name of a <code>WebACL</code> after you create it.</p>
    public let name: String?
    /// <p>A unique identifier for a <code>WebACL</code>. You use <code>WebACLId</code> to get information about a <code>WebACL</code>
    /// 			(see <a>GetWebACL</a>), update a <code>WebACL</code> (see <a>UpdateWebACL</a>), and delete a <code>WebACL</code> from AWS WAF
    /// 			(see <a>DeleteWebACL</a>).</p>
    /// 		       <p>
    ///             <code>WebACLId</code> is returned by <a>CreateWebACL</a> and by <a>ListWebACLs</a>.</p>
    public let webACLId: String?

    public init (
        name: String? = nil,
        webACLId: String? = nil
    )
    {
        self.name = name
        self.webACLId = webACLId
    }
}

extension WebACLUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case activatedRule = "ActivatedRule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let activatedRule = activatedRule {
            try encodeContainer.encode(activatedRule, forKey: .activatedRule)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let activatedRuleDecoded = try containerValues.decodeIfPresent(ActivatedRule.self, forKey: .activatedRule)
        activatedRule = activatedRuleDecoded
    }
}

extension WebACLUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebACLUpdate(action: \(String(describing: action)), activatedRule: \(String(describing: activatedRule)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies whether to insert a <code>Rule</code> into or delete a <code>Rule</code> from a <code>WebACL</code>.</p>
public struct WebACLUpdate: Equatable {
    /// <p>Specifies whether to insert a <code>Rule</code> into or delete a <code>Rule</code> from a <code>WebACL</code>.</p>
    public let action: ChangeAction?
    /// <p>The <code>ActivatedRule</code> object in an <a>UpdateWebACL</a> request specifies a <code>Rule</code> that you want to insert or delete,
    ///          the priority of the <code>Rule</code> in the <code>WebACL</code>, and the action that you want AWS WAF to take when a web request matches the <code>Rule</code>
    ///          (<code>ALLOW</code>, <code>BLOCK</code>, or <code>COUNT</code>).</p>
    public let activatedRule: ActivatedRule?

    public init (
        action: ChangeAction? = nil,
        activatedRule: ActivatedRule? = nil
    )
    {
        self.action = action
        self.activatedRule = activatedRule
    }
}

extension XssMatchSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case xssMatchSetId = "XssMatchSetId"
        case xssMatchTuples = "XssMatchTuples"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let xssMatchSetId = xssMatchSetId {
            try encodeContainer.encode(xssMatchSetId, forKey: .xssMatchSetId)
        }
        if let xssMatchTuples = xssMatchTuples {
            var xssMatchTuplesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .xssMatchTuples)
            for xssmatchtuples0 in xssMatchTuples {
                try xssMatchTuplesContainer.encode(xssmatchtuples0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xssMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .xssMatchSetId)
        xssMatchSetId = xssMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let xssMatchTuplesContainer = try containerValues.decodeIfPresent([XssMatchTuple?].self, forKey: .xssMatchTuples)
        var xssMatchTuplesDecoded0:[XssMatchTuple]? = nil
        if let xssMatchTuplesContainer = xssMatchTuplesContainer {
            xssMatchTuplesDecoded0 = [XssMatchTuple]()
            for structure0 in xssMatchTuplesContainer {
                if let structure0 = structure0 {
                    xssMatchTuplesDecoded0?.append(structure0)
                }
            }
        }
        xssMatchTuples = xssMatchTuplesDecoded0
    }
}

extension XssMatchSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "XssMatchSet(name: \(String(describing: name)), xssMatchSetId: \(String(describing: xssMatchSetId)), xssMatchTuples: \(String(describing: xssMatchTuples)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>A complex type that contains <code>XssMatchTuple</code> objects, which specify the parts of web requests that you
/// 			want AWS WAF to inspect for cross-site scripting attacks and, if you want AWS WAF to inspect a header, the name of the header. If a
/// 			<code>XssMatchSet</code> contains more than one <code>XssMatchTuple</code> object, a request needs to
/// 			include cross-site scripting attacks in only one of the specified parts of the request to be considered a match.</p>
public struct XssMatchSet: Equatable {
    /// <p>The name, if any, of the <code>XssMatchSet</code>.</p>
    public let name: String?
    /// <p>A unique identifier for an <code>XssMatchSet</code>. You use <code>XssMatchSetId</code> to get information about an
    /// 			<code>XssMatchSet</code> (see <a>GetXssMatchSet</a>), update an <code>XssMatchSet</code>
    /// 			(see <a>UpdateXssMatchSet</a>), insert an <code>XssMatchSet</code> into a <code>Rule</code> or
    /// 			delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete an <code>XssMatchSet</code> from AWS WAF
    /// 			(see <a>DeleteXssMatchSet</a>).</p>
    /// 		       <p>
    ///             <code>XssMatchSetId</code> is returned by <a>CreateXssMatchSet</a> and by <a>ListXssMatchSets</a>.</p>
    public let xssMatchSetId: String?
    /// <p>Specifies the parts of web requests that you want to inspect for cross-site scripting attacks.</p>
    public let xssMatchTuples: [XssMatchTuple]?

    public init (
        name: String? = nil,
        xssMatchSetId: String? = nil,
        xssMatchTuples: [XssMatchTuple]? = nil
    )
    {
        self.name = name
        self.xssMatchSetId = xssMatchSetId
        self.xssMatchTuples = xssMatchTuples
    }
}

extension XssMatchSetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case xssMatchSetId = "XssMatchSetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let xssMatchSetId = xssMatchSetId {
            try encodeContainer.encode(xssMatchSetId, forKey: .xssMatchSetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let xssMatchSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .xssMatchSetId)
        xssMatchSetId = xssMatchSetIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension XssMatchSetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "XssMatchSetSummary(name: \(String(describing: name)), xssMatchSetId: \(String(describing: xssMatchSetId)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>The <code>Id</code> and <code>Name</code> of an <code>XssMatchSet</code>.</p>
public struct XssMatchSetSummary: Equatable {
    /// <p>The name of the <code>XssMatchSet</code>, if any, specified by <code>Id</code>.</p>
    public let name: String?
    /// <p>A unique identifier for an <code>XssMatchSet</code>. You use <code>XssMatchSetId</code> to get information about a
    /// 			<code>XssMatchSet</code> (see <a>GetXssMatchSet</a>), update an <code>XssMatchSet</code>
    /// 			(see <a>UpdateXssMatchSet</a>), insert an <code>XssMatchSet</code> into a <code>Rule</code> or
    /// 			delete one from a <code>Rule</code> (see <a>UpdateRule</a>), and delete an <code>XssMatchSet</code> from AWS WAF
    /// 			(see <a>DeleteXssMatchSet</a>).</p>
    /// 		       <p>
    ///             <code>XssMatchSetId</code> is returned by <a>CreateXssMatchSet</a> and by <a>ListXssMatchSets</a>.</p>
    public let xssMatchSetId: String?

    public init (
        name: String? = nil,
        xssMatchSetId: String? = nil
    )
    {
        self.name = name
        self.xssMatchSetId = xssMatchSetId
    }
}

extension XssMatchSetUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case xssMatchTuple = "XssMatchTuple"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let xssMatchTuple = xssMatchTuple {
            try encodeContainer.encode(xssMatchTuple, forKey: .xssMatchTuple)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ChangeAction.self, forKey: .action)
        action = actionDecoded
        let xssMatchTupleDecoded = try containerValues.decodeIfPresent(XssMatchTuple.self, forKey: .xssMatchTuple)
        xssMatchTuple = xssMatchTupleDecoded
    }
}

extension XssMatchSetUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "XssMatchSetUpdate(action: \(String(describing: action)), xssMatchTuple: \(String(describing: xssMatchTuple)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies the part of a web request that you want to inspect for cross-site scripting attacks and indicates whether you want to
/// 			add the specification to an <a>XssMatchSet</a> or delete it from an <code>XssMatchSet</code>.</p>
public struct XssMatchSetUpdate: Equatable {
    /// <p>Specify <code>INSERT</code> to add an
    ///          <a>XssMatchSetUpdate</a> to an <a>XssMatchSet</a>. Use
    ///             <code>DELETE</code> to remove an
    ///          <code>XssMatchSetUpdate</code> from an <code>XssMatchSet</code>.</p>
    public let action: ChangeAction?
    /// <p>Specifies the part of a web request that you want AWS WAF to inspect for cross-site scripting attacks and, if you want AWS WAF to inspect a header, the name of the header.</p>
    public let xssMatchTuple: XssMatchTuple?

    public init (
        action: ChangeAction? = nil,
        xssMatchTuple: XssMatchTuple? = nil
    )
    {
        self.action = action
        self.xssMatchTuple = xssMatchTuple
    }
}

extension XssMatchTuple: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldToMatch = "FieldToMatch"
        case textTransformation = "TextTransformation"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldToMatch = fieldToMatch {
            try encodeContainer.encode(fieldToMatch, forKey: .fieldToMatch)
        }
        if let textTransformation = textTransformation {
            try encodeContainer.encode(textTransformation.rawValue, forKey: .textTransformation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldToMatchDecoded = try containerValues.decodeIfPresent(FieldToMatch.self, forKey: .fieldToMatch)
        fieldToMatch = fieldToMatchDecoded
        let textTransformationDecoded = try containerValues.decodeIfPresent(TextTransformation.self, forKey: .textTransformation)
        textTransformation = textTransformationDecoded
    }
}

extension XssMatchTuple: CustomDebugStringConvertible {
    public var debugDescription: String {
        "XssMatchTuple(fieldToMatch: \(String(describing: fieldToMatch)), textTransformation: \(String(describing: textTransformation)))"}
}

/// <note>
///             <p>This is <b>AWS WAF Classic</b> documentation. For
///       more information, see <a href="https://docs.aws.amazon.com/waf/latest/developerguide/classic-waf-chapter.html">AWS
///       WAF Classic</a> in the developer guide.</p>
///             <p>
///                <b>For the latest version of AWS
///       WAF</b>, use the AWS WAFV2 API and see the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/waf-chapter.html">AWS WAF Developer Guide</a>. With the latest version, AWS WAF has a single set of endpoints for regional and global use. </p>
///          </note>
/// 		       <p>Specifies the part of a web request that you want AWS WAF to inspect for cross-site scripting attacks and, if you want AWS WAF to inspect a header, the name of the header.</p>
public struct XssMatchTuple: Equatable {
    /// <p>Specifies where in a web request to look for cross-site scripting attacks.</p>
    public let fieldToMatch: FieldToMatch?
    /// <p>Text transformations eliminate some of the unusual formatting that attackers use in web requests in an effort to bypass AWS WAF.
    /// 			If you specify a transformation, AWS WAF performs the transformation on <code>FieldToMatch</code> before inspecting it for a match.</p>	
    ///          <p>You can only specify a single type of TextTransformation.</p>			
    /// 		       <p>
    ///             <b>CMD_LINE</b>
    ///          </p>
    /// 		       <p>When you're concerned that attackers are injecting an operating system command line
    ///          command and using unusual formatting to disguise some or all of the command, use this
    ///          option to perform the following transformations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Delete the following characters: \ " ' ^</p>
    ///             </li>
    ///             <li>
    ///                <p>Delete spaces before the following characters: / (</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace the following characters with a space: , ;</p>
    ///             </li>
    ///             <li>
    ///                <p>Replace multiple spaces with one space</p>
    ///             </li>
    ///             <li>
    ///                <p>Convert uppercase letters (A-Z) to lowercase (a-z)</p>
    ///             </li>
    ///          </ul>		
    /// 		       <p>
    ///             <b>COMPRESS_WHITE_SPACE</b>
    ///          </p>
    /// 		       <p>Use this option to replace the following characters with a space character (decimal 32):</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>\f, formfeed, decimal 12</p>
    ///             </li>
    ///             <li>
    ///                <p>\t, tab, decimal 9</p>
    ///             </li>
    ///             <li>
    ///                <p>\n, newline, decimal 10</p>
    ///             </li>
    ///             <li>
    ///                <p>\r, carriage return, decimal 13</p>
    ///             </li>
    ///             <li>
    ///                <p>\v, vertical tab, decimal 11</p>
    ///             </li>
    ///             <li>
    ///                <p>non-breaking space, decimal 160</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>COMPRESS_WHITE_SPACE</code> also replaces multiple spaces with one space.</p>		
    /// 		       <p>
    ///             <b>HTML_ENTITY_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to replace HTML-encoded characters with unencoded characters. <code>HTML_ENTITY_DECODE</code> performs
    /// 			the following operations:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)quot;</code> with <code>"</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)nbsp;</code> with a non-breaking space, decimal 160</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)lt;</code> with a "less than" symbol</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces <code>(ampersand)gt;</code> with <code>></code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in hexadecimal format, <code>(ampersand)#xhhhh;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Replaces characters that are represented in decimal format, <code>(ampersand)#nnnn;</code>, with the corresponding
    /// 				characters</p>
    ///             </li>
    ///          </ul>		
    /// 		       <p>
    ///             <b>LOWERCASE</b>
    ///          </p>
    /// 		       <p>Use this option to convert uppercase letters (A-Z) to lowercase (a-z).</p>		
    /// 		       <p>
    ///             <b>URL_DECODE</b>
    ///          </p>
    /// 		       <p>Use this option to decode a URL-encoded value.</p>		
    /// 		       <p>
    ///             <b>NONE</b>
    ///          </p>
    /// 		       <p>Specify <code>NONE</code> if you don't want to perform any text transformations.</p>
    public let textTransformation: TextTransformation?

    public init (
        fieldToMatch: FieldToMatch? = nil,
        textTransformation: TextTransformation? = nil
    )
    {
        self.fieldToMatch = fieldToMatch
        self.textTransformation = textTransformation
    }
}
