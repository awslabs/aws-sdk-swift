// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ApiGatewayClientTypes.AccessLogSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn
        case format
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let format = format {
            try encodeContainer.encode(format, forKey: .format)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .format)
        format = formatDecoded
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Access log settings, including the access log format and access log destination ARN.
    public struct AccessLogSettings: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the CloudWatch Logs log group or Kinesis Data Firehose delivery stream to receive access logs. If you specify a Kinesis Data Firehose delivery stream, the stream name must begin with amazon-apigateway-.
        public var destinationArn: Swift.String?
        /// A single line format of the access logs of data, as specified by selected [$context variables](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#context-variable-reference). The format must include at least $context.requestId.
        public var format: Swift.String?

        public init (
            destinationArn: Swift.String? = nil,
            format: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.format = format
        }
    }

}

extension ApiGatewayClientTypes.ApiKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let customerId = customerId {
            try encodeContainer.encode(customerId, forKey: .customerId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stageKeys = stageKeys {
            var stageKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stageKeys)
            for listofstring0 in stageKeys {
                try stageKeysContainer.encode(listofstring0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[Swift.String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [Swift.String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// A resource that can be distributed to callers for executing [Method] resources that require an API key. API keys can be mapped to any [Stage] on any [RestApi], which indicates that the callers with the API key can make requests to that stage. [Use API Keys](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html)
    public struct ApiKey: Swift.Equatable {
        /// The timestamp when the API Key was created.
        public var createdDate: ClientRuntime.Date?
        /// An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.
        public var customerId: Swift.String?
        /// The description of the API Key.
        public var description: Swift.String?
        /// Specifies whether the API Key can be used by callers.
        public var enabled: Swift.Bool
        /// The identifier of the API Key.
        public var id: Swift.String?
        /// The timestamp when the API Key was last updated.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// The name of the API Key.
        public var name: Swift.String?
        /// A list of [Stage] resources that are associated with the [ApiKey] resource.
        public var stageKeys: [Swift.String]?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// The value of the API Key.
        public var value: Swift.String?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            customerId: Swift.String? = nil,
            description: Swift.String? = nil,
            enabled: Swift.Bool = false,
            id: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            stageKeys: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.customerId = customerId
            self.description = description
            self.enabled = enabled
            self.id = id
            self.lastUpdatedDate = lastUpdatedDate
            self.name = name
            self.stageKeys = stageKeys
            self.tags = tags
            self.value = value
        }
    }

}

extension ApiGatewayClientTypes {
    public enum ApiKeySourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorizer
        case header
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiKeySourceType] {
            return [
                .authorizer,
                .header,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorizer: return "AUTHORIZER"
            case .header: return "HEADER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiKeySourceType(rawValue: rawValue) ?? ApiKeySourceType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes {
    public enum ApiKeysFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiKeysFormat] {
            return [
                .csv,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "csv"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiKeysFormat(rawValue: rawValue) ?? ApiKeysFormat.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes.ApiStage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiId
        case stage
        case throttle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiId = apiId {
            try encodeContainer.encode(apiId, forKey: .apiId)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let throttle = throttle {
            var throttleContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .throttle)
            for (dictKey0, mapofapistagethrottlesettings0) in throttle {
                try throttleContainer.encode(mapofapistagethrottlesettings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiId)
        apiId = apiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
        let throttleContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.ThrottleSettings?].self, forKey: .throttle)
        var throttleDecoded0: [Swift.String:ApiGatewayClientTypes.ThrottleSettings]? = nil
        if let throttleContainer = throttleContainer {
            throttleDecoded0 = [Swift.String:ApiGatewayClientTypes.ThrottleSettings]()
            for (key0, throttlesettings0) in throttleContainer {
                if let throttlesettings0 = throttlesettings0 {
                    throttleDecoded0?[key0] = throttlesettings0
                }
            }
        }
        throttle = throttleDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// API stage name of the associated API stage in a usage plan.
    public struct ApiStage: Swift.Equatable {
        /// API Id of the associated API stage in a usage plan.
        public var apiId: Swift.String?
        /// API stage name of the associated API stage in a usage plan.
        public var stage: Swift.String?
        /// Map containing method level throttling information for API stage in a usage plan.
        public var throttle: [Swift.String:ApiGatewayClientTypes.ThrottleSettings]?

        public init (
            apiId: Swift.String? = nil,
            stage: Swift.String? = nil,
            throttle: [Swift.String:ApiGatewayClientTypes.ThrottleSettings]? = nil
        )
        {
            self.apiId = apiId
            self.stage = stage
            self.throttle = throttle
        }
    }

}

extension ApiGatewayClientTypes.Authorizer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = authType {
            try encodeContainer.encode(authType, forKey: .authType)
        }
        if let authorizerCredentials = authorizerCredentials {
            try encodeContainer.encode(authorizerCredentials, forKey: .authorizerCredentials)
        }
        if let authorizerResultTtlInSeconds = authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identitySource = identitySource {
            try encodeContainer.encode(identitySource, forKey: .identitySource)
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let providerARNs = providerARNs {
            var providerARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providerARNs)
            for listofarns0 in providerARNs {
                try providerARNsContainer.encode(listofarns0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method. [Use Lambda Function as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html)[Use Cognito User Pool as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html)
    public struct Authorizer: Swift.Equatable {
        /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
        public var authType: Swift.String?
        /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
        public var authorizerCredentials: Swift.String?
        /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
        public var authorizerResultTtlInSeconds: Swift.Int?
        /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
        public var authorizerUri: Swift.String?
        /// The identifier for the authorizer resource.
        public var id: Swift.String?
        /// The identity source for which authorization is requested.
        ///
        /// * For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth.
        ///
        /// * For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
        public var identitySource: Swift.String?
        /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
        public var identityValidationExpression: Swift.String?
        /// [Required] The name of the authorizer.
        public var name: Swift.String?
        /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
        public var providerARNs: [Swift.String]?
        /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
        public var type: ApiGatewayClientTypes.AuthorizerType?

        public init (
            authType: Swift.String? = nil,
            authorizerCredentials: Swift.String? = nil,
            authorizerResultTtlInSeconds: Swift.Int? = nil,
            authorizerUri: Swift.String? = nil,
            id: Swift.String? = nil,
            identitySource: Swift.String? = nil,
            identityValidationExpression: Swift.String? = nil,
            name: Swift.String? = nil,
            providerARNs: [Swift.String]? = nil,
            type: ApiGatewayClientTypes.AuthorizerType? = nil
        )
        {
            self.authType = authType
            self.authorizerCredentials = authorizerCredentials
            self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
            self.authorizerUri = authorizerUri
            self.id = id
            self.identitySource = identitySource
            self.identityValidationExpression = identityValidationExpression
            self.name = name
            self.providerARNs = providerARNs
            self.type = type
        }
    }

}

extension ApiGatewayClientTypes {
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public enum AuthorizerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cognitoUserPools
        case request
        case token
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthorizerType] {
            return [
                .cognitoUserPools,
                .request,
                .token,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cognitoUserPools: return "COGNITO_USER_POOLS"
            case .request: return "REQUEST"
            case .token: return "TOKEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthorizerType(rawValue: rawValue) ?? AuthorizerType.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The submitted request is not valid, for example, the input is incomplete or incorrect. See the accompanying error message for details.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayClientTypes.BasePathMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let restApiId = restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents the base path that callers of the API must provide as part of the URL after the domain name. A custom domain name plus a BasePathMapping specification identifies a deployed [RestApi] in a given stage of the owner [Account]. [Use Custom Domain Names](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
    public struct BasePathMapping: Swift.Equatable {
        /// The base path name that callers of the API must provide as part of the URL after the domain name.
        public var basePath: Swift.String?
        /// The string identifier of the associated [RestApi].
        public var restApiId: Swift.String?
        /// The name of the associated stage.
        public var stage: Swift.String?

        public init (
            basePath: Swift.String? = nil,
            restApiId: Swift.String? = nil,
            stage: Swift.String? = nil
        )
        {
            self.basePath = basePath
            self.restApiId = restApiId
            self.stage = stage
        }
    }

}

extension ApiGatewayClientTypes {
    /// Returns the size of the CacheCluster.
    public enum CacheClusterSize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case size0Point5Gb
        case size118Gb
        case size13Point5Gb
        case size1Point6Gb
        case size237Gb
        case size28Point4Gb
        case size58Point2Gb
        case size6Point1Gb
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheClusterSize] {
            return [
                .size0Point5Gb,
                .size118Gb,
                .size13Point5Gb,
                .size1Point6Gb,
                .size237Gb,
                .size28Point4Gb,
                .size58Point2Gb,
                .size6Point1Gb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .size0Point5Gb: return "0.5"
            case .size118Gb: return "118"
            case .size13Point5Gb: return "13.5"
            case .size1Point6Gb: return "1.6"
            case .size237Gb: return "237"
            case .size28Point4Gb: return "28.4"
            case .size58Point2Gb: return "58.2"
            case .size6Point1Gb: return "6.1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CacheClusterSize(rawValue: rawValue) ?? CacheClusterSize.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes {
    /// Returns the status of the CacheCluster.
    public enum CacheClusterStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case createInProgress
        case deleteInProgress
        case flushInProgress
        case notAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [CacheClusterStatus] {
            return [
                .available,
                .createInProgress,
                .deleteInProgress,
                .flushInProgress,
                .notAvailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .flushInProgress: return "FLUSH_IN_PROGRESS"
            case .notAvailable: return "NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CacheClusterStatus(rawValue: rawValue) ?? CacheClusterStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes.CanarySettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId
        case percentTraffic
        case stageVariableOverrides
        case useStageCache
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if percentTraffic != 0.0 {
            try encodeContainer.encode(percentTraffic, forKey: .percentTraffic)
        }
        if let stageVariableOverrides = stageVariableOverrides {
            var stageVariableOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariableOverrides)
            for (dictKey0, mapofstringtostring0) in stageVariableOverrides {
                try stageVariableOverridesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if useStageCache != false {
            try encodeContainer.encode(useStageCache, forKey: .useStageCache)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentTrafficDecoded = try containerValues.decode(Swift.Double.self, forKey: .percentTraffic)
        percentTraffic = percentTrafficDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let stageVariableOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariableOverrides)
        var stageVariableOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariableOverridesContainer = stageVariableOverridesContainer {
            stageVariableOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in stageVariableOverridesContainer {
                if let string0 = string0 {
                    stageVariableOverridesDecoded0?[key0] = string0
                }
            }
        }
        stageVariableOverrides = stageVariableOverridesDecoded0
        let useStageCacheDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useStageCache)
        useStageCache = useStageCacheDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Configuration settings of a canary deployment.
    public struct CanarySettings: Swift.Equatable {
        /// The ID of the canary deployment.
        public var deploymentId: Swift.String?
        /// The percent (0-100) of traffic diverted to a canary deployment.
        public var percentTraffic: Swift.Double
        /// Stage variables overridden for a canary release deployment, including new stage variables introduced in the canary. These stage variables are represented as a string-to-string map between stage variable names and their values.
        public var stageVariableOverrides: [Swift.String:Swift.String]?
        /// A Boolean flag to indicate whether the canary deployment uses the stage cache or not.
        public var useStageCache: Swift.Bool

        public init (
            deploymentId: Swift.String? = nil,
            percentTraffic: Swift.Double = 0.0,
            stageVariableOverrides: [Swift.String:Swift.String]? = nil,
            useStageCache: Swift.Bool = false
        )
        {
            self.deploymentId = deploymentId
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }
    }

}

extension ApiGatewayClientTypes.ClientCertificate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expirationDate = expirationDate {
            try encodeContainer.encode(expirationDate.timeIntervalSince1970, forKey: .expirationDate)
        }
        if let pemEncodedCertificate = pemEncodedCertificate {
            try encodeContainer.encode(pemEncodedCertificate, forKey: .pemEncodedCertificate)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint. Client certificates are used to authenticate an API by the backend server. To authenticate an API client (or user), use IAM roles and policies, a custom [Authorizer] or an Amazon Cognito user pool. [Use Client-Side Certificate](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html)
    public struct ClientCertificate: Swift.Equatable {
        /// The identifier of the client certificate.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the client certificate was created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the client certificate.
        public var description: Swift.String?
        /// The timestamp when the client certificate will expire.
        public var expirationDate: ClientRuntime.Date?
        /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
        public var pemEncodedCertificate: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            clientCertificateId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            expirationDate: ClientRuntime.Date? = nil,
            pemEncodedCertificate: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.description = description
            self.expirationDate = expirationDate
            self.pemEncodedCertificate = pemEncodedCertificate
            self.tags = tags
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request configuration has conflicts. For details, see the accompanying error message.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internet
        case vpcLink
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .internet,
                .vpcLink,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internet: return "INTERNET"
            case .vpcLink: return "VPC_LINK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes {
    public enum ContentHandlingStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case convertToBinary
        case convertToText
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentHandlingStrategy] {
            return [
                .convertToBinary,
                .convertToText,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .convertToBinary: return "CONVERT_TO_BINARY"
            case .convertToText: return "CONVERT_TO_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentHandlingStrategy(rawValue: rawValue) ?? ContentHandlingStrategy.sdkUnknown(rawValue)
        }
    }
}

extension CreateApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerId
        case description
        case enabled
        case generateDistinctId
        case name
        case stageKeys
        case tags
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerId = customerId {
            try encodeContainer.encode(customerId, forKey: .customerId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if generateDistinctId != false {
            try encodeContainer.encode(generateDistinctId, forKey: .generateDistinctId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stageKeys = stageKeys {
            var stageKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stageKeys)
            for listofstagekeys0 in stageKeys {
                try stageKeysContainer.encode(listofstagekeys0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

extension CreateApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/apikeys"
    }
}

/// Request to create an [ApiKey] resource.
public struct CreateApiKeyInput: Swift.Equatable {
    /// An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the [ApiKey].
    public var description: Swift.String?
    /// Specifies whether the [ApiKey] can be used by callers.
    public var enabled: Swift.Bool
    /// Specifies whether (true) or not (false) the key identifier is distinct from the created API key value. This parameter is deprecated and should not be used.
    public var generateDistinctId: Swift.Bool
    /// The name of the [ApiKey].
    public var name: Swift.String?
    /// DEPRECATED FOR USAGE PLANS - Specifies stages associated with the API key.
    public var stageKeys: [ApiGatewayClientTypes.StageKey]?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies a value of the API key.
    public var value: Swift.String?

    public init (
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        generateDistinctId: Swift.Bool = false,
        name: Swift.String? = nil,
        stageKeys: [ApiGatewayClientTypes.StageKey]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.generateDistinctId = generateDistinctId
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct CreateApiKeyInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let enabled: Swift.Bool
    let generateDistinctId: Swift.Bool
    let value: Swift.String?
    let stageKeys: [ApiGatewayClientTypes.StageKey]?
    let customerId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerId
        case description
        case enabled
        case generateDistinctId
        case name
        case stageKeys
        case tags
        case value
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let generateDistinctIdDecoded = try containerValues.decode(Swift.Bool.self, forKey: .generateDistinctId)
        generateDistinctId = generateDistinctIdDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.StageKey?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[ApiGatewayClientTypes.StageKey]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [ApiGatewayClientTypes.StageKey]()
            for structure0 in stageKeysContainer {
                if let structure0 = structure0 {
                    stageKeysDecoded0?.append(structure0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// A resource that can be distributed to callers for executing [Method] resources that require an API key. API keys can be mapped to any [Stage] on any [RestApi], which indicates that the callers with the API key can make requests to that stage. [Use API Keys](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html)
public struct CreateApiKeyOutputResponse: Swift.Equatable {
    /// The timestamp when the API Key was created.
    public var createdDate: ClientRuntime.Date?
    /// An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of [Stage] resources that are associated with the [ApiKey] resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct CreateApiKeyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
    let customerId: Swift.String?
    let description: Swift.String?
    let enabled: Swift.Bool
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
    let stageKeys: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApiKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[Swift.String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [Swift.String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = authType {
            try encodeContainer.encode(authType, forKey: .authType)
        }
        if let authorizerCredentials = authorizerCredentials {
            try encodeContainer.encode(authorizerCredentials, forKey: .authorizerCredentials)
        }
        if let authorizerResultTtlInSeconds = authorizerResultTtlInSeconds {
            try encodeContainer.encode(authorizerResultTtlInSeconds, forKey: .authorizerResultTtlInSeconds)
        }
        if let authorizerUri = authorizerUri {
            try encodeContainer.encode(authorizerUri, forKey: .authorizerUri)
        }
        if let identitySource = identitySource {
            try encodeContainer.encode(identitySource, forKey: .identitySource)
        }
        if let identityValidationExpression = identityValidationExpression {
            try encodeContainer.encode(identityValidationExpression, forKey: .identityValidationExpression)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let providerARNs = providerARNs {
            var providerARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .providerARNs)
            for listofarns0 in providerARNs {
                try providerARNsContainer.encode(listofarns0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers"
    }
}

/// Request to add a new [Authorizer] to an existing [RestApi] resource.
public struct CreateAuthorizerInput: Swift.Equatable {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identity source for which authorization is requested.
    ///
    /// * For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth.
    ///
    /// * For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// [Required] The name of the authorizer.
    /// This member is required.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    /// This member is required.
    public var type: ApiGatewayClientTypes.AuthorizerType?

    public init (
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        type: ApiGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.restApiId = restApiId
        self.type = type
    }
}

struct CreateAuthorizerInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: ApiGatewayClientTypes.AuthorizerType?
    let providerARNs: [Swift.String]?
    let authType: Swift.String?
    let authorizerUri: Swift.String?
    let authorizerCredentials: Swift.String?
    let identitySource: Swift.String?
    let identityValidationExpression: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
}

extension CreateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension CreateAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method. [Use Lambda Function as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html)[Use Cognito User Pool as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html)
public struct CreateAuthorizerOutputResponse: Swift.Equatable {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested.
    ///
    /// * For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth.
    ///
    /// * For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// [Required] The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: ApiGatewayClientTypes.AuthorizerType?

    public init (
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: ApiGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct CreateAuthorizerOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let type: ApiGatewayClientTypes.AuthorizerType?
    let providerARNs: [Swift.String]?
    let authType: Swift.String?
    let authorizerUri: Swift.String?
    let authorizerCredentials: Swift.String?
    let identitySource: Swift.String?
    let identityValidationExpression: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
}

extension CreateAuthorizerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension CreateBasePathMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basePath = basePath {
            try encodeContainer.encode(basePath, forKey: .basePath)
        }
        if let restApiId = restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }
}

extension CreateBasePathMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings"
    }
}

/// Requests API Gateway to create a new [BasePathMapping] resource.
public struct CreateBasePathMappingInput: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify a base path name after the domain name.
    public var basePath: Swift.String?
    /// [Required] The domain name of the [BasePathMapping] resource to create.
    /// This member is required.
    public var domainName: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the API's stage that you want to use for this mapping. Specify '(none)' if you want callers to explicitly specify the stage name after any base path name.
    public var stage: Swift.String?

    public init (
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct CreateBasePathMappingInputBody: Swift.Equatable {
    let basePath: Swift.String?
    let restApiId: Swift.String?
    let stage: Swift.String?
}

extension CreateBasePathMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateBasePathMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBasePathMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBasePathMappingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBasePathMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBasePathMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name. A custom domain name plus a BasePathMapping specification identifies a deployed [RestApi] in a given stage of the owner [Account]. [Use Custom Domain Names](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
public struct CreateBasePathMappingOutputResponse: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated [RestApi].
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init (
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct CreateBasePathMappingOutputResponseBody: Swift.Equatable {
    let basePath: Swift.String?
    let restApiId: Swift.String?
    let stage: Swift.String?
}

extension CreateBasePathMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case description
        case stageDescription
        case stageName
        case tracingEnabled
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheClusterEnabled = cacheClusterEnabled {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let canarySettings = canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let stageDescription = stageDescription {
            try encodeContainer.encode(stageDescription, forKey: .stageDescription)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tracingEnabled = tracingEnabled {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, mapofstringtostring0) in variables {
                try variablesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments"
    }
}

/// Requests API Gateway to create a [Deployment] resource.
public struct CreateDeploymentInput: Swift.Equatable {
    /// Enables a cache cluster for the [Stage] resource specified in the input.
    public var cacheClusterEnabled: Swift.Bool?
    /// Specifies the cache cluster size for the [Stage] resource specified in the input, if a cache cluster is enabled.
    public var cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    /// The input configuration for the canary deployment when the deployment is a canary release deployment.
    public var canarySettings: ApiGatewayClientTypes.DeploymentCanarySettings?
    /// The description for the [Deployment] resource to create.
    public var description: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// The description of the [Stage] resource for the [Deployment] resource to create.
    public var stageDescription: Swift.String?
    /// The name of the [Stage] resource for the [Deployment] resource to create.
    public var stageName: Swift.String?
    /// Specifies whether active tracing with X-ray is enabled for the [Stage].
    public var tracingEnabled: Swift.Bool?
    /// A map that defines the stage variables for the [Stage] resource that is associated with the new deployment. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?

    public init (
        cacheClusterEnabled: Swift.Bool? = nil,
        cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize? = nil,
        canarySettings: ApiGatewayClientTypes.DeploymentCanarySettings? = nil,
        description: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageDescription: Swift.String? = nil,
        stageName: Swift.String? = nil,
        tracingEnabled: Swift.Bool? = nil,
        variables: [Swift.String:Swift.String]? = nil
    )
    {
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.canarySettings = canarySettings
        self.description = description
        self.restApiId = restApiId
        self.stageDescription = stageDescription
        self.stageName = stageName
        self.tracingEnabled = tracingEnabled
        self.variables = variables
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let stageName: Swift.String?
    let stageDescription: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool?
    let cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    let variables: [Swift.String:Swift.String]?
    let canarySettings: ApiGatewayClientTypes.DeploymentCanarySettings?
    let tracingEnabled: Swift.Bool?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case description
        case stageDescription
        case stageName
        case tracingEnabled
        case variables
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let stageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageDescription)
        stageDescription = stageDescriptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let canarySettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DeploymentCanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
    }
}

extension CreateDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// An immutable representation of a [RestApi] resource that can be called by users using [Stages]. A deployment must be associated with a [Stage] for it to be callable over the Internet. To create a deployment, call POST on the [Deployments] resource of a [RestApi]. To view, update, or delete a deployment, call GET, PATCH, or DELETE on the specified deployment resource (/restapis/{restapi_id}/deployments/{deployment_id}). [RestApi], [Deployments], [Stage], [AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html), [AWS SDKs](https://aws.amazon.com/tools/)
public struct CreateDeploymentOutputResponse: Swift.Equatable {
    /// A summary of the [RestApi] at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init (
        apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct CreateDeploymentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]?
}

extension CreateDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: ApiGatewayClientTypes.MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [Swift.String: ApiGatewayClientTypes.MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [Swift.String: ApiGatewayClientTypes.MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

extension CreateDocumentationPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }
}

extension CreateDocumentationPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

/// Creates a new documentation part of a given API.
public struct CreateDocumentationPartInput: Swift.Equatable {
    /// [Required] The location of the targeted API entity of the to-be-created documentation part.
    /// This member is required.
    public var location: ApiGatewayClientTypes.DocumentationPartLocation?
    /// [Required] The new documentation content map of the targeted API entity. Enclosed key-value pairs are API-specific, but only OpenAPI-compliant key-value pairs can be exported and, hence, published.
    /// This member is required.
    public var properties: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        location: ApiGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.location = location
        self.properties = properties
        self.restApiId = restApiId
    }
}

struct CreateDocumentationPartInputBody: Swift.Equatable {
    let location: ApiGatewayClientTypes.DocumentationPartLocation?
    let properties: Swift.String?
}

extension CreateDocumentationPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case properties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CreateDocumentationPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDocumentationPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDocumentationPartOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDocumentationPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDocumentationPartOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// A documentation part for a targeted API entity. A documentation part consists of a content map (properties) and a target (location). The target specifies an API entity to which the documentation content applies. The supported API entity types are API, AUTHORIZER, MODEL, RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. Valid location fields depend on the API entity type. All valid fields are not required. The content map is a JSON string of API-specific key-value pairs. Although an API can use any shape for the content map, only the OpenAPI-compliant documentation fields will be injected into the associated API entity definition in the exported OpenAPI definition file. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationParts]
public struct CreateDocumentationPartOutputResponse: Swift.Equatable {
    /// The [DocumentationPart] identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: ApiGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init (
        id: Swift.String? = nil,
        location: ApiGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct CreateDocumentationPartOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let location: ApiGatewayClientTypes.DocumentationPartLocation?
    let properties: Swift.String?
}

extension CreateDocumentationPartOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case location
        case properties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension CreateDocumentationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case documentationVersion
        case stageName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

extension CreateDocumentationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions"
    }
}

/// Creates a new documentation version of a given API.
public struct CreateDocumentationVersionInput: Swift.Equatable {
    /// A description about the new documentation snapshot.
    public var description: Swift.String?
    /// [Required] The version identifier of the new snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// The stage name to be associated with the new documentation snapshot.
    public var stageName: Swift.String?

    public init (
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.description = description
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct CreateDocumentationVersionInputBody: Swift.Equatable {
    let documentationVersion: Swift.String?
    let stageName: Swift.String?
    let description: Swift.String?
}

extension CreateDocumentationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case documentationVersion
        case stageName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateDocumentationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDocumentationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDocumentationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDocumentationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDocumentationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// A snapshot of the documentation of an API. Publishing API documentation involves creating a documentation version associated with an API stage and exporting the versioned documentation to an external (e.g., OpenAPI) file. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationPart], [DocumentationVersions]
public struct CreateDocumentationVersionOutputResponse: Swift.Equatable {
    /// The date when the API documentation snapshot is created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct CreateDocumentationVersionOutputResponseBody: Swift.Equatable {
    let version: Swift.String?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
}

extension CreateDocumentationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateBody
        case certificateChain
        case certificateName
        case certificatePrivateKey
        case domainName
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case securityPolicy
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateBody = certificateBody {
            try encodeContainer.encode(certificateBody, forKey: .certificateBody)
        }
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let certificateName = certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificatePrivateKey = certificatePrivateKey {
            try encodeContainer.encode(certificatePrivateKey, forKey: .certificatePrivateKey)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let ownershipVerificationCertificateArn = ownershipVerificationCertificateArn {
            try encodeContainer.encode(ownershipVerificationCertificateArn, forKey: .ownershipVerificationCertificateArn)
        }
        if let regionalCertificateArn = regionalCertificateArn {
            try encodeContainer.encode(regionalCertificateArn, forKey: .regionalCertificateArn)
        }
        if let regionalCertificateName = regionalCertificateName {
            try encodeContainer.encode(regionalCertificateName, forKey: .regionalCertificateName)
        }
        if let securityPolicy = securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domainnames"
    }
}

/// A request to create a new domain name.
public struct CreateDomainNameInput: Swift.Equatable {
    /// The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// [Deprecated] The body of the server certificate that will be used by edge-optimized endpoint for this domain name provided by your certificate authority.
    public var certificateBody: Swift.String?
    /// [Deprecated] The intermediate certificates and optionally the root certificate, one after the other without any blank lines, used by an edge-optimized endpoint for this domain name. If you include the root certificate, your certificate chain must start with intermediate certificates and end with the root certificate. Use the intermediate certificates that were provided by your certificate authority. Do not include any intermediaries that are not in the chain of trust path.
    public var certificateChain: Swift.String?
    /// The user-friendly name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// [Deprecated] Your edge-optimized endpoint's domain name certificate's private key.
    public var certificatePrivateKey: Swift.String?
    /// [Required] The name of the [DomainName] resource.
    /// This member is required.
    public var domainName: Swift.String?
    /// The endpoint configuration of this [DomainName] showing the endpoint types of the domain name.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your custom domain name.
    public var mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthenticationInput?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an AWS-managed certificate that will be used by regional endpoint for this domain name. AWS Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The user-friendly name of the certificate that will be used by regional endpoint for this domain name.
    public var regionalCertificateName: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this [DomainName]. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init (
        certificateArn: Swift.String? = nil,
        certificateBody: Swift.String? = nil,
        certificateChain: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificatePrivateKey: Swift.String? = nil,
        domainName: Swift.String? = nil,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthenticationInput? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        securityPolicy: ApiGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateBody = certificateBody
        self.certificateChain = certificateChain
        self.certificateName = certificateName
        self.certificatePrivateKey = certificatePrivateKey
        self.domainName = domainName
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct CreateDomainNameInputBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateName: Swift.String?
    let certificateBody: Swift.String?
    let certificatePrivateKey: Swift.String?
    let certificateChain: Swift.String?
    let certificateArn: Swift.String?
    let regionalCertificateName: Swift.String?
    let regionalCertificateArn: Swift.String?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let tags: [Swift.String:Swift.String]?
    let securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
    let mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthenticationInput?
    let ownershipVerificationCertificateArn: Swift.String?
}

extension CreateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateBody
        case certificateChain
        case certificateName
        case certificatePrivateKey
        case domainName
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case securityPolicy
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateBody)
        certificateBody = certificateBodyDecoded
        let certificatePrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificatePrivateKey)
        certificatePrivateKey = certificatePrivateKeyDecoded
        let certificateChainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let securityPolicyDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.MutualTlsAuthenticationInput.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension CreateDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDomainNameOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = output.ownershipVerificationCertificateArn
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.ownershipVerificationCertificateArn = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// Represents a custom domain name as a user-friendly host name of an API ([RestApi]). When you deploy an API, API Gateway creates a default host name for the API. This default API host name is of the {restapi-id}.execute-api.{region}.amazonaws.com format. With the default host name, you can access the API's root resource with the URL of https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/. When you set up a custom domain name of apis.example.com for this API, you can then access the same resource using the URL of the https://apis.examples.com/myApi, where myApi is the base path mapping ([BasePathMapping]) of your API under the custom domain name. [Set a Custom Host Name for an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
public struct CreateDomainNameOutputResponse: Swift.Equatable {
    /// The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
    public var certificateUploadDate: ClientRuntime.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the [Amazon CloudFront documentation](https://aws.amazon.com/documentation/cloudfront/).
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see [Set up a Regional Custom Domain Name](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) and [AWS Regions and Endpoints for API Gateway](https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the [DomainName] migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: ApiGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the [DomainName] migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this [DomainName] showing the endpoint types of the domain name.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see [Set up a Regional Custom Domain Name](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) and [AWS Regions and Endpoints for API Gateway](https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this [DomainName]. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: ClientRuntime.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: ApiGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: ApiGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct CreateDomainNameOutputResponseBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateName: Swift.String?
    let certificateArn: Swift.String?
    let certificateUploadDate: ClientRuntime.Date?
    let regionalDomainName: Swift.String?
    let regionalHostedZoneId: Swift.String?
    let regionalCertificateName: Swift.String?
    let regionalCertificateArn: Swift.String?
    let distributionDomainName: Swift.String?
    let distributionHostedZoneId: Swift.String?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let domainNameStatus: ApiGatewayClientTypes.DomainNameStatus?
    let domainNameStatusMessage: Swift.String?
    let securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
    let tags: [Swift.String:Swift.String]?
    let mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication?
    let ownershipVerificationCertificateArn: Swift.String?
}

extension CreateDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension CreateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case name
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }
}

extension CreateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models"
    }
}

/// Request to add a new [Model] to an existing [RestApi] resource.
public struct CreateModelInput: Swift.Equatable {
    /// [Required] The content-type for the model.
    /// This member is required.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// [Required] The name of the model. Must be alphanumeric.
    /// This member is required.
    public var name: Swift.String?
    /// [Required] The [RestApi] identifier under which the [Model] will be created.
    /// This member is required.
    public var restApiId: Swift.String?
    /// The schema for the model. For application/json models, this should be [JSON schema draft 4](https://tools.ietf.org/html/draft-zyp-json-schema-04) model.
    public var schema: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.name = name
        self.restApiId = restApiId
        self.schema = schema
    }
}

struct CreateModelInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let schema: Swift.String?
    let contentType: Swift.String?
}

extension CreateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case name
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CreateModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// Represents the data structure of a method's request or response payload. A request model defines the data structure of the client-supplied request payload. A response model defines the data structure of the response payload returned by the back end. Although not required, models are useful for mapping payloads between the front end and back end. A model is used for generating an API's SDK, validating the input request body, and creating a skeletal mapping template. [Method], [MethodResponse], [Models and Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html)
public struct CreateModelOutputResponse: Swift.Equatable {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be [JSON schema draft 4](https://tools.ietf.org/html/draft-zyp-json-schema-04) model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct CreateModelOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let schema: Swift.String?
    let contentType: Swift.String?
}

extension CreateModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension CreateRequestValidatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if validateRequestBody != false {
            try encodeContainer.encode(validateRequestBody, forKey: .validateRequestBody)
        }
        if validateRequestParameters != false {
            try encodeContainer.encode(validateRequestParameters, forKey: .validateRequestParameters)
        }
    }
}

extension CreateRequestValidatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators"
    }
}

/// Creates a [RequestValidator] of a given [RestApi].
public struct CreateRequestValidatorInput: Swift.Equatable {
    /// The name of the to-be-created [RequestValidator].
    public var name: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// A Boolean flag to indicate whether to validate request body according to the configured model schema for the method (true) or not (false).
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters, true, or not false.
    public var validateRequestParameters: Swift.Bool

    public init (
        name: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.name = name
        self.restApiId = restApiId
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct CreateRequestValidatorInputBody: Swift.Equatable {
    let name: Swift.String?
    let validateRequestBody: Swift.Bool
    let validateRequestParameters: Swift.Bool
}

extension CreateRequestValidatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension CreateRequestValidatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRequestValidatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRequestValidatorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRequestValidatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRequestValidatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// A set of validation rules for incoming [Method] requests. In OpenAPI, a [RequestValidator] of an API is defined by the [x-amazon-apigateway-request-validators.requestValidator](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html) object. It the referenced using the [x-amazon-apigateway-request-validator](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator) property. [Enable Basic Request Validation in API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html)
public struct CreateRequestValidatorOutputResponse: Swift.Equatable {
    /// The identifier of this [RequestValidator].
    public var id: Swift.String?
    /// The name of this [RequestValidator]
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured [Model] schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct CreateRequestValidatorOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let validateRequestBody: Swift.Bool
    let validateRequestParameters: Swift.Bool
}

extension CreateRequestValidatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension CreateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pathPart
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pathPart = pathPart {
            try encodeContainer.encode(pathPart, forKey: .pathPart)
        }
    }
}

extension CreateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let parentId = parentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(parentId.urlPercentEncoding())"
    }
}

/// Requests API Gateway to create a [Resource] resource.
public struct CreateResourceInput: Swift.Equatable {
    /// [Required] The parent resource's identifier.
    /// This member is required.
    public var parentId: Swift.String?
    /// The last path segment for this resource.
    /// This member is required.
    public var pathPart: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        parentId: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.parentId = parentId
        self.pathPart = pathPart
        self.restApiId = restApiId
    }
}

struct CreateResourceInputBody: Swift.Equatable {
    let pathPart: Swift.String?
}

extension CreateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pathPart
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
    }
}

extension CreateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// Represents an API resource. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct CreateResourceOutputResponse: Swift.Equatable {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb. The resource methods are a map of methods indexed by methods' HTTP verbs enabled on the resource. This method map is included in the 200 OK response of the GET /restapis/{restapi_id}/resources/{resource_id} or GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods request.
    /// Example: Get the GET method of an API resource
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20170223T031827Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html", "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET", "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}", "templated": true } }, "apiKeyRequired": false, "authorizationType": "NONE", "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type": "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n" }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" } } } If the OPTIONS is enabled on the resource, you can follow the example here to get that method. Just replace the GET of the last path segment in the request URL with OPTIONS.
    public var resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]?

    public init (
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct CreateResourceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let parentId: Swift.String?
    let pathPart: Swift.String?
    let path: Swift.String?
    let resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]?
}

extension CreateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [Swift.String:ApiGatewayClientTypes.Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [Swift.String:ApiGatewayClientTypes.Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

extension CreateRestApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case cloneFrom
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySource = apiKeySource {
            try encodeContainer.encode(apiKeySource.rawValue, forKey: .apiKeySource)
        }
        if let binaryMediaTypes = binaryMediaTypes {
            var binaryMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binaryMediaTypes)
            for listofstring0 in binaryMediaTypes {
                try binaryMediaTypesContainer.encode(listofstring0)
            }
        }
        if let cloneFrom = cloneFrom {
            try encodeContainer.encode(cloneFrom, forKey: .cloneFrom)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableExecuteApiEndpoint != false {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let minimumCompressionSize = minimumCompressionSize {
            try encodeContainer.encode(minimumCompressionSize, forKey: .minimumCompressionSize)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

extension CreateRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restapis"
    }
}

/// The POST Request to add a new [RestApi] resource to your collection.
public struct CreateRestApiInput: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are:
    ///
    /// * HEADER to read the API key from the X-API-Key header of a request.
    ///
    /// * AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the [RestApi]. By default, the [RestApi] supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The ID of the [RestApi] that you want to clone from.
    public var cloneFrom: Swift.String?
    /// The description of the [RestApi].
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this [RestApi] showing the endpoint types of the API.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// [Required] The name of the [RestApi].
    /// This member is required.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and [Method] configuration.
    public var policy: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?

    public init (
        apiKeySource: ApiGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        cloneFrom: Swift.String? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.cloneFrom = cloneFrom
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
    }
}

struct CreateRestApiInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let version: Swift.String?
    let cloneFrom: Swift.String?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
}

extension CreateRestApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case cloneFrom
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let cloneFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloneFrom)
        cloneFrom = cloneFromDecoded
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension CreateRestApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRestApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRestApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRestApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRestApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct CreateRestApiOutputResponse: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are:
    ///
    /// * HEADER to read the API key from the X-API-Key header of a request.
    ///
    /// * AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the [RestApi]. By default, the [RestApi] supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this [RestApi] showing the endpoint types of the API.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and [Method] configuration.
    public var policy: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiKeySource: ApiGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct CreateRestApiOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
}

extension CreateRestApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension CreateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case deploymentId
        case description
        case documentationVersion
        case stageName
        case tags
        case tracingEnabled
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cacheClusterEnabled != false {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let canarySettings = canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if tracingEnabled != false {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, mapofstringtostring0) in variables {
                try variablesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages"
    }
}

/// Requests API Gateway to create a [Stage] resource.
public struct CreateStageInput: Swift.Equatable {
    /// Whether cache clustering is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool
    /// The stage's cache cluster size.
    public var cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    /// The canary deployment settings of this stage.
    public var canarySettings: ApiGatewayClientTypes.CanarySettings?
    /// [Required] The identifier of the [Deployment] resource for the [Stage] resource.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The description of the [Stage] resource.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The name for the [Stage] resource. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    /// This member is required.
    public var stageName: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the [Stage].
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for the new [Stage] resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?

    public init (
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize? = nil,
        canarySettings: ApiGatewayClientTypes.CanarySettings? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String:Swift.String]? = nil
    )
    {
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.canarySettings = canarySettings
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
    }
}

struct CreateStageInputBody: Swift.Equatable {
    let stageName: Swift.String?
    let deploymentId: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool
    let cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    let variables: [Swift.String:Swift.String]?
    let documentationVersion: Swift.String?
    let canarySettings: ApiGatewayClientTypes.CanarySettings?
    let tracingEnabled: Swift.Bool
    let tags: [Swift.String:Swift.String]?
}

extension CreateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheClusterEnabled
        case cacheClusterSize
        case canarySettings
        case deploymentId
        case description
        case documentationVersion
        case stageName
        case tags
        case tracingEnabled
        case variables
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// Represents a unique identifier for a version of a deployed [RestApi] that is callable by users. [Deploy an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html)
public struct CreateStageOutputResponse: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool
    /// The size of the cache cluster for the stage, if enabled.
    public var cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: ApiGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier of the [Deployment] that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// A map that defines the method settings for a [Stage] resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the [Stage].
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a [Stage] resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?
    /// The ARN of the WebAcl associated with the [Stage].
    public var webAclArn: Swift.String?

    public init (
        accessLogSettings: ApiGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: ApiGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String:Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct CreateStageOutputResponseBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let clientCertificateId: Swift.String?
    let stageName: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool
    let cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    let cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus?
    let methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]?
    let variables: [Swift.String:Swift.String]?
    let documentationVersion: Swift.String?
    let accessLogSettings: ApiGatewayClientTypes.AccessLogSettings?
    let canarySettings: ApiGatewayClientTypes.CanarySettings?
    let tracingEnabled: Swift.Bool
    let webAclArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension CreateStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [Swift.String:ApiGatewayClientTypes.MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [Swift.String:ApiGatewayClientTypes.MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension CreateUsagePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case name
        case quota
        case tags
        case throttle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiStages = apiStages {
            var apiStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .apiStages)
            for listofapistage0 in apiStages {
                try apiStagesContainer.encode(listofapistage0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quota = quota {
            try encodeContainer.encode(quota, forKey: .quota)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let throttle = throttle {
            try encodeContainer.encode(throttle, forKey: .throttle)
        }
    }
}

extension CreateUsagePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/usageplans"
    }
}

/// The POST request to create a usage plan with the name, description, throttle limits and quota limits, as well as the associated API stages, specified in the payload.
public struct CreateUsagePlanInput: Swift.Equatable {
    /// The associated API stages of the usage plan.
    public var apiStages: [ApiGatewayClientTypes.ApiStage]?
    /// The description of the usage plan.
    public var description: Swift.String?
    /// [Required] The name of the usage plan.
    /// This member is required.
    public var name: Swift.String?
    /// The quota of the usage plan.
    public var quota: ApiGatewayClientTypes.QuotaSettings?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// The throttling limits of the usage plan.
    public var throttle: ApiGatewayClientTypes.ThrottleSettings?

    public init (
        apiStages: [ApiGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        quota: ApiGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        throttle: ApiGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.name = name
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct CreateUsagePlanInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let apiStages: [ApiGatewayClientTypes.ApiStage]?
    let throttle: ApiGatewayClientTypes.ThrottleSettings?
    let quota: ApiGatewayClientTypes.QuotaSettings?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUsagePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case name
        case quota
        case tags
        case throttle
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUsagePlanKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId
        case keyType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyId = keyId {
            try encodeContainer.encode(keyId, forKey: .keyId)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType, forKey: .keyType)
        }
    }
}

extension CreateUsagePlanKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys"
    }
}

/// The POST request to create a usage plan key for adding an existing API key to a usage plan.
public struct CreateUsagePlanKeyInput: Swift.Equatable {
    /// [Required] The identifier of a [UsagePlanKey] resource for a plan customer.
    /// This member is required.
    public var keyId: Swift.String?
    /// [Required] The type of a [UsagePlanKey] resource for a plan customer.
    /// This member is required.
    public var keyType: Swift.String?
    /// [Required] The Id of the [UsagePlan] resource representing the usage plan containing the to-be-created [UsagePlanKey] resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        keyId: Swift.String? = nil,
        keyType: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.keyType = keyType
        self.usagePlanId = usagePlanId
    }
}

struct CreateUsagePlanKeyInputBody: Swift.Equatable {
    let keyId: Swift.String?
    let keyType: Swift.String?
}

extension CreateUsagePlanKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyId
        case keyType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyId)
        keyId = keyIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension CreateUsagePlanKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUsagePlanKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsagePlanKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsagePlanKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUsagePlanKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.type = output.type
            self.value = output.value
        } else {
            self.id = nil
            self.name = nil
            self.type = nil
            self.value = nil
        }
    }
}

/// Represents a usage plan key to identify a plan customer. To associate an API stage with a selected API key in a usage plan, you must create a UsagePlanKey resource to represent the selected [ApiKey]. " [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
public struct CreateUsagePlanKeyOutputResponse: Swift.Equatable {
    /// The Id of a usage plan key.
    public var id: Swift.String?
    /// The name of a usage plan key.
    public var name: Swift.String?
    /// The type of a usage plan key. Currently, the valid key type is API_KEY.
    public var type: Swift.String?
    /// The value of a usage plan key.
    public var value: Swift.String?

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

struct CreateUsagePlanKeyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let type: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
}

extension CreateUsagePlanKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case type
        case value
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateUsagePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUsagePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsagePlanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsagePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUsagePlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// Represents a usage plan than can specify who can assess associated API stages with specified request limits and quotas. In a usage plan, you associate an API by specifying the API's Id and a stage name of the specified API. You add plan customers by adding API keys to the plan. [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
public struct CreateUsagePlanOutputResponse: Swift.Equatable {
    /// The associated API stages of a usage plan.
    public var apiStages: [ApiGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a [UsagePlan] resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.
    public var productCode: Swift.String?
    /// The maximum number of permitted requests per a given unit time interval.
    public var quota: ApiGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The request throttle limits of a usage plan.
    public var throttle: ApiGatewayClientTypes.ThrottleSettings?

    public init (
        apiStages: [ApiGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: ApiGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        throttle: ApiGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct CreateUsagePlanOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let apiStages: [ApiGatewayClientTypes.ApiStage]?
    let throttle: ApiGatewayClientTypes.ThrottleSettings?
    let quota: ApiGatewayClientTypes.QuotaSettings?
    let productCode: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateUsagePlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
        case targetArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArns = targetArns {
            var targetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetArns)
            for listofstring0 in targetArns {
                try targetArnsContainer.encode(listofstring0)
            }
        }
    }
}

extension CreateVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vpclinks"
    }
}

/// Creates a VPC link, under the caller's account in a selected region, in an asynchronous operation that typically takes 2-4 minutes to complete and become operational. The caller must have permissions to create and update VPC Endpoint services.
public struct CreateVpcLinkInput: Swift.Equatable {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// [Required] The name used to label and identify the VPC link.
    /// This member is required.
    public var name: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?
    /// [Required] The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.
    /// This member is required.
    public var targetArns: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct CreateVpcLinkInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let targetArns: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVpcLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
        case targetArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVpcLinkOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// An API Gateway VPC link for a [RestApi] to access resources in an Amazon Virtual Private Cloud (VPC). To enable access to a resource in an Amazon Virtual Private Cloud through Amazon API Gateway, you, as an API developer, create a [VpcLink] resource targeted for one or more network load balancers of the VPC and then integrate an API method with a private integration that uses the [VpcLink]. The private integration has an integration type of HTTP or HTTP_PROXY and has a connection type of VPC_LINK. The integration uses the connectionId property to identify the [VpcLink] used.
public struct CreateVpcLinkOutputResponse: Swift.Equatable {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the [VpcLink]. It is used in an [Integration] to reference this [VpcLink].
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: ApiGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.
    public var targetArns: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ApiGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct CreateVpcLinkOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let targetArns: [Swift.String]?
    let status: ApiGatewayClientTypes.VpcLinkStatus?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateVpcLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiKey = apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

/// A request to delete the [ApiKey] resource.
public struct DeleteApiKeyInput: Swift.Equatable {
    /// [Required] The identifier of the [ApiKey] resource to be deleted.
    /// This member is required.
    public var apiKey: Swift.String?

    public init (
        apiKey: Swift.String? = nil
    )
    {
        self.apiKey = apiKey
    }
}

struct DeleteApiKeyInputBody: Swift.Equatable {
}

extension DeleteApiKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiKeyOutputResponse: Swift.Equatable {

}

extension DeleteAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Request to delete an existing [Authorizer] resource.
public struct DeleteAuthorizerInput: Swift.Equatable {
    /// [Required] The identifier of the [Authorizer] resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        authorizerId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.restApiId = restApiId
    }
}

struct DeleteAuthorizerInputBody: Swift.Equatable {
}

extension DeleteAuthorizerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAuthorizerOutputResponse: Swift.Equatable {

}

extension DeleteBasePathMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let basePath = basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

/// A request to delete the [BasePathMapping] resource.
public struct DeleteBasePathMappingInput: Swift.Equatable {
    /// [Required] The base path name of the [BasePathMapping] resource to delete. To specify an empty base path, set this parameter to '(none)'.
    /// This member is required.
    public var basePath: Swift.String?
    /// [Required] The domain name of the [BasePathMapping] resource to delete.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
    }
}

struct DeleteBasePathMappingInputBody: Swift.Equatable {
}

extension DeleteBasePathMappingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteBasePathMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBasePathMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBasePathMappingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBasePathMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBasePathMappingOutputResponse: Swift.Equatable {

}

extension DeleteClientCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clientCertificateId = clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

/// A request to delete the [ClientCertificate] resource.
public struct DeleteClientCertificateInput: Swift.Equatable {
    /// [Required] The identifier of the [ClientCertificate] resource to be deleted.
    /// This member is required.
    public var clientCertificateId: Swift.String?

    public init (
        clientCertificateId: Swift.String? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
    }
}

struct DeleteClientCertificateInputBody: Swift.Equatable {
}

extension DeleteClientCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteClientCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClientCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClientCertificateOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClientCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteClientCertificateOutputResponse: Swift.Equatable {

}

extension DeleteDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

/// Requests API Gateway to delete a [Deployment] resource.
public struct DeleteDeploymentInput: Swift.Equatable {
    /// [Required] The identifier of the [Deployment] resource to delete.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.restApiId = restApiId
    }
}

struct DeleteDeploymentInputBody: Swift.Equatable {
}

extension DeleteDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeploymentOutputResponse: Swift.Equatable {

}

extension DeleteDocumentationPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationPartId = documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

/// Deletes an existing documentation part of an API.
public struct DeleteDocumentationPartInput: Swift.Equatable {
    /// [Required] The identifier of the to-be-deleted documentation part.
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        documentationPartId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.restApiId = restApiId
    }
}

struct DeleteDocumentationPartInputBody: Swift.Equatable {
}

extension DeleteDocumentationPartInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDocumentationPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentationPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentationPartOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentationPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentationPartOutputResponse: Swift.Equatable {

}

extension DeleteDocumentationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationVersion = documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

/// Deletes an existing documentation version of an API.
public struct DeleteDocumentationVersionInput: Swift.Equatable {
    /// [Required] The version identifier of a to-be-deleted documentation snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
    }
}

struct DeleteDocumentationVersionInputBody: Swift.Equatable {
}

extension DeleteDocumentationVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDocumentationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDocumentationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDocumentationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDocumentationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDocumentationVersionOutputResponse: Swift.Equatable {

}

extension DeleteDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

/// A request to delete the [DomainName] resource.
public struct DeleteDomainNameInput: Swift.Equatable {
    /// [Required] The name of the [DomainName] resource to be deleted.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct DeleteDomainNameInputBody: Swift.Equatable {
}

extension DeleteDomainNameInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDomainNameOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDomainNameOutputResponse: Swift.Equatable {

}

extension DeleteGatewayResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let responseType = responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

/// Clears any customization of a [GatewayResponse] of a specified response type on the given [RestApi] and resets it with the default settings.
public struct DeleteGatewayResponseInput: Swift.Equatable {
    /// [Required] The response type of the associated [GatewayResponse].
    /// This member is required.
    public var responseType: ApiGatewayClientTypes.GatewayResponseType?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        responseType: ApiGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct DeleteGatewayResponseInputBody: Swift.Equatable {
}

extension DeleteGatewayResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGatewayResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGatewayResponseOutputResponse: Swift.Equatable {

}

extension DeleteIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

/// Represents a delete integration request.
public struct DeleteIntegrationInput: Swift.Equatable {
    /// [Required] Specifies a delete integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] Specifies a delete integration request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteIntegrationInputBody: Swift.Equatable {
}

extension DeleteIntegrationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationOutputResponse: Swift.Equatable {

}

extension DeleteIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Represents a delete integration response request.
public struct DeleteIntegrationResponseInput: Swift.Equatable {
    /// [Required] Specifies a delete integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] Specifies a delete integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] Specifies a delete integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct DeleteIntegrationResponseInputBody: Swift.Equatable {
}

extension DeleteIntegrationResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIntegrationResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIntegrationResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIntegrationResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIntegrationResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIntegrationResponseOutputResponse: Swift.Equatable {

}

extension DeleteMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Request to delete an existing [Method] resource.
public struct DeleteMethodInput: Swift.Equatable {
    /// [Required] The HTTP verb of the [Method] resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] The [Resource] identifier for the [Method] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteMethodInputBody: Swift.Equatable {
}

extension DeleteMethodInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMethodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMethodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMethodOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMethodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMethodOutputResponse: Swift.Equatable {

}

extension DeleteMethodResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// A request to delete an existing [MethodResponse] resource.
public struct DeleteMethodResponseInput: Swift.Equatable {
    /// [Required] The HTTP verb of the [Method] resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] The [Resource] identifier for the [MethodResponse] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The status code identifier for the [MethodResponse] resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct DeleteMethodResponseInputBody: Swift.Equatable {
}

extension DeleteMethodResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMethodResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMethodResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMethodResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMethodResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMethodResponseOutputResponse: Swift.Equatable {

}

extension DeleteModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let modelName = modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

/// Request to delete an existing model in an existing [RestApi] resource.
public struct DeleteModelInput: Swift.Equatable {
    /// [Required] The name of the model to delete.
    /// This member is required.
    public var modelName: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct DeleteModelInputBody: Swift.Equatable {
}

extension DeleteModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteModelOutputResponse: Swift.Equatable {

}

extension DeleteRequestValidatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let requestValidatorId = requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

/// Deletes a specified [RequestValidator] of a given [RestApi].
public struct DeleteRequestValidatorInput: Swift.Equatable {
    /// [Required] The identifier of the [RequestValidator] to be deleted.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct DeleteRequestValidatorInputBody: Swift.Equatable {
}

extension DeleteRequestValidatorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRequestValidatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRequestValidatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRequestValidatorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRequestValidatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRequestValidatorOutputResponse: Swift.Equatable {

}

extension DeleteResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

/// Request to delete a [Resource].
public struct DeleteResourceInput: Swift.Equatable {
    /// [Required] The identifier of the [Resource] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct DeleteResourceInputBody: Swift.Equatable {
}

extension DeleteResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceOutputResponse: Swift.Equatable {

}

extension DeleteRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

/// Request to delete the specified API from your collection.
public struct DeleteRestApiInput: Swift.Equatable {
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        restApiId: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
    }
}

struct DeleteRestApiInputBody: Swift.Equatable {
}

extension DeleteRestApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRestApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRestApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRestApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRestApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRestApiOutputResponse: Swift.Equatable {

}

extension DeleteStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

/// Requests API Gateway to delete a [Stage] resource.
public struct DeleteStageInput: Swift.Equatable {
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The name of the [Stage] resource to delete.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct DeleteStageInputBody: Swift.Equatable {
}

extension DeleteStageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStageOutputResponse: Swift.Equatable {

}

extension DeleteUsagePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

/// The DELETE request to delete a usage plan of a given plan Id.
public struct DeleteUsagePlanInput: Swift.Equatable {
    /// [Required] The Id of the to-be-deleted usage plan.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        usagePlanId: Swift.String? = nil
    )
    {
        self.usagePlanId = usagePlanId
    }
}

struct DeleteUsagePlanInputBody: Swift.Equatable {
}

extension DeleteUsagePlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUsagePlanKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        guard let keyId = keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())"
    }
}

/// The DELETE request to delete a usage plan key and remove the underlying API key from the associated usage plan.
public struct DeleteUsagePlanKeyInput: Swift.Equatable {
    /// [Required] The Id of the [UsagePlanKey] resource to be deleted.
    /// This member is required.
    public var keyId: Swift.String?
    /// [Required] The Id of the [UsagePlan] resource representing the usage plan containing the to-be-deleted [UsagePlanKey] resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        keyId: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.usagePlanId = usagePlanId
    }
}

struct DeleteUsagePlanKeyInputBody: Swift.Equatable {
}

extension DeleteUsagePlanKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUsagePlanKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUsagePlanKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsagePlanKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsagePlanKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsagePlanKeyOutputResponse: Swift.Equatable {

}

extension DeleteUsagePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUsagePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsagePlanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsagePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsagePlanOutputResponse: Swift.Equatable {

}

extension DeleteVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

/// Deletes an existing [VpcLink] of a specified identifier.
public struct DeleteVpcLinkInput: Swift.Equatable {
    /// [Required] The identifier of the [VpcLink]. It is used in an [Integration] to reference this [VpcLink].
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init (
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct DeleteVpcLinkInputBody: Swift.Equatable {
}

extension DeleteVpcLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVpcLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVpcLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVpcLinkOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVpcLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVpcLinkOutputResponse: Swift.Equatable {

}

extension ApiGatewayClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiSummary = apiSummary {
            var apiSummaryContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .apiSummary)
            for (dictKey0, pathtomapofmethodsnapshot0) in apiSummary {
                try apiSummaryContainer.encode(pathtomapofmethodsnapshot0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: ApiGatewayClientTypes.MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [Swift.String: ApiGatewayClientTypes.MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [Swift.String: ApiGatewayClientTypes.MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// An immutable representation of a [RestApi] resource that can be called by users using [Stages]. A deployment must be associated with a [Stage] for it to be callable over the Internet. To create a deployment, call POST on the [Deployments] resource of a [RestApi]. To view, update, or delete a deployment, call GET, PATCH, or DELETE on the specified deployment resource (/restapis/{restapi_id}/deployments/{deployment_id}). [RestApi], [Deployments], [Stage], [AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html), [AWS SDKs](https://aws.amazon.com/tools/)
    public struct Deployment: Swift.Equatable {
        /// A summary of the [RestApi] at the date and time that the deployment resource was created.
        public var apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]?
        /// The date and time that the deployment resource was created.
        public var createdDate: ClientRuntime.Date?
        /// The description for the deployment resource.
        public var description: Swift.String?
        /// The identifier for the deployment resource.
        public var id: Swift.String?

        public init (
            apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.apiSummary = apiSummary
            self.createdDate = createdDate
            self.description = description
            self.id = id
        }
    }

}

extension ApiGatewayClientTypes.DeploymentCanarySettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case percentTraffic
        case stageVariableOverrides
        case useStageCache
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if percentTraffic != 0.0 {
            try encodeContainer.encode(percentTraffic, forKey: .percentTraffic)
        }
        if let stageVariableOverrides = stageVariableOverrides {
            var stageVariableOverridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariableOverrides)
            for (dictKey0, mapofstringtostring0) in stageVariableOverrides {
                try stageVariableOverridesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if useStageCache != false {
            try encodeContainer.encode(useStageCache, forKey: .useStageCache)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let percentTrafficDecoded = try containerValues.decode(Swift.Double.self, forKey: .percentTraffic)
        percentTraffic = percentTrafficDecoded
        let stageVariableOverridesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariableOverrides)
        var stageVariableOverridesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariableOverridesContainer = stageVariableOverridesContainer {
            stageVariableOverridesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in stageVariableOverridesContainer {
                if let string0 = string0 {
                    stageVariableOverridesDecoded0?[key0] = string0
                }
            }
        }
        stageVariableOverrides = stageVariableOverridesDecoded0
        let useStageCacheDecoded = try containerValues.decode(Swift.Bool.self, forKey: .useStageCache)
        useStageCache = useStageCacheDecoded
    }
}

extension ApiGatewayClientTypes {
    /// The input configuration for a canary deployment.
    public struct DeploymentCanarySettings: Swift.Equatable {
        /// The percentage (0.0-100.0) of traffic routed to the canary deployment.
        public var percentTraffic: Swift.Double
        /// A stage variable overrides used for the canary release deployment. They can override existing stage variables or add new stage variables for the canary release deployment. These stage variables are represented as a string-to-string map between stage variable names and their values.
        public var stageVariableOverrides: [Swift.String:Swift.String]?
        /// A Boolean flag to indicate whether the canary release deployment uses the stage cache or not.
        public var useStageCache: Swift.Bool

        public init (
            percentTraffic: Swift.Double = 0.0,
            stageVariableOverrides: [Swift.String:Swift.String]? = nil,
            useStageCache: Swift.Bool = false
        )
        {
            self.percentTraffic = percentTraffic
            self.stageVariableOverrides = stageVariableOverrides
            self.useStageCache = useStageCache
        }
    }

}

extension ApiGatewayClientTypes.DocumentationPart: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case location
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension ApiGatewayClientTypes {
    /// A documentation part for a targeted API entity. A documentation part consists of a content map (properties) and a target (location). The target specifies an API entity to which the documentation content applies. The supported API entity types are API, AUTHORIZER, MODEL, RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. Valid location fields depend on the API entity type. All valid fields are not required. The content map is a JSON string of API-specific key-value pairs. Although an API can use any shape for the content map, only the OpenAPI-compliant documentation fields will be injected into the associated API entity definition in the exported OpenAPI definition file. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationParts]
    public struct DocumentationPart: Swift.Equatable {
        /// The [DocumentationPart] identifier, generated by API Gateway when the DocumentationPart is created.
        public var id: Swift.String?
        /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
        public var location: ApiGatewayClientTypes.DocumentationPartLocation?
        /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
        public var properties: Swift.String?

        public init (
            id: Swift.String? = nil,
            location: ApiGatewayClientTypes.DocumentationPartLocation? = nil,
            properties: Swift.String? = nil
        )
        {
            self.id = id
            self.location = location
            self.properties = properties
        }
    }

}

extension ApiGatewayClientTypes.DocumentationPartLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case method
        case name
        case path
        case statusCode
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let method = method {
            try encodeContainer.encode(method, forKey: .method)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DocumentationPartType.self, forKey: .type)
        type = typeDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let methodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .method)
        method = methodDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Specifies the target API entity to which the documentation applies.
    public struct DocumentationPartLocation: Swift.Equatable {
        /// The HTTP verb of a method. It is a valid field for the API entity types of METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is * for any method. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other location attributes, the child entity's method attribute must match that of the parent entity exactly.
        public var method: Swift.String?
        /// The name of the targeted API entity. It is a valid and required field for the API entity types of AUTHORIZER, MODEL, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY and RESPONSE_HEADER. It is an invalid field for any other entity type.
        public var name: Swift.String?
        /// The URL path of the target. It is a valid field for the API entity types of RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is / for the root resource. When an applicable child entity inherits the content of another entity of the same type with more general specifications of the other location attributes, the child entity's path attribute must match that of the parent entity as a prefix.
        public var path: Swift.String?
        /// The HTTP status code of a response. It is a valid field for the API entity types of RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. The default value is * for any status code. When an applicable child entity inherits the content of an entity of the same type with more general specifications of the other location attributes, the child entity's statusCode attribute must match that of the parent entity exactly.
        public var statusCode: Swift.String?
        /// [Required] The type of API entity to which the documentation content applies. Valid values are API, AUTHORIZER, MODEL, RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. Content inheritance does not apply to any entity of the API, AUTHORIZER, METHOD, MODEL, REQUEST_BODY, or RESOURCE type.
        /// This member is required.
        public var type: ApiGatewayClientTypes.DocumentationPartType?

        public init (
            method: Swift.String? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            statusCode: Swift.String? = nil,
            type: ApiGatewayClientTypes.DocumentationPartType? = nil
        )
        {
            self.method = method
            self.name = name
            self.path = path
            self.statusCode = statusCode
            self.type = type
        }
    }

}

extension ApiGatewayClientTypes {
    public enum DocumentationPartType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case authorizer
        case method
        case model
        case pathParameter
        case queryParameter
        case requestBody
        case requestHeader
        case resource
        case response
        case responseBody
        case responseHeader
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentationPartType] {
            return [
                .api,
                .authorizer,
                .method,
                .model,
                .pathParameter,
                .queryParameter,
                .requestBody,
                .requestHeader,
                .resource,
                .response,
                .responseBody,
                .responseHeader,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .authorizer: return "AUTHORIZER"
            case .method: return "METHOD"
            case .model: return "MODEL"
            case .pathParameter: return "PATH_PARAMETER"
            case .queryParameter: return "QUERY_PARAMETER"
            case .requestBody: return "REQUEST_BODY"
            case .requestHeader: return "REQUEST_HEADER"
            case .resource: return "RESOURCE"
            case .response: return "RESPONSE"
            case .responseBody: return "RESPONSE_BODY"
            case .responseHeader: return "RESPONSE_HEADER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DocumentationPartType(rawValue: rawValue) ?? DocumentationPartType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes.DocumentationVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ApiGatewayClientTypes {
    /// A snapshot of the documentation of an API. Publishing API documentation involves creating a documentation version associated with an API stage and exporting the versioned documentation to an external (e.g., OpenAPI) file. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationPart], [DocumentationVersions]
    public struct DocumentationVersion: Swift.Equatable {
        /// The date when the API documentation snapshot is created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the API documentation snapshot.
        public var description: Swift.String?
        /// The version identifier of the API documentation snapshot.
        public var version: Swift.String?

        public init (
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.version = version
        }
    }

}

extension ApiGatewayClientTypes.DomainName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateName = certificateName {
            try encodeContainer.encode(certificateName, forKey: .certificateName)
        }
        if let certificateUploadDate = certificateUploadDate {
            try encodeContainer.encode(certificateUploadDate.timeIntervalSince1970, forKey: .certificateUploadDate)
        }
        if let distributionDomainName = distributionDomainName {
            try encodeContainer.encode(distributionDomainName, forKey: .distributionDomainName)
        }
        if let distributionHostedZoneId = distributionHostedZoneId {
            try encodeContainer.encode(distributionHostedZoneId, forKey: .distributionHostedZoneId)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainNameStatus = domainNameStatus {
            try encodeContainer.encode(domainNameStatus.rawValue, forKey: .domainNameStatus)
        }
        if let domainNameStatusMessage = domainNameStatusMessage {
            try encodeContainer.encode(domainNameStatusMessage, forKey: .domainNameStatusMessage)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let mutualTlsAuthentication = mutualTlsAuthentication {
            try encodeContainer.encode(mutualTlsAuthentication, forKey: .mutualTlsAuthentication)
        }
        if let ownershipVerificationCertificateArn = ownershipVerificationCertificateArn {
            try encodeContainer.encode(ownershipVerificationCertificateArn, forKey: .ownershipVerificationCertificateArn)
        }
        if let regionalCertificateArn = regionalCertificateArn {
            try encodeContainer.encode(regionalCertificateArn, forKey: .regionalCertificateArn)
        }
        if let regionalCertificateName = regionalCertificateName {
            try encodeContainer.encode(regionalCertificateName, forKey: .regionalCertificateName)
        }
        if let regionalDomainName = regionalDomainName {
            try encodeContainer.encode(regionalDomainName, forKey: .regionalDomainName)
        }
        if let regionalHostedZoneId = regionalHostedZoneId {
            try encodeContainer.encode(regionalHostedZoneId, forKey: .regionalHostedZoneId)
        }
        if let securityPolicy = securityPolicy {
            try encodeContainer.encode(securityPolicy.rawValue, forKey: .securityPolicy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents a custom domain name as a user-friendly host name of an API ([RestApi]). When you deploy an API, API Gateway creates a default host name for the API. This default API host name is of the {restapi-id}.execute-api.{region}.amazonaws.com format. With the default host name, you can access the API's root resource with the URL of https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/. When you set up a custom domain name of apis.example.com for this API, you can then access the same resource using the URL of the https://apis.examples.com/myApi, where myApi is the base path mapping ([BasePathMapping]) of your API under the custom domain name. [Set a Custom Host Name for an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
    public struct DomainName: Swift.Equatable {
        /// The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
        public var certificateArn: Swift.String?
        /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
        public var certificateName: Swift.String?
        /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
        public var certificateUploadDate: ClientRuntime.Date?
        /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the [Amazon CloudFront documentation](https://aws.amazon.com/documentation/cloudfront/).
        public var distributionDomainName: Swift.String?
        /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see [Set up a Regional Custom Domain Name](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) and [AWS Regions and Endpoints for API Gateway](https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
        public var distributionHostedZoneId: Swift.String?
        /// The custom domain name as an API host name, for example, my-api.example.com.
        public var domainName: Swift.String?
        /// The status of the [DomainName] migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
        public var domainNameStatus: ApiGatewayClientTypes.DomainNameStatus?
        /// An optional text message containing detailed information about status of the [DomainName] migration.
        public var domainNameStatusMessage: Swift.String?
        /// The endpoint configuration of this [DomainName] showing the endpoint types of the domain name.
        public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
        /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
        public var mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication?
        /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
        public var ownershipVerificationCertificateArn: Swift.String?
        /// The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.
        public var regionalCertificateArn: Swift.String?
        /// The name of the certificate that will be used for validating the regional domain name.
        public var regionalCertificateName: Swift.String?
        /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
        public var regionalDomainName: Swift.String?
        /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see [Set up a Regional Custom Domain Name](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) and [AWS Regions and Endpoints for API Gateway](https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
        public var regionalHostedZoneId: Swift.String?
        /// The Transport Layer Security (TLS) version + cipher suite for this [DomainName]. The valid values are TLS_1_0 and TLS_1_2.
        public var securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?

        public init (
            certificateArn: Swift.String? = nil,
            certificateName: Swift.String? = nil,
            certificateUploadDate: ClientRuntime.Date? = nil,
            distributionDomainName: Swift.String? = nil,
            distributionHostedZoneId: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainNameStatus: ApiGatewayClientTypes.DomainNameStatus? = nil,
            domainNameStatusMessage: Swift.String? = nil,
            endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
            mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication? = nil,
            ownershipVerificationCertificateArn: Swift.String? = nil,
            regionalCertificateArn: Swift.String? = nil,
            regionalCertificateName: Swift.String? = nil,
            regionalDomainName: Swift.String? = nil,
            regionalHostedZoneId: Swift.String? = nil,
            securityPolicy: ApiGatewayClientTypes.SecurityPolicy? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateName = certificateName
            self.certificateUploadDate = certificateUploadDate
            self.distributionDomainName = distributionDomainName
            self.distributionHostedZoneId = distributionHostedZoneId
            self.domainName = domainName
            self.domainNameStatus = domainNameStatus
            self.domainNameStatusMessage = domainNameStatusMessage
            self.endpointConfiguration = endpointConfiguration
            self.mutualTlsAuthentication = mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
            self.regionalCertificateArn = regionalCertificateArn
            self.regionalCertificateName = regionalCertificateName
            self.regionalDomainName = regionalDomainName
            self.regionalHostedZoneId = regionalHostedZoneId
            self.securityPolicy = securityPolicy
            self.tags = tags
        }
    }

}

extension ApiGatewayClientTypes {
    public enum DomainNameStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case pending
        case pendingCertificateReimport
        case pendingOwnershipVerification
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainNameStatus] {
            return [
                .available,
                .pending,
                .pendingCertificateReimport,
                .pendingOwnershipVerification,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .pending: return "PENDING"
            case .pendingCertificateReimport: return "PENDING_CERTIFICATE_REIMPORT"
            case .pendingOwnershipVerification: return "PENDING_OWNERSHIP_VERIFICATION"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainNameStatus(rawValue: rawValue) ?? DomainNameStatus.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes.EndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case types
        case vpcEndpointIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let types = types {
            var typesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .types)
            for listofendpointtype0 in types {
                try typesContainer.encode(listofendpointtype0.rawValue)
            }
        }
        if let vpcEndpointIds = vpcEndpointIds {
            var vpcEndpointIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcEndpointIds)
            for listofstring0 in vpcEndpointIds {
                try vpcEndpointIdsContainer.encode(listofstring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typesContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.EndpointType?].self, forKey: .types)
        var typesDecoded0:[ApiGatewayClientTypes.EndpointType]? = nil
        if let typesContainer = typesContainer {
            typesDecoded0 = [ApiGatewayClientTypes.EndpointType]()
            for string0 in typesContainer {
                if let string0 = string0 {
                    typesDecoded0?.append(string0)
                }
            }
        }
        types = typesDecoded0
        let vpcEndpointIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .vpcEndpointIds)
        var vpcEndpointIdsDecoded0:[Swift.String]? = nil
        if let vpcEndpointIdsContainer = vpcEndpointIdsContainer {
            vpcEndpointIdsDecoded0 = [Swift.String]()
            for string0 in vpcEndpointIdsContainer {
                if let string0 = string0 {
                    vpcEndpointIdsDecoded0?.append(string0)
                }
            }
        }
        vpcEndpointIds = vpcEndpointIdsDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// The endpoint configuration to indicate the types of endpoints an API ([RestApi]) or its custom domain name ([DomainName]) has.
    public struct EndpointConfiguration: Swift.Equatable {
        /// A list of endpoint types of an API ([RestApi]) or its custom domain name ([DomainName]). For an edge-optimized API and its custom domain name, the endpoint type is "EDGE". For a regional API and its custom domain name, the endpoint type is REGIONAL. For a private API, the endpoint type is PRIVATE.
        public var types: [ApiGatewayClientTypes.EndpointType]?
        /// A list of VpcEndpointIds of an API ([RestApi]) against which to create Route53 ALIASes. It is only supported for PRIVATE endpoint type.
        public var vpcEndpointIds: [Swift.String]?

        public init (
            types: [ApiGatewayClientTypes.EndpointType]? = nil,
            vpcEndpointIds: [Swift.String]? = nil
        )
        {
            self.types = types
            self.vpcEndpointIds = vpcEndpointIds
        }
    }

}

extension ApiGatewayClientTypes {
    /// The endpoint type. The valid values are EDGE for edge-optimized API setup, most suitable for mobile applications; REGIONAL for regional API endpoint setup, most suitable for calling from AWS Region; and PRIVATE for private APIs.
    public enum EndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edge
        case `private`
        case regional
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointType] {
            return [
                .edge,
                .private,
                .regional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .private: return "PRIVATE"
            case .regional: return "REGIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
        }
    }
}

extension FlushStageAuthorizersCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/authorizers"
    }
}

/// Request to flush authorizer cache entries on a specified stage.
public struct FlushStageAuthorizersCacheInput: Swift.Equatable {
    /// The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// The name of the stage to flush.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct FlushStageAuthorizersCacheInputBody: Swift.Equatable {
}

extension FlushStageAuthorizersCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension FlushStageAuthorizersCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FlushStageAuthorizersCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FlushStageAuthorizersCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FlushStageAuthorizersCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct FlushStageAuthorizersCacheOutputResponse: Swift.Equatable {

}

extension FlushStageCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/cache/data"
    }
}

/// Requests API Gateway to flush a stage's cache.
public struct FlushStageCacheInput: Swift.Equatable {
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The name of the stage to flush its cache.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct FlushStageCacheInputBody: Swift.Equatable {
}

extension FlushStageCacheInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension FlushStageCacheOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FlushStageCacheOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FlushStageCacheOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FlushStageCacheOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct FlushStageCacheOutputResponse: Swift.Equatable {

}

extension ApiGatewayClientTypes.GatewayResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defaultResponse != false {
            try encodeContainer.encode(defaultResponse, forKey: .defaultResponse)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtostring0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, mapofstringtostring0) in responseTemplates {
                try responseTemplatesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseType = responseType {
            try encodeContainer.encode(responseType.rawValue, forKey: .responseType)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultResponse)
        defaultResponse = defaultResponseDecoded
    }
}

extension ApiGatewayClientTypes {
    /// A gateway response of a given response type and status code, with optional response parameters and mapping templates. For more information about valid gateway response types, see [Gateway Response Types Supported by API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html)
    /// Example: Get a Gateway Response of a given response type
    ///
    ///
    /// Request
    ///
    /// This example shows how to get a gateway response of the MISSING_AUTHENTICATION_TOKEN type. GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1 Host: beta-apigateway.us-east-1.amazonaws.com Content-Type: application/json X-Amz-Date: 20170503T202516Z Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a Cache-Control: no-cache Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45  The response type is specified as a URL path.
    /// Response
    ///
    /// The successful operation returns the 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html", "name": "gatewayresponse", "templated": true }, "self": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:delete": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" } }, "defaultResponse": false, "responseParameters": { "gatewayresponse.header.x-request-path": "method.request.path.petId", "gatewayresponse.header.Access-Control-Allow-Origin": "'a.b.c'", "gatewayresponse.header.x-request-query": "method.request.querystring.q", "gatewayresponse.header.x-request-header": "method.request.header.Accept" }, "responseTemplates": { "application/json": "{\n \"message\": $context.error.messageString,\n \"type\": \"$context.error.responseType\",\n \"stage\": \"$context.stage\",\n \"resourcePath\": \"$context.resourcePath\",\n \"stageVariables.a\": \"$stageVariables.a\",\n \"statusCode\": \"'404'\"\n}" }, "responseType": "MISSING_AUTHENTICATION_TOKEN", "statusCode": "404" }[Customize Gateway Responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html)
    public struct GatewayResponse: Swift.Equatable {
        /// A Boolean flag to indicate whether this [GatewayResponse] is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
        public var defaultResponse: Swift.Bool
        /// Response parameters (paths, query strings and headers) of the [GatewayResponse] as a string-to-string map of key-value pairs.
        public var responseParameters: [Swift.String:Swift.String]?
        /// Response templates of the [GatewayResponse] as a string-to-string map of key-value pairs.
        public var responseTemplates: [Swift.String:Swift.String]?
        /// The response type of the associated [GatewayResponse].
        public var responseType: ApiGatewayClientTypes.GatewayResponseType?
        /// The HTTP status code for this [GatewayResponse].
        public var statusCode: Swift.String?

        public init (
            defaultResponse: Swift.Bool = false,
            responseParameters: [Swift.String:Swift.String]? = nil,
            responseTemplates: [Swift.String:Swift.String]? = nil,
            responseType: ApiGatewayClientTypes.GatewayResponseType? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.defaultResponse = defaultResponse
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.responseType = responseType
            self.statusCode = statusCode
        }
    }

}

extension ApiGatewayClientTypes {
    public enum GatewayResponseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case apiConfigurationError
        case authorizerConfigurationError
        case authorizerFailure
        case badRequestBody
        case badRequestParameters
        case default4xx
        case default5xx
        case expiredToken
        case integrationFailure
        case integrationTimeout
        case invalidApiKey
        case invalidSignature
        case missingAuthenticationToken
        case quotaExceeded
        case requestTooLarge
        case resourceNotFound
        case throttled
        case unauthorized
        case unsupportedMediaType
        case wafFiltered
        case sdkUnknown(Swift.String)

        public static var allCases: [GatewayResponseType] {
            return [
                .accessDenied,
                .apiConfigurationError,
                .authorizerConfigurationError,
                .authorizerFailure,
                .badRequestBody,
                .badRequestParameters,
                .default4xx,
                .default5xx,
                .expiredToken,
                .integrationFailure,
                .integrationTimeout,
                .invalidApiKey,
                .invalidSignature,
                .missingAuthenticationToken,
                .quotaExceeded,
                .requestTooLarge,
                .resourceNotFound,
                .throttled,
                .unauthorized,
                .unsupportedMediaType,
                .wafFiltered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .apiConfigurationError: return "API_CONFIGURATION_ERROR"
            case .authorizerConfigurationError: return "AUTHORIZER_CONFIGURATION_ERROR"
            case .authorizerFailure: return "AUTHORIZER_FAILURE"
            case .badRequestBody: return "BAD_REQUEST_BODY"
            case .badRequestParameters: return "BAD_REQUEST_PARAMETERS"
            case .default4xx: return "DEFAULT_4XX"
            case .default5xx: return "DEFAULT_5XX"
            case .expiredToken: return "EXPIRED_TOKEN"
            case .integrationFailure: return "INTEGRATION_FAILURE"
            case .integrationTimeout: return "INTEGRATION_TIMEOUT"
            case .invalidApiKey: return "INVALID_API_KEY"
            case .invalidSignature: return "INVALID_SIGNATURE"
            case .missingAuthenticationToken: return "MISSING_AUTHENTICATION_TOKEN"
            case .quotaExceeded: return "QUOTA_EXCEEDED"
            case .requestTooLarge: return "REQUEST_TOO_LARGE"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .throttled: return "THROTTLED"
            case .unauthorized: return "UNAUTHORIZED"
            case .unsupportedMediaType: return "UNSUPPORTED_MEDIA_TYPE"
            case .wafFiltered: return "WAF_FILTERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GatewayResponseType(rawValue: rawValue) ?? GatewayResponseType.sdkUnknown(rawValue)
        }
    }
}

extension GenerateClientCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GenerateClientCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/clientcertificates"
    }
}

/// A request to generate a [ClientCertificate] resource.
public struct GenerateClientCertificateInput: Swift.Equatable {
    /// The description of the [ClientCertificate].
    public var description: Swift.String?
    /// The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

struct GenerateClientCertificateInputBody: Swift.Equatable {
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GenerateClientCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GenerateClientCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GenerateClientCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GenerateClientCertificateOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GenerateClientCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GenerateClientCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint. Client certificates are used to authenticate an API by the backend server. To authenticate an API client (or user), use IAM roles and policies, a custom [Authorizer] or an Amazon Cognito user pool. [Use Client-Side Certificate](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html)
public struct GenerateClientCertificateOutputResponse: Swift.Equatable {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: ClientRuntime.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct GenerateClientCertificateOutputResponseBody: Swift.Equatable {
    let clientCertificateId: Swift.String?
    let description: Swift.String?
    let pemEncodedCertificate: Swift.String?
    let createdDate: ClientRuntime.Date?
    let expirationDate: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GenerateClientCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account"
    }
}

/// Requests API Gateway to get information about the current [Account] resource.
public struct GetAccountInput: Swift.Equatable {

}

struct GetAccountInputBody: Swift.Equatable {
}

extension GetAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyVersion = output.apiKeyVersion
            self.cloudwatchRoleArn = output.cloudwatchRoleArn
            self.features = output.features
            self.throttleSettings = output.throttleSettings
        } else {
            self.apiKeyVersion = nil
            self.cloudwatchRoleArn = nil
            self.features = nil
            self.throttleSettings = nil
        }
    }
}

/// Represents an AWS account that is associated with API Gateway. To view the account info, call GET on this resource.
/// Error Codes
///
/// The following exception may be thrown when the request fails.
///
/// * UnauthorizedException
///
/// * NotFoundException
///
/// * TooManyRequestsException
///
///
/// For detailed error code information, including the corresponding HTTP Status Codes, see [API Gateway Error Codes](https://docs.aws.amazon.com/apigateway/api-reference/handling-errors/#api-error-codes)
/// Example: Get the information about an account.
///
///
/// Request
///
///
///     GET /account HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160531T184618Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
///
///
/// Response
///
/// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/account-apigateway-{rel}.html", "name": "account", "templated": true }, "self": { "href": "/account" }, "account:update": { "href": "/account" } }, "cloudwatchRoleArn": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "throttleSettings": { "rateLimit": 500, "burstLimit": 1000 } }  In addition to making the REST API call directly, you can use the AWS CLI and an AWS SDK to access this resource. [API Gateway Limits](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-limits.html)[Developer Guide](https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html), [AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-account.html)
public struct GetAccountOutputResponse: Swift.Equatable {
    /// The version of the API keys used for the account.
    public var apiKeyVersion: Swift.String?
    /// The ARN of an Amazon CloudWatch role for the current [Account].
    public var cloudwatchRoleArn: Swift.String?
    /// A list of features supported for the account. When usage plans are enabled, the features list will include an entry of "UsagePlans".
    public var features: [Swift.String]?
    /// Specifies the API request limits configured for the current [Account].
    public var throttleSettings: ApiGatewayClientTypes.ThrottleSettings?

    public init (
        apiKeyVersion: Swift.String? = nil,
        cloudwatchRoleArn: Swift.String? = nil,
        features: [Swift.String]? = nil,
        throttleSettings: ApiGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiKeyVersion = apiKeyVersion
        self.cloudwatchRoleArn = cloudwatchRoleArn
        self.features = features
        self.throttleSettings = throttleSettings
    }
}

struct GetAccountOutputResponseBody: Swift.Equatable {
    let cloudwatchRoleArn: Swift.String?
    let throttleSettings: ApiGatewayClientTypes.ThrottleSettings?
    let features: [Swift.String]?
    let apiKeyVersion: Swift.String?
}

extension GetAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyVersion
        case cloudwatchRoleArn
        case features
        case throttleSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudwatchRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudwatchRoleArn)
        cloudwatchRoleArn = cloudwatchRoleArnDecoded
        let throttleSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ThrottleSettings.self, forKey: .throttleSettings)
        throttleSettings = throttleSettingsDecoded
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .features)
        var featuresDecoded0:[Swift.String]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String]()
            for string0 in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?.append(string0)
                }
            }
        }
        features = featuresDecoded0
        let apiKeyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyVersion)
        apiKeyVersion = apiKeyVersionDecoded
    }
}

extension GetApiKeyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let includeValue = includeValue {
            let includeValueQueryItem = ClientRuntime.URLQueryItem(name: "includeValue".urlPercentEncoding(), value: Swift.String(includeValue).urlPercentEncoding())
            items.append(includeValueQueryItem)
        }
        return items
    }
}

extension GetApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiKey = apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

/// A request to get information about the current [ApiKey] resource.
public struct GetApiKeyInput: Swift.Equatable {
    /// [Required] The identifier of the [ApiKey] resource.
    /// This member is required.
    public var apiKey: Swift.String?
    /// A boolean flag to specify whether (true) or not (false) the result contains the key value.
    public var includeValue: Swift.Bool?

    public init (
        apiKey: Swift.String? = nil,
        includeValue: Swift.Bool? = nil
    )
    {
        self.apiKey = apiKey
        self.includeValue = includeValue
    }
}

struct GetApiKeyInputBody: Swift.Equatable {
}

extension GetApiKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// A resource that can be distributed to callers for executing [Method] resources that require an API key. API keys can be mapped to any [Stage] on any [RestApi], which indicates that the callers with the API key can make requests to that stage. [Use API Keys](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html)
public struct GetApiKeyOutputResponse: Swift.Equatable {
    /// The timestamp when the API Key was created.
    public var createdDate: ClientRuntime.Date?
    /// An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of [Stage] resources that are associated with the [ApiKey] resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct GetApiKeyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
    let customerId: Swift.String?
    let description: Swift.String?
    let enabled: Swift.Bool
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
    let stageKeys: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension GetApiKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[Swift.String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [Swift.String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetApiKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let includeValues = includeValues {
            let includeValuesQueryItem = ClientRuntime.URLQueryItem(name: "includeValues".urlPercentEncoding(), value: Swift.String(includeValues).urlPercentEncoding())
            items.append(includeValuesQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let customerId = customerId {
            let customerIdQueryItem = ClientRuntime.URLQueryItem(name: "customerId".urlPercentEncoding(), value: Swift.String(customerId).urlPercentEncoding())
            items.append(customerIdQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let nameQuery = nameQuery {
            let nameQueryQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
            items.append(nameQueryQueryItem)
        }
        return items
    }
}

extension GetApiKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/apikeys"
    }
}

/// A request to get information about the current [ApiKeys] resource.
public struct GetApiKeysInput: Swift.Equatable {
    /// The identifier of a customer in AWS Marketplace or an external system, such as a developer portal.
    public var customerId: Swift.String?
    /// A boolean flag to specify whether (true) or not (false) the result contains key values.
    public var includeValues: Swift.Bool?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The name of queried API keys.
    public var nameQuery: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        customerId: Swift.String? = nil,
        includeValues: Swift.Bool? = nil,
        limit: Swift.Int? = nil,
        nameQuery: Swift.String? = nil,
        position: Swift.String? = nil
    )
    {
        self.customerId = customerId
        self.includeValues = includeValues
        self.limit = limit
        self.nameQuery = nameQuery
        self.position = position
    }
}

struct GetApiKeysInputBody: Swift.Equatable {
}

extension GetApiKeysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApiKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApiKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApiKeysOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApiKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApiKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.warnings = output.warnings
        } else {
            self.items = nil
            self.warnings = nil
        }
        self.position = nil
    }
}

/// Represents a collection of API keys as represented by an [ApiKeys] resource. [Use API Keys](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html)
public struct GetApiKeysOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.ApiKey]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// A list of warning messages logged during the import of API keys when the failOnWarnings option is set to true.
    public var warnings: [Swift.String]?

    public init (
        items: [ApiGatewayClientTypes.ApiKey]? = nil,
        position: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.items = items
        self.position = position
        self.warnings = warnings
    }
}

struct GetApiKeysOutputResponseBody: Swift.Equatable {
    let warnings: [Swift.String]?
    let items: [ApiGatewayClientTypes.ApiKey]?
}

extension GetApiKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
        case warnings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.ApiKey?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.ApiKey]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.ApiKey]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Request to describe an existing [Authorizer] resource.
public struct GetAuthorizerInput: Swift.Equatable {
    /// [Required] The identifier of the [Authorizer] resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        authorizerId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.restApiId = restApiId
    }
}

struct GetAuthorizerInputBody: Swift.Equatable {
}

extension GetAuthorizerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method. [Use Lambda Function as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html)[Use Cognito User Pool as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html)
public struct GetAuthorizerOutputResponse: Swift.Equatable {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested.
    ///
    /// * For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth.
    ///
    /// * For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// [Required] The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: ApiGatewayClientTypes.AuthorizerType?

    public init (
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: ApiGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct GetAuthorizerOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let type: ApiGatewayClientTypes.AuthorizerType?
    let providerARNs: [Swift.String]?
    let authType: Swift.String?
    let authorizerUri: Swift.String?
    let authorizerCredentials: Swift.String?
    let identitySource: Swift.String?
    let identityValidationExpression: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
}

extension GetAuthorizerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension GetAuthorizersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetAuthorizersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers"
    }
}

/// Request to describe an existing [Authorizers] resource.
public struct GetAuthorizersInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetAuthorizersInputBody: Swift.Equatable {
}

extension GetAuthorizersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAuthorizersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of [Authorizer] resources. [Use Lambda Function as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html)[Use Cognito User Pool as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html)
public struct GetAuthorizersOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.Authorizer]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.Authorizer]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetAuthorizersOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.Authorizer]?
}

extension GetAuthorizersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.Authorizer?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.Authorizer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.Authorizer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetBasePathMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let basePath = basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

/// Request to describe a [BasePathMapping] resource.
public struct GetBasePathMappingInput: Swift.Equatable {
    /// [Required] The base path name that callers of the API must provide as part of the URL after the domain name. This value must be unique for all of the mappings across a single API. Specify '(none)' if you do not want callers to specify any base path name after the domain name.
    /// This member is required.
    public var basePath: Swift.String?
    /// [Required] The domain name of the [BasePathMapping] resource to be described.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
    }
}

struct GetBasePathMappingInputBody: Swift.Equatable {
}

extension GetBasePathMappingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBasePathMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBasePathMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBasePathMappingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBasePathMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBasePathMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name. A custom domain name plus a BasePathMapping specification identifies a deployed [RestApi] in a given stage of the owner [Account]. [Use Custom Domain Names](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
public struct GetBasePathMappingOutputResponse: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated [RestApi].
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init (
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct GetBasePathMappingOutputResponseBody: Swift.Equatable {
    let basePath: Swift.String?
    let restApiId: Swift.String?
    let stage: Swift.String?
}

extension GetBasePathMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension GetBasePathMappingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetBasePathMappingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings"
    }
}

/// A request to get information about a collection of [BasePathMapping] resources.
public struct GetBasePathMappingsInput: Swift.Equatable {
    /// [Required] The domain name of a [BasePathMapping] resource.
    /// This member is required.
    public var domainName: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.limit = limit
        self.position = position
    }
}

struct GetBasePathMappingsInputBody: Swift.Equatable {
}

extension GetBasePathMappingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetBasePathMappingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBasePathMappingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBasePathMappingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBasePathMappingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetBasePathMappingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of [BasePathMapping] resources. [Use Custom Domain Names](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
public struct GetBasePathMappingsOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.BasePathMapping]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.BasePathMapping]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetBasePathMappingsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.BasePathMapping]?
}

extension GetBasePathMappingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.BasePathMapping?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.BasePathMapping]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.BasePathMapping]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetClientCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clientCertificateId = clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

/// A request to get information about the current [ClientCertificate] resource.
public struct GetClientCertificateInput: Swift.Equatable {
    /// [Required] The identifier of the [ClientCertificate] resource to be described.
    /// This member is required.
    public var clientCertificateId: Swift.String?

    public init (
        clientCertificateId: Swift.String? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
    }
}

struct GetClientCertificateInputBody: Swift.Equatable {
}

extension GetClientCertificateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetClientCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetClientCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClientCertificateOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClientCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetClientCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint. Client certificates are used to authenticate an API by the backend server. To authenticate an API client (or user), use IAM roles and policies, a custom [Authorizer] or an Amazon Cognito user pool. [Use Client-Side Certificate](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html)
public struct GetClientCertificateOutputResponse: Swift.Equatable {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: ClientRuntime.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct GetClientCertificateOutputResponseBody: Swift.Equatable {
    let clientCertificateId: Swift.String?
    let description: Swift.String?
    let pemEncodedCertificate: Swift.String?
    let createdDate: ClientRuntime.Date?
    let expirationDate: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetClientCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetClientCertificatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetClientCertificatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/clientcertificates"
    }
}

/// A request to get information about a collection of [ClientCertificate] resources.
public struct GetClientCertificatesInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetClientCertificatesInputBody: Swift.Equatable {
}

extension GetClientCertificatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetClientCertificatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetClientCertificatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetClientCertificatesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetClientCertificatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetClientCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of [ClientCertificate] resources. [Use Client-Side Certificate](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html)
public struct GetClientCertificatesOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.ClientCertificate]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.ClientCertificate]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetClientCertificatesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.ClientCertificate]?
}

extension GetClientCertificatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.ClientCertificate?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.ClientCertificate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.ClientCertificate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetDeploymentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let embed = embed {
            embed.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

/// Requests API Gateway to get information about a [Deployment] resource.
public struct GetDeploymentInput: Swift.Equatable {
    /// [Required] The identifier of the [Deployment] resource to get information about.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// A query parameter to retrieve the specified embedded resources of the returned [Deployment] resource in the response. In a REST API call, this embed parameter value is a list of comma-separated strings, as in GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=var1,var2. The SDK and other platform-dependent libraries might use a different format for the list. Currently, this request supports only retrieval of the embedded API summary this way. Hence, the parameter value must be a single-valued list containing only the "apisummary" string. For example, GET /restapis/{restapi_id}/deployments/{deployment_id}?embed=apisummary.
    public var embed: [Swift.String]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil,
        embed: [Swift.String]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.embed = embed
        self.restApiId = restApiId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// An immutable representation of a [RestApi] resource that can be called by users using [Stages]. A deployment must be associated with a [Stage] for it to be callable over the Internet. To create a deployment, call POST on the [Deployments] resource of a [RestApi]. To view, update, or delete a deployment, call GET, PATCH, or DELETE on the specified deployment resource (/restapis/{restapi_id}/deployments/{deployment_id}). [RestApi], [Deployments], [Stage], [AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html), [AWS SDKs](https://aws.amazon.com/tools/)
public struct GetDeploymentOutputResponse: Swift.Equatable {
    /// A summary of the [RestApi] at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init (
        apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct GetDeploymentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]?
}

extension GetDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: ApiGatewayClientTypes.MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [Swift.String: ApiGatewayClientTypes.MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [Swift.String: ApiGatewayClientTypes.MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

extension GetDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments"
    }
}

/// Requests API Gateway to get information about a [Deployments] collection.
public struct GetDeploymentsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetDeploymentsInputBody: Swift.Equatable {
}

extension GetDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection resource that contains zero or more references to your existing deployments, and links that guide you on how to interact with your collection. The collection offers a paginated view of the contained deployments. To create a new deployment of a [RestApi], make a POST request against this resource. To view, update, or delete an existing deployment, make a GET, PATCH, or DELETE request, respectively, on a specified [Deployment] resource. [Deploying an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html), [AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html), [AWS SDKs](https://aws.amazon.com/tools/)
public struct GetDeploymentsOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.Deployment]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.Deployment]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDeploymentsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.Deployment]?
}

extension GetDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.Deployment?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.Deployment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.Deployment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetDocumentationPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationPartId = documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

/// Gets a specified documentation part of a given API.
public struct GetDocumentationPartInput: Swift.Equatable {
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        documentationPartId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.restApiId = restApiId
    }
}

struct GetDocumentationPartInputBody: Swift.Equatable {
}

extension GetDocumentationPartInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentationPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentationPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentationPartOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentationPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentationPartOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// A documentation part for a targeted API entity. A documentation part consists of a content map (properties) and a target (location). The target specifies an API entity to which the documentation content applies. The supported API entity types are API, AUTHORIZER, MODEL, RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. Valid location fields depend on the API entity type. All valid fields are not required. The content map is a JSON string of API-specific key-value pairs. Although an API can use any shape for the content map, only the OpenAPI-compliant documentation fields will be injected into the associated API entity definition in the exported OpenAPI definition file. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationParts]
public struct GetDocumentationPartOutputResponse: Swift.Equatable {
    /// The [DocumentationPart] identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: ApiGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init (
        id: Swift.String? = nil,
        location: ApiGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct GetDocumentationPartOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let location: ApiGatewayClientTypes.DocumentationPartLocation?
    let properties: Swift.String?
}

extension GetDocumentationPartOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case location
        case properties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension GetDocumentationPartsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let locationStatus = locationStatus {
            let locationStatusQueryItem = ClientRuntime.URLQueryItem(name: "locationStatus".urlPercentEncoding(), value: Swift.String(locationStatus.rawValue).urlPercentEncoding())
            items.append(locationStatusQueryItem)
        }
        if let path = path {
            let pathQueryItem = ClientRuntime.URLQueryItem(name: "path".urlPercentEncoding(), value: Swift.String(path).urlPercentEncoding())
            items.append(pathQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let nameQuery = nameQuery {
            let nameQueryQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
            items.append(nameQueryQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        return items
    }
}

extension GetDocumentationPartsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

/// Gets the documentation parts of an API. The result may be filtered by the type, name, or path of API entities (targets).
public struct GetDocumentationPartsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The status of the API documentation parts to retrieve. Valid values are DOCUMENTED for retrieving [DocumentationPart] resources with content and UNDOCUMENTED for [DocumentationPart] resources without content.
    public var locationStatus: ApiGatewayClientTypes.LocationStatusType?
    /// The name of API entities of the to-be-retrieved documentation parts.
    public var nameQuery: Swift.String?
    /// The path of API entities of the to-be-retrieved documentation parts.
    public var path: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// The type of API entities of the to-be-retrieved documentation parts.
    public var type: ApiGatewayClientTypes.DocumentationPartType?

    public init (
        limit: Swift.Int? = nil,
        locationStatus: ApiGatewayClientTypes.LocationStatusType? = nil,
        nameQuery: Swift.String? = nil,
        path: Swift.String? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        type: ApiGatewayClientTypes.DocumentationPartType? = nil
    )
    {
        self.limit = limit
        self.locationStatus = locationStatus
        self.nameQuery = nameQuery
        self.path = path
        self.position = position
        self.restApiId = restApiId
        self.type = type
    }
}

struct GetDocumentationPartsInputBody: Swift.Equatable {
}

extension GetDocumentationPartsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentationPartsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentationPartsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentationPartsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentationPartsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentationPartsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// The collection of documentation parts of an API. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationPart]
public struct GetDocumentationPartsOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.DocumentationPart]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.DocumentationPart]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDocumentationPartsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.DocumentationPart]?
}

extension GetDocumentationPartsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.DocumentationPart?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.DocumentationPart]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.DocumentationPart]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetDocumentationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationVersion = documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

/// Gets a documentation snapshot of an API.
public struct GetDocumentationVersionInput: Swift.Equatable {
    /// [Required] The version identifier of the to-be-retrieved documentation snapshot.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        documentationVersion: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.restApiId = restApiId
    }
}

struct GetDocumentationVersionInputBody: Swift.Equatable {
}

extension GetDocumentationVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentationVersionOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// A snapshot of the documentation of an API. Publishing API documentation involves creating a documentation version associated with an API stage and exporting the versioned documentation to an external (e.g., OpenAPI) file. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationPart], [DocumentationVersions]
public struct GetDocumentationVersionOutputResponse: Swift.Equatable {
    /// The date when the API documentation snapshot is created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct GetDocumentationVersionOutputResponseBody: Swift.Equatable {
    let version: Swift.String?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
}

extension GetDocumentationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetDocumentationVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetDocumentationVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions"
    }
}

/// Gets the documentation versions of an API.
public struct GetDocumentationVersionsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetDocumentationVersionsInputBody: Swift.Equatable {
}

extension GetDocumentationVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDocumentationVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDocumentationVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDocumentationVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDocumentationVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDocumentationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// The collection of documentation snapshots of an API. Use the [DocumentationVersions] to manage documentation snapshots associated with various API stages. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationPart], [DocumentationVersion]
public struct GetDocumentationVersionsOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.DocumentationVersion]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.DocumentationVersion]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDocumentationVersionsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.DocumentationVersion]?
}

extension GetDocumentationVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.DocumentationVersion?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.DocumentationVersion]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.DocumentationVersion]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

/// Request to get the name of a [DomainName] resource.
public struct GetDomainNameInput: Swift.Equatable {
    /// [Required] The name of the [DomainName] resource.
    /// This member is required.
    public var domainName: Swift.String?

    public init (
        domainName: Swift.String? = nil
    )
    {
        self.domainName = domainName
    }
}

struct GetDomainNameInputBody: Swift.Equatable {
}

extension GetDomainNameInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNameOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = output.ownershipVerificationCertificateArn
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.ownershipVerificationCertificateArn = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// Represents a custom domain name as a user-friendly host name of an API ([RestApi]). When you deploy an API, API Gateway creates a default host name for the API. This default API host name is of the {restapi-id}.execute-api.{region}.amazonaws.com format. With the default host name, you can access the API's root resource with the URL of https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/. When you set up a custom domain name of apis.example.com for this API, you can then access the same resource using the URL of the https://apis.examples.com/myApi, where myApi is the base path mapping ([BasePathMapping]) of your API under the custom domain name. [Set a Custom Host Name for an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
public struct GetDomainNameOutputResponse: Swift.Equatable {
    /// The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
    public var certificateUploadDate: ClientRuntime.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the [Amazon CloudFront documentation](https://aws.amazon.com/documentation/cloudfront/).
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see [Set up a Regional Custom Domain Name](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) and [AWS Regions and Endpoints for API Gateway](https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the [DomainName] migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: ApiGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the [DomainName] migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this [DomainName] showing the endpoint types of the domain name.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see [Set up a Regional Custom Domain Name](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) and [AWS Regions and Endpoints for API Gateway](https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this [DomainName]. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: ClientRuntime.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: ApiGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: ApiGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct GetDomainNameOutputResponseBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateName: Swift.String?
    let certificateArn: Swift.String?
    let certificateUploadDate: ClientRuntime.Date?
    let regionalDomainName: Swift.String?
    let regionalHostedZoneId: Swift.String?
    let regionalCertificateName: Swift.String?
    let regionalCertificateArn: Swift.String?
    let distributionDomainName: Swift.String?
    let distributionHostedZoneId: Swift.String?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let domainNameStatus: ApiGatewayClientTypes.DomainNameStatus?
    let domainNameStatusMessage: Swift.String?
    let securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
    let tags: [Swift.String:Swift.String]?
    let mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication?
    let ownershipVerificationCertificateArn: Swift.String?
}

extension GetDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension GetDomainNamesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetDomainNamesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/domainnames"
    }
}

/// Request to describe a collection of [DomainName] resources.
public struct GetDomainNamesInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetDomainNamesInputBody: Swift.Equatable {
}

extension GetDomainNamesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainNamesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDomainNamesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDomainNamesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDomainNamesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDomainNamesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of [DomainName] resources. [Use Client-Side Certificate](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
public struct GetDomainNamesOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.DomainName]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.DomainName]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetDomainNamesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.DomainName]?
}

extension GetDomainNamesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.DomainName?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.DomainName]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.DomainName]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetExportInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accepts = accepts {
            items.add(Header(name: "Accept", value: Swift.String(accepts)))
        }
        return items
    }
}

extension GetExportInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let parameters = parameters {
            let currentQueryItemNames = items.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension GetExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let exportType = exportType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/exports/\(exportType.urlPercentEncoding())"
    }
}

/// Request a new export of a [RestApi] for a particular [Stage].
public struct GetExportInput: Swift.Equatable {
    /// The content-type of the export, for example application/json. Currently application/json and application/yaml are supported for exportType ofoas30 and swagger. This should be specified in the Accept header for direct API requests.
    public var accepts: Swift.String?
    /// [Required] The type of export. Acceptable values are 'oas30' for OpenAPI 3.0.x and 'swagger' for Swagger/OpenAPI 2.0.
    /// This member is required.
    public var exportType: Swift.String?
    /// A key-value map of query string parameters that specify properties of the export, depending on the requested exportType. For exportTypeoas30 and swagger, any combination of the following parameters are supported: extensions='integrations' or extensions='apigateway' will export the API with x-amazon-apigateway-integration extensions. extensions='authorizers' will export the API with x-amazon-apigateway-authorizer extensions. postman will export the API with Postman extensions, allowing for import to the Postman tool
    public var parameters: [Swift.String:Swift.String]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The name of the [Stage] that will be exported.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        accepts: Swift.String? = nil,
        exportType: Swift.String? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.accepts = accepts
        self.exportType = exportType
        self.parameters = parameters
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct GetExportInputBody: Swift.Equatable {
}

extension GetExportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExportOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.body = data
        } else {
            self.body = nil
        }
    }
}

/// The binary blob response to [GetExport], which contains the generated SDK.
public struct GetExportOutputResponse: Swift.Equatable {
    /// The binary blob response to [GetExport], which contains the export.
    public var body: ClientRuntime.Data?
    /// The content-disposition header value in the HTTP response.
    public var contentDisposition: Swift.String?
    /// The content-type header value in the HTTP response. This will correspond to a valid 'accept' type in the request.
    public var contentType: Swift.String?

    public init (
        body: ClientRuntime.Data? = nil,
        contentDisposition: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentDisposition = contentDisposition
        self.contentType = contentType
    }
}

struct GetExportOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension GetExportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension GetGatewayResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let responseType = responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

/// Gets a [GatewayResponse] of a specified response type on the given [RestApi].
public struct GetGatewayResponseInput: Swift.Equatable {
    /// [Required] The response type of the associated [GatewayResponse].
    /// This member is required.
    public var responseType: ApiGatewayClientTypes.GatewayResponseType?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        responseType: ApiGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct GetGatewayResponseInputBody: Swift.Equatable {
}

extension GetGatewayResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGatewayResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGatewayResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGatewayResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates. For more information about valid gateway response types, see [Gateway Response Types Supported by API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html)
/// Example: Get a Gateway Response of a given response type
///
///
/// Request
///
/// This example shows how to get a gateway response of the MISSING_AUTHENTICATION_TOKEN type. GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1 Host: beta-apigateway.us-east-1.amazonaws.com Content-Type: application/json X-Amz-Date: 20170503T202516Z Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a Cache-Control: no-cache Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45  The response type is specified as a URL path.
/// Response
///
/// The successful operation returns the 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html", "name": "gatewayresponse", "templated": true }, "self": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:delete": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" } }, "defaultResponse": false, "responseParameters": { "gatewayresponse.header.x-request-path": "method.request.path.petId", "gatewayresponse.header.Access-Control-Allow-Origin": "'a.b.c'", "gatewayresponse.header.x-request-query": "method.request.querystring.q", "gatewayresponse.header.x-request-header": "method.request.header.Accept" }, "responseTemplates": { "application/json": "{\n \"message\": $context.error.messageString,\n \"type\": \"$context.error.responseType\",\n \"stage\": \"$context.stage\",\n \"resourcePath\": \"$context.resourcePath\",\n \"stageVariables.a\": \"$stageVariables.a\",\n \"statusCode\": \"'404'\"\n}" }, "responseType": "MISSING_AUTHENTICATION_TOKEN", "statusCode": "404" }[Customize Gateway Responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html)
public struct GetGatewayResponseOutputResponse: Swift.Equatable {
    /// A Boolean flag to indicate whether this [GatewayResponse] is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the [GatewayResponse] as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Response templates of the [GatewayResponse] as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The response type of the associated [GatewayResponse].
    public var responseType: ApiGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this [GatewayResponse].
    public var statusCode: Swift.String?

    public init (
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        responseType: ApiGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct GetGatewayResponseOutputResponseBody: Swift.Equatable {
    let responseType: ApiGatewayClientTypes.GatewayResponseType?
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let defaultResponse: Swift.Bool
}

extension GetGatewayResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultResponse)
        defaultResponse = defaultResponseDecoded
    }
}

extension GetGatewayResponsesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetGatewayResponsesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses"
    }
}

/// Gets the [GatewayResponses] collection on the given [RestApi]. If an API developer has not added any definitions for gateway responses, the result will be the API Gateway-generated default [GatewayResponses] collection for the supported response types.
public struct GetGatewayResponsesInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500. The [GatewayResponses] collection does not support pagination and the limit does not apply here.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set. The [GatewayResponse] collection does not support pagination and the position does not apply here.
    public var position: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetGatewayResponsesInputBody: Swift.Equatable {
}

extension GetGatewayResponsesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGatewayResponsesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayResponsesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGatewayResponsesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayResponsesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGatewayResponsesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// The collection of the [GatewayResponse] instances of a [RestApi] as a responseType-to-[GatewayResponse] object map of key-value pairs. As such, pagination is not supported for querying this collection. For more information about valid gateway response types, see [Gateway Response Types Supported by API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html)
/// Example: Get the collection of gateway responses of an API
///
///
/// Request
///
/// This example request shows how to retrieve the [GatewayResponses] collection from an API. GET /restapis/o81lxisefl/gatewayresponses HTTP/1.1 Host: beta-apigateway.us-east-1.amazonaws.com Content-Type: application/json X-Amz-Date: 20170503T220604Z Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=59b42fe54a76a5de8adf2c67baa6d39206f8e9ad49a1d77ccc6a5da3103a398a Cache-Control: no-cache Postman-Token: 5637af27-dc29-fc5c-9dfe-0645d52cb515
/// Response
///
/// The successful operation returns the 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html", "name": "gatewayresponse", "templated": true }, "self": { "href": "/restapis/o81lxisefl/gatewayresponses" }, "first": { "href": "/restapis/o81lxisefl/gatewayresponses" }, "gatewayresponse:by-type": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "item": [ { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE" }, { "href": "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND" }, { "href": "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE" }, { "href": "/restapis/o81lxisefl/gatewayresponses/THROTTLED" }, { "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE" }, { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR" }, { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX" }, { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX" }, { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS" }, { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY" }, { "href": "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN" }, { "href": "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED" }, { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY" }, { "href": "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED" }, { "href": "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR" }, { "href": "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED" }, { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT" }, { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE" }, { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE" } ] }, "_embedded": { "item": [ { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_FAILURE" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "INTEGRATION_FAILURE", "statusCode": "504" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/RESOURCE_NOT_FOUND" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "RESOURCE_NOT_FOUND", "statusCode": "404" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/REQUEST_TOO_LARGE" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "REQUEST_TOO_LARGE", "statusCode": "413" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/THROTTLED" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/THROTTLED" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "THROTTLED", "statusCode": "429" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/UNSUPPORTED_MEDIA_TYPE" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "UNSUPPORTED_MEDIA_TYPE", "statusCode": "415" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_CONFIGURATION_ERROR" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "AUTHORIZER_CONFIGURATION_ERROR", "statusCode": "500" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_5XX" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "DEFAULT_5XX" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/DEFAULT_4XX" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "DEFAULT_4XX" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_PARAMETERS" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "BAD_REQUEST_PARAMETERS", "statusCode": "400" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/BAD_REQUEST_BODY" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "BAD_REQUEST_BODY", "statusCode": "400" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/EXPIRED_TOKEN" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "EXPIRED_TOKEN", "statusCode": "403" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/ACCESS_DENIED" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "ACCESS_DENIED", "statusCode": "403" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_API_KEY" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "INVALID_API_KEY", "statusCode": "403" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/UNAUTHORIZED" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "UNAUTHORIZED", "statusCode": "401" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/API_CONFIGURATION_ERROR" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "API_CONFIGURATION_ERROR", "statusCode": "500" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/QUOTA_EXCEEDED" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "QUOTA_EXCEEDED", "statusCode": "429" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/INTEGRATION_TIMEOUT" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "INTEGRATION_TIMEOUT", "statusCode": "504" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "MISSING_AUTHENTICATION_TOKEN", "statusCode": "403" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/INVALID_SIGNATURE" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "INVALID_SIGNATURE", "statusCode": "403" }, { "_links": { "self": { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/AUTHORIZER_FAILURE" } }, "defaultResponse": true, "responseParameters": {}, "responseTemplates": { "application/json": "{\"message\":$context.error.messageString}" }, "responseType": "AUTHORIZER_FAILURE", "statusCode": "500" } ] } }[Customize Gateway Responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html)
public struct GetGatewayResponsesOutputResponse: Swift.Equatable {
    /// Returns the entire collection, because of no pagination support.
    public var items: [ApiGatewayClientTypes.GatewayResponse]?
    /// The current pagination position in the paged result set. The [GatewayResponse] collection does not support pagination and the position does not apply here.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.GatewayResponse]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetGatewayResponsesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.GatewayResponse]?
}

extension GetGatewayResponsesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.GatewayResponse?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.GatewayResponse]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.GatewayResponse]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

/// Represents a request to get the integration configuration.
public struct GetIntegrationInput: Swift.Equatable {
    /// [Required] Specifies a get integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] Specifies a get integration request's resource identifier
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetIntegrationInputBody: Swift.Equatable {
}

extension GetIntegrationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration. In the API Gateway console, the built-in Lambda integration is an AWS integration. [Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct GetIntegrationOutputResponse: Swift.Equatable {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for [Method]requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ([id](https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id)) of the [VpcLink] used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
    ///
    /// * CONVERT_TO_BINARY: Converts a request payload from a Base64-encoded string to the corresponding binary blob.
    ///
    /// * CONVERT_TO_TEXT: Converts a request payload from a binary blob to a Base64-encoded string.
    ///
    ///
    /// If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported AWS services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    /// Example: Get integration responses of a method
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160607T191449Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns 200 OK status and a payload as follows: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n" }, "statusCode": "200" }[Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
    public var integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following:
    ///
    /// * WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request.
    ///
    /// * WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response.
    ///
    /// * NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: ApiGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following:
    ///
    /// * AWS: for integrating the API method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration.
    ///
    /// * AWS_PROXY: for integrating the API method request with the Lambda function-invoking action with the client request passed through as-is. This integration is also referred to as the Lambda proxy integration.
    ///
    /// * HTTP: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC. This integration is also referred to as the HTTP custom integration.
    ///
    /// * HTTP_PROXY: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC, with the client request passed through as-is. This is also referred to as the HTTP proxy integration.
    ///
    /// * MOCK: for integrating the API method request with API Gateway as a "loop-back" endpoint without invoking any backend.
    ///
    ///
    /// For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a [VpcLink] to connect API Gateway to a network load balancer of a VPC.
    public var type: ApiGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
    ///
    /// * For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the [RFC-3986 specification](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier), for either standard integration, where connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For a private HTTP integration, the URI is not used for routing.
    ///
    /// * For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS service for fast host-name lookup. action can be used for an AWS service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an AWS service path-based API. The ensuing service_api refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of [GetObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html), the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init (
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayClientTypes.ConnectionType? = nil,
        contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: ApiGatewayClientTypes.TlsConfig? = nil,
        type: ApiGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct GetIntegrationOutputResponseBody: Swift.Equatable {
    let type: ApiGatewayClientTypes.IntegrationType?
    let httpMethod: Swift.String?
    let uri: Swift.String?
    let connectionType: ApiGatewayClientTypes.ConnectionType?
    let connectionId: Swift.String?
    let credentials: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let passthroughBehavior: Swift.String?
    let contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    let timeoutInMillis: Swift.Int
    let cacheNamespace: Swift.String?
    let cacheKeyParameters: [Swift.String]?
    let integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]?
    let tlsConfig: ApiGatewayClientTypes.TlsConfig?
}

extension GetIntegrationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [Swift.String:ApiGatewayClientTypes.IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension GetIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Represents a get integration response request.
public struct GetIntegrationResponseInput: Swift.Equatable {
    /// [Required] Specifies a get integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] Specifies a get integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] Specifies a get integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct GetIntegrationResponseInputBody: Swift.Equatable {
}

extension GetIntegrationResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIntegrationResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIntegrationResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIntegrationResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIntegrationResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// Represents an integration response. The status code must map to an existing [MethodResponse], and parameters and templates can be used to transform the back-end response. [Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct GetIntegrationResponseOutputResponse: Swift.Equatable {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
    ///
    /// * CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.
    ///
    /// * CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.
    ///
    ///
    /// If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing [MethodResponse].
    public var statusCode: Swift.String?

    public init (
        contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct GetIntegrationResponseOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.String?
    let selectionPattern: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
}

extension GetIntegrationResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension GetMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Request to describe an existing [Method] resource.
public struct GetMethodInput: Swift.Equatable {
    /// [Required] Specifies the method request's HTTP method type.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] The [Resource] identifier for the [Method] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetMethodInputBody: Swift.Equatable {
}

extension GetMethodInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMethodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMethodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMethodOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMethodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMethodOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an [Integration] resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an [Integration] resource. On the other hand, a method response is represented by a [MethodResponse] resource, whereas an integration response is represented by an [IntegrationResponse] resource.
/// Example: Retrive the GET method on a specified resource
///
///
/// Request
///
/// The following example request retrieves the information about the GET method on an API resource (3kzxbg5sa2) of an API (fugvjdxtri). GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160603T210259Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
/// Response
///
/// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html", "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET", "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}", "templated": true } }, "apiKeyRequired": true, "authorizationType": "NONE", "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type": "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")" }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" } } } In the example above, the response template for the 200 OK response maps the JSON output from the ListStreams action in the back end to an XML output. The mapping template is URL-encoded as %3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E and the output is decoded using the [$util.urlDecode()](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference) helper function. [MethodResponse], [Integration], [IntegrationResponse], [Resource], [Set up an API's method](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html)
public struct GetMethodOutputResponse: Swift.Equatable {
    /// A boolean flag specifying whether a valid [ApiKey] is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an [Authorizer] to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    /// Example:
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length: 117 X-Amz-Date: 20160613T213210Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true } ], "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integration:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integration:responses": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "0cjtch", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestTemplates": { "application/json": "{\n \"a\": \"$input.params('operand1')\",\n \"b\": \"$input.params('operand2')\", \n \"op\": \"$input.params('operator')\" \n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.operator": "integration.response.body.op", "method.response.header.operand_2": "integration.response.body.b", "method.response.header.operand_1": "integration.response.body.a" }, "responseTemplates": { "application/json": "#set($res = $input.path('$'))\n{\n \"result\": \"$res.a, $res.b, $res.op => $res.c\",\n \"a\" : \"$res.a\",\n \"b\" : \"$res.b\",\n \"op\" : \"$res.op\",\n \"c\" : \"$res.c\"\n}" }, "selectionPattern": "", "statusCode": "200" } } }[AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-integration.html)
    public var methodIntegration: ApiGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code. The collection of method responses are encapsulated in a key-value map, where the key is a response's HTTP status code and the value is a [MethodResponse] resource that specifies the response returned to the caller from the back end through the integration response.
    /// Example: Get a 200 OK response of a GET method
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length: 117 X-Amz-Date: 20160613T215008Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.operator": false, "method.response.header.operand_2": false, "method.response.header.operand_1": false }, "statusCode": "200" }[AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-method-response.html)
    public var methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by [Model] resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String:Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in [Integration] to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String:Swift.Bool]?
    /// The identifier of a [RequestValidator] for request validation.
    public var requestValidatorId: Swift.String?

    public init (
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: ApiGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct GetMethodOutputResponseBody: Swift.Equatable {
    let httpMethod: Swift.String?
    let authorizationType: Swift.String?
    let authorizerId: Swift.String?
    let apiKeyRequired: Swift.Bool?
    let requestValidatorId: Swift.String?
    let operationName: Swift.String?
    let requestParameters: [Swift.String:Swift.Bool]?
    let requestModels: [Swift.String:Swift.String]?
    let methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]?
    let methodIntegration: ApiGatewayClientTypes.Integration?
    let authorizationScopes: [Swift.String]?
}

extension GetMethodOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [Swift.String:ApiGatewayClientTypes.MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [Swift.String:ApiGatewayClientTypes.MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension GetMethodResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Request to describe a [MethodResponse] resource.
public struct GetMethodResponseInput: Swift.Equatable {
    /// [Required] The HTTP verb of the [Method] resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] The [Resource] identifier for the [MethodResponse] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The status code for the [MethodResponse] resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct GetMethodResponseInputBody: Swift.Equatable {
}

extension GetMethodResponseInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMethodResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMethodResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMethodResponseOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMethodResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMethodResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
/// Example: A MethodResponse instance of an API
///
///
/// Request
///
/// The example request retrieves a MethodResponse of the 200 status code. GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160603T222952Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
/// Response
///
/// The successful response returns 200 OK status and a payload as follows: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" }[Method], [IntegrationResponse], [Integration][Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct GetMethodResponseOutputResponse: Swift.Equatable {
    /// Specifies the [Model] resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a [Model] name as the value.
    public var responseModels: [Swift.String:Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's [IntegrationResponse]. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String:Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init (
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct GetMethodResponseOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.Bool]?
    let responseModels: [Swift.String:Swift.String]?
}

extension GetMethodResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension GetModelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if flatten != false {
            let flattenQueryItem = ClientRuntime.URLQueryItem(name: "flatten".urlPercentEncoding(), value: Swift.String(flatten).urlPercentEncoding())
            items.append(flattenQueryItem)
        }
        return items
    }
}

extension GetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let modelName = modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

/// Request to list information about a model in an existing [RestApi] resource.
public struct GetModelInput: Swift.Equatable {
    /// A query parameter of a Boolean value to resolve (true) all external model references and returns a flattened model schema or not (false) The default is false.
    public var flatten: Swift.Bool
    /// [Required] The name of the model as an identifier.
    /// This member is required.
    public var modelName: Swift.String?
    /// [Required] The [RestApi] identifier under which the [Model] exists.
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        flatten: Swift.Bool = false,
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.flatten = flatten
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct GetModelInputBody: Swift.Equatable {
}

extension GetModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// Represents the data structure of a method's request or response payload. A request model defines the data structure of the client-supplied request payload. A response model defines the data structure of the response payload returned by the back end. Although not required, models are useful for mapping payloads between the front end and back end. A model is used for generating an API's SDK, validating the input request body, and creating a skeletal mapping template. [Method], [MethodResponse], [Models and Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html)
public struct GetModelOutputResponse: Swift.Equatable {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be [JSON schema draft 4](https://tools.ietf.org/html/draft-zyp-json-schema-04) model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct GetModelOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let schema: Swift.String?
    let contentType: Swift.String?
}

extension GetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension GetModelTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let modelName = modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())/default_template"
    }
}

/// Request to generate a sample mapping template used to transform the payload.
public struct GetModelTemplateInput: Swift.Equatable {
    /// [Required] The name of the model for which to generate a template.
    /// This member is required.
    public var modelName: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        modelName: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.restApiId = restApiId
    }
}

struct GetModelTemplateInputBody: Swift.Equatable {
}

extension GetModelTemplateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetModelTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelTemplateOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetModelTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.value = output.value
        } else {
            self.value = nil
        }
    }
}

/// Represents a mapping template used to transform a payload. [Mapping Templates](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html#models-mappings-mappings)
public struct GetModelTemplateOutputResponse: Swift.Equatable {
    /// The Apache [Velocity Template Language (VTL)](https://velocity.apache.org/engine/devel/vtl-reference.html) template content used for the template resource.
    public var value: Swift.String?

    public init (
        value: Swift.String? = nil
    )
    {
        self.value = value
    }
}

struct GetModelTemplateOutputResponseBody: Swift.Equatable {
    let value: Swift.String?
}

extension GetModelTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GetModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models"
    }
}

/// Request to list existing [Models] defined for a [RestApi] resource.
public struct GetModelsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetModelsInputBody: Swift.Equatable {
}

extension GetModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetModelsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of [Model] resources. [Method], [MethodResponse], [Models and Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html)
public struct GetModelsOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.Model]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.Model]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetModelsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.Model]?
}

extension GetModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.Model?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.Model]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.Model]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetRequestValidatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let requestValidatorId = requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

/// Gets a [RequestValidator] of a given [RestApi].
public struct GetRequestValidatorInput: Swift.Equatable {
    /// [Required] The identifier of the [RequestValidator] to be retrieved.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct GetRequestValidatorInputBody: Swift.Equatable {
}

extension GetRequestValidatorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRequestValidatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRequestValidatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRequestValidatorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRequestValidatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRequestValidatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// A set of validation rules for incoming [Method] requests. In OpenAPI, a [RequestValidator] of an API is defined by the [x-amazon-apigateway-request-validators.requestValidator](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html) object. It the referenced using the [x-amazon-apigateway-request-validator](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator) property. [Enable Basic Request Validation in API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html)
public struct GetRequestValidatorOutputResponse: Swift.Equatable {
    /// The identifier of this [RequestValidator].
    public var id: Swift.String?
    /// The name of this [RequestValidator]
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured [Model] schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct GetRequestValidatorOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let validateRequestBody: Swift.Bool
    let validateRequestParameters: Swift.Bool
}

extension GetRequestValidatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension GetRequestValidatorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetRequestValidatorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators"
    }
}

/// Gets the [RequestValidators] collection of a given [RestApi].
public struct GetRequestValidatorsInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetRequestValidatorsInputBody: Swift.Equatable {
}

extension GetRequestValidatorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRequestValidatorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRequestValidatorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRequestValidatorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRequestValidatorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRequestValidatorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// A collection of [RequestValidator] resources of a given [RestApi]. In OpenAPI, the [RequestValidators] of an API is defined by the [x-amazon-apigateway-request-validators](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.html) extension. [Enable Basic Request Validation in API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html)
public struct GetRequestValidatorsOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.RequestValidator]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.RequestValidator]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetRequestValidatorsOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.RequestValidator]?
}

extension GetRequestValidatorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.RequestValidator?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.RequestValidator]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.RequestValidator]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let embed = embed {
            embed.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

/// Request to list information about a resource.
public struct GetResourceInput: Swift.Equatable {
    /// A query parameter to retrieve the specified resources embedded in the returned [Resource] representation in the response. This embed parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded [Method] resources this way. The query parameter value must be a single-valued list and contain the "methods" string. For example, GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods.
    public var embed: [Swift.String]?
    /// [Required] The identifier for the [Resource] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        embed: [Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.embed = embed
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct GetResourceInputBody: Swift.Equatable {
}

extension GetResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// Represents an API resource. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct GetResourceOutputResponse: Swift.Equatable {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb. The resource methods are a map of methods indexed by methods' HTTP verbs enabled on the resource. This method map is included in the 200 OK response of the GET /restapis/{restapi_id}/resources/{resource_id} or GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods request.
    /// Example: Get the GET method of an API resource
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20170223T031827Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html", "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET", "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}", "templated": true } }, "apiKeyRequired": false, "authorizationType": "NONE", "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type": "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n" }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" } } } If the OPTIONS is enabled on the resource, you can follow the example here to get that method. Just replace the GET of the last path segment in the request URL with OPTIONS.
    public var resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]?

    public init (
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct GetResourceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let parentId: Swift.String?
    let pathPart: Swift.String?
    let path: Swift.String?
    let resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]?
}

extension GetResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [Swift.String:ApiGatewayClientTypes.Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [Swift.String:ApiGatewayClientTypes.Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

extension GetResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let embed = embed {
            embed.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "embed".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension GetResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources"
    }
}

/// Request to list information about a collection of resources.
public struct GetResourcesInput: Swift.Equatable {
    /// A query parameter used to retrieve the specified resources embedded in the returned [Resources] resource in the response. This embed parameter value is a list of comma-separated strings. Currently, the request supports only retrieval of the embedded [Method] resources this way. The query parameter value must be a single-valued list and contain the "methods" string. For example, GET /restapis/{restapi_id}/resources?embed=methods.
    public var embed: [Swift.String]?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        embed: [Swift.String]? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.embed = embed
        self.limit = limit
        self.position = position
        self.restApiId = restApiId
    }
}

struct GetResourcesInputBody: Swift.Equatable {
}

extension GetResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of [Resource] resources. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct GetResourcesOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.Resource]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.Resource]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetResourcesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.Resource]?
}

extension GetResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.Resource?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.Resource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.Resource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

/// The GET request to list an existing [RestApi] defined for your collection.
public struct GetRestApiInput: Swift.Equatable {
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        restApiId: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
    }
}

struct GetRestApiInputBody: Swift.Equatable {
}

extension GetRestApiInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRestApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRestApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRestApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRestApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRestApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct GetRestApiOutputResponse: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are:
    ///
    /// * HEADER to read the API key from the X-API-Key header of a request.
    ///
    /// * AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the [RestApi]. By default, the [RestApi] supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this [RestApi] showing the endpoint types of the API.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and [Method] configuration.
    public var policy: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiKeySource: ApiGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct GetRestApiOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
}

extension GetRestApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension GetRestApisInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetRestApisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restapis"
    }
}

/// The GET request to list existing [RestApis] defined for your collection.
public struct GetRestApisInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetRestApisInputBody: Swift.Equatable {
}

extension GetRestApisInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRestApisOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRestApisOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRestApisOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRestApisOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRestApisOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Contains references to your APIs and links that guide you in how to interact with your collection. A collection offers a paginated view of your APIs. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct GetRestApisOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.RestApi]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.RestApi]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetRestApisOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.RestApi]?
}

extension GetRestApisOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.RestApi?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.RestApi]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.RestApi]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetSdkInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let parameters = parameters {
            let currentQueryItemNames = items.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension GetSdkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        guard let sdkType = sdkType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())/sdks/\(sdkType.urlPercentEncoding())"
    }
}

/// Request a new generated client SDK for a [RestApi] and [Stage].
public struct GetSdkInput: Swift.Equatable {
    /// A string-to-string key-value map of query parameters sdkType-dependent properties of the SDK. For sdkType of objectivec or swift, a parameter named classPrefix is required. For sdkType of android, parameters named groupId, artifactId, artifactVersion, and invokerPackage are required. For sdkType of java, parameters named serviceName and javaPackageName are required.
    public var parameters: [Swift.String:Swift.String]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The language for the generated SDK. Currently java, javascript, android, objectivec (for iOS), swift (for iOS), and ruby are supported.
    /// This member is required.
    public var sdkType: Swift.String?
    /// [Required] The name of the [Stage] that the SDK will use.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        parameters: [Swift.String:Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        sdkType: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.parameters = parameters
        self.restApiId = restApiId
        self.sdkType = sdkType
        self.stageName = stageName
    }
}

struct GetSdkInputBody: Swift.Equatable {
}

extension GetSdkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSdkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSdkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSdkOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSdkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let contentDispositionHeaderValue = httpResponse.headers.value(for: "Content-Disposition") {
            self.contentDisposition = contentDispositionHeaderValue
        } else {
            self.contentDisposition = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.body = data
        } else {
            self.body = nil
        }
    }
}

/// The binary blob response to [GetSdk], which contains the generated SDK.
public struct GetSdkOutputResponse: Swift.Equatable {
    /// The binary blob response to [GetSdk], which contains the generated SDK.
    public var body: ClientRuntime.Data?
    /// The content-disposition header value in the HTTP response.
    public var contentDisposition: Swift.String?
    /// The content-type header value in the HTTP response.
    public var contentType: Swift.String?

    public init (
        body: ClientRuntime.Data? = nil,
        contentDisposition: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.body = body
        self.contentDisposition = contentDisposition
        self.contentType = contentType
    }
}

struct GetSdkOutputResponseBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension GetSdkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension GetSdkTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/sdktypes/\(id.urlPercentEncoding())"
    }
}

/// Get an [SdkType] instance.
public struct GetSdkTypeInput: Swift.Equatable {
    /// [Required] The identifier of the queried [SdkType] instance.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSdkTypeInputBody: Swift.Equatable {
}

extension GetSdkTypeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSdkTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSdkTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSdkTypeOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSdkTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSdkTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationProperties = output.configurationProperties
            self.description = output.description
            self.friendlyName = output.friendlyName
            self.id = output.id
        } else {
            self.configurationProperties = nil
            self.description = nil
            self.friendlyName = nil
            self.id = nil
        }
    }
}

/// A type of SDK that API Gateway can generate.
public struct GetSdkTypeOutputResponse: Swift.Equatable {
    /// A list of configuration properties of an [SdkType].
    public var configurationProperties: [ApiGatewayClientTypes.SdkConfigurationProperty]?
    /// The description of an [SdkType].
    public var description: Swift.String?
    /// The user-friendly name of an [SdkType] instance.
    public var friendlyName: Swift.String?
    /// The identifier of an [SdkType] instance.
    public var id: Swift.String?

    public init (
        configurationProperties: [ApiGatewayClientTypes.SdkConfigurationProperty]? = nil,
        description: Swift.String? = nil,
        friendlyName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.configurationProperties = configurationProperties
        self.description = description
        self.friendlyName = friendlyName
        self.id = id
    }
}

struct GetSdkTypeOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let friendlyName: Swift.String?
    let description: Swift.String?
    let configurationProperties: [ApiGatewayClientTypes.SdkConfigurationProperty]?
}

extension GetSdkTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProperties
        case description
        case friendlyName
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configurationPropertiesContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.SdkConfigurationProperty?].self, forKey: .configurationProperties)
        var configurationPropertiesDecoded0:[ApiGatewayClientTypes.SdkConfigurationProperty]? = nil
        if let configurationPropertiesContainer = configurationPropertiesContainer {
            configurationPropertiesDecoded0 = [ApiGatewayClientTypes.SdkConfigurationProperty]()
            for structure0 in configurationPropertiesContainer {
                if let structure0 = structure0 {
                    configurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        configurationProperties = configurationPropertiesDecoded0
    }
}

extension GetSdkTypesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetSdkTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sdktypes"
    }
}

/// Get the [SdkTypes] collection.
public struct GetSdkTypesInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetSdkTypesInputBody: Swift.Equatable {
}

extension GetSdkTypesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSdkTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSdkTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSdkTypesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSdkTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSdkTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
    }
}

/// The collection of [SdkType] instances.
public struct GetSdkTypesOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.SdkType]?

    public init (
        items: [ApiGatewayClientTypes.SdkType]? = nil
    )
    {
        self.items = items
    }
}

struct GetSdkTypesOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.SdkType]?
}

extension GetSdkTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.SdkType?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.SdkType]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.SdkType]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

/// Requests API Gateway to get information about a [Stage] resource.
public struct GetStageInput: Swift.Equatable {
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The name of the [Stage] resource to get information about.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct GetStageInputBody: Swift.Equatable {
}

extension GetStageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// Represents a unique identifier for a version of a deployed [RestApi] that is callable by users. [Deploy an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html)
public struct GetStageOutputResponse: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool
    /// The size of the cache cluster for the stage, if enabled.
    public var cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: ApiGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier of the [Deployment] that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// A map that defines the method settings for a [Stage] resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the [Stage].
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a [Stage] resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?
    /// The ARN of the WebAcl associated with the [Stage].
    public var webAclArn: Swift.String?

    public init (
        accessLogSettings: ApiGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: ApiGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String:Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct GetStageOutputResponseBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let clientCertificateId: Swift.String?
    let stageName: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool
    let cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    let cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus?
    let methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]?
    let variables: [Swift.String:Swift.String]?
    let documentationVersion: Swift.String?
    let accessLogSettings: ApiGatewayClientTypes.AccessLogSettings?
    let canarySettings: ApiGatewayClientTypes.CanarySettings?
    let tracingEnabled: Swift.Bool
    let webAclArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension GetStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [Swift.String:ApiGatewayClientTypes.MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [Swift.String:ApiGatewayClientTypes.MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension GetStagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let deploymentId = deploymentId {
            let deploymentIdQueryItem = ClientRuntime.URLQueryItem(name: "deploymentId".urlPercentEncoding(), value: Swift.String(deploymentId).urlPercentEncoding())
            items.append(deploymentIdQueryItem)
        }
        return items
    }
}

extension GetStagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages"
    }
}

/// Requests API Gateway to get information about one or more [Stage] resources.
public struct GetStagesInput: Swift.Equatable {
    /// The stages' deployment identifiers.
    public var deploymentId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.restApiId = restApiId
    }
}

struct GetStagesInputBody: Swift.Equatable {
}

extension GetStagesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetStagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetStagesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetStagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.item = output.item
        } else {
            self.item = nil
        }
    }
}

/// A list of [Stage] resources that are associated with the [ApiKey] resource. [Deploying API in Stages](https://docs.aws.amazon.com/apigateway/latest/developerguide/stages.html)
public struct GetStagesOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var item: [ApiGatewayClientTypes.Stage]?

    public init (
        item: [ApiGatewayClientTypes.Stage]? = nil
    )
    {
        self.item = item
    }
}

struct GetStagesOutputResponseBody: Swift.Equatable {
    let item: [ApiGatewayClientTypes.Stage]?
}

extension GetStagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case item
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.Stage?].self, forKey: .item)
        var itemDecoded0:[ApiGatewayClientTypes.Stage]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [ApiGatewayClientTypes.Stage]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
    }
}

extension GetTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Gets the [Tags] collection for a given resource.
public struct GetTagsInput: Swift.Equatable {
    /// (Not currently supported) The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// (Not currently supported) The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
        self.resourceArn = resourceArn
    }
}

struct GetTagsInputBody: Swift.Equatable {
}

extension GetTagsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// The collection of tags. Each tag element is associated with a given resource.
public struct GetTagsOutputResponse: Swift.Equatable {
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct GetTagsOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension GetTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetUsageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let endDate = endDate {
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(endDate).urlPercentEncoding())
            items.append(endDateQueryItem)
        }
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let keyId = keyId {
            let keyIdQueryItem = ClientRuntime.URLQueryItem(name: "keyId".urlPercentEncoding(), value: Swift.String(keyId).urlPercentEncoding())
            items.append(keyIdQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let startDate = startDate {
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(startDate).urlPercentEncoding())
            items.append(startDateQueryItem)
        }
        return items
    }
}

extension GetUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/usage"
    }
}

/// The GET request to get the usage data of a usage plan in a specified time interval.
public struct GetUsageInput: Swift.Equatable {
    /// [Required] The ending date (e.g., 2016-12-31) of the usage data.
    /// This member is required.
    public var endDate: Swift.String?
    /// The Id of the API key associated with the resultant usage data.
    public var keyId: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The starting date (e.g., 2016-01-01) of the usage data.
    /// This member is required.
    public var startDate: Swift.String?
    /// [Required] The Id of the usage plan associated with the usage data.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        endDate: Swift.String? = nil,
        keyId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.keyId = keyId
        self.limit = limit
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct GetUsageInputBody: Swift.Equatable {
}

extension GetUsageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endDate = output.endDate
            self.items = output.items
            self.startDate = output.startDate
            self.usagePlanId = output.usagePlanId
        } else {
            self.endDate = nil
            self.items = nil
            self.startDate = nil
            self.usagePlanId = nil
        }
        self.position = nil
    }
}

/// Represents the usage data of a usage plan. [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html), [Manage Usage in a Usage Plan](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-console.html#api-gateway-usage-plan-manage-usage)
public struct GetUsageOutputResponse: Swift.Equatable {
    /// The ending date of the usage data.
    public var endDate: Swift.String?
    /// The usage data, as daily logs of used and remaining quotas, over the specified time interval indexed over the API keys in a usage plan. For example, {..., "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}, where {api_key} stands for an API key value and the daily log entry is of the format [used quota, remaining quota].
    public var items: [Swift.String:[[Swift.Int]]]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The starting date of the usage data.
    public var startDate: Swift.String?
    /// The plan Id associated with this usage data.
    public var usagePlanId: Swift.String?

    public init (
        endDate: Swift.String? = nil,
        items: [Swift.String:[[Swift.Int]]]? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.items = items
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct GetUsageOutputResponseBody: Swift.Equatable {
    let usagePlanId: Swift.String?
    let startDate: Swift.String?
    let endDate: Swift.String?
    let items: [Swift.String:[[Swift.Int]]]?
}

extension GetUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate
        case items = "values"
        case startDate
        case usagePlanId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usagePlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usagePlanId)
        usagePlanId = usagePlanIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let itemsContainer = try containerValues.decodeIfPresent([Swift.String: [[Swift.Int?]?]?].self, forKey: .items)
        var itemsDecoded0: [Swift.String:[[Swift.Int]]]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Swift.String:[[Swift.Int]]]()
            for (key0, listofusage0) in itemsContainer {
                var listofusage0Decoded0: [[Swift.Int]]? = nil
                if let listofusage0 = listofusage0 {
                    listofusage0Decoded0 = [[Swift.Int]]()
                    for list1 in listofusage0 {
                        var list1Decoded1: [Swift.Int]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Int]()
                            for long2 in list1 {
                                if let long2 = long2 {
                                    list1Decoded1?.append(long2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            listofusage0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                itemsDecoded0?[key0] = listofusage0Decoded0
            }
        }
        items = itemsDecoded0
    }
}

extension GetUsagePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

/// The GET request to get a usage plan of a given plan identifier.
public struct GetUsagePlanInput: Swift.Equatable {
    /// [Required] The identifier of the [UsagePlan] resource to be retrieved.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        usagePlanId: Swift.String? = nil
    )
    {
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanInputBody: Swift.Equatable {
}

extension GetUsagePlanInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUsagePlanKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        guard let keyId = keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())"
    }
}

/// The GET request to get a usage plan key of a given key identifier.
public struct GetUsagePlanKeyInput: Swift.Equatable {
    /// [Required] The key Id of the to-be-retrieved [UsagePlanKey] resource representing a plan customer.
    /// This member is required.
    public var keyId: Swift.String?
    /// [Required] The Id of the [UsagePlan] resource representing the usage plan containing the to-be-retrieved [UsagePlanKey] resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        keyId: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanKeyInputBody: Swift.Equatable {
}

extension GetUsagePlanKeyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUsagePlanKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsagePlanKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsagePlanKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsagePlanKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUsagePlanKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.type = output.type
            self.value = output.value
        } else {
            self.id = nil
            self.name = nil
            self.type = nil
            self.value = nil
        }
    }
}

/// Represents a usage plan key to identify a plan customer. To associate an API stage with a selected API key in a usage plan, you must create a UsagePlanKey resource to represent the selected [ApiKey]. " [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
public struct GetUsagePlanKeyOutputResponse: Swift.Equatable {
    /// The Id of a usage plan key.
    public var id: Swift.String?
    /// The name of a usage plan key.
    public var name: Swift.String?
    /// The type of a usage plan key. Currently, the valid key type is API_KEY.
    public var type: Swift.String?
    /// The value of a usage plan key.
    public var value: Swift.String?

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        type: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.id = id
        self.name = name
        self.type = type
        self.value = value
    }
}

struct GetUsagePlanKeyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let type: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
}

extension GetUsagePlanKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case type
        case value
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetUsagePlanKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        if let nameQuery = nameQuery {
            let nameQueryQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(nameQuery).urlPercentEncoding())
            items.append(nameQueryQueryItem)
        }
        return items
    }
}

extension GetUsagePlanKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys"
    }
}

/// The GET request to get all the usage plan keys representing the API keys added to a specified usage plan.
public struct GetUsagePlanKeysInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// A query parameter specifying the name of the to-be-returned usage plan keys.
    public var nameQuery: Swift.String?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// [Required] The Id of the [UsagePlan] resource representing the usage plan containing the to-be-retrieved [UsagePlanKey] resource representing a plan customer.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        nameQuery: Swift.String? = nil,
        position: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.limit = limit
        self.nameQuery = nameQuery
        self.position = position
        self.usagePlanId = usagePlanId
    }
}

struct GetUsagePlanKeysInputBody: Swift.Equatable {
}

extension GetUsagePlanKeysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUsagePlanKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsagePlanKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsagePlanKeysOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsagePlanKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUsagePlanKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents the collection of usage plan keys added to usage plans for the associated API keys and, possibly, other types of keys. [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
public struct GetUsagePlanKeysOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.UsagePlanKey]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.UsagePlanKey]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetUsagePlanKeysOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.UsagePlanKey]?
}

extension GetUsagePlanKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.UsagePlanKey?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.UsagePlanKey]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.UsagePlanKey]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetUsagePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsagePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsagePlanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsagePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUsagePlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// Represents a usage plan than can specify who can assess associated API stages with specified request limits and quotas. In a usage plan, you associate an API by specifying the API's Id and a stage name of the specified API. You add plan customers by adding API keys to the plan. [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
public struct GetUsagePlanOutputResponse: Swift.Equatable {
    /// The associated API stages of a usage plan.
    public var apiStages: [ApiGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a [UsagePlan] resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.
    public var productCode: Swift.String?
    /// The maximum number of permitted requests per a given unit time interval.
    public var quota: ApiGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The request throttle limits of a usage plan.
    public var throttle: ApiGatewayClientTypes.ThrottleSettings?

    public init (
        apiStages: [ApiGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: ApiGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        throttle: ApiGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct GetUsagePlanOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let apiStages: [ApiGatewayClientTypes.ApiStage]?
    let throttle: ApiGatewayClientTypes.ThrottleSettings?
    let quota: ApiGatewayClientTypes.QuotaSettings?
    let productCode: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetUsagePlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetUsagePlansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let keyId = keyId {
            let keyIdQueryItem = ClientRuntime.URLQueryItem(name: "keyId".urlPercentEncoding(), value: Swift.String(keyId).urlPercentEncoding())
            items.append(keyIdQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetUsagePlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/usageplans"
    }
}

/// The GET request to get all the usage plans of the caller's account.
public struct GetUsagePlansInput: Swift.Equatable {
    /// The identifier of the API key associated with the usage plans.
    public var keyId: Swift.String?
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        keyId: Swift.String? = nil,
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.limit = limit
        self.position = position
    }
}

struct GetUsagePlansInputBody: Swift.Equatable {
}

extension GetUsagePlansInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUsagePlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsagePlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsagePlansOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsagePlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetUsagePlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// Represents a collection of usage plans for an AWS account. [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
public struct GetUsagePlansOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.UsagePlan]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.UsagePlan]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetUsagePlansOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.UsagePlan]?
}

extension GetUsagePlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.UsagePlan?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.UsagePlan]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.UsagePlan]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension GetVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

/// Gets a specified VPC link under the caller's account in a region.
public struct GetVpcLinkInput: Swift.Equatable {
    /// [Required] The identifier of the [VpcLink]. It is used in an [Integration] to reference this [VpcLink].
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init (
        vpcLinkId: Swift.String? = nil
    )
    {
        self.vpcLinkId = vpcLinkId
    }
}

struct GetVpcLinkInputBody: Swift.Equatable {
}

extension GetVpcLinkInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcLinkOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// An API Gateway VPC link for a [RestApi] to access resources in an Amazon Virtual Private Cloud (VPC). To enable access to a resource in an Amazon Virtual Private Cloud through Amazon API Gateway, you, as an API developer, create a [VpcLink] resource targeted for one or more network load balancers of the VPC and then integrate an API method with a private integration that uses the [VpcLink]. The private integration has an integration type of HTTP or HTTP_PROXY and has a connection type of VPC_LINK. The integration uses the connectionId property to identify the [VpcLink] used.
public struct GetVpcLinkOutputResponse: Swift.Equatable {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the [VpcLink]. It is used in an [Integration] to reference this [VpcLink].
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: ApiGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.
    public var targetArns: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ApiGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct GetVpcLinkOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let targetArns: [Swift.String]?
    let status: ApiGatewayClientTypes.VpcLinkStatus?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetVpcLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetVpcLinksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let limit = limit {
            let limitQueryItem = ClientRuntime.URLQueryItem(name: "limit".urlPercentEncoding(), value: Swift.String(limit).urlPercentEncoding())
            items.append(limitQueryItem)
        }
        if let position = position {
            let positionQueryItem = ClientRuntime.URLQueryItem(name: "position".urlPercentEncoding(), value: Swift.String(position).urlPercentEncoding())
            items.append(positionQueryItem)
        }
        return items
    }
}

extension GetVpcLinksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/vpclinks"
    }
}

/// Gets the [VpcLinks] collection under the caller's account in a selected region.
public struct GetVpcLinksInput: Swift.Equatable {
    /// The maximum number of returned results per page. The default value is 25 and the maximum value is 500.
    public var limit: Swift.Int?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        limit: Swift.Int? = nil,
        position: Swift.String? = nil
    )
    {
        self.limit = limit
        self.position = position
    }
}

struct GetVpcLinksInputBody: Swift.Equatable {
}

extension GetVpcLinksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVpcLinksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVpcLinksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVpcLinksOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVpcLinksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetVpcLinksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
        } else {
            self.items = nil
        }
        self.position = nil
    }
}

/// The collection of VPC links under the caller's account in a region. [Getting Started with Private Integrations](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-private-integration.html), [Set up Private Integrations](https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-private-integration.html)
public struct GetVpcLinksOutputResponse: Swift.Equatable {
    /// The current page of elements from this collection.
    public var items: [ApiGatewayClientTypes.VpcLink]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?

    public init (
        items: [ApiGatewayClientTypes.VpcLink]? = nil,
        position: Swift.String? = nil
    )
    {
        self.items = items
        self.position = position
    }
}

struct GetVpcLinksOutputResponseBody: Swift.Equatable {
    let items: [ApiGatewayClientTypes.VpcLink]?
}

extension GetVpcLinksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "item"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.VpcLink?].self, forKey: .items)
        var itemsDecoded0:[ApiGatewayClientTypes.VpcLink]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [ApiGatewayClientTypes.VpcLink]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

public struct ImportApiKeysInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportApiKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportApiKeysInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ImportApiKeysOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.data(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportApiKeysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportApiKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension ImportApiKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

extension ImportApiKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "mode", value: "import"))
        if let format = format {
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
        }
        if failOnWarnings != false {
            let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        return items
    }
}

extension ImportApiKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/apikeys"
    }
}

/// The POST request to import API keys from an external source, such as a CSV-formatted file.
public struct ImportApiKeysInput: Swift.Equatable {
    /// The payload of the POST request to import API keys. For the payload format, see [API Key File Format](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-key-file-format.html).
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// A query parameter to indicate whether to rollback [ApiKey] importation (true) or not (false) when error is encountered.
    public var failOnWarnings: Swift.Bool
    /// A query parameter to specify the input format to imported API keys. Currently, only the csv format is supported.
    /// This member is required.
    public var format: ApiGatewayClientTypes.ApiKeysFormat?

    public init (
        body: ClientRuntime.Data? = nil,
        failOnWarnings: Swift.Bool = false,
        format: ApiGatewayClientTypes.ApiKeysFormat? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.format = format
    }
}

struct ImportApiKeysInputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension ImportApiKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportApiKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportApiKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportApiKeysOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportApiKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportApiKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
            self.warnings = output.warnings
        } else {
            self.ids = nil
            self.warnings = nil
        }
    }
}

/// The identifier of an [ApiKey] used in a [UsagePlan].
public struct ImportApiKeysOutputResponse: Swift.Equatable {
    /// A list of all the [ApiKey] identifiers.
    public var ids: [Swift.String]?
    /// A list of warning messages.
    public var warnings: [Swift.String]?

    public init (
        ids: [Swift.String]? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.warnings = warnings
    }
}

struct ImportApiKeysOutputResponseBody: Swift.Equatable {
    let ids: [Swift.String]?
    let warnings: [Swift.String]?
}

extension ImportApiKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case warnings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct ImportDocumentationPartsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportDocumentationPartsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportDocumentationPartsInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ImportDocumentationPartsOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.data(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportDocumentationPartsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportDocumentationPartsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension ImportDocumentationPartsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

extension ImportDocumentationPartsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let mode = mode {
            let modeQueryItem = ClientRuntime.URLQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
            items.append(modeQueryItem)
        }
        if failOnWarnings != false {
            let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        return items
    }
}

extension ImportDocumentationPartsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts"
    }
}

/// Import documentation parts from an external (e.g., OpenAPI) definition file.
public struct ImportDocumentationPartsInput: Swift.Equatable {
    /// [Required] Raw byte array representing the to-be-imported documentation parts. To import from an OpenAPI file, this is a JSON object.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// A query parameter to specify whether to rollback the documentation importation (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool
    /// A query parameter to indicate whether to overwrite (OVERWRITE) any existing [DocumentationParts] definition or to merge (MERGE) the new definition into the existing one. The default value is MERGE.
    public var mode: ApiGatewayClientTypes.PutMode?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        body: ClientRuntime.Data? = nil,
        failOnWarnings: Swift.Bool = false,
        mode: ApiGatewayClientTypes.PutMode? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.mode = mode
        self.restApiId = restApiId
    }
}

struct ImportDocumentationPartsInputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension ImportDocumentationPartsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportDocumentationPartsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportDocumentationPartsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportDocumentationPartsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportDocumentationPartsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportDocumentationPartsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ids = output.ids
            self.warnings = output.warnings
        } else {
            self.ids = nil
            self.warnings = nil
        }
    }
}

/// A collection of the imported [DocumentationPart] identifiers. This is used to return the result when documentation parts in an external (e.g., OpenAPI) file are imported into API Gateway [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [documentationpart:import](https://docs.aws.amazon.com/apigateway/api-reference/link-relation/documentationpart-import/), [DocumentationPart]
public struct ImportDocumentationPartsOutputResponse: Swift.Equatable {
    /// A list of the returned documentation part identifiers.
    public var ids: [Swift.String]?
    /// A list of warning messages reported during import of documentation parts.
    public var warnings: [Swift.String]?

    public init (
        ids: [Swift.String]? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.ids = ids
        self.warnings = warnings
    }
}

struct ImportDocumentationPartsOutputResponseBody: Swift.Equatable {
    let ids: [Swift.String]?
    let warnings: [Swift.String]?
}

extension ImportDocumentationPartsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
        case warnings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
    }
}

public struct ImportRestApiInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportRestApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportRestApiInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ImportRestApiOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.data(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportRestApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension ImportRestApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

extension ImportRestApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        items.append(ClientRuntime.URLQueryItem(name: "mode", value: "import"))
        if failOnWarnings != false {
            let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let parameters = parameters {
            let currentQueryItemNames = items.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension ImportRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/restapis"
    }
}

/// A POST request to import an API to API Gateway using an input of an API definition file.
public struct ImportRestApiInput: Swift.Equatable {
    /// [Required] The POST request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// A query parameter to indicate whether to rollback the API creation (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool
    /// A key-value map of context-specific query string parameters specifying the behavior of different API importing operations. The following shows operation-specific parameters and their supported values. To exclude [DocumentationParts] from the import, set parameters as ignore=documentation. To configure the endpoint type, set parameters as endpointConfigurationTypes=EDGE, endpointConfigurationTypes=REGIONAL, or endpointConfigurationTypes=PRIVATE. The default endpoint type is EDGE. To handle imported basepath, set parameters as basepath=ignore, basepath=prepend or basepath=split. For example, the AWS CLI command to exclude documentation from the imported API is: aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json' The AWS CLI command to set the regional endpoint on the imported API is: aws apigateway import-rest-api --parameters endpointConfigurationTypes=REGIONAL --body 'file:///path/to/imported-api-body.json'
    public var parameters: [Swift.String:Swift.String]?

    public init (
        body: ClientRuntime.Data? = nil,
        failOnWarnings: Swift.Bool = false,
        parameters: [Swift.String:Swift.String]? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.parameters = parameters
    }
}

struct ImportRestApiInputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension ImportRestApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension ImportRestApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportRestApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportRestApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportRestApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportRestApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct ImportRestApiOutputResponse: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are:
    ///
    /// * HEADER to read the API key from the X-API-Key header of a request.
    ///
    /// * AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the [RestApi]. By default, the [RestApi] supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this [RestApi] showing the endpoint types of the API.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and [Method] configuration.
    public var policy: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiKeySource: ApiGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct ImportRestApiOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
}

extension ImportRestApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension ApiGatewayClientTypes.Integration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheKeyParameters = cacheKeyParameters {
            var cacheKeyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheKeyParameters)
            for listofstring0 in cacheKeyParameters {
                try cacheKeyParametersContainer.encode(listofstring0)
            }
        }
        if let cacheNamespace = cacheNamespace {
            try encodeContainer.encode(cacheNamespace, forKey: .cacheNamespace)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandling = contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let credentials = credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let integrationResponses = integrationResponses {
            var integrationResponsesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .integrationResponses)
            for (dictKey0, mapofintegrationresponse0) in integrationResponses {
                try integrationResponsesContainer.encode(mapofintegrationresponse0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior, forKey: .passthroughBehavior)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, mapofstringtostring0) in requestParameters {
                try requestParametersContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, mapofstringtostring0) in requestTemplates {
                try requestTemplatesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if timeoutInMillis != 0 {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [Swift.String:ApiGatewayClientTypes.IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration. In the API Gateway console, the built-in Lambda integration is an AWS integration. [Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
    public struct Integration: Swift.Equatable {
        /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for [Method]requestParameters.
        public var cacheKeyParameters: [Swift.String]?
        /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
        public var cacheNamespace: Swift.String?
        /// The ([id](https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id)) of the [VpcLink] used for the integration when connectionType=VPC_LINK and undefined, otherwise.
        public var connectionId: Swift.String?
        /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
        public var connectionType: ApiGatewayClientTypes.ConnectionType?
        /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
        ///
        /// * CONVERT_TO_BINARY: Converts a request payload from a Base64-encoded string to the corresponding binary blob.
        ///
        /// * CONVERT_TO_TEXT: Converts a request payload from a binary blob to a Base64-encoded string.
        ///
        ///
        /// If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
        public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
        /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported AWS services, specify null.
        public var credentials: Swift.String?
        /// Specifies the integration's HTTP method type.
        public var httpMethod: Swift.String?
        /// Specifies the integration's responses.
        /// Example: Get integration responses of a method
        ///
        ///
        /// Request
        ///
        ///
        ///     GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160607T191449Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
        ///
        ///
        /// Response
        ///
        /// The successful response returns 200 OK status and a payload as follows: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n" }, "statusCode": "200" }[Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
        public var integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]?
        /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following:
        ///
        /// * WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request.
        ///
        /// * WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response.
        ///
        /// * NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
        public var passthroughBehavior: Swift.String?
        /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
        public var requestParameters: [Swift.String:Swift.String]?
        /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
        public var requestTemplates: [Swift.String:Swift.String]?
        /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
        public var timeoutInMillis: Swift.Int
        /// Specifies the TLS configuration for an integration.
        public var tlsConfig: ApiGatewayClientTypes.TlsConfig?
        /// Specifies an API method integration type. The valid value is one of the following:
        ///
        /// * AWS: for integrating the API method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration.
        ///
        /// * AWS_PROXY: for integrating the API method request with the Lambda function-invoking action with the client request passed through as-is. This integration is also referred to as the Lambda proxy integration.
        ///
        /// * HTTP: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC. This integration is also referred to as the HTTP custom integration.
        ///
        /// * HTTP_PROXY: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC, with the client request passed through as-is. This is also referred to as the HTTP proxy integration.
        ///
        /// * MOCK: for integrating the API method request with API Gateway as a "loop-back" endpoint without invoking any backend.
        ///
        ///
        /// For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a [VpcLink] to connect API Gateway to a network load balancer of a VPC.
        public var type: ApiGatewayClientTypes.IntegrationType?
        /// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
        ///
        /// * For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the [RFC-3986 specification](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier), for either standard integration, where connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For a private HTTP integration, the URI is not used for routing.
        ///
        /// * For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS service for fast host-name lookup. action can be used for an AWS service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an AWS service path-based API. The ensuing service_api refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of [GetObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html), the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
        public var uri: Swift.String?

        public init (
            cacheKeyParameters: [Swift.String]? = nil,
            cacheNamespace: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            connectionType: ApiGatewayClientTypes.ConnectionType? = nil,
            contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
            credentials: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]? = nil,
            passthroughBehavior: Swift.String? = nil,
            requestParameters: [Swift.String:Swift.String]? = nil,
            requestTemplates: [Swift.String:Swift.String]? = nil,
            timeoutInMillis: Swift.Int = 0,
            tlsConfig: ApiGatewayClientTypes.TlsConfig? = nil,
            type: ApiGatewayClientTypes.IntegrationType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.cacheKeyParameters = cacheKeyParameters
            self.cacheNamespace = cacheNamespace
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.contentHandling = contentHandling
            self.credentials = credentials
            self.httpMethod = httpMethod
            self.integrationResponses = integrationResponses
            self.passthroughBehavior = passthroughBehavior
            self.requestParameters = requestParameters
            self.requestTemplates = requestTemplates
            self.timeoutInMillis = timeoutInMillis
            self.tlsConfig = tlsConfig
            self.type = type
            self.uri = uri
        }
    }

}

extension ApiGatewayClientTypes.IntegrationResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandling = contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtostring0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, mapofstringtostring0) in responseTemplates {
                try responseTemplatesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let selectionPattern = selectionPattern {
            try encodeContainer.encode(selectionPattern, forKey: .selectionPattern)
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents an integration response. The status code must map to an existing [MethodResponse], and parameters and templates can be used to transform the back-end response. [Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
    public struct IntegrationResponse: Swift.Equatable {
        /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
        ///
        /// * CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.
        ///
        /// * CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.
        ///
        ///
        /// If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
        public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
        /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
        public var responseParameters: [Swift.String:Swift.String]?
        /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
        public var responseTemplates: [Swift.String:Swift.String]?
        /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.
        public var selectionPattern: Swift.String?
        /// Specifies the status code that is used to map the integration response to an existing [MethodResponse].
        public var statusCode: Swift.String?

        public init (
            contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
            responseParameters: [Swift.String:Swift.String]? = nil,
            responseTemplates: [Swift.String:Swift.String]? = nil,
            selectionPattern: Swift.String? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.contentHandling = contentHandling
            self.responseParameters = responseParameters
            self.responseTemplates = responseTemplates
            self.selectionPattern = selectionPattern
            self.statusCode = statusCode
        }
    }

}

extension ApiGatewayClientTypes {
    /// The integration type. The valid value is HTTP for integrating an API method with an HTTP backend; AWS with any AWS service endpoints; MOCK for testing without actually invoking the backend; HTTP_PROXY for integrating with the HTTP proxy integration; AWS_PROXY for integrating with the Lambda proxy integration.
    public enum IntegrationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case awsProxy
        case http
        case httpProxy
        case mock
        case sdkUnknown(Swift.String)

        public static var allCases: [IntegrationType] {
            return [
                .aws,
                .awsProxy,
                .http,
                .httpProxy,
                .mock,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .awsProxy: return "AWS_PROXY"
            case .http: return "HTTP"
            case .httpProxy: return "HTTP_PROXY"
            case .mock: return "MOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IntegrationType(rawValue: rawValue) ?? IntegrationType.sdkUnknown(rawValue)
        }
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeded the rate limit. Retry after the specified time period.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayClientTypes {
    public enum LocationStatusType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case documented
        case undocumented
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationStatusType] {
            return [
                .documented,
                .undocumented,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .documented: return "DOCUMENTED"
            case .undocumented: return "UNDOCUMENTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationStatusType(rawValue: rawValue) ?? LocationStatusType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes.Method: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyRequired = apiKeyRequired {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for listofstring0 in authorizationScopes {
                try authorizationScopesContainer.encode(listofstring0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod, forKey: .httpMethod)
        }
        if let methodIntegration = methodIntegration {
            try encodeContainer.encode(methodIntegration, forKey: .methodIntegration)
        }
        if let methodResponses = methodResponses {
            var methodResponsesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .methodResponses)
            for (dictKey0, mapofmethodresponse0) in methodResponses {
                try methodResponsesContainer.encode(mapofmethodresponse0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, mapofstringtostring0) in requestModels {
                try requestModelsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, mapofstringtoboolean0) in requestParameters {
                try requestParametersContainer.encode(mapofstringtoboolean0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestValidatorId = requestValidatorId {
            try encodeContainer.encode(requestValidatorId, forKey: .requestValidatorId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [Swift.String:ApiGatewayClientTypes.MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [Swift.String:ApiGatewayClientTypes.MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an [Integration] resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an [Integration] resource. On the other hand, a method response is represented by a [MethodResponse] resource, whereas an integration response is represented by an [IntegrationResponse] resource.
    /// Example: Retrive the GET method on a specified resource
    ///
    ///
    /// Request
    ///
    /// The following example request retrieves the information about the GET method on an API resource (3kzxbg5sa2) of an API (fugvjdxtri). GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160603T210259Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    /// Response
    ///
    /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html", "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET", "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}", "templated": true } }, "apiKeyRequired": true, "authorizationType": "NONE", "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type": "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")" }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" } } } In the example above, the response template for the 200 OK response maps the JSON output from the ListStreams action in the back end to an XML output. The mapping template is URL-encoded as %3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E and the output is decoded using the [$util.urlDecode()](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference) helper function. [MethodResponse], [Integration], [IntegrationResponse], [Resource], [Set up an API's method](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html)
    public struct Method: Swift.Equatable {
        /// A boolean flag specifying whether a valid [ApiKey] is required to invoke this method.
        public var apiKeyRequired: Swift.Bool?
        /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
        public var authorizationScopes: [Swift.String]?
        /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
        public var authorizationType: Swift.String?
        /// The identifier of an [Authorizer] to use on this method. The authorizationType must be CUSTOM.
        public var authorizerId: Swift.String?
        /// The method's HTTP verb.
        public var httpMethod: Swift.String?
        /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
        /// Example:
        ///
        ///
        /// Request
        ///
        ///
        ///     GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length: 117 X-Amz-Date: 20160613T213210Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
        ///
        ///
        /// Response
        ///
        /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true } ], "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integration:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integration:responses": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "0cjtch", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestTemplates": { "application/json": "{\n \"a\": \"$input.params('operand1')\",\n \"b\": \"$input.params('operand2')\", \n \"op\": \"$input.params('operator')\" \n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.operator": "integration.response.body.op", "method.response.header.operand_2": "integration.response.body.b", "method.response.header.operand_1": "integration.response.body.a" }, "responseTemplates": { "application/json": "#set($res = $input.path('$'))\n{\n \"result\": \"$res.a, $res.b, $res.op => $res.c\",\n \"a\" : \"$res.a\",\n \"b\" : \"$res.b\",\n \"op\" : \"$res.op\",\n \"c\" : \"$res.c\"\n}" }, "selectionPattern": "", "statusCode": "200" } } }[AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-integration.html)
        public var methodIntegration: ApiGatewayClientTypes.Integration?
        /// Gets a method response associated with a given HTTP status code. The collection of method responses are encapsulated in a key-value map, where the key is a response's HTTP status code and the value is a [MethodResponse] resource that specifies the response returned to the caller from the back end through the integration response.
        /// Example: Get a 200 OK response of a GET method
        ///
        ///
        /// Request
        ///
        ///
        ///     GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length: 117 X-Amz-Date: 20160613T215008Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
        ///
        ///
        /// Response
        ///
        /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.operator": false, "method.response.header.operand_2": false, "method.response.header.operand_1": false }, "statusCode": "200" }[AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-method-response.html)
        public var methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]?
        /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
        public var operationName: Swift.String?
        /// A key-value map specifying data schemas, represented by [Model] resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
        public var requestModels: [Swift.String:Swift.String]?
        /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in [Integration] to be mapped to integration request parameters or templates.
        public var requestParameters: [Swift.String:Swift.Bool]?
        /// The identifier of a [RequestValidator] for request validation.
        public var requestValidatorId: Swift.String?

        public init (
            apiKeyRequired: Swift.Bool? = nil,
            authorizationScopes: [Swift.String]? = nil,
            authorizationType: Swift.String? = nil,
            authorizerId: Swift.String? = nil,
            httpMethod: Swift.String? = nil,
            methodIntegration: ApiGatewayClientTypes.Integration? = nil,
            methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]? = nil,
            operationName: Swift.String? = nil,
            requestModels: [Swift.String:Swift.String]? = nil,
            requestParameters: [Swift.String:Swift.Bool]? = nil,
            requestValidatorId: Swift.String? = nil
        )
        {
            self.apiKeyRequired = apiKeyRequired
            self.authorizationScopes = authorizationScopes
            self.authorizationType = authorizationType
            self.authorizerId = authorizerId
            self.httpMethod = httpMethod
            self.methodIntegration = methodIntegration
            self.methodResponses = methodResponses
            self.operationName = operationName
            self.requestModels = requestModels
            self.requestParameters = requestParameters
            self.requestValidatorId = requestValidatorId
        }
    }

}

extension ApiGatewayClientTypes.MethodResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, mapofstringtostring0) in responseModels {
                try responseModelsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtoboolean0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtoboolean0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
    /// Example: A MethodResponse instance of an API
    ///
    ///
    /// Request
    ///
    /// The example request retrieves a MethodResponse of the 200 status code. GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160603T222952Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    /// Response
    ///
    /// The successful response returns 200 OK status and a payload as follows: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" }[Method], [IntegrationResponse], [Integration][Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
    public struct MethodResponse: Swift.Equatable {
        /// Specifies the [Model] resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a [Model] name as the value.
        public var responseModels: [Swift.String:Swift.String]?
        /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's [IntegrationResponse]. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
        public var responseParameters: [Swift.String:Swift.Bool]?
        /// The method response's status code.
        public var statusCode: Swift.String?

        public init (
            responseModels: [Swift.String:Swift.String]? = nil,
            responseParameters: [Swift.String:Swift.Bool]? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.responseModels = responseModels
            self.responseParameters = responseParameters
            self.statusCode = statusCode
        }
    }

}

extension ApiGatewayClientTypes.MethodSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheDataEncrypted
        case cacheTtlInSeconds
        case cachingEnabled
        case dataTraceEnabled
        case loggingLevel
        case metricsEnabled
        case requireAuthorizationForCacheControl
        case throttlingBurstLimit
        case throttlingRateLimit
        case unauthorizedCacheControlHeaderStrategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cacheDataEncrypted != false {
            try encodeContainer.encode(cacheDataEncrypted, forKey: .cacheDataEncrypted)
        }
        if cacheTtlInSeconds != 0 {
            try encodeContainer.encode(cacheTtlInSeconds, forKey: .cacheTtlInSeconds)
        }
        if cachingEnabled != false {
            try encodeContainer.encode(cachingEnabled, forKey: .cachingEnabled)
        }
        if dataTraceEnabled != false {
            try encodeContainer.encode(dataTraceEnabled, forKey: .dataTraceEnabled)
        }
        if let loggingLevel = loggingLevel {
            try encodeContainer.encode(loggingLevel, forKey: .loggingLevel)
        }
        if metricsEnabled != false {
            try encodeContainer.encode(metricsEnabled, forKey: .metricsEnabled)
        }
        if requireAuthorizationForCacheControl != false {
            try encodeContainer.encode(requireAuthorizationForCacheControl, forKey: .requireAuthorizationForCacheControl)
        }
        if throttlingBurstLimit != 0 {
            try encodeContainer.encode(throttlingBurstLimit, forKey: .throttlingBurstLimit)
        }
        if throttlingRateLimit != 0.0 {
            try encodeContainer.encode(throttlingRateLimit, forKey: .throttlingRateLimit)
        }
        if let unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy {
            try encodeContainer.encode(unauthorizedCacheControlHeaderStrategy.rawValue, forKey: .unauthorizedCacheControlHeaderStrategy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .metricsEnabled)
        metricsEnabled = metricsEnabledDecoded
        let loggingLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggingLevel)
        loggingLevel = loggingLevelDecoded
        let dataTraceEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dataTraceEnabled)
        dataTraceEnabled = dataTraceEnabledDecoded
        let throttlingBurstLimitDecoded = try containerValues.decode(Swift.Int.self, forKey: .throttlingBurstLimit)
        throttlingBurstLimit = throttlingBurstLimitDecoded
        let throttlingRateLimitDecoded = try containerValues.decode(Swift.Double.self, forKey: .throttlingRateLimit)
        throttlingRateLimit = throttlingRateLimitDecoded
        let cachingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cachingEnabled)
        cachingEnabled = cachingEnabledDecoded
        let cacheTtlInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .cacheTtlInSeconds)
        cacheTtlInSeconds = cacheTtlInSecondsDecoded
        let cacheDataEncryptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cacheDataEncrypted)
        cacheDataEncrypted = cacheDataEncryptedDecoded
        let requireAuthorizationForCacheControlDecoded = try containerValues.decode(Swift.Bool.self, forKey: .requireAuthorizationForCacheControl)
        requireAuthorizationForCacheControl = requireAuthorizationForCacheControlDecoded
        let unauthorizedCacheControlHeaderStrategyDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.UnauthorizedCacheControlHeaderStrategy.self, forKey: .unauthorizedCacheControlHeaderStrategy)
        unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategyDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Specifies the method setting properties.
    public struct MethodSetting: Swift.Equatable {
        /// Specifies whether the cached responses are encrypted. The PATCH path for this setting is /{method_setting_key}/caching/dataEncrypted, and the value is a Boolean.
        public var cacheDataEncrypted: Swift.Bool
        /// Specifies the time to live (TTL), in seconds, for cached responses. The higher the TTL, the longer the response will be cached. The PATCH path for this setting is /{method_setting_key}/caching/ttlInSeconds, and the value is an integer.
        public var cacheTtlInSeconds: Swift.Int
        /// Specifies whether responses should be cached and returned for requests. A cache cluster must be enabled on the stage for responses to be cached. The PATCH path for this setting is /{method_setting_key}/caching/enabled, and the value is a Boolean.
        public var cachingEnabled: Swift.Bool
        /// Specifies whether full requests and responses are logged for this method, which affects the log entries pushed to Amazon CloudWatch Logs. This can be useful to troubleshoot APIs, but can result in logging sensitive data. We recommend that you don't enable this option for production APIs. The PATCH path for this setting is /{method_setting_key}/logging/dataTrace, and the value is a Boolean.
        public var dataTraceEnabled: Swift.Bool
        /// Specifies the logging level for this method, which affects the log entries pushed to Amazon CloudWatch Logs. The PATCH path for this setting is /{method_setting_key}/logging/loglevel, and the available levels are OFF, ERROR, and INFO. Choose ERROR to write only error-level entries to CloudWatch Logs, or choose INFO to include all ERROR events as well as extra informational events.
        public var loggingLevel: Swift.String?
        /// Specifies whether Amazon CloudWatch metrics are enabled for this method. The PATCH path for this setting is /{method_setting_key}/metrics/enabled, and the value is a Boolean.
        public var metricsEnabled: Swift.Bool
        /// Specifies whether authorization is required for a cache invalidation request. The PATCH path for this setting is /{method_setting_key}/caching/requireAuthorizationForCacheControl, and the value is a Boolean.
        public var requireAuthorizationForCacheControl: Swift.Bool
        /// Specifies the throttling burst limit. The PATCH path for this setting is /{method_setting_key}/throttling/burstLimit, and the value is an integer.
        public var throttlingBurstLimit: Swift.Int
        /// Specifies the throttling rate limit. The PATCH path for this setting is /{method_setting_key}/throttling/rateLimit, and the value is a double.
        public var throttlingRateLimit: Swift.Double
        /// Specifies how to handle unauthorized requests for cache invalidation. The PATCH path for this setting is /{method_setting_key}/caching/unauthorizedCacheControlHeaderStrategy, and the available values are FAIL_WITH_403, SUCCEED_WITH_RESPONSE_HEADER, SUCCEED_WITHOUT_RESPONSE_HEADER.
        public var unauthorizedCacheControlHeaderStrategy: ApiGatewayClientTypes.UnauthorizedCacheControlHeaderStrategy?

        public init (
            cacheDataEncrypted: Swift.Bool = false,
            cacheTtlInSeconds: Swift.Int = 0,
            cachingEnabled: Swift.Bool = false,
            dataTraceEnabled: Swift.Bool = false,
            loggingLevel: Swift.String? = nil,
            metricsEnabled: Swift.Bool = false,
            requireAuthorizationForCacheControl: Swift.Bool = false,
            throttlingBurstLimit: Swift.Int = 0,
            throttlingRateLimit: Swift.Double = 0.0,
            unauthorizedCacheControlHeaderStrategy: ApiGatewayClientTypes.UnauthorizedCacheControlHeaderStrategy? = nil
        )
        {
            self.cacheDataEncrypted = cacheDataEncrypted
            self.cacheTtlInSeconds = cacheTtlInSeconds
            self.cachingEnabled = cachingEnabled
            self.dataTraceEnabled = dataTraceEnabled
            self.loggingLevel = loggingLevel
            self.metricsEnabled = metricsEnabled
            self.requireAuthorizationForCacheControl = requireAuthorizationForCacheControl
            self.throttlingBurstLimit = throttlingBurstLimit
            self.throttlingRateLimit = throttlingRateLimit
            self.unauthorizedCacheControlHeaderStrategy = unauthorizedCacheControlHeaderStrategy
        }
    }

}

extension ApiGatewayClientTypes.MethodSnapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiKeyRequired != false {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let apiKeyRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents a summary of a [Method] resource, given a particular date and time.
    public struct MethodSnapshot: Swift.Equatable {
        /// Specifies whether the method requires a valid [ApiKey].
        public var apiKeyRequired: Swift.Bool
        /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
        public var authorizationType: Swift.String?

        public init (
            apiKeyRequired: Swift.Bool = false,
            authorizationType: Swift.String? = nil
        )
        {
            self.apiKeyRequired = apiKeyRequired
            self.authorizationType = authorizationType
        }
    }

}

extension ApiGatewayClientTypes.Model: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents the data structure of a method's request or response payload. A request model defines the data structure of the client-supplied request payload. A response model defines the data structure of the response payload returned by the back end. Although not required, models are useful for mapping payloads between the front end and back end. A model is used for generating an API's SDK, validating the input request body, and creating a skeletal mapping template. [Method], [MethodResponse], [Models and Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html)
    public struct Model: Swift.Equatable {
        /// The content-type for the model.
        public var contentType: Swift.String?
        /// The description of the model.
        public var description: Swift.String?
        /// The identifier for the model resource.
        public var id: Swift.String?
        /// The name of the model. Must be an alphanumeric string.
        public var name: Swift.String?
        /// The schema for the model. For application/json models, this should be [JSON schema draft 4](https://tools.ietf.org/html/draft-zyp-json-schema-04) model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
        public var schema: Swift.String?

        public init (
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.description = description
            self.id = id
            self.name = name
            self.schema = schema
        }
    }

}

extension ApiGatewayClientTypes.MutualTlsAuthentication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truststoreUri
        case truststoreVersion
        case truststoreWarnings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
        if let truststoreWarnings = truststoreWarnings {
            var truststoreWarningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .truststoreWarnings)
            for listofstring0 in truststoreWarnings {
                try truststoreWarningsContainer.encode(listofstring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
        let truststoreWarningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .truststoreWarnings)
        var truststoreWarningsDecoded0:[Swift.String]? = nil
        if let truststoreWarningsContainer = truststoreWarningsContainer {
            truststoreWarningsDecoded0 = [Swift.String]()
            for string0 in truststoreWarningsContainer {
                if let string0 = string0 {
                    truststoreWarningsDecoded0?.append(string0)
                }
            }
        }
        truststoreWarnings = truststoreWarningsDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your custom domain name.
    public struct MutualTlsAuthentication: Swift.Equatable {
        /// An Amazon S3 URL that specifies the truststore for mutual TLS authentication, for example s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?
        /// A list of warnings that API Gateway returns while processing your truststore. Invalid certificates produce warnings. Mutual TLS is still enabled, but some clients might not be able to access your API. To resolve warnings, upload a new truststore to S3, and then update you domain name to use the new version.
        public var truststoreWarnings: [Swift.String]?

        public init (
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil,
            truststoreWarnings: [Swift.String]? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
            self.truststoreWarnings = truststoreWarnings
        }
    }

}

extension ApiGatewayClientTypes.MutualTlsAuthenticationInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case truststoreUri
        case truststoreVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let truststoreUri = truststoreUri {
            try encodeContainer.encode(truststoreUri, forKey: .truststoreUri)
        }
        if let truststoreVersion = truststoreVersion {
            try encodeContainer.encode(truststoreVersion, forKey: .truststoreVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let truststoreUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreUri)
        truststoreUri = truststoreUriDecoded
        let truststoreVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .truststoreVersion)
        truststoreVersion = truststoreVersionDecoded
    }
}

extension ApiGatewayClientTypes {
    /// If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your custom domain name.
    public struct MutualTlsAuthenticationInput: Swift.Equatable {
        /// An Amazon S3 resource ARN that specifies the truststore for mutual TLS authentication, for example, s3://bucket-name/key-name. The truststore can contain certificates from public or private certificate authorities. To update the truststore, upload a new version to S3, and then update your custom domain name to use the new version. To update the truststore, you must have permissions to access the S3 object.
        public var truststoreUri: Swift.String?
        /// The version of the S3 object that contains your truststore. To specify a version, you must have versioning enabled for the S3 bucket.
        public var truststoreVersion: Swift.String?

        public init (
            truststoreUri: Swift.String? = nil,
            truststoreVersion: Swift.String? = nil
        )
        {
            self.truststoreUri = truststoreUri
            self.truststoreVersion = truststoreVersion
        }
    }

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource is not found. Make sure that the request URI is correct.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayClientTypes {
    public enum Op: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case copy
        case move
        case remove
        case replace
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [Op] {
            return [
                .add,
                .copy,
                .move,
                .remove,
                .replace,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "add"
            case .copy: return "copy"
            case .move: return "move"
            case .remove: return "remove"
            case .replace: return "replace"
            case .test: return "test"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Op(rawValue: rawValue) ?? Op.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes.PatchOperation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from
        case op
        case path
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let op = op {
            try encodeContainer.encode(op.rawValue, forKey: .op)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let opDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.Op.self, forKey: .op)
        op = opDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
    }
}

extension ApiGatewayClientTypes {
    /// A single patch operation to apply to the specified resource. Please refer to http://tools.ietf.org/html/rfc6902#section-4 for an explanation of how each operation is used.
    public struct PatchOperation: Swift.Equatable {
        /// The copy update operation's source as identified by a JSON-Pointer value referencing the location within the targeted resource to copy the value from. For example, to promote a canary deployment, you copy the canary deployment ID to the affiliated deployment ID by calling a PATCH request on a [Stage] resource with "op":"copy", "from":"/canarySettings/deploymentId" and "path":"/deploymentId".
        public var from: Swift.String?
        /// An update operation to be performed with this PATCH request. The valid value can be add, remove, replace or copy. Not all valid operations are supported for a given resource. Support of the operations depends on specific operational contexts. Attempts to apply an unsupported operation on a resource will return an error message.
        public var op: ApiGatewayClientTypes.Op?
        /// The op operation's target, as identified by a [JSON Pointer](https://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-08) value that references a location within the targeted resource. For example, if the target resource has an updateable property of {"name":"value"}, the path for this property is /name. If the name property value is a JSON object (e.g., {"name": {"child/name": "child-value"}}), the path for the child/name property will be /name/child~1name. Any slash ("/") character appearing in path names must be escaped with "~1", as shown in the example above. Each op operation can have only one path associated with it.
        public var path: Swift.String?
        /// The new target value of the update operation. It is applicable for the add or replace operation. When using AWS CLI to update a property of a JSON value, enclose the JSON object with a pair of single quotes in a Linux shell, e.g., '{"a": ...}'. In a Windows shell, see [Using JSON for Parameters](https://docs.aws.amazon.com/cli/latest/userguide/cli-using-param.html#cli-using-param-json).
        public var value: Swift.String?

        public init (
            from: Swift.String? = nil,
            op: ApiGatewayClientTypes.Op? = nil,
            path: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.from = from
            self.op = op
            self.path = path
            self.value = value
        }
    }

}

extension PutGatewayResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseParameters
        case responseTemplates
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtostring0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, mapofstringtostring0) in responseTemplates {
                try responseTemplatesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let statusCode = statusCode {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }
}

extension PutGatewayResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let responseType = responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

/// Creates a customization of a [GatewayResponse] of a specified response type and status code on the given [RestApi].
public struct PutGatewayResponseInput: Swift.Equatable {
    /// Response parameters (paths, query strings and headers) of the [GatewayResponse] as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Response templates of the [GatewayResponse] as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// [Required] The response type of the associated [GatewayResponse].
    /// This member is required.
    public var responseType: ApiGatewayClientTypes.GatewayResponseType?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// The HTTP status code of the [GatewayResponse].
    public var statusCode: Swift.String?

    public init (
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        responseType: ApiGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct PutGatewayResponseInputBody: Swift.Equatable {
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
}

extension PutGatewayResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseParameters
        case responseTemplates
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
    }
}

extension PutGatewayResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutGatewayResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutGatewayResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutGatewayResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutGatewayResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates. For more information about valid gateway response types, see [Gateway Response Types Supported by API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html)
/// Example: Get a Gateway Response of a given response type
///
///
/// Request
///
/// This example shows how to get a gateway response of the MISSING_AUTHENTICATION_TOKEN type. GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1 Host: beta-apigateway.us-east-1.amazonaws.com Content-Type: application/json X-Amz-Date: 20170503T202516Z Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a Cache-Control: no-cache Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45  The response type is specified as a URL path.
/// Response
///
/// The successful operation returns the 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html", "name": "gatewayresponse", "templated": true }, "self": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:delete": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" } }, "defaultResponse": false, "responseParameters": { "gatewayresponse.header.x-request-path": "method.request.path.petId", "gatewayresponse.header.Access-Control-Allow-Origin": "'a.b.c'", "gatewayresponse.header.x-request-query": "method.request.querystring.q", "gatewayresponse.header.x-request-header": "method.request.header.Accept" }, "responseTemplates": { "application/json": "{\n \"message\": $context.error.messageString,\n \"type\": \"$context.error.responseType\",\n \"stage\": \"$context.stage\",\n \"resourcePath\": \"$context.resourcePath\",\n \"stageVariables.a\": \"$stageVariables.a\",\n \"statusCode\": \"'404'\"\n}" }, "responseType": "MISSING_AUTHENTICATION_TOKEN", "statusCode": "404" }[Customize Gateway Responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html)
public struct PutGatewayResponseOutputResponse: Swift.Equatable {
    /// A Boolean flag to indicate whether this [GatewayResponse] is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the [GatewayResponse] as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Response templates of the [GatewayResponse] as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The response type of the associated [GatewayResponse].
    public var responseType: ApiGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this [GatewayResponse].
    public var statusCode: Swift.String?

    public init (
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        responseType: ApiGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct PutGatewayResponseOutputResponseBody: Swift.Equatable {
    let responseType: ApiGatewayClientTypes.GatewayResponseType?
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let defaultResponse: Swift.Bool
}

extension PutGatewayResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultResponse)
        defaultResponse = defaultResponseDecoded
    }
}

extension PutIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case integrationHttpMethod = "httpMethod"
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cacheKeyParameters = cacheKeyParameters {
            var cacheKeyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cacheKeyParameters)
            for listofstring0 in cacheKeyParameters {
                try cacheKeyParametersContainer.encode(listofstring0)
            }
        }
        if let cacheNamespace = cacheNamespace {
            try encodeContainer.encode(cacheNamespace, forKey: .cacheNamespace)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let connectionType = connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let contentHandling = contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let credentials = credentials {
            try encodeContainer.encode(credentials, forKey: .credentials)
        }
        if let integrationHttpMethod = integrationHttpMethod {
            try encodeContainer.encode(integrationHttpMethod, forKey: .integrationHttpMethod)
        }
        if let passthroughBehavior = passthroughBehavior {
            try encodeContainer.encode(passthroughBehavior, forKey: .passthroughBehavior)
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, mapofstringtostring0) in requestParameters {
                try requestParametersContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestTemplates = requestTemplates {
            var requestTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestTemplates)
            for (dictKey0, mapofstringtostring0) in requestTemplates {
                try requestTemplatesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeoutInMillis = timeoutInMillis {
            try encodeContainer.encode(timeoutInMillis, forKey: .timeoutInMillis)
        }
        if let tlsConfig = tlsConfig {
            try encodeContainer.encode(tlsConfig, forKey: .tlsConfig)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension PutIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

/// Sets up a method's integration.
public struct PutIntegrationInput: Swift.Equatable {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for [Method]requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ([id](https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id)) of the [VpcLink] used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
    ///
    /// * CONVERT_TO_BINARY: Converts a request payload from a Base64-encoded string to the corresponding binary blob.
    ///
    /// * CONVERT_TO_TEXT: Converts a request payload from a binary blob to a Base64-encoded string.
    ///
    ///
    /// If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies whether credentials are required for a put integration.
    public var credentials: Swift.String?
    /// [Required] Specifies a put integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// Specifies a put integration HTTP method. When the integration type is HTTP or AWS, this field is required.
    public var integrationHttpMethod: Swift.String?
    /// Specifies the pass-through behavior for incoming requests based on the Content-Type header in the request, and the available mapping templates specified as the requestTemplates property on the Integration resource. There are three valid values: WHEN_NO_MATCH, WHEN_NO_TEMPLATES, and NEVER.
    ///
    /// * WHEN_NO_MATCH passes the request body for unmapped content types through to the integration back end without transformation.
    ///
    /// * NEVER rejects unmapped content types with an HTTP 415 'Unsupported Media Type' response.
    ///
    /// * WHEN_NO_TEMPLATES allows pass-through when the integration has NO content types mapped to templates. However if there is at least one content type defined, unmapped content types will be rejected with the same 415 response.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// [Required] Specifies a put integration request's resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int?
    public var tlsConfig: ApiGatewayClientTypes.TlsConfig?
    /// [Required] Specifies a put integration input's type.
    /// This member is required.
    public var type: ApiGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
    ///
    /// * For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the [RFC-3986 specification](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier), for either standard integration, where connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For a private HTTP integration, the URI is not used for routing.
    ///
    /// * For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS service for fast host-name lookup. action can be used for an AWS service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an AWS service path-based API. The ensuing service_api refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of [GetObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html), the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init (
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayClientTypes.ConnectionType? = nil,
        contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationHttpMethod: Swift.String? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        timeoutInMillis: Swift.Int? = nil,
        tlsConfig: ApiGatewayClientTypes.TlsConfig? = nil,
        type: ApiGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationHttpMethod = integrationHttpMethod
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct PutIntegrationInputBody: Swift.Equatable {
    let type: ApiGatewayClientTypes.IntegrationType?
    let integrationHttpMethod: Swift.String?
    let uri: Swift.String?
    let connectionType: ApiGatewayClientTypes.ConnectionType?
    let connectionId: Swift.String?
    let credentials: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let passthroughBehavior: Swift.String?
    let cacheNamespace: Swift.String?
    let cacheKeyParameters: [Swift.String]?
    let contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    let timeoutInMillis: Swift.Int?
    let tlsConfig: ApiGatewayClientTypes.TlsConfig?
}

extension PutIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case integrationHttpMethod = "httpMethod"
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let integrationHttpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .integrationHttpMethod)
        integrationHttpMethod = integrationHttpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension PutIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutIntegrationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration. In the API Gateway console, the built-in Lambda integration is an AWS integration. [Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct PutIntegrationOutputResponse: Swift.Equatable {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for [Method]requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ([id](https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id)) of the [VpcLink] used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
    ///
    /// * CONVERT_TO_BINARY: Converts a request payload from a Base64-encoded string to the corresponding binary blob.
    ///
    /// * CONVERT_TO_TEXT: Converts a request payload from a binary blob to a Base64-encoded string.
    ///
    ///
    /// If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported AWS services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    /// Example: Get integration responses of a method
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160607T191449Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns 200 OK status and a payload as follows: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n" }, "statusCode": "200" }[Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
    public var integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following:
    ///
    /// * WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request.
    ///
    /// * WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response.
    ///
    /// * NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: ApiGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following:
    ///
    /// * AWS: for integrating the API method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration.
    ///
    /// * AWS_PROXY: for integrating the API method request with the Lambda function-invoking action with the client request passed through as-is. This integration is also referred to as the Lambda proxy integration.
    ///
    /// * HTTP: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC. This integration is also referred to as the HTTP custom integration.
    ///
    /// * HTTP_PROXY: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC, with the client request passed through as-is. This is also referred to as the HTTP proxy integration.
    ///
    /// * MOCK: for integrating the API method request with API Gateway as a "loop-back" endpoint without invoking any backend.
    ///
    ///
    /// For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a [VpcLink] to connect API Gateway to a network load balancer of a VPC.
    public var type: ApiGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
    ///
    /// * For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the [RFC-3986 specification](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier), for either standard integration, where connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For a private HTTP integration, the URI is not used for routing.
    ///
    /// * For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS service for fast host-name lookup. action can be used for an AWS service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an AWS service path-based API. The ensuing service_api refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of [GetObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html), the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init (
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayClientTypes.ConnectionType? = nil,
        contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: ApiGatewayClientTypes.TlsConfig? = nil,
        type: ApiGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct PutIntegrationOutputResponseBody: Swift.Equatable {
    let type: ApiGatewayClientTypes.IntegrationType?
    let httpMethod: Swift.String?
    let uri: Swift.String?
    let connectionType: ApiGatewayClientTypes.ConnectionType?
    let connectionId: Swift.String?
    let credentials: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let passthroughBehavior: Swift.String?
    let contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    let timeoutInMillis: Swift.Int
    let cacheNamespace: Swift.String?
    let cacheKeyParameters: [Swift.String]?
    let integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]?
    let tlsConfig: ApiGatewayClientTypes.TlsConfig?
}

extension PutIntegrationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [Swift.String:ApiGatewayClientTypes.IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension PutIntegrationResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentHandling = contentHandling {
            try encodeContainer.encode(contentHandling.rawValue, forKey: .contentHandling)
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtostring0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseTemplates = responseTemplates {
            var responseTemplatesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseTemplates)
            for (dictKey0, mapofstringtostring0) in responseTemplates {
                try responseTemplatesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let selectionPattern = selectionPattern {
            try encodeContainer.encode(selectionPattern, forKey: .selectionPattern)
        }
    }
}

extension PutIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Represents a put integration response request.
public struct PutIntegrationResponseInput: Swift.Equatable {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
    ///
    /// * CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.
    ///
    /// * CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.
    ///
    ///
    /// If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    /// [Required] Specifies a put integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] Specifies a put integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name must be a valid and unique response header name and JSON-expression a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Specifies a put integration response's templates.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// Specifies the selection pattern of a put integration response.
    public var selectionPattern: Swift.String?
    /// [Required] Specifies the status code that is used to map the integration response to an existing [MethodResponse].
    /// This member is required.
    public var statusCode: Swift.String?

    public init (
        contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        restApiId: Swift.String? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.restApiId = restApiId
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct PutIntegrationResponseInputBody: Swift.Equatable {
    let selectionPattern: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
}

extension PutIntegrationResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension PutIntegrationResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutIntegrationResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutIntegrationResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutIntegrationResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// Represents an integration response. The status code must map to an existing [MethodResponse], and parameters and templates can be used to transform the back-end response. [Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct PutIntegrationResponseOutputResponse: Swift.Equatable {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
    ///
    /// * CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.
    ///
    /// * CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.
    ///
    ///
    /// If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing [MethodResponse].
    public var statusCode: Swift.String?

    public init (
        contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct PutIntegrationResponseOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.String?
    let selectionPattern: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
}

extension PutIntegrationResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension PutMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if apiKeyRequired != false {
            try encodeContainer.encode(apiKeyRequired, forKey: .apiKeyRequired)
        }
        if let authorizationScopes = authorizationScopes {
            var authorizationScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizationScopes)
            for listofstring0 in authorizationScopes {
                try authorizationScopesContainer.encode(listofstring0)
            }
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType, forKey: .authorizationType)
        }
        if let authorizerId = authorizerId {
            try encodeContainer.encode(authorizerId, forKey: .authorizerId)
        }
        if let operationName = operationName {
            try encodeContainer.encode(operationName, forKey: .operationName)
        }
        if let requestModels = requestModels {
            var requestModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestModels)
            for (dictKey0, mapofstringtostring0) in requestModels {
                try requestModelsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestParameters = requestParameters {
            var requestParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestParameters)
            for (dictKey0, mapofstringtoboolean0) in requestParameters {
                try requestParametersContainer.encode(mapofstringtoboolean0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestValidatorId = requestValidatorId {
            try encodeContainer.encode(requestValidatorId, forKey: .requestValidatorId)
        }
    }
}

extension PutMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Request to add a method to an existing [Resource] resource.
public struct PutMethodInput: Swift.Equatable {
    /// Specifies whether the method required a valid [ApiKey].
    public var apiKeyRequired: Swift.Bool
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// [Required] The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    /// This member is required.
    public var authorizationType: Swift.String?
    /// Specifies the identifier of an [Authorizer] to use on this Method, if the type is CUSTOM or COGNITO_USER_POOLS. The authorizer identifier is generated by API Gateway when you created the authorizer.
    public var authorizerId: Swift.String?
    /// [Required] Specifies the method request's HTTP method type.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// Specifies the [Model] resources used for the request's content type. Request models are represented as a key/value map, with a content type as the key and a [Model] name as the value.
    public var requestModels: [Swift.String:Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key defines a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in [Integration] to be mapped to integration request parameters or body-mapping templates.
    public var requestParameters: [Swift.String:Swift.Bool]?
    /// The identifier of a [RequestValidator] for validating the method request.
    public var requestValidatorId: Swift.String?
    /// [Required] The [Resource] identifier for the new [Method] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        apiKeyRequired: Swift.Bool = false,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct PutMethodInputBody: Swift.Equatable {
    let authorizationType: Swift.String?
    let authorizerId: Swift.String?
    let apiKeyRequired: Swift.Bool
    let operationName: Swift.String?
    let requestParameters: [Swift.String:Swift.Bool]?
    let requestModels: [Swift.String:Swift.String]?
    let requestValidatorId: Swift.String?
    let authorizationScopes: [Swift.String]?
}

extension PutMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension PutMethodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMethodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMethodOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMethodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutMethodOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an [Integration] resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an [Integration] resource. On the other hand, a method response is represented by a [MethodResponse] resource, whereas an integration response is represented by an [IntegrationResponse] resource.
/// Example: Retrive the GET method on a specified resource
///
///
/// Request
///
/// The following example request retrieves the information about the GET method on an API resource (3kzxbg5sa2) of an API (fugvjdxtri). GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160603T210259Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
/// Response
///
/// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html", "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET", "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}", "templated": true } }, "apiKeyRequired": true, "authorizationType": "NONE", "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type": "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")" }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" } } } In the example above, the response template for the 200 OK response maps the JSON output from the ListStreams action in the back end to an XML output. The mapping template is URL-encoded as %3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E and the output is decoded using the [$util.urlDecode()](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference) helper function. [MethodResponse], [Integration], [IntegrationResponse], [Resource], [Set up an API's method](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html)
public struct PutMethodOutputResponse: Swift.Equatable {
    /// A boolean flag specifying whether a valid [ApiKey] is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an [Authorizer] to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    /// Example:
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length: 117 X-Amz-Date: 20160613T213210Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true } ], "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integration:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integration:responses": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "0cjtch", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestTemplates": { "application/json": "{\n \"a\": \"$input.params('operand1')\",\n \"b\": \"$input.params('operand2')\", \n \"op\": \"$input.params('operator')\" \n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.operator": "integration.response.body.op", "method.response.header.operand_2": "integration.response.body.b", "method.response.header.operand_1": "integration.response.body.a" }, "responseTemplates": { "application/json": "#set($res = $input.path('$'))\n{\n \"result\": \"$res.a, $res.b, $res.op => $res.c\",\n \"a\" : \"$res.a\",\n \"b\" : \"$res.b\",\n \"op\" : \"$res.op\",\n \"c\" : \"$res.c\"\n}" }, "selectionPattern": "", "statusCode": "200" } } }[AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-integration.html)
    public var methodIntegration: ApiGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code. The collection of method responses are encapsulated in a key-value map, where the key is a response's HTTP status code and the value is a [MethodResponse] resource that specifies the response returned to the caller from the back end through the integration response.
    /// Example: Get a 200 OK response of a GET method
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length: 117 X-Amz-Date: 20160613T215008Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.operator": false, "method.response.header.operand_2": false, "method.response.header.operand_1": false }, "statusCode": "200" }[AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-method-response.html)
    public var methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by [Model] resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String:Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in [Integration] to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String:Swift.Bool]?
    /// The identifier of a [RequestValidator] for request validation.
    public var requestValidatorId: Swift.String?

    public init (
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: ApiGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct PutMethodOutputResponseBody: Swift.Equatable {
    let httpMethod: Swift.String?
    let authorizationType: Swift.String?
    let authorizerId: Swift.String?
    let apiKeyRequired: Swift.Bool?
    let requestValidatorId: Swift.String?
    let operationName: Swift.String?
    let requestParameters: [Swift.String:Swift.Bool]?
    let requestModels: [Swift.String:Swift.String]?
    let methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]?
    let methodIntegration: ApiGatewayClientTypes.Integration?
    let authorizationScopes: [Swift.String]?
}

extension PutMethodOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [Swift.String:ApiGatewayClientTypes.MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [Swift.String:ApiGatewayClientTypes.MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension PutMethodResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let responseModels = responseModels {
            var responseModelsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseModels)
            for (dictKey0, mapofstringtostring0) in responseModels {
                try responseModelsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let responseParameters = responseParameters {
            var responseParametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .responseParameters)
            for (dictKey0, mapofstringtoboolean0) in responseParameters {
                try responseParametersContainer.encode(mapofstringtoboolean0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension PutMethodResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Request to add a [MethodResponse] to an existing [Method] resource.
public struct PutMethodResponseInput: Swift.Equatable {
    /// [Required] The HTTP verb of the [Method] resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// [Required] The [Resource] identifier for the [Method] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// Specifies the [Model] resources used for the response's content type. Response models are represented as a key/value map, with a content type as the key and a [Model] name as the value.
    public var responseModels: [Swift.String:Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header name and the associated value is a Boolean flag indicating whether the method response parameter is required or not. The method response header names must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The response parameter names defined here are available in the integration response to be mapped from an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String:Swift.Bool]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The method response's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:Swift.Bool]? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.resourceId = resourceId
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct PutMethodResponseInputBody: Swift.Equatable {
    let responseParameters: [Swift.String:Swift.Bool]?
    let responseModels: [Swift.String:Swift.String]?
}

extension PutMethodResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension PutMethodResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMethodResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMethodResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMethodResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutMethodResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
/// Example: A MethodResponse instance of an API
///
///
/// Request
///
/// The example request retrieves a MethodResponse of the 200 status code. GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160603T222952Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
/// Response
///
/// The successful response returns 200 OK status and a payload as follows: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" }[Method], [IntegrationResponse], [Integration][Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct PutMethodResponseOutputResponse: Swift.Equatable {
    /// Specifies the [Model] resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a [Model] name as the value.
    public var responseModels: [Swift.String:Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's [IntegrationResponse]. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String:Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init (
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct PutMethodResponseOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.Bool]?
    let responseModels: [Swift.String:Swift.String]?
}

extension PutMethodResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension ApiGatewayClientTypes {
    public enum PutMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case merge
        case overwrite
        case sdkUnknown(Swift.String)

        public static var allCases: [PutMode] {
            return [
                .merge,
                .overwrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .merge: return "merge"
            case .overwrite: return "overwrite"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PutMode(rawValue: rawValue) ?? PutMode.sdkUnknown(rawValue)
        }
    }
}

public struct PutRestApiInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRestApiInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRestApiInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PutRestApiOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let body = input.operationInput.body {
            let bodydata = body
            let bodybody = ClientRuntime.HttpBody.data(bodydata)
            input.builder.withBody(bodybody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRestApiInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRestApiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PutRestApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

extension PutRestApiInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let mode = mode {
            let modeQueryItem = ClientRuntime.URLQueryItem(name: "mode".urlPercentEncoding(), value: Swift.String(mode.rawValue).urlPercentEncoding())
            items.append(modeQueryItem)
        }
        if failOnWarnings != false {
            let failOnWarningsQueryItem = ClientRuntime.URLQueryItem(name: "failonwarnings".urlPercentEncoding(), value: Swift.String(failOnWarnings).urlPercentEncoding())
            items.append(failOnWarningsQueryItem)
        }
        if let parameters = parameters {
            let currentQueryItemNames = items.map({$0.name})
            parameters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    let queryItem = ClientRuntime.URLQueryItem(name: key0.urlPercentEncoding(), value: value0.urlPercentEncoding())
                    items.append(queryItem)
                }
            }
        }
        return items
    }
}

extension PutRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

/// A PUT request to update an existing API, with external API definitions specified as the request body.
public struct PutRestApiInput: Swift.Equatable {
    /// [Required] The PUT request body containing external API definitions. Currently, only OpenAPI definition JSON/YAML files are supported. The maximum size of the API definition file is 6MB.
    /// This member is required.
    public var body: ClientRuntime.Data?
    /// A query parameter to indicate whether to rollback the API update (true) or not (false) when a warning is encountered. The default value is false.
    public var failOnWarnings: Swift.Bool
    /// The mode query parameter to specify the update mode. Valid values are "merge" and "overwrite". By default, the update mode is "merge".
    public var mode: ApiGatewayClientTypes.PutMode?
    /// Custom header parameters as part of the request. For example, to exclude [DocumentationParts] from an imported API, set ignore=documentation as a parameters value, as in the AWS CLI command of aws apigateway import-rest-api --parameters ignore=documentation --body 'file:///path/to/imported-api-body.json'.
    public var parameters: [Swift.String:Swift.String]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        body: ClientRuntime.Data? = nil,
        failOnWarnings: Swift.Bool = false,
        mode: ApiGatewayClientTypes.PutMode? = nil,
        parameters: [Swift.String:Swift.String]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.body = body
        self.failOnWarnings = failOnWarnings
        self.mode = mode
        self.parameters = parameters
        self.restApiId = restApiId
    }
}

struct PutRestApiInputBody: Swift.Equatable {
    let body: ClientRuntime.Data?
}

extension PutRestApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension PutRestApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRestApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRestApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRestApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRestApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct PutRestApiOutputResponse: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are:
    ///
    /// * HEADER to read the API key from the X-API-Key header of a request.
    ///
    /// * AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the [RestApi]. By default, the [RestApi] supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this [RestApi] showing the endpoint types of the API.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and [Method] configuration.
    public var policy: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiKeySource: ApiGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct PutRestApiOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
}

extension PutRestApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension ApiGatewayClientTypes {
    public enum QuotaPeriodType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case month
        case week
        case sdkUnknown(Swift.String)

        public static var allCases: [QuotaPeriodType] {
            return [
                .day,
                .month,
                .week,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .month: return "MONTH"
            case .week: return "WEEK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QuotaPeriodType(rawValue: rawValue) ?? QuotaPeriodType.sdkUnknown(rawValue)
        }
    }
}

extension ApiGatewayClientTypes.QuotaSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit
        case offset
        case period
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if limit != 0 {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if offset != 0 {
            try encodeContainer.encode(offset, forKey: .offset)
        }
        if let period = period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let limitDecoded = try containerValues.decode(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let offsetDecoded = try containerValues.decode(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
        let periodDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.QuotaPeriodType.self, forKey: .period)
        period = periodDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Quotas configured for a usage plan.
    public struct QuotaSettings: Swift.Equatable {
        /// The maximum number of requests that can be made in a given time period.
        public var limit: Swift.Int
        /// The day that a time period starts. For example, with a time period of WEEK, an offset of 0 starts on Sunday, and an offset of 1 starts on Monday.
        public var offset: Swift.Int
        /// The time period in which the limit applies. Valid values are "DAY", "WEEK" or "MONTH".
        public var period: ApiGatewayClientTypes.QuotaPeriodType?

        public init (
            limit: Swift.Int = 0,
            offset: Swift.Int = 0,
            period: ApiGatewayClientTypes.QuotaPeriodType? = nil
        )
        {
            self.limit = limit
            self.offset = offset
            self.period = period
        }
    }

}

extension ApiGatewayClientTypes.RequestValidator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if validateRequestBody != false {
            try encodeContainer.encode(validateRequestBody, forKey: .validateRequestBody)
        }
        if validateRequestParameters != false {
            try encodeContainer.encode(validateRequestParameters, forKey: .validateRequestParameters)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension ApiGatewayClientTypes {
    /// A set of validation rules for incoming [Method] requests. In OpenAPI, a [RequestValidator] of an API is defined by the [x-amazon-apigateway-request-validators.requestValidator](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html) object. It the referenced using the [x-amazon-apigateway-request-validator](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator) property. [Enable Basic Request Validation in API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html)
    public struct RequestValidator: Swift.Equatable {
        /// The identifier of this [RequestValidator].
        public var id: Swift.String?
        /// The name of this [RequestValidator]
        public var name: Swift.String?
        /// A Boolean flag to indicate whether to validate a request body according to the configured [Model] schema.
        public var validateRequestBody: Swift.Bool
        /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
        public var validateRequestParameters: Swift.Bool

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            validateRequestBody: Swift.Bool = false,
            validateRequestParameters: Swift.Bool = false
        )
        {
            self.id = id
            self.name = name
            self.validateRequestBody = validateRequestBody
            self.validateRequestParameters = validateRequestParameters
        }
    }

}

extension ApiGatewayClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parentId = parentId {
            try encodeContainer.encode(parentId, forKey: .parentId)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let pathPart = pathPart {
            try encodeContainer.encode(pathPart, forKey: .pathPart)
        }
        if let resourceMethods = resourceMethods {
            var resourceMethodsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceMethods)
            for (dictKey0, mapofmethod0) in resourceMethods {
                try resourceMethodsContainer.encode(mapofmethod0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [Swift.String:ApiGatewayClientTypes.Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [Swift.String:ApiGatewayClientTypes.Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// Represents an API resource. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
    public struct Resource: Swift.Equatable {
        /// The resource's identifier.
        public var id: Swift.String?
        /// The parent resource's identifier.
        public var parentId: Swift.String?
        /// The full path for this resource.
        public var path: Swift.String?
        /// The last path segment for this resource.
        public var pathPart: Swift.String?
        /// Gets an API resource's method of a given HTTP verb. The resource methods are a map of methods indexed by methods' HTTP verbs enabled on the resource. This method map is included in the 200 OK response of the GET /restapis/{restapi_id}/resources/{resource_id} or GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods request.
        /// Example: Get the GET method of an API resource
        ///
        ///
        /// Request
        ///
        ///
        ///     GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20170223T031827Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
        ///
        ///
        /// Response
        ///
        /// { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html", "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET", "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}", "templated": true } }, "apiKeyRequired": false, "authorizationType": "NONE", "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type": "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n" }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" } } } If the OPTIONS is enabled on the resource, you can follow the example here to get that method. Just replace the GET of the last path segment in the request URL with OPTIONS.
        public var resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]?

        public init (
            id: Swift.String? = nil,
            parentId: Swift.String? = nil,
            path: Swift.String? = nil,
            pathPart: Swift.String? = nil,
            resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]? = nil
        )
        {
            self.id = id
            self.parentId = parentId
            self.path = path
            self.pathPart = pathPart
            self.resourceMethods = resourceMethods
        }
    }

}

extension ApiGatewayClientTypes.RestApi: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeySource = apiKeySource {
            try encodeContainer.encode(apiKeySource.rawValue, forKey: .apiKeySource)
        }
        if let binaryMediaTypes = binaryMediaTypes {
            var binaryMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .binaryMediaTypes)
            for listofstring0 in binaryMediaTypes {
                try binaryMediaTypesContainer.encode(listofstring0)
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableExecuteApiEndpoint != false {
            try encodeContainer.encode(disableExecuteApiEndpoint, forKey: .disableExecuteApiEndpoint)
        }
        if let endpointConfiguration = endpointConfiguration {
            try encodeContainer.encode(endpointConfiguration, forKey: .endpointConfiguration)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let minimumCompressionSize = minimumCompressionSize {
            try encodeContainer.encode(minimumCompressionSize, forKey: .minimumCompressionSize)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let warnings = warnings {
            var warningsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .warnings)
            for listofstring0 in warnings {
                try warningsContainer.encode(listofstring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents a REST API. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
    public struct RestApi: Swift.Equatable {
        /// The source of the API key for metering requests according to a usage plan. Valid values are:
        ///
        /// * HEADER to read the API key from the X-API-Key header of a request.
        ///
        /// * AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
        public var apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
        /// The list of binary media types supported by the [RestApi]. By default, the [RestApi] supports only UTF-8-encoded text payloads.
        public var binaryMediaTypes: [Swift.String]?
        /// The timestamp when the API was created.
        public var createdDate: ClientRuntime.Date?
        /// The API's description.
        public var description: Swift.String?
        /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
        public var disableExecuteApiEndpoint: Swift.Bool
        /// The endpoint configuration of this [RestApi] showing the endpoint types of the API.
        public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
        /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
        public var id: Swift.String?
        /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
        public var minimumCompressionSize: Swift.Int?
        /// The API's name.
        public var name: Swift.String?
        /// A stringified JSON policy document that applies to this RestApi regardless of the caller and [Method] configuration.
        public var policy: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// A version identifier for the API.
        public var version: Swift.String?
        /// The warning messages reported when failonwarnings is turned on during API import.
        public var warnings: [Swift.String]?

        public init (
            apiKeySource: ApiGatewayClientTypes.ApiKeySourceType? = nil,
            binaryMediaTypes: [Swift.String]? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            disableExecuteApiEndpoint: Swift.Bool = false,
            endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
            id: Swift.String? = nil,
            minimumCompressionSize: Swift.Int? = nil,
            name: Swift.String? = nil,
            policy: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            version: Swift.String? = nil,
            warnings: [Swift.String]? = nil
        )
        {
            self.apiKeySource = apiKeySource
            self.binaryMediaTypes = binaryMediaTypes
            self.createdDate = createdDate
            self.description = description
            self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
            self.endpointConfiguration = endpointConfiguration
            self.id = id
            self.minimumCompressionSize = minimumCompressionSize
            self.name = name
            self.policy = policy
            self.tags = tags
            self.version = version
            self.warnings = warnings
        }
    }

}

extension ApiGatewayClientTypes.SdkConfigurationProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case friendlyName
        case name
        case `required` = "required"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let requiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension ApiGatewayClientTypes {
    /// A configuration property of an SDK type.
    public struct SdkConfigurationProperty: Swift.Equatable {
        /// The default value of an [SdkType] configuration property.
        public var defaultValue: Swift.String?
        /// The description of an [SdkType] configuration property.
        public var description: Swift.String?
        /// The user-friendly name of an [SdkType] configuration property.
        public var friendlyName: Swift.String?
        /// The name of a an [SdkType] configuration property.
        public var name: Swift.String?
        /// A boolean flag of an [SdkType] configuration property to indicate if the associated SDK configuration property is required (true) or not (false).
        public var `required`: Swift.Bool

        public init (
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            name: Swift.String? = nil,
            `required`: Swift.Bool = false
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.friendlyName = friendlyName
            self.name = name
            self.`required` = `required`
        }
    }

}

extension ApiGatewayClientTypes.SdkType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProperties
        case description
        case friendlyName
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationProperties = configurationProperties {
            var configurationPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationProperties)
            for listofsdkconfigurationproperty0 in configurationProperties {
                try configurationPropertiesContainer.encode(listofsdkconfigurationproperty0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let friendlyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configurationPropertiesContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.SdkConfigurationProperty?].self, forKey: .configurationProperties)
        var configurationPropertiesDecoded0:[ApiGatewayClientTypes.SdkConfigurationProperty]? = nil
        if let configurationPropertiesContainer = configurationPropertiesContainer {
            configurationPropertiesDecoded0 = [ApiGatewayClientTypes.SdkConfigurationProperty]()
            for structure0 in configurationPropertiesContainer {
                if let structure0 = structure0 {
                    configurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        configurationProperties = configurationPropertiesDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// A type of SDK that API Gateway can generate.
    public struct SdkType: Swift.Equatable {
        /// A list of configuration properties of an [SdkType].
        public var configurationProperties: [ApiGatewayClientTypes.SdkConfigurationProperty]?
        /// The description of an [SdkType].
        public var description: Swift.String?
        /// The user-friendly name of an [SdkType] instance.
        public var friendlyName: Swift.String?
        /// The identifier of an [SdkType] instance.
        public var id: Swift.String?

        public init (
            configurationProperties: [ApiGatewayClientTypes.SdkConfigurationProperty]? = nil,
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.configurationProperties = configurationProperties
            self.description = description
            self.friendlyName = friendlyName
            self.id = id
        }
    }

}

extension ApiGatewayClientTypes {
    public enum SecurityPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case tls10
        case tls12
        case sdkUnknown(Swift.String)

        public static var allCases: [SecurityPolicy] {
            return [
                .tls10,
                .tls12,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .tls10: return "TLS_1_0"
            case .tls12: return "TLS_1_2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SecurityPolicy(rawValue: rawValue) ?? SecurityPolicy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested service is not available. For details see the accompanying error message. Retry after the specified time period.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayClientTypes.Stage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLogSettings = accessLogSettings {
            try encodeContainer.encode(accessLogSettings, forKey: .accessLogSettings)
        }
        if cacheClusterEnabled != false {
            try encodeContainer.encode(cacheClusterEnabled, forKey: .cacheClusterEnabled)
        }
        if let cacheClusterSize = cacheClusterSize {
            try encodeContainer.encode(cacheClusterSize.rawValue, forKey: .cacheClusterSize)
        }
        if let cacheClusterStatus = cacheClusterStatus {
            try encodeContainer.encode(cacheClusterStatus.rawValue, forKey: .cacheClusterStatus)
        }
        if let canarySettings = canarySettings {
            try encodeContainer.encode(canarySettings, forKey: .canarySettings)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate.timeIntervalSince1970, forKey: .createdDate)
        }
        if let deploymentId = deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let documentationVersion = documentationVersion {
            try encodeContainer.encode(documentationVersion, forKey: .documentationVersion)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate.timeIntervalSince1970, forKey: .lastUpdatedDate)
        }
        if let methodSettings = methodSettings {
            var methodSettingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .methodSettings)
            for (dictKey0, mapofmethodsettings0) in methodSettings {
                try methodSettingsContainer.encode(mapofmethodsettings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if tracingEnabled != false {
            try encodeContainer.encode(tracingEnabled, forKey: .tracingEnabled)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, mapofstringtostring0) in variables {
                try variablesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let webAclArn = webAclArn {
            try encodeContainer.encode(webAclArn, forKey: .webAclArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [Swift.String:ApiGatewayClientTypes.MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [Swift.String:ApiGatewayClientTypes.MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents a unique identifier for a version of a deployed [RestApi] that is callable by users. [Deploy an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html)
    public struct Stage: Swift.Equatable {
        /// Settings for logging access in this stage.
        public var accessLogSettings: ApiGatewayClientTypes.AccessLogSettings?
        /// Specifies whether a cache cluster is enabled for the stage.
        public var cacheClusterEnabled: Swift.Bool
        /// The size of the cache cluster for the stage, if enabled.
        public var cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
        /// The status of the cache cluster for the stage, if enabled.
        public var cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus?
        /// Settings for the canary deployment in this stage.
        public var canarySettings: ApiGatewayClientTypes.CanarySettings?
        /// The identifier of a client certificate for an API stage.
        public var clientCertificateId: Swift.String?
        /// The timestamp when the stage was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier of the [Deployment] that the stage points to.
        public var deploymentId: Swift.String?
        /// The stage's description.
        public var description: Swift.String?
        /// The version of the associated API documentation.
        public var documentationVersion: Swift.String?
        /// The timestamp when the stage last updated.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// A map that defines the method settings for a [Stage] resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
        public var methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]?
        /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
        public var stageName: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether active tracing with X-ray is enabled for the [Stage].
        public var tracingEnabled: Swift.Bool
        /// A map that defines the stage variables for a [Stage] resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
        public var variables: [Swift.String:Swift.String]?
        /// The ARN of the WebAcl associated with the [Stage].
        public var webAclArn: Swift.String?

        public init (
            accessLogSettings: ApiGatewayClientTypes.AccessLogSettings? = nil,
            cacheClusterEnabled: Swift.Bool = false,
            cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize? = nil,
            cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus? = nil,
            canarySettings: ApiGatewayClientTypes.CanarySettings? = nil,
            clientCertificateId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            deploymentId: Swift.String? = nil,
            description: Swift.String? = nil,
            documentationVersion: Swift.String? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]? = nil,
            stageName: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            tracingEnabled: Swift.Bool = false,
            variables: [Swift.String:Swift.String]? = nil,
            webAclArn: Swift.String? = nil
        )
        {
            self.accessLogSettings = accessLogSettings
            self.cacheClusterEnabled = cacheClusterEnabled
            self.cacheClusterSize = cacheClusterSize
            self.cacheClusterStatus = cacheClusterStatus
            self.canarySettings = canarySettings
            self.clientCertificateId = clientCertificateId
            self.createdDate = createdDate
            self.deploymentId = deploymentId
            self.description = description
            self.documentationVersion = documentationVersion
            self.lastUpdatedDate = lastUpdatedDate
            self.methodSettings = methodSettings
            self.stageName = stageName
            self.tags = tags
            self.tracingEnabled = tracingEnabled
            self.variables = variables
            self.webAclArn = webAclArn
        }
    }

}

extension ApiGatewayClientTypes.StageKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restApiId
        case stageName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let restApiId = restApiId {
            try encodeContainer.encode(restApiId, forKey: .restApiId)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
    }
}

extension ApiGatewayClientTypes {
    /// A reference to a unique stage identified in the format {restApiId}/{stage}.
    public struct StageKey: Swift.Equatable {
        /// The string identifier of the associated [RestApi].
        public var restApiId: Swift.String?
        /// The stage name associated with the stage key.
        public var stageName: Swift.String?

        public init (
            restApiId: Swift.String? = nil,
            stageName: Swift.String? = nil
        )
        {
            self.restApiId = restApiId
            self.stageName = stageName
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Adds or updates a tag on a given resource.
public struct TagResourceInput: Swift.Equatable {
    /// [Required] The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// [Required] The key-value map of strings. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension TestInvokeAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalContext
        case body
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalContext = additionalContext {
            var additionalContextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .additionalContext)
            for (dictKey0, mapofstringtostring0) in additionalContext {
                try additionalContextContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headers)
            for (dictKey0, mapofstringtostring0) in headers {
                try headersContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let multiValueHeaders = multiValueHeaders {
            var multiValueHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .multiValueHeaders)
            for (dictKey0, mapofstringtolist0) in multiValueHeaders {
                try multiValueHeadersContainer.encode(mapofstringtolist0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let pathWithQueryString = pathWithQueryString {
            try encodeContainer.encode(pathWithQueryString, forKey: .pathWithQueryString)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, mapofstringtostring0) in stageVariables {
                try stageVariablesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TestInvokeAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Make a request to simulate the execution of an [Authorizer].
public struct TestInvokeAuthorizerInput: Swift.Equatable {
    /// [Optional] A key-value map of additional context variables.
    public var additionalContext: [Swift.String:Swift.String]?
    /// [Required] Specifies a test invoke authorizer request's [Authorizer] ID.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// [Optional] The simulated request body of an incoming invocation request.
    public var body: Swift.String?
    /// [Required] A key-value map of headers to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, should be specified.
    public var headers: [Swift.String:Swift.String]?
    /// [Optional] The headers as a map from string to list of values to simulate an incoming invocation request. This is where the incoming authorization token, or identity source, may be specified.
    public var multiValueHeaders: [Swift.String:[Swift.String]]?
    /// [Optional] The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.
    public var pathWithQueryString: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// A key-value map of stage variables to simulate an invocation on a deployed [Stage].
    public var stageVariables: [Swift.String:Swift.String]?

    public init (
        additionalContext: [Swift.String:Swift.String]? = nil,
        authorizerId: Swift.String? = nil,
        body: Swift.String? = nil,
        headers: [Swift.String:Swift.String]? = nil,
        multiValueHeaders: [Swift.String:[Swift.String]]? = nil,
        pathWithQueryString: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil
    )
    {
        self.additionalContext = additionalContext
        self.authorizerId = authorizerId
        self.body = body
        self.headers = headers
        self.multiValueHeaders = multiValueHeaders
        self.pathWithQueryString = pathWithQueryString
        self.restApiId = restApiId
        self.stageVariables = stageVariables
    }
}

struct TestInvokeAuthorizerInputBody: Swift.Equatable {
    let headers: [Swift.String:Swift.String]?
    let multiValueHeaders: [Swift.String:[Swift.String]]?
    let pathWithQueryString: Swift.String?
    let body: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
    let additionalContext: [Swift.String:Swift.String]?
}

extension TestInvokeAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalContext
        case body
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headers)
        var headersDecoded0: [Swift.String:Swift.String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [Swift.String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [Swift.String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let pathWithQueryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathWithQueryString)
        pathWithQueryString = pathWithQueryStringDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in stageVariablesContainer {
                if let string0 = string0 {
                    stageVariablesDecoded0?[key0] = string0
                }
            }
        }
        stageVariables = stageVariablesDecoded0
        let additionalContextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .additionalContext)
        var additionalContextDecoded0: [Swift.String:Swift.String]? = nil
        if let additionalContextContainer = additionalContextContainer {
            additionalContextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in additionalContextContainer {
                if let string0 = string0 {
                    additionalContextDecoded0?[key0] = string0
                }
            }
        }
        additionalContext = additionalContextDecoded0
    }
}

extension TestInvokeAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestInvokeAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestInvokeAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestInvokeAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestInvokeAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorization = output.authorization
            self.claims = output.claims
            self.clientStatus = output.clientStatus
            self.latency = output.latency
            self.log = output.log
            self.policy = output.policy
            self.principalId = output.principalId
        } else {
            self.authorization = nil
            self.claims = nil
            self.clientStatus = 0
            self.latency = 0
            self.log = nil
            self.policy = nil
            self.principalId = nil
        }
    }
}

/// Represents the response of the test invoke request for a custom [Authorizer]
public struct TestInvokeAuthorizerOutputResponse: Swift.Equatable {
    public var authorization: [Swift.String:[Swift.String]]?
    /// The [open identity claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims), with any supported custom attributes, returned from the Cognito Your User Pool configured for the API.
    public var claims: [Swift.String:Swift.String]?
    /// The HTTP status code that the client would have received. Value is 0 if the authorizer succeeded.
    public var clientStatus: Swift.Int
    /// The execution latency of the test authorizer request.
    public var latency: Swift.Int
    /// The API Gateway execution log for the test authorizer request.
    public var log: Swift.String?
    /// The JSON policy document returned by the [Authorizer]
    public var policy: Swift.String?
    /// The principal identity returned by the [Authorizer]
    public var principalId: Swift.String?

    public init (
        authorization: [Swift.String:[Swift.String]]? = nil,
        claims: [Swift.String:Swift.String]? = nil,
        clientStatus: Swift.Int = 0,
        latency: Swift.Int = 0,
        log: Swift.String? = nil,
        policy: Swift.String? = nil,
        principalId: Swift.String? = nil
    )
    {
        self.authorization = authorization
        self.claims = claims
        self.clientStatus = clientStatus
        self.latency = latency
        self.log = log
        self.policy = policy
        self.principalId = principalId
    }
}

struct TestInvokeAuthorizerOutputResponseBody: Swift.Equatable {
    let clientStatus: Swift.Int
    let log: Swift.String?
    let latency: Swift.Int
    let principalId: Swift.String?
    let policy: Swift.String?
    let authorization: [Swift.String:[Swift.String]]?
    let claims: [Swift.String:Swift.String]?
}

extension TestInvokeAuthorizerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorization
        case claims
        case clientStatus
        case latency
        case log
        case policy
        case principalId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientStatusDecoded = try containerValues.decode(Swift.Int.self, forKey: .clientStatus)
        clientStatus = clientStatusDecoded
        let logDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .log)
        log = logDecoded
        let latencyDecoded = try containerValues.decode(Swift.Int.self, forKey: .latency)
        latency = latencyDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let authorizationContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .authorization)
        var authorizationDecoded0: [Swift.String:[Swift.String]]? = nil
        if let authorizationContainer = authorizationContainer {
            authorizationDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstring0) in authorizationContainer {
                var listofstring0Decoded0: [Swift.String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [Swift.String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                authorizationDecoded0?[key0] = listofstring0Decoded0
            }
        }
        authorization = authorizationDecoded0
        let claimsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .claims)
        var claimsDecoded0: [Swift.String:Swift.String]? = nil
        if let claimsContainer = claimsContainer {
            claimsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in claimsContainer {
                if let string0 = string0 {
                    claimsDecoded0?[key0] = string0
                }
            }
        }
        claims = claimsDecoded0
    }
}

extension TestInvokeMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case clientCertificateId
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let clientCertificateId = clientCertificateId {
            try encodeContainer.encode(clientCertificateId, forKey: .clientCertificateId)
        }
        if let headers = headers {
            var headersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headers)
            for (dictKey0, mapofstringtostring0) in headers {
                try headersContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let multiValueHeaders = multiValueHeaders {
            var multiValueHeadersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .multiValueHeaders)
            for (dictKey0, mapofstringtolist0) in multiValueHeaders {
                try multiValueHeadersContainer.encode(mapofstringtolist0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let pathWithQueryString = pathWithQueryString {
            try encodeContainer.encode(pathWithQueryString, forKey: .pathWithQueryString)
        }
        if let stageVariables = stageVariables {
            var stageVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stageVariables)
            for (dictKey0, mapofstringtostring0) in stageVariables {
                try stageVariablesContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TestInvokeMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Make a request to simulate the execution of a [Method].
public struct TestInvokeMethodInput: Swift.Equatable {
    /// The simulated request body of an incoming invocation request.
    public var body: Swift.String?
    /// A [ClientCertificate] identifier to use in the test invocation. API Gateway will use the certificate when making the HTTPS request to the defined back-end endpoint.
    public var clientCertificateId: Swift.String?
    /// A key-value map of headers to simulate an incoming invocation request.
    public var headers: [Swift.String:Swift.String]?
    /// [Required] Specifies a test invoke method request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// The headers as a map from string to list of values to simulate an incoming invocation request.
    public var multiValueHeaders: [Swift.String:[Swift.String]]?
    /// The URI path, including query string, of the simulated invocation request. Use this to specify path parameters and query string parameters.
    public var pathWithQueryString: Swift.String?
    /// [Required] Specifies a test invoke method request's resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// A key-value map of stage variables to simulate an invocation on a deployed [Stage].
    public var stageVariables: [Swift.String:Swift.String]?

    public init (
        body: Swift.String? = nil,
        clientCertificateId: Swift.String? = nil,
        headers: [Swift.String:Swift.String]? = nil,
        httpMethod: Swift.String? = nil,
        multiValueHeaders: [Swift.String:[Swift.String]]? = nil,
        pathWithQueryString: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stageVariables: [Swift.String:Swift.String]? = nil
    )
    {
        self.body = body
        self.clientCertificateId = clientCertificateId
        self.headers = headers
        self.httpMethod = httpMethod
        self.multiValueHeaders = multiValueHeaders
        self.pathWithQueryString = pathWithQueryString
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.stageVariables = stageVariables
    }
}

struct TestInvokeMethodInputBody: Swift.Equatable {
    let pathWithQueryString: Swift.String?
    let body: Swift.String?
    let headers: [Swift.String:Swift.String]?
    let multiValueHeaders: [Swift.String:[Swift.String]]?
    let clientCertificateId: Swift.String?
    let stageVariables: [Swift.String:Swift.String]?
}

extension TestInvokeMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case clientCertificateId
        case headers
        case multiValueHeaders
        case pathWithQueryString
        case stageVariables
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathWithQueryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathWithQueryString)
        pathWithQueryString = pathWithQueryStringDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let headersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headers)
        var headersDecoded0: [Swift.String:Swift.String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [Swift.String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [Swift.String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stageVariables)
        var stageVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let stageVariablesContainer = stageVariablesContainer {
            stageVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in stageVariablesContainer {
                if let string0 = string0 {
                    stageVariablesDecoded0?[key0] = string0
                }
            }
        }
        stageVariables = stageVariablesDecoded0
    }
}

extension TestInvokeMethodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestInvokeMethodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestInvokeMethodOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestInvokeMethodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TestInvokeMethodOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.body = output.body
            self.headers = output.headers
            self.latency = output.latency
            self.log = output.log
            self.multiValueHeaders = output.multiValueHeaders
            self.status = output.status
        } else {
            self.body = nil
            self.headers = nil
            self.latency = 0
            self.log = nil
            self.multiValueHeaders = nil
            self.status = 0
        }
    }
}

/// Represents the response of the test invoke request in the HTTP method. [Test API using the API Gateway console](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-test-method.html#how-to-test-method-console)
public struct TestInvokeMethodOutputResponse: Swift.Equatable {
    /// The body of the HTTP response.
    public var body: Swift.String?
    /// The headers of the HTTP response.
    public var headers: [Swift.String:Swift.String]?
    /// The execution latency of the test invoke request.
    public var latency: Swift.Int
    /// The API Gateway execution log for the test invoke request.
    public var log: Swift.String?
    /// The headers of the HTTP response as a map from string to list of values.
    public var multiValueHeaders: [Swift.String:[Swift.String]]?
    /// The HTTP status code.
    public var status: Swift.Int

    public init (
        body: Swift.String? = nil,
        headers: [Swift.String:Swift.String]? = nil,
        latency: Swift.Int = 0,
        log: Swift.String? = nil,
        multiValueHeaders: [Swift.String:[Swift.String]]? = nil,
        status: Swift.Int = 0
    )
    {
        self.body = body
        self.headers = headers
        self.latency = latency
        self.log = log
        self.multiValueHeaders = multiValueHeaders
        self.status = status
    }
}

struct TestInvokeMethodOutputResponseBody: Swift.Equatable {
    let status: Swift.Int
    let body: Swift.String?
    let headers: [Swift.String:Swift.String]?
    let multiValueHeaders: [Swift.String:[Swift.String]]?
    let log: Swift.String?
    let latency: Swift.Int
}

extension TestInvokeMethodOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case body
        case headers
        case latency
        case log
        case multiValueHeaders
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Swift.Int.self, forKey: .status)
        status = statusDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .body)
        body = bodyDecoded
        let headersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headers)
        var headersDecoded0: [Swift.String:Swift.String]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in headersContainer {
                if let string0 = string0 {
                    headersDecoded0?[key0] = string0
                }
            }
        }
        headers = headersDecoded0
        let multiValueHeadersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .multiValueHeaders)
        var multiValueHeadersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let multiValueHeadersContainer = multiValueHeadersContainer {
            multiValueHeadersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstring0) in multiValueHeadersContainer {
                var listofstring0Decoded0: [Swift.String]? = nil
                if let listofstring0 = listofstring0 {
                    listofstring0Decoded0 = [Swift.String]()
                    for string1 in listofstring0 {
                        if let string1 = string1 {
                            listofstring0Decoded0?.append(string1)
                        }
                    }
                }
                multiValueHeadersDecoded0?[key0] = listofstring0Decoded0
            }
        }
        multiValueHeaders = multiValueHeadersDecoded0
        let logDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .log)
        log = logDecoded
        let latencyDecoded = try containerValues.decode(Swift.Int.self, forKey: .latency)
        latency = latencyDecoded
    }
}

extension ApiGatewayClientTypes.ThrottleSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case burstLimit
        case rateLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if burstLimit != 0 {
            try encodeContainer.encode(burstLimit, forKey: .burstLimit)
        }
        if rateLimit != 0.0 {
            try encodeContainer.encode(rateLimit, forKey: .rateLimit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let burstLimitDecoded = try containerValues.decode(Swift.Int.self, forKey: .burstLimit)
        burstLimit = burstLimitDecoded
        let rateLimitDecoded = try containerValues.decode(Swift.Double.self, forKey: .rateLimit)
        rateLimit = rateLimitDecoded
    }
}

extension ApiGatewayClientTypes {
    /// The API request rate limits.
    public struct ThrottleSettings: Swift.Equatable {
        /// The API request burst limit, the maximum rate limit over a time ranging from one to a few seconds, depending upon whether the underlying token bucket is at its full capacity.
        public var burstLimit: Swift.Int
        /// The API request steady-state rate limit.
        public var rateLimit: Swift.Double

        public init (
            burstLimit: Swift.Int = 0,
            rateLimit: Swift.Double = 0.0
        )
        {
            self.burstLimit = burstLimit
            self.rateLimit = rateLimit
        }
    }

}

extension ApiGatewayClientTypes.TlsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case insecureSkipVerification
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if insecureSkipVerification != false {
            try encodeContainer.encode(insecureSkipVerification, forKey: .insecureSkipVerification)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insecureSkipVerificationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .insecureSkipVerification)
        insecureSkipVerification = insecureSkipVerificationDecoded
    }
}

extension ApiGatewayClientTypes {
    public struct TlsConfig: Swift.Equatable {
        /// Specifies whether or not API Gateway skips verification that the certificate for an integration endpoint is issued by a [supported certificate authority](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-supported-certificate-authorities-for-http-endpoints.html). This isnt recommended, but it enables you to use certificates that are signed by private certificate authorities, or certificates that are self-signed. If enabled, API Gateway still performs basic certificate validation, which includes checking the certificate's expiration date, hostname, and presence of a root certificate authority. Supported only for HTTP and HTTP_PROXY integrations.
        public var insecureSkipVerification: Swift.Bool

        public init (
            insecureSkipVerification: Swift.Bool = false
        )
        {
            self.insecureSkipVerification = insecureSkipVerification
        }
    }

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request has reached its throttling limit. Retry after the specified time period.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApiGatewayClientTypes {
    public enum UnauthorizedCacheControlHeaderStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failWith403
        case succeedWithoutResponseHeader
        case succeedWithResponseHeader
        case sdkUnknown(Swift.String)

        public static var allCases: [UnauthorizedCacheControlHeaderStrategy] {
            return [
                .failWith403,
                .succeedWithoutResponseHeader,
                .succeedWithResponseHeader,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failWith403: return "FAIL_WITH_403"
            case .succeedWithoutResponseHeader: return "SUCCEED_WITHOUT_RESPONSE_HEADER"
            case .succeedWithResponseHeader: return "SUCCEED_WITH_RESPONSE_HEADER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnauthorizedCacheControlHeaderStrategy(rawValue: rawValue) ?? UnauthorizedCacheControlHeaderStrategy.sdkUnknown(rawValue)
        }
    }
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request is denied because the caller has insufficient permissions.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Removes a tag from a given resource.
public struct UntagResourceInput: Swift.Equatable {
    /// [Required] The ARN of a resource that can be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// [Required] The Tag keys to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/account"
    }
}

/// Requests API Gateway to change information about the current [Account] resource.
public struct UpdateAccountInput: Swift.Equatable {
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?

    public init (
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.patchOperations = patchOperations
    }
}

struct UpdateAccountInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyVersion = output.apiKeyVersion
            self.cloudwatchRoleArn = output.cloudwatchRoleArn
            self.features = output.features
            self.throttleSettings = output.throttleSettings
        } else {
            self.apiKeyVersion = nil
            self.cloudwatchRoleArn = nil
            self.features = nil
            self.throttleSettings = nil
        }
    }
}

/// Represents an AWS account that is associated with API Gateway. To view the account info, call GET on this resource.
/// Error Codes
///
/// The following exception may be thrown when the request fails.
///
/// * UnauthorizedException
///
/// * NotFoundException
///
/// * TooManyRequestsException
///
///
/// For detailed error code information, including the corresponding HTTP Status Codes, see [API Gateway Error Codes](https://docs.aws.amazon.com/apigateway/api-reference/handling-errors/#api-error-codes)
/// Example: Get the information about an account.
///
///
/// Request
///
///
///     GET /account HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160531T184618Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
///
///
/// Response
///
/// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/account-apigateway-{rel}.html", "name": "account", "templated": true }, "self": { "href": "/account" }, "account:update": { "href": "/account" } }, "cloudwatchRoleArn": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "throttleSettings": { "rateLimit": 500, "burstLimit": 1000 } }  In addition to making the REST API call directly, you can use the AWS CLI and an AWS SDK to access this resource. [API Gateway Limits](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-limits.html)[Developer Guide](https://docs.aws.amazon.com/apigateway/latest/developerguide/welcome.html), [AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-account.html)
public struct UpdateAccountOutputResponse: Swift.Equatable {
    /// The version of the API keys used for the account.
    public var apiKeyVersion: Swift.String?
    /// The ARN of an Amazon CloudWatch role for the current [Account].
    public var cloudwatchRoleArn: Swift.String?
    /// A list of features supported for the account. When usage plans are enabled, the features list will include an entry of "UsagePlans".
    public var features: [Swift.String]?
    /// Specifies the API request limits configured for the current [Account].
    public var throttleSettings: ApiGatewayClientTypes.ThrottleSettings?

    public init (
        apiKeyVersion: Swift.String? = nil,
        cloudwatchRoleArn: Swift.String? = nil,
        features: [Swift.String]? = nil,
        throttleSettings: ApiGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiKeyVersion = apiKeyVersion
        self.cloudwatchRoleArn = cloudwatchRoleArn
        self.features = features
        self.throttleSettings = throttleSettings
    }
}

struct UpdateAccountOutputResponseBody: Swift.Equatable {
    let cloudwatchRoleArn: Swift.String?
    let throttleSettings: ApiGatewayClientTypes.ThrottleSettings?
    let features: [Swift.String]?
    let apiKeyVersion: Swift.String?
}

extension UpdateAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyVersion
        case cloudwatchRoleArn
        case features
        case throttleSettings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudwatchRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudwatchRoleArn)
        cloudwatchRoleArn = cloudwatchRoleArnDecoded
        let throttleSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ThrottleSettings.self, forKey: .throttleSettings)
        throttleSettings = throttleSettingsDecoded
        let featuresContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .features)
        var featuresDecoded0:[Swift.String]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [Swift.String]()
            for string0 in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?.append(string0)
                }
            }
        }
        features = featuresDecoded0
        let apiKeyVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKeyVersion)
        apiKeyVersion = apiKeyVersionDecoded
    }
}

extension UpdateApiKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateApiKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let apiKey = apiKey else {
            return nil
        }
        return "/apikeys/\(apiKey.urlPercentEncoding())"
    }
}

/// A request to change information about an [ApiKey] resource.
public struct UpdateApiKeyInput: Swift.Equatable {
    /// [Required] The identifier of the [ApiKey] resource to be updated.
    /// This member is required.
    public var apiKey: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?

    public init (
        apiKey: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.apiKey = apiKey
        self.patchOperations = patchOperations
    }
}

struct UpdateApiKeyInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateApiKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateApiKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiKeyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApiKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.customerId = output.customerId
            self.description = output.description
            self.enabled = output.enabled
            self.id = output.id
            self.lastUpdatedDate = output.lastUpdatedDate
            self.name = output.name
            self.stageKeys = output.stageKeys
            self.tags = output.tags
            self.value = output.value
        } else {
            self.createdDate = nil
            self.customerId = nil
            self.description = nil
            self.enabled = false
            self.id = nil
            self.lastUpdatedDate = nil
            self.name = nil
            self.stageKeys = nil
            self.tags = nil
            self.value = nil
        }
    }
}

/// A resource that can be distributed to callers for executing [Method] resources that require an API key. API keys can be mapped to any [Stage] on any [RestApi], which indicates that the callers with the API key can make requests to that stage. [Use API Keys](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-api-keys.html)
public struct UpdateApiKeyOutputResponse: Swift.Equatable {
    /// The timestamp when the API Key was created.
    public var createdDate: ClientRuntime.Date?
    /// An AWS Marketplace customer identifier , when integrating with the AWS SaaS Marketplace.
    public var customerId: Swift.String?
    /// The description of the API Key.
    public var description: Swift.String?
    /// Specifies whether the API Key can be used by callers.
    public var enabled: Swift.Bool
    /// The identifier of the API Key.
    public var id: Swift.String?
    /// The timestamp when the API Key was last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// The name of the API Key.
    public var name: Swift.String?
    /// A list of [Stage] resources that are associated with the [ApiKey] resource.
    public var stageKeys: [Swift.String]?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The value of the API Key.
    public var value: Swift.String?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        customerId: Swift.String? = nil,
        description: Swift.String? = nil,
        enabled: Swift.Bool = false,
        id: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        stageKeys: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        value: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.customerId = customerId
        self.description = description
        self.enabled = enabled
        self.id = id
        self.lastUpdatedDate = lastUpdatedDate
        self.name = name
        self.stageKeys = stageKeys
        self.tags = tags
        self.value = value
    }
}

struct UpdateApiKeyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let value: Swift.String?
    let name: Swift.String?
    let customerId: Swift.String?
    let description: Swift.String?
    let enabled: Swift.Bool
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
    let stageKeys: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateApiKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case customerId
        case description
        case enabled
        case id
        case lastUpdatedDate
        case name
        case stageKeys
        case tags
        case value
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let customerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customerId)
        customerId = customerIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let stageKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stageKeys)
        var stageKeysDecoded0:[Swift.String]? = nil
        if let stageKeysContainer = stageKeysContainer {
            stageKeysDecoded0 = [Swift.String]()
            for string0 in stageKeysContainer {
                if let string0 = string0 {
                    stageKeysDecoded0?.append(string0)
                }
            }
        }
        stageKeys = stageKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateAuthorizerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateAuthorizerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let authorizerId = authorizerId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/authorizers/\(authorizerId.urlPercentEncoding())"
    }
}

/// Request to update an existing [Authorizer] resource.
public struct UpdateAuthorizerInput: Swift.Equatable {
    /// [Required] The identifier of the [Authorizer] resource.
    /// This member is required.
    public var authorizerId: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        authorizerId: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.authorizerId = authorizerId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateAuthorizerInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateAuthorizerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateAuthorizerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAuthorizerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAuthorizerOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAuthorizerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAuthorizerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authType = output.authType
            self.authorizerCredentials = output.authorizerCredentials
            self.authorizerResultTtlInSeconds = output.authorizerResultTtlInSeconds
            self.authorizerUri = output.authorizerUri
            self.id = output.id
            self.identitySource = output.identitySource
            self.identityValidationExpression = output.identityValidationExpression
            self.name = output.name
            self.providerARNs = output.providerARNs
            self.type = output.type
        } else {
            self.authType = nil
            self.authorizerCredentials = nil
            self.authorizerResultTtlInSeconds = nil
            self.authorizerUri = nil
            self.id = nil
            self.identitySource = nil
            self.identityValidationExpression = nil
            self.name = nil
            self.providerARNs = nil
            self.type = nil
        }
    }
}

/// Represents an authorization layer for methods. If enabled on a method, API Gateway will activate the authorizer when a client calls the method. [Use Lambda Function as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html)[Use Cognito User Pool as Authorizer](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html)
public struct UpdateAuthorizerOutputResponse: Swift.Equatable {
    /// Optional customer-defined field, used in OpenAPI imports and exports without functional impact.
    public var authType: Swift.String?
    /// Specifies the required credentials as an IAM role for API Gateway to invoke the authorizer. To specify an IAM role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To use resource-based permissions on the Lambda function, specify null.
    public var authorizerCredentials: Swift.String?
    /// The TTL in seconds of cached authorizer results. If it equals 0, authorization caching is disabled. If it is greater than 0, API Gateway will cache authorizer responses. If this field is not set, the default value is 300. The maximum value is 3600, or 1 hour.
    public var authorizerResultTtlInSeconds: Swift.Int?
    /// Specifies the authorizer's Uniform Resource Identifier (URI). For TOKEN or REQUEST authorizers, this must be a well-formed Lambda function URI, for example, arn:aws:apigateway:us-west-2:lambda:path/2015-03-31/functions/arn:aws:lambda:us-west-2:{account_id}:function:{lambda_function_name}/invocations. In general, the URI has this form arn:aws:apigateway:{region}:lambda:path/{service_api}, where {region} is the same as the region hosting the Lambda function, path indicates that the remaining substring in the URI should be treated as the path to the resource, including the initial /. For Lambda functions, this is usually of the form /2015-03-31/functions/[FunctionARN]/invocations.
    public var authorizerUri: Swift.String?
    /// The identifier for the authorizer resource.
    public var id: Swift.String?
    /// The identity source for which authorization is requested.
    ///
    /// * For a TOKEN or COGNITO_USER_POOLS authorizer, this is required and specifies the request header mapping expression for the custom header holding the authorization token submitted by the client. For example, if the token header name is Auth, the header mapping expression is method.request.header.Auth.
    ///
    /// * For the REQUEST authorizer, this is required when authorization caching is enabled. The value is a comma-separated string of one or more mapping expressions of the specified request parameters. For example, if an Auth header, a Name query string parameter are defined as identity sources, this value is method.request.header.Auth, method.request.querystring.Name. These parameters will be used to derive the authorization caching key and to perform runtime validation of the REQUEST authorizer by verifying all of the identity-related request parameters are present, not null and non-empty. Only when this is true does the authorizer invoke the authorizer Lambda function, otherwise, it returns a 401 Unauthorized response without calling the Lambda function. The valid value is a string of comma-separated mapping expressions of the specified request parameters. When the authorization caching is not enabled, this property is optional.
    public var identitySource: Swift.String?
    /// A validation expression for the incoming identity token. For TOKEN authorizers, this value is a regular expression. For COGNITO_USER_POOLS authorizers, API Gateway will match the aud field of the incoming token from the client against the specified regular expression. It will invoke the authorizer's Lambda function when there is a match. Otherwise, it will return a 401 Unauthorized response without calling the Lambda function. The validation expression does not apply to the REQUEST authorizer.
    public var identityValidationExpression: Swift.String?
    /// [Required] The name of the authorizer.
    public var name: Swift.String?
    /// A list of the Amazon Cognito user pool ARNs for the COGNITO_USER_POOLS authorizer. Each element is of this format: arn:aws:cognito-idp:{region}:{account_id}:userpool/{user_pool_id}. For a TOKEN or REQUEST authorizer, this is not defined.
    public var providerARNs: [Swift.String]?
    /// The authorizer type. Valid values are TOKEN for a Lambda function using a single authorization token submitted in a custom header, REQUEST for a Lambda function using incoming request parameters, and COGNITO_USER_POOLS for using an Amazon Cognito user pool.
    public var type: ApiGatewayClientTypes.AuthorizerType?

    public init (
        authType: Swift.String? = nil,
        authorizerCredentials: Swift.String? = nil,
        authorizerResultTtlInSeconds: Swift.Int? = nil,
        authorizerUri: Swift.String? = nil,
        id: Swift.String? = nil,
        identitySource: Swift.String? = nil,
        identityValidationExpression: Swift.String? = nil,
        name: Swift.String? = nil,
        providerARNs: [Swift.String]? = nil,
        type: ApiGatewayClientTypes.AuthorizerType? = nil
    )
    {
        self.authType = authType
        self.authorizerCredentials = authorizerCredentials
        self.authorizerResultTtlInSeconds = authorizerResultTtlInSeconds
        self.authorizerUri = authorizerUri
        self.id = id
        self.identitySource = identitySource
        self.identityValidationExpression = identityValidationExpression
        self.name = name
        self.providerARNs = providerARNs
        self.type = type
    }
}

struct UpdateAuthorizerOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let type: ApiGatewayClientTypes.AuthorizerType?
    let providerARNs: [Swift.String]?
    let authType: Swift.String?
    let authorizerUri: Swift.String?
    let authorizerCredentials: Swift.String?
    let identitySource: Swift.String?
    let identityValidationExpression: Swift.String?
    let authorizerResultTtlInSeconds: Swift.Int?
}

extension UpdateAuthorizerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case authorizerCredentials
        case authorizerResultTtlInSeconds
        case authorizerUri
        case id
        case identitySource
        case identityValidationExpression
        case name
        case providerARNs
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AuthorizerType.self, forKey: .type)
        type = typeDecoded
        let providerARNsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .providerARNs)
        var providerARNsDecoded0:[Swift.String]? = nil
        if let providerARNsContainer = providerARNsContainer {
            providerARNsDecoded0 = [Swift.String]()
            for string0 in providerARNsContainer {
                if let string0 = string0 {
                    providerARNsDecoded0?.append(string0)
                }
            }
        }
        providerARNs = providerARNsDecoded0
        let authTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authType)
        authType = authTypeDecoded
        let authorizerUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerUri)
        authorizerUri = authorizerUriDecoded
        let authorizerCredentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerCredentials)
        authorizerCredentials = authorizerCredentialsDecoded
        let identitySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identitySource)
        identitySource = identitySourceDecoded
        let identityValidationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityValidationExpression)
        identityValidationExpression = identityValidationExpressionDecoded
        let authorizerResultTtlInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .authorizerResultTtlInSeconds)
        authorizerResultTtlInSeconds = authorizerResultTtlInSecondsDecoded
    }
}

extension UpdateBasePathMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateBasePathMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        guard let basePath = basePath else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())/basepathmappings/\(basePath.urlPercentEncoding())"
    }
}

/// A request to change information about the [BasePathMapping] resource.
public struct UpdateBasePathMappingInput: Swift.Equatable {
    /// [Required] The base path of the [BasePathMapping] resource to change. To specify an empty base path, set this parameter to '(none)'.
    /// This member is required.
    public var basePath: Swift.String?
    /// [Required] The domain name of the [BasePathMapping] resource to change.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?

    public init (
        basePath: Swift.String? = nil,
        domainName: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.basePath = basePath
        self.domainName = domainName
        self.patchOperations = patchOperations
    }
}

struct UpdateBasePathMappingInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateBasePathMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateBasePathMappingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBasePathMappingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBasePathMappingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBasePathMappingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateBasePathMappingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.basePath = output.basePath
            self.restApiId = output.restApiId
            self.stage = output.stage
        } else {
            self.basePath = nil
            self.restApiId = nil
            self.stage = nil
        }
    }
}

/// Represents the base path that callers of the API must provide as part of the URL after the domain name. A custom domain name plus a BasePathMapping specification identifies a deployed [RestApi] in a given stage of the owner [Account]. [Use Custom Domain Names](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
public struct UpdateBasePathMappingOutputResponse: Swift.Equatable {
    /// The base path name that callers of the API must provide as part of the URL after the domain name.
    public var basePath: Swift.String?
    /// The string identifier of the associated [RestApi].
    public var restApiId: Swift.String?
    /// The name of the associated stage.
    public var stage: Swift.String?

    public init (
        basePath: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        stage: Swift.String? = nil
    )
    {
        self.basePath = basePath
        self.restApiId = restApiId
        self.stage = stage
    }
}

struct UpdateBasePathMappingOutputResponseBody: Swift.Equatable {
    let basePath: Swift.String?
    let restApiId: Swift.String?
    let stage: Swift.String?
}

extension UpdateBasePathMappingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basePath
        case restApiId
        case stage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .basePath)
        basePath = basePathDecoded
        let restApiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .restApiId)
        restApiId = restApiIdDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
    }
}

extension UpdateClientCertificateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateClientCertificateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let clientCertificateId = clientCertificateId else {
            return nil
        }
        return "/clientcertificates/\(clientCertificateId.urlPercentEncoding())"
    }
}

/// A request to change information about an [ClientCertificate] resource.
public struct UpdateClientCertificateInput: Swift.Equatable {
    /// [Required] The identifier of the [ClientCertificate] resource to be updated.
    /// This member is required.
    public var clientCertificateId: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?

    public init (
        clientCertificateId: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.patchOperations = patchOperations
    }
}

struct UpdateClientCertificateInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateClientCertificateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateClientCertificateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClientCertificateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClientCertificateOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClientCertificateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateClientCertificateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.description = output.description
            self.expirationDate = output.expirationDate
            self.pemEncodedCertificate = output.pemEncodedCertificate
            self.tags = output.tags
        } else {
            self.clientCertificateId = nil
            self.createdDate = nil
            self.description = nil
            self.expirationDate = nil
            self.pemEncodedCertificate = nil
            self.tags = nil
        }
    }
}

/// Represents a client certificate used to configure client-side SSL authentication while sending requests to the integration endpoint. Client certificates are used to authenticate an API by the backend server. To authenticate an API client (or user), use IAM roles and policies, a custom [Authorizer] or an Amazon Cognito user pool. [Use Client-Side Certificate](https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-client-side-ssl-authentication.html)
public struct UpdateClientCertificateOutputResponse: Swift.Equatable {
    /// The identifier of the client certificate.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the client certificate was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the client certificate.
    public var description: Swift.String?
    /// The timestamp when the client certificate will expire.
    public var expirationDate: ClientRuntime.Date?
    /// The PEM-encoded public key of the client certificate, which can be used to configure certificate authentication in the integration endpoint .
    public var pemEncodedCertificate: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        expirationDate: ClientRuntime.Date? = nil,
        pemEncodedCertificate: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.description = description
        self.expirationDate = expirationDate
        self.pemEncodedCertificate = pemEncodedCertificate
        self.tags = tags
    }
}

struct UpdateClientCertificateOutputResponseBody: Swift.Equatable {
    let clientCertificateId: Swift.String?
    let description: Swift.String?
    let pemEncodedCertificate: Swift.String?
    let createdDate: ClientRuntime.Date?
    let expirationDate: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateClientCertificateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientCertificateId
        case createdDate
        case description
        case expirationDate
        case pemEncodedCertificate
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())"
    }
}

/// Requests API Gateway to change information about a [Deployment] resource.
public struct UpdateDeploymentInput: Swift.Equatable {
    /// The replacement identifier for the [Deployment] resource to change information about.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        deploymentId: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDeploymentInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiSummary = output.apiSummary
            self.createdDate = output.createdDate
            self.description = output.description
            self.id = output.id
        } else {
            self.apiSummary = nil
            self.createdDate = nil
            self.description = nil
            self.id = nil
        }
    }
}

/// An immutable representation of a [RestApi] resource that can be called by users using [Stages]. A deployment must be associated with a [Stage] for it to be callable over the Internet. To create a deployment, call POST on the [Deployments] resource of a [RestApi]. To view, update, or delete a deployment, call GET, PATCH, or DELETE on the specified deployment resource (/restapis/{restapi_id}/deployments/{deployment_id}). [RestApi], [Deployments], [Stage], [AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-deployment.html), [AWS SDKs](https://aws.amazon.com/tools/)
public struct UpdateDeploymentOutputResponse: Swift.Equatable {
    /// A summary of the [RestApi] at the date and time that the deployment resource was created.
    public var apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]?
    /// The date and time that the deployment resource was created.
    public var createdDate: ClientRuntime.Date?
    /// The description for the deployment resource.
    public var description: Swift.String?
    /// The identifier for the deployment resource.
    public var id: Swift.String?

    public init (
        apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.apiSummary = apiSummary
        self.createdDate = createdDate
        self.description = description
        self.id = id
    }
}

struct UpdateDeploymentOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let apiSummary: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]?
}

extension UpdateDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSummary
        case createdDate
        case description
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let apiSummaryContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: ApiGatewayClientTypes.MethodSnapshot?]?].self, forKey: .apiSummary)
        var apiSummaryDecoded0: [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]? = nil
        if let apiSummaryContainer = apiSummaryContainer {
            apiSummaryDecoded0 = [Swift.String:[Swift.String:ApiGatewayClientTypes.MethodSnapshot]]()
            for (key0, mapofmethodsnapshot0) in apiSummaryContainer {
                var mapofmethodsnapshot0Decoded0: [Swift.String: ApiGatewayClientTypes.MethodSnapshot]? = nil
                if let mapofmethodsnapshot0 = mapofmethodsnapshot0 {
                    mapofmethodsnapshot0Decoded0 = [Swift.String: ApiGatewayClientTypes.MethodSnapshot]()
                    for (key1, methodsnapshot1) in mapofmethodsnapshot0 {
                        if let methodsnapshot1 = methodsnapshot1 {
                            mapofmethodsnapshot0Decoded0?[key1] = methodsnapshot1
                        }
                    }
                }
                apiSummaryDecoded0?[key0] = mapofmethodsnapshot0Decoded0
            }
        }
        apiSummary = apiSummaryDecoded0
    }
}

extension UpdateDocumentationPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateDocumentationPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationPartId = documentationPartId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/parts/\(documentationPartId.urlPercentEncoding())"
    }
}

/// Updates an existing documentation part of a given API.
public struct UpdateDocumentationPartInput: Swift.Equatable {
    /// [Required] The identifier of the to-be-updated documentation part.
    /// This member is required.
    public var documentationPartId: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        documentationPartId: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationPartId = documentationPartId
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDocumentationPartInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateDocumentationPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDocumentationPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentationPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentationPartOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentationPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDocumentationPartOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.location = output.location
            self.properties = output.properties
        } else {
            self.id = nil
            self.location = nil
            self.properties = nil
        }
    }
}

/// A documentation part for a targeted API entity. A documentation part consists of a content map (properties) and a target (location). The target specifies an API entity to which the documentation content applies. The supported API entity types are API, AUTHORIZER, MODEL, RESOURCE, METHOD, PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER, REQUEST_BODY, RESPONSE, RESPONSE_HEADER, and RESPONSE_BODY. Valid location fields depend on the API entity type. All valid fields are not required. The content map is a JSON string of API-specific key-value pairs. Although an API can use any shape for the content map, only the OpenAPI-compliant documentation fields will be injected into the associated API entity definition in the exported OpenAPI definition file. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationParts]
public struct UpdateDocumentationPartOutputResponse: Swift.Equatable {
    /// The [DocumentationPart] identifier, generated by API Gateway when the DocumentationPart is created.
    public var id: Swift.String?
    /// The location of the API entity to which the documentation applies. Valid fields depend on the targeted API entity type. All the valid location fields are not required. If not explicitly specified, a valid location field is treated as a wildcard and associated documentation content may be inherited by matching entities, unless overridden.
    public var location: ApiGatewayClientTypes.DocumentationPartLocation?
    /// A content map of API-specific key-value pairs describing the targeted API entity. The map must be encoded as a JSON string, e.g., "{ \"description\": \"The API does ...\" }". Only OpenAPI-compliant documentation-related fields from the properties map are exported and, hence, published as part of the API entity definitions, while the original documentation parts are exported in a OpenAPI extension of x-amazon-apigateway-documentation.
    public var properties: Swift.String?

    public init (
        id: Swift.String? = nil,
        location: ApiGatewayClientTypes.DocumentationPartLocation? = nil,
        properties: Swift.String? = nil
    )
    {
        self.id = id
        self.location = location
        self.properties = properties
    }
}

struct UpdateDocumentationPartOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let location: ApiGatewayClientTypes.DocumentationPartLocation?
    let properties: Swift.String?
}

extension UpdateDocumentationPartOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case location
        case properties
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DocumentationPartLocation.self, forKey: .location)
        location = locationDecoded
        let propertiesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .properties)
        properties = propertiesDecoded
    }
}

extension UpdateDocumentationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateDocumentationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let documentationVersion = documentationVersion else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/documentation/versions/\(documentationVersion.urlPercentEncoding())"
    }
}

/// Updates an existing documentation version of an API.
public struct UpdateDocumentationVersionInput: Swift.Equatable {
    /// [Required] The version identifier of the to-be-updated documentation version.
    /// This member is required.
    public var documentationVersion: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The string identifier of the associated [RestApi]..
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        documentationVersion: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.documentationVersion = documentationVersion
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateDocumentationVersionInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateDocumentationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDocumentationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDocumentationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDocumentationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDocumentationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDocumentationVersionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.description = output.description
            self.version = output.version
        } else {
            self.createdDate = nil
            self.description = nil
            self.version = nil
        }
    }
}

/// A snapshot of the documentation of an API. Publishing API documentation involves creating a documentation version associated with an API stage and exporting the versioned documentation to an external (e.g., OpenAPI) file. [Documenting an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-documenting-api.html), [DocumentationPart], [DocumentationVersions]
public struct UpdateDocumentationVersionOutputResponse: Swift.Equatable {
    /// The date when the API documentation snapshot is created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the API documentation snapshot.
    public var description: Swift.String?
    /// The version identifier of the API documentation snapshot.
    public var version: Swift.String?

    public init (
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.createdDate = createdDate
        self.description = description
        self.version = version
    }
}

struct UpdateDocumentationVersionOutputResponseBody: Swift.Equatable {
    let version: Swift.String?
    let createdDate: ClientRuntime.Date?
    let description: Swift.String?
}

extension UpdateDocumentationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate
        case description
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDomainNameInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateDomainNameInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let domainName = domainName else {
            return nil
        }
        return "/domainnames/\(domainName.urlPercentEncoding())"
    }
}

/// A request to change information about the [DomainName] resource.
public struct UpdateDomainNameInput: Swift.Equatable {
    /// [Required] The name of the [DomainName] resource to be changed.
    /// This member is required.
    public var domainName: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?

    public init (
        domainName: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil
    )
    {
        self.domainName = domainName
        self.patchOperations = patchOperations
    }
}

struct UpdateDomainNameInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateDomainNameInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateDomainNameOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDomainNameOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDomainNameOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDomainNameOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDomainNameOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.certificateArn = output.certificateArn
            self.certificateName = output.certificateName
            self.certificateUploadDate = output.certificateUploadDate
            self.distributionDomainName = output.distributionDomainName
            self.distributionHostedZoneId = output.distributionHostedZoneId
            self.domainName = output.domainName
            self.domainNameStatus = output.domainNameStatus
            self.domainNameStatusMessage = output.domainNameStatusMessage
            self.endpointConfiguration = output.endpointConfiguration
            self.mutualTlsAuthentication = output.mutualTlsAuthentication
            self.ownershipVerificationCertificateArn = output.ownershipVerificationCertificateArn
            self.regionalCertificateArn = output.regionalCertificateArn
            self.regionalCertificateName = output.regionalCertificateName
            self.regionalDomainName = output.regionalDomainName
            self.regionalHostedZoneId = output.regionalHostedZoneId
            self.securityPolicy = output.securityPolicy
            self.tags = output.tags
        } else {
            self.certificateArn = nil
            self.certificateName = nil
            self.certificateUploadDate = nil
            self.distributionDomainName = nil
            self.distributionHostedZoneId = nil
            self.domainName = nil
            self.domainNameStatus = nil
            self.domainNameStatusMessage = nil
            self.endpointConfiguration = nil
            self.mutualTlsAuthentication = nil
            self.ownershipVerificationCertificateArn = nil
            self.regionalCertificateArn = nil
            self.regionalCertificateName = nil
            self.regionalDomainName = nil
            self.regionalHostedZoneId = nil
            self.securityPolicy = nil
            self.tags = nil
        }
    }
}

/// Represents a custom domain name as a user-friendly host name of an API ([RestApi]). When you deploy an API, API Gateway creates a default host name for the API. This default API host name is of the {restapi-id}.execute-api.{region}.amazonaws.com format. With the default host name, you can access the API's root resource with the URL of https://{restapi-id}.execute-api.{region}.amazonaws.com/{stage}/. When you set up a custom domain name of apis.example.com for this API, you can then access the same resource using the URL of the https://apis.examples.com/myApi, where myApi is the base path mapping ([BasePathMapping]) of your API under the custom domain name. [Set a Custom Host Name for an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html)
public struct UpdateDomainNameOutputResponse: Swift.Equatable {
    /// The reference to an AWS-managed certificate that will be used by edge-optimized endpoint for this domain name. AWS Certificate Manager is the only supported source.
    public var certificateArn: Swift.String?
    /// The name of the certificate that will be used by edge-optimized endpoint for this domain name.
    public var certificateName: Swift.String?
    /// The timestamp when the certificate that was used by edge-optimized endpoint for this domain name was uploaded.
    public var certificateUploadDate: ClientRuntime.Date?
    /// The domain name of the Amazon CloudFront distribution associated with this custom domain name for an edge-optimized endpoint. You set up this association when adding a DNS record pointing the custom domain name to this distribution name. For more information about CloudFront distributions, see the [Amazon CloudFront documentation](https://aws.amazon.com/documentation/cloudfront/).
    public var distributionDomainName: Swift.String?
    /// The region-agnostic Amazon Route 53 Hosted Zone ID of the edge-optimized endpoint. The valid value is Z2FDTNDATAQYW2 for all the regions. For more information, see [Set up a Regional Custom Domain Name](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) and [AWS Regions and Endpoints for API Gateway](https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
    public var distributionHostedZoneId: Swift.String?
    /// The custom domain name as an API host name, for example, my-api.example.com.
    public var domainName: Swift.String?
    /// The status of the [DomainName] migration. The valid values are AVAILABLE, UPDATING, PENDING_CERTIFICATE_REIMPORT, and PENDING_OWNERSHIP_VERIFICATION. If the status is UPDATING, the domain cannot be modified further until the existing operation is complete. If it is AVAILABLE, the domain can be updated.
    public var domainNameStatus: ApiGatewayClientTypes.DomainNameStatus?
    /// An optional text message containing detailed information about status of the [DomainName] migration.
    public var domainNameStatusMessage: Swift.String?
    /// The endpoint configuration of this [DomainName] showing the endpoint types of the domain name.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// The mutual TLS authentication configuration for a custom domain name. If specified, API Gateway performs two-way authentication between the client and the server. Clients must present a trusted certificate to access your API.
    public var mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication?
    /// The ARN of the public certificate issued by ACM to validate ownership of your custom domain. Only required when configuring mutual TLS and using an ACM imported or private CA certificate ARN as the regionalCertificateArn.
    public var ownershipVerificationCertificateArn: Swift.String?
    /// The reference to an AWS-managed certificate that will be used for validating the regional domain name. AWS Certificate Manager is the only supported source.
    public var regionalCertificateArn: Swift.String?
    /// The name of the certificate that will be used for validating the regional domain name.
    public var regionalCertificateName: Swift.String?
    /// The domain name associated with the regional endpoint for this custom domain name. You set up this association by adding a DNS record that points the custom domain name to this regional domain name. The regional domain name is returned by API Gateway when you create a regional endpoint.
    public var regionalDomainName: Swift.String?
    /// The region-specific Amazon Route 53 Hosted Zone ID of the regional endpoint. For more information, see [Set up a Regional Custom Domain Name](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-regional-api-custom-domain-create.html) and [AWS Regions and Endpoints for API Gateway](https://docs.aws.amazon.com/general/latest/gr/rande.html#apigateway_region).
    public var regionalHostedZoneId: Swift.String?
    /// The Transport Layer Security (TLS) version + cipher suite for this [DomainName]. The valid values are TLS_1_0 and TLS_1_2.
    public var securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        certificateArn: Swift.String? = nil,
        certificateName: Swift.String? = nil,
        certificateUploadDate: ClientRuntime.Date? = nil,
        distributionDomainName: Swift.String? = nil,
        distributionHostedZoneId: Swift.String? = nil,
        domainName: Swift.String? = nil,
        domainNameStatus: ApiGatewayClientTypes.DomainNameStatus? = nil,
        domainNameStatusMessage: Swift.String? = nil,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication? = nil,
        ownershipVerificationCertificateArn: Swift.String? = nil,
        regionalCertificateArn: Swift.String? = nil,
        regionalCertificateName: Swift.String? = nil,
        regionalDomainName: Swift.String? = nil,
        regionalHostedZoneId: Swift.String? = nil,
        securityPolicy: ApiGatewayClientTypes.SecurityPolicy? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.certificateArn = certificateArn
        self.certificateName = certificateName
        self.certificateUploadDate = certificateUploadDate
        self.distributionDomainName = distributionDomainName
        self.distributionHostedZoneId = distributionHostedZoneId
        self.domainName = domainName
        self.domainNameStatus = domainNameStatus
        self.domainNameStatusMessage = domainNameStatusMessage
        self.endpointConfiguration = endpointConfiguration
        self.mutualTlsAuthentication = mutualTlsAuthentication
        self.ownershipVerificationCertificateArn = ownershipVerificationCertificateArn
        self.regionalCertificateArn = regionalCertificateArn
        self.regionalCertificateName = regionalCertificateName
        self.regionalDomainName = regionalDomainName
        self.regionalHostedZoneId = regionalHostedZoneId
        self.securityPolicy = securityPolicy
        self.tags = tags
    }
}

struct UpdateDomainNameOutputResponseBody: Swift.Equatable {
    let domainName: Swift.String?
    let certificateName: Swift.String?
    let certificateArn: Swift.String?
    let certificateUploadDate: ClientRuntime.Date?
    let regionalDomainName: Swift.String?
    let regionalHostedZoneId: Swift.String?
    let regionalCertificateName: Swift.String?
    let regionalCertificateArn: Swift.String?
    let distributionDomainName: Swift.String?
    let distributionHostedZoneId: Swift.String?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let domainNameStatus: ApiGatewayClientTypes.DomainNameStatus?
    let domainNameStatusMessage: Swift.String?
    let securityPolicy: ApiGatewayClientTypes.SecurityPolicy?
    let tags: [Swift.String:Swift.String]?
    let mutualTlsAuthentication: ApiGatewayClientTypes.MutualTlsAuthentication?
    let ownershipVerificationCertificateArn: Swift.String?
}

extension UpdateDomainNameOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case certificateName
        case certificateUploadDate
        case distributionDomainName
        case distributionHostedZoneId
        case domainName
        case domainNameStatus
        case domainNameStatusMessage
        case endpointConfiguration
        case mutualTlsAuthentication
        case ownershipVerificationCertificateArn
        case regionalCertificateArn
        case regionalCertificateName
        case regionalDomainName
        case regionalHostedZoneId
        case securityPolicy
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let certificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateName)
        certificateName = certificateNameDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateUploadDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .certificateUploadDate)
        certificateUploadDate = certificateUploadDateDecoded
        let regionalDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalDomainName)
        regionalDomainName = regionalDomainNameDecoded
        let regionalHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalHostedZoneId)
        regionalHostedZoneId = regionalHostedZoneIdDecoded
        let regionalCertificateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateName)
        regionalCertificateName = regionalCertificateNameDecoded
        let regionalCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionalCertificateArn)
        regionalCertificateArn = regionalCertificateArnDecoded
        let distributionDomainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionDomainName)
        distributionDomainName = distributionDomainNameDecoded
        let distributionHostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionHostedZoneId)
        distributionHostedZoneId = distributionHostedZoneIdDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let domainNameStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.DomainNameStatus.self, forKey: .domainNameStatus)
        domainNameStatus = domainNameStatusDecoded
        let domainNameStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainNameStatusMessage)
        domainNameStatusMessage = domainNameStatusMessageDecoded
        let securityPolicyDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.SecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let mutualTlsAuthenticationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.MutualTlsAuthentication.self, forKey: .mutualTlsAuthentication)
        mutualTlsAuthentication = mutualTlsAuthenticationDecoded
        let ownershipVerificationCertificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownershipVerificationCertificateArn)
        ownershipVerificationCertificateArn = ownershipVerificationCertificateArnDecoded
    }
}

extension UpdateGatewayResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateGatewayResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let responseType = responseType else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/gatewayresponses/\(responseType.rawValue.urlPercentEncoding())"
    }
}

/// Updates a [GatewayResponse] of a specified response type on the given [RestApi].
public struct UpdateGatewayResponseInput: Swift.Equatable {
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The response type of the associated [GatewayResponse].
    /// This member is required.
    public var responseType: ApiGatewayClientTypes.GatewayResponseType?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        responseType: ApiGatewayClientTypes.GatewayResponseType? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.responseType = responseType
        self.restApiId = restApiId
    }
}

struct UpdateGatewayResponseInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateGatewayResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateGatewayResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGatewayResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.defaultResponse = output.defaultResponse
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.responseType = output.responseType
            self.statusCode = output.statusCode
        } else {
            self.defaultResponse = false
            self.responseParameters = nil
            self.responseTemplates = nil
            self.responseType = nil
            self.statusCode = nil
        }
    }
}

/// A gateway response of a given response type and status code, with optional response parameters and mapping templates. For more information about valid gateway response types, see [Gateway Response Types Supported by API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/supported-gateway-response-types.html)
/// Example: Get a Gateway Response of a given response type
///
///
/// Request
///
/// This example shows how to get a gateway response of the MISSING_AUTHENTICATION_TOKEN type. GET /restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN HTTP/1.1 Host: beta-apigateway.us-east-1.amazonaws.com Content-Type: application/json X-Amz-Date: 20170503T202516Z Authorization: AWS4-HMAC-SHA256 Credential={access-key-id}/20170503/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature=1b52460e3159c1a26cff29093855d50ea141c1c5b937528fecaf60f51129697a Cache-Control: no-cache Postman-Token: 3b2a1ce9-c848-2e26-2e2f-9c2caefbed45  The response type is specified as a URL path.
/// Response
///
/// The successful operation returns the 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "http://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-gatewayresponse-{rel}.html", "name": "gatewayresponse", "templated": true }, "self": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:delete": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" }, "gatewayresponse:put": { "href": "/restapis/o81lxisefl/gatewayresponses/{response_type}", "templated": true }, "gatewayresponse:update": { "href": "/restapis/o81lxisefl/gatewayresponses/MISSING_AUTHENTICATION_TOKEN" } }, "defaultResponse": false, "responseParameters": { "gatewayresponse.header.x-request-path": "method.request.path.petId", "gatewayresponse.header.Access-Control-Allow-Origin": "'a.b.c'", "gatewayresponse.header.x-request-query": "method.request.querystring.q", "gatewayresponse.header.x-request-header": "method.request.header.Accept" }, "responseTemplates": { "application/json": "{\n \"message\": $context.error.messageString,\n \"type\": \"$context.error.responseType\",\n \"stage\": \"$context.stage\",\n \"resourcePath\": \"$context.resourcePath\",\n \"stageVariables.a\": \"$stageVariables.a\",\n \"statusCode\": \"'404'\"\n}" }, "responseType": "MISSING_AUTHENTICATION_TOKEN", "statusCode": "404" }[Customize Gateway Responses](https://docs.aws.amazon.com/apigateway/latest/developerguide/customize-gateway-responses.html)
public struct UpdateGatewayResponseOutputResponse: Swift.Equatable {
    /// A Boolean flag to indicate whether this [GatewayResponse] is the default gateway response (true) or not (false). A default gateway response is one generated by API Gateway without any customization by an API developer.
    public var defaultResponse: Swift.Bool
    /// Response parameters (paths, query strings and headers) of the [GatewayResponse] as a string-to-string map of key-value pairs.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Response templates of the [GatewayResponse] as a string-to-string map of key-value pairs.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// The response type of the associated [GatewayResponse].
    public var responseType: ApiGatewayClientTypes.GatewayResponseType?
    /// The HTTP status code for this [GatewayResponse].
    public var statusCode: Swift.String?

    public init (
        defaultResponse: Swift.Bool = false,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        responseType: ApiGatewayClientTypes.GatewayResponseType? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.defaultResponse = defaultResponse
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.responseType = responseType
        self.statusCode = statusCode
    }
}

struct UpdateGatewayResponseOutputResponseBody: Swift.Equatable {
    let responseType: ApiGatewayClientTypes.GatewayResponseType?
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let defaultResponse: Swift.Bool
}

extension UpdateGatewayResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResponse
        case responseParameters
        case responseTemplates
        case responseType
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.GatewayResponseType.self, forKey: .responseType)
        responseType = responseTypeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let defaultResponseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .defaultResponse)
        defaultResponse = defaultResponseDecoded
    }
}

extension UpdateIntegrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateIntegrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration"
    }
}

/// Represents an update integration request.
public struct UpdateIntegrationInput: Swift.Equatable {
    /// [Required] Represents an update integration request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] Represents an update integration request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateIntegrationInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateIntegrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateIntegrationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntegrationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntegrationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntegrationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIntegrationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cacheKeyParameters = output.cacheKeyParameters
            self.cacheNamespace = output.cacheNamespace
            self.connectionId = output.connectionId
            self.connectionType = output.connectionType
            self.contentHandling = output.contentHandling
            self.credentials = output.credentials
            self.httpMethod = output.httpMethod
            self.integrationResponses = output.integrationResponses
            self.passthroughBehavior = output.passthroughBehavior
            self.requestParameters = output.requestParameters
            self.requestTemplates = output.requestTemplates
            self.timeoutInMillis = output.timeoutInMillis
            self.tlsConfig = output.tlsConfig
            self.type = output.type
            self.uri = output.uri
        } else {
            self.cacheKeyParameters = nil
            self.cacheNamespace = nil
            self.connectionId = nil
            self.connectionType = nil
            self.contentHandling = nil
            self.credentials = nil
            self.httpMethod = nil
            self.integrationResponses = nil
            self.passthroughBehavior = nil
            self.requestParameters = nil
            self.requestTemplates = nil
            self.timeoutInMillis = 0
            self.tlsConfig = nil
            self.type = nil
            self.uri = nil
        }
    }
}

/// Represents an HTTP, HTTP_PROXY, AWS, AWS_PROXY, or Mock integration. In the API Gateway console, the built-in Lambda integration is an AWS integration. [Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct UpdateIntegrationOutputResponse: Swift.Equatable {
    /// A list of request parameters whose values API Gateway caches. To be valid values for cacheKeyParameters, these parameters must also be specified for [Method]requestParameters.
    public var cacheKeyParameters: [Swift.String]?
    /// Specifies a group of related cached parameters. By default, API Gateway uses the resource ID as the cacheNamespace. You can specify the same cacheNamespace across resources to return the same cached data for requests to different resources.
    public var cacheNamespace: Swift.String?
    /// The ([id](https://docs.aws.amazon.com/apigateway/api-reference/resource/vpc-link/#id)) of the [VpcLink] used for the integration when connectionType=VPC_LINK and undefined, otherwise.
    public var connectionId: Swift.String?
    /// The type of the network connection to the integration endpoint. The valid value is INTERNET for connections through the public routable internet or VPC_LINK for private connections between API Gateway and a network load balancer in a VPC. The default value is INTERNET.
    public var connectionType: ApiGatewayClientTypes.ConnectionType?
    /// Specifies how to handle request payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
    ///
    /// * CONVERT_TO_BINARY: Converts a request payload from a Base64-encoded string to the corresponding binary blob.
    ///
    /// * CONVERT_TO_TEXT: Converts a request payload from a binary blob to a Base64-encoded string.
    ///
    ///
    /// If this property is not defined, the request payload will be passed through from the method request to integration request without modification, provided that the passthroughBehavior is configured to support payload pass-through.
    public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    /// Specifies the credentials required for the integration, if any. For AWS integrations, three options are available. To specify an IAM Role for API Gateway to assume, use the role's Amazon Resource Name (ARN). To require that the caller's identity be passed through from the request, specify the string arn:aws:iam::\*:user/\*. To use resource-based permissions on supported AWS services, specify null.
    public var credentials: Swift.String?
    /// Specifies the integration's HTTP method type.
    public var httpMethod: Swift.String?
    /// Specifies the integration's responses.
    /// Example: Get integration responses of a method
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160607T191449Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160607/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns 200 OK status and a payload as follows: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n" }, "statusCode": "200" }[Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
    public var integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]?
    /// Specifies how the method request body of an unmapped content type will be passed through the integration request to the back end without transformation. A content type is unmapped if no mapping template is defined in the integration or the content type does not match any of the mapped content types, as specified in requestTemplates. The valid value is one of the following:
    ///
    /// * WHEN_NO_MATCH: passes the method request body through the integration request to the back end without transformation when the method request content type does not match any content type associated with the mapping templates defined in the integration request.
    ///
    /// * WHEN_NO_TEMPLATES: passes the method request body through the integration request to the back end without transformation when no mapping template is defined in the integration request. If a template is defined when this option is selected, the method request of an unmapped content-type will be rejected with an HTTP 415 Unsupported Media Type response.
    ///
    /// * NEVER: rejects the method request with an HTTP 415 Unsupported Media Type response when either the method request content type does not match any content type associated with the mapping templates defined in the integration request or no mapping template is defined in the integration request.
    public var passthroughBehavior: Swift.String?
    /// A key-value map specifying request parameters that are passed from the method request to the back end. The key is an integration request parameter name and the associated value is a method request parameter value or static value that must be enclosed within single quotes and pre-encoded as required by the back end. The method request parameter value must match the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name must be a valid and unique method request parameter name.
    public var requestParameters: [Swift.String:Swift.String]?
    /// Represents a map of Velocity templates that are applied on the request payload based on the value of the Content-Type header sent by the client. The content type value is the key in this map, and the template (as a String) is the value.
    public var requestTemplates: [Swift.String:Swift.String]?
    /// Custom timeout between 50 and 29,000 milliseconds. The default value is 29,000 milliseconds or 29 seconds.
    public var timeoutInMillis: Swift.Int
    /// Specifies the TLS configuration for an integration.
    public var tlsConfig: ApiGatewayClientTypes.TlsConfig?
    /// Specifies an API method integration type. The valid value is one of the following:
    ///
    /// * AWS: for integrating the API method request with an AWS service action, including the Lambda function-invoking action. With the Lambda function-invoking action, this is referred to as the Lambda custom integration. With any other AWS service action, this is known as AWS integration.
    ///
    /// * AWS_PROXY: for integrating the API method request with the Lambda function-invoking action with the client request passed through as-is. This integration is also referred to as the Lambda proxy integration.
    ///
    /// * HTTP: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC. This integration is also referred to as the HTTP custom integration.
    ///
    /// * HTTP_PROXY: for integrating the API method request with an HTTP endpoint, including a private HTTP endpoint within a VPC, with the client request passed through as-is. This is also referred to as the HTTP proxy integration.
    ///
    /// * MOCK: for integrating the API method request with API Gateway as a "loop-back" endpoint without invoking any backend.
    ///
    ///
    /// For the HTTP and HTTP proxy integrations, each integration can specify a protocol (http/https), port and path. Standard 80 and 443 ports are supported as well as custom ports above 1024. An HTTP or HTTP proxy integration with a connectionType of VPC_LINK is referred to as a private integration and uses a [VpcLink] to connect API Gateway to a network load balancer of a VPC.
    public var type: ApiGatewayClientTypes.IntegrationType?
    /// Specifies Uniform Resource Identifier (URI) of the integration endpoint.
    ///
    /// * For HTTP or HTTP_PROXY integrations, the URI must be a fully formed, encoded HTTP(S) URL according to the [RFC-3986 specification](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier), for either standard integration, where connectionType is not VPC_LINK, or private integration, where connectionType is VPC_LINK. For a private HTTP integration, the URI is not used for routing.
    ///
    /// * For AWS or AWS_PROXY integrations, the URI is of the form arn:aws:apigateway:{region}:{subdomain.service|service}:path|action/{service_api}. Here, {Region} is the API Gateway region (e.g., us-east-1); {service} is the name of the integrated AWS service (e.g., s3); and {subdomain} is a designated subdomain supported by certain AWS service for fast host-name lookup. action can be used for an AWS service action-based API, using an Action={name}&{p1}={v1}&p2={v2}... query string. The ensuing {service_api} refers to a supported action {name} plus any required input parameters. Alternatively, path can be used for an AWS service path-based API. The ensuing service_api refers to the path to an AWS service resource, including the region of the integrated AWS service, if applicable. For example, for integration with the S3 API of [GetObject](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTObjectGET.html), the uri can be either arn:aws:apigateway:us-west-2:s3:action/GetObject&Bucket={bucket}&Key={key} or arn:aws:apigateway:us-west-2:s3:path/{bucket}/{key}
    public var uri: Swift.String?

    public init (
        cacheKeyParameters: [Swift.String]? = nil,
        cacheNamespace: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: ApiGatewayClientTypes.ConnectionType? = nil,
        contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
        credentials: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]? = nil,
        passthroughBehavior: Swift.String? = nil,
        requestParameters: [Swift.String:Swift.String]? = nil,
        requestTemplates: [Swift.String:Swift.String]? = nil,
        timeoutInMillis: Swift.Int = 0,
        tlsConfig: ApiGatewayClientTypes.TlsConfig? = nil,
        type: ApiGatewayClientTypes.IntegrationType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.cacheKeyParameters = cacheKeyParameters
        self.cacheNamespace = cacheNamespace
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.contentHandling = contentHandling
        self.credentials = credentials
        self.httpMethod = httpMethod
        self.integrationResponses = integrationResponses
        self.passthroughBehavior = passthroughBehavior
        self.requestParameters = requestParameters
        self.requestTemplates = requestTemplates
        self.timeoutInMillis = timeoutInMillis
        self.tlsConfig = tlsConfig
        self.type = type
        self.uri = uri
    }
}

struct UpdateIntegrationOutputResponseBody: Swift.Equatable {
    let type: ApiGatewayClientTypes.IntegrationType?
    let httpMethod: Swift.String?
    let uri: Swift.String?
    let connectionType: ApiGatewayClientTypes.ConnectionType?
    let connectionId: Swift.String?
    let credentials: Swift.String?
    let requestParameters: [Swift.String:Swift.String]?
    let requestTemplates: [Swift.String:Swift.String]?
    let passthroughBehavior: Swift.String?
    let contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    let timeoutInMillis: Swift.Int
    let cacheNamespace: Swift.String?
    let cacheKeyParameters: [Swift.String]?
    let integrationResponses: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]?
    let tlsConfig: ApiGatewayClientTypes.TlsConfig?
}

extension UpdateIntegrationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cacheKeyParameters
        case cacheNamespace
        case connectionId
        case connectionType
        case contentHandling
        case credentials
        case httpMethod
        case integrationResponses
        case passthroughBehavior
        case requestParameters
        case requestTemplates
        case timeoutInMillis
        case tlsConfig
        case type
        case uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.IntegrationType.self, forKey: .type)
        type = typeDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let connectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentials)
        credentials = credentialsDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestParametersContainer {
                if let string0 = string0 {
                    requestParametersDecoded0?[key0] = string0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestTemplates)
        var requestTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestTemplatesContainer = requestTemplatesContainer {
            requestTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestTemplatesContainer {
                if let string0 = string0 {
                    requestTemplatesDecoded0?[key0] = string0
                }
            }
        }
        requestTemplates = requestTemplatesDecoded0
        let passthroughBehaviorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .passthroughBehavior)
        passthroughBehavior = passthroughBehaviorDecoded
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
        let timeoutInMillisDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeoutInMillis)
        timeoutInMillis = timeoutInMillisDecoded
        let cacheNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cacheNamespace)
        cacheNamespace = cacheNamespaceDecoded
        let cacheKeyParametersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cacheKeyParameters)
        var cacheKeyParametersDecoded0:[Swift.String]? = nil
        if let cacheKeyParametersContainer = cacheKeyParametersContainer {
            cacheKeyParametersDecoded0 = [Swift.String]()
            for string0 in cacheKeyParametersContainer {
                if let string0 = string0 {
                    cacheKeyParametersDecoded0?.append(string0)
                }
            }
        }
        cacheKeyParameters = cacheKeyParametersDecoded0
        let integrationResponsesContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.IntegrationResponse?].self, forKey: .integrationResponses)
        var integrationResponsesDecoded0: [Swift.String:ApiGatewayClientTypes.IntegrationResponse]? = nil
        if let integrationResponsesContainer = integrationResponsesContainer {
            integrationResponsesDecoded0 = [Swift.String:ApiGatewayClientTypes.IntegrationResponse]()
            for (key0, integrationresponse0) in integrationResponsesContainer {
                if let integrationresponse0 = integrationresponse0 {
                    integrationResponsesDecoded0?[key0] = integrationresponse0
                }
            }
        }
        integrationResponses = integrationResponsesDecoded0
        let tlsConfigDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.TlsConfig.self, forKey: .tlsConfig)
        tlsConfig = tlsConfigDecoded
    }
}

extension UpdateIntegrationResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateIntegrationResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/integration/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// Represents an update integration response request.
public struct UpdateIntegrationResponseInput: Swift.Equatable {
    /// [Required] Specifies an update integration response request's HTTP method.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] Specifies an update integration response request's resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] Specifies an update integration response request's status code.
    /// This member is required.
    public var statusCode: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct UpdateIntegrationResponseInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateIntegrationResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateIntegrationResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIntegrationResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIntegrationResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIntegrationResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateIntegrationResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentHandling = output.contentHandling
            self.responseParameters = output.responseParameters
            self.responseTemplates = output.responseTemplates
            self.selectionPattern = output.selectionPattern
            self.statusCode = output.statusCode
        } else {
            self.contentHandling = nil
            self.responseParameters = nil
            self.responseTemplates = nil
            self.selectionPattern = nil
            self.statusCode = nil
        }
    }
}

/// Represents an integration response. The status code must map to an existing [MethodResponse], and parameters and templates can be used to transform the back-end response. [Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct UpdateIntegrationResponseOutputResponse: Swift.Equatable {
    /// Specifies how to handle response payload content type conversions. Supported values are CONVERT_TO_BINARY and CONVERT_TO_TEXT, with the following behaviors:
    ///
    /// * CONVERT_TO_BINARY: Converts a response payload from a Base64-encoded string to the corresponding binary blob.
    ///
    /// * CONVERT_TO_TEXT: Converts a response payload from a binary blob to a Base64-encoded string.
    ///
    ///
    /// If this property is not defined, the response payload will be passed through from the integration response to the method response without modification.
    public var contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
    /// A key-value map specifying response parameters that are passed to the method response from the back end. The key is a method response header parameter name and the mapped value is an integration response header value, a static value enclosed within a pair of single quotes, or a JSON expression from the integration response body. The mapping key must match the pattern of method.response.header.{name}, where name is a valid and unique header name. The mapped non-static value must match the pattern of integration.response.header.{name} or integration.response.body.{JSON-expression}, where name is a valid and unique response header name and JSON-expression is a valid JSON expression without the $ prefix.
    public var responseParameters: [Swift.String:Swift.String]?
    /// Specifies the templates used to transform the integration response body. Response templates are represented as a key/value map, with a content-type as the key and a template as the value.
    public var responseTemplates: [Swift.String:Swift.String]?
    /// Specifies the regular expression (regex) pattern used to choose an integration response based on the response from the back end. For example, if the success response returns nothing and the error response returns some string, you could use the .+ regex to match error response. However, make sure that the error response does not contain any newline (\n) character in such cases. If the back end is an AWS Lambda function, the AWS Lambda function error header is matched. For all other HTTP and AWS back ends, the HTTP status code is matched.
    public var selectionPattern: Swift.String?
    /// Specifies the status code that is used to map the integration response to an existing [MethodResponse].
    public var statusCode: Swift.String?

    public init (
        contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy? = nil,
        responseParameters: [Swift.String:Swift.String]? = nil,
        responseTemplates: [Swift.String:Swift.String]? = nil,
        selectionPattern: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.contentHandling = contentHandling
        self.responseParameters = responseParameters
        self.responseTemplates = responseTemplates
        self.selectionPattern = selectionPattern
        self.statusCode = statusCode
    }
}

struct UpdateIntegrationResponseOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.String?
    let selectionPattern: Swift.String?
    let responseParameters: [Swift.String:Swift.String]?
    let responseTemplates: [Swift.String:Swift.String]?
    let contentHandling: ApiGatewayClientTypes.ContentHandlingStrategy?
}

extension UpdateIntegrationResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentHandling
        case responseParameters
        case responseTemplates
        case selectionPattern
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let selectionPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .selectionPattern)
        selectionPattern = selectionPatternDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.String]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseParametersContainer {
                if let string0 = string0 {
                    responseParametersDecoded0?[key0] = string0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseTemplatesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseTemplates)
        var responseTemplatesDecoded0: [Swift.String:Swift.String]? = nil
        if let responseTemplatesContainer = responseTemplatesContainer {
            responseTemplatesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseTemplatesContainer {
                if let string0 = string0 {
                    responseTemplatesDecoded0?[key0] = string0
                }
            }
        }
        responseTemplates = responseTemplatesDecoded0
        let contentHandlingDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ContentHandlingStrategy.self, forKey: .contentHandling)
        contentHandling = contentHandlingDecoded
    }
}

extension UpdateMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateMethodInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())"
    }
}

/// Request to update an existing [Method] resource.
public struct UpdateMethodInput: Swift.Equatable {
    /// [Required] The HTTP verb of the [Method] resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The [Resource] identifier for the [Method] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateMethodInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateMethodOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMethodOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMethodOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMethodOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMethodOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeyRequired = output.apiKeyRequired
            self.authorizationScopes = output.authorizationScopes
            self.authorizationType = output.authorizationType
            self.authorizerId = output.authorizerId
            self.httpMethod = output.httpMethod
            self.methodIntegration = output.methodIntegration
            self.methodResponses = output.methodResponses
            self.operationName = output.operationName
            self.requestModels = output.requestModels
            self.requestParameters = output.requestParameters
            self.requestValidatorId = output.requestValidatorId
        } else {
            self.apiKeyRequired = nil
            self.authorizationScopes = nil
            self.authorizationType = nil
            self.authorizerId = nil
            self.httpMethod = nil
            self.methodIntegration = nil
            self.methodResponses = nil
            self.operationName = nil
            self.requestModels = nil
            self.requestParameters = nil
            self.requestValidatorId = nil
        }
    }
}

/// Represents a client-facing interface by which the client calls the API to access back-end resources. A Method resource is integrated with an [Integration] resource. Both consist of a request and one or more responses. The method request takes the client input that is passed to the back end through the integration request. A method response returns the output from the back end to the client through an integration response. A method request is embodied in a Method resource, whereas an integration request is embodied in an [Integration] resource. On the other hand, a method response is represented by a [MethodResponse] resource, whereas an integration response is represented by an [IntegrationResponse] resource.
/// Example: Retrive the GET method on a specified resource
///
///
/// Request
///
/// The following example request retrieves the information about the GET method on an API resource (3kzxbg5sa2) of an API (fugvjdxtri). GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160603T210259Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
/// Response
///
/// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html", "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET", "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}", "templated": true } }, "apiKeyRequired": true, "authorizationType": "NONE", "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type": "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E\")" }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" } } } In the example above, the response template for the 200 OK response maps the JSON output from the ListStreams action in the back end to an XML output. The mapping template is URL-encoded as %3CkinesisStreams%3E%23foreach(%24stream%20in%20%24input.path(%27%24.StreamNames%27))%3Cstream%3E%3Cname%3E%24stream%3C%2Fname%3E%3C%2Fstream%3E%23end%3C%2FkinesisStreams%3E and the output is decoded using the [$util.urlDecode()](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html#util-templat-reference) helper function. [MethodResponse], [Integration], [IntegrationResponse], [Resource], [Set up an API's method](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html)
public struct UpdateMethodOutputResponse: Swift.Equatable {
    /// A boolean flag specifying whether a valid [ApiKey] is required to invoke this method.
    public var apiKeyRequired: Swift.Bool?
    /// A list of authorization scopes configured on the method. The scopes are used with a COGNITO_USER_POOLS authorizer to authorize the method invocation. The authorization works by matching the method scopes against the scopes parsed from the access token in the incoming request. The method invocation is authorized if any method scopes matches a claimed scope in the access token. Otherwise, the invocation is not authorized. When the method scope is configured, the client must provide an access token instead of an identity token for authorization purposes.
    public var authorizationScopes: [Swift.String]?
    /// The method's authorization type. Valid values are NONE for open access, AWS_IAM for using AWS IAM permissions, CUSTOM for using a custom authorizer, or COGNITO_USER_POOLS for using a Cognito user pool.
    public var authorizationType: Swift.String?
    /// The identifier of an [Authorizer] to use on this method. The authorizationType must be CUSTOM.
    public var authorizerId: Swift.String?
    /// The method's HTTP verb.
    public var httpMethod: Swift.String?
    /// Gets the method's integration responsible for passing the client-submitted request to the back end and performing necessary transformations to make the request compliant with the back end.
    /// Example:
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length: 117 X-Amz-Date: 20160613T213210Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true } ], "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integration:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integration:responses": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "0cjtch", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestTemplates": { "application/json": "{\n \"a\": \"$input.params('operand1')\",\n \"b\": \"$input.params('operand2')\", \n \"op\": \"$input.params('operator')\" \n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-west-2:lambda:path//2015-03-31/functions/arn:aws:lambda:us-west-2:123456789012:function:Calc/invocations", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.operator": "integration.response.body.op", "method.response.header.operand_2": "integration.response.body.b", "method.response.header.operand_1": "integration.response.body.a" }, "responseTemplates": { "application/json": "#set($res = $input.path('$'))\n{\n \"result\": \"$res.a, $res.b, $res.op => $res.c\",\n \"a\" : \"$res.a\",\n \"b\" : \"$res.b\",\n \"op\" : \"$res.op\",\n \"c\" : \"$res.c\"\n}" }, "selectionPattern": "", "statusCode": "200" } } }[AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-integration.html)
    public var methodIntegration: ApiGatewayClientTypes.Integration?
    /// Gets a method response associated with a given HTTP status code. The collection of method responses are encapsulated in a key-value map, where the key is a response's HTTP status code and the value is a [MethodResponse] resource that specifies the response returned to the caller from the back end through the integration response.
    /// Example: Get a 200 OK response of a GET method
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com Content-Length: 117 X-Amz-Date: 20160613T215008Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160613/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// The successful response returns a 200 OK status code and a payload similar to the following: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/uojnr9hd57/resources/0cjtch/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.operator": false, "method.response.header.operand_2": false, "method.response.header.operand_1": false }, "statusCode": "200" }[AWS CLI](https://docs.aws.amazon.com/cli/latest/reference/apigateway/get-method-response.html)
    public var methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]?
    /// A human-friendly operation identifier for the method. For example, you can assign the operationName of ListPets for the GET /pets method in the PetStore example.
    public var operationName: Swift.String?
    /// A key-value map specifying data schemas, represented by [Model] resources, (as the mapped value) of the request payloads of given content types (as the mapping key).
    public var requestModels: [Swift.String:Swift.String]?
    /// A key-value map defining required or optional method request parameters that can be accepted by API Gateway. A key is a method request parameter name matching the pattern of method.request.{location}.{name}, where location is querystring, path, or header and name is a valid and unique parameter name. The value associated with the key is a Boolean flag indicating whether the parameter is required (true) or optional (false). The method request parameter names defined here are available in [Integration] to be mapped to integration request parameters or templates.
    public var requestParameters: [Swift.String:Swift.Bool]?
    /// The identifier of a [RequestValidator] for request validation.
    public var requestValidatorId: Swift.String?

    public init (
        apiKeyRequired: Swift.Bool? = nil,
        authorizationScopes: [Swift.String]? = nil,
        authorizationType: Swift.String? = nil,
        authorizerId: Swift.String? = nil,
        httpMethod: Swift.String? = nil,
        methodIntegration: ApiGatewayClientTypes.Integration? = nil,
        methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]? = nil,
        operationName: Swift.String? = nil,
        requestModels: [Swift.String:Swift.String]? = nil,
        requestParameters: [Swift.String:Swift.Bool]? = nil,
        requestValidatorId: Swift.String? = nil
    )
    {
        self.apiKeyRequired = apiKeyRequired
        self.authorizationScopes = authorizationScopes
        self.authorizationType = authorizationType
        self.authorizerId = authorizerId
        self.httpMethod = httpMethod
        self.methodIntegration = methodIntegration
        self.methodResponses = methodResponses
        self.operationName = operationName
        self.requestModels = requestModels
        self.requestParameters = requestParameters
        self.requestValidatorId = requestValidatorId
    }
}

struct UpdateMethodOutputResponseBody: Swift.Equatable {
    let httpMethod: Swift.String?
    let authorizationType: Swift.String?
    let authorizerId: Swift.String?
    let apiKeyRequired: Swift.Bool?
    let requestValidatorId: Swift.String?
    let operationName: Swift.String?
    let requestParameters: [Swift.String:Swift.Bool]?
    let requestModels: [Swift.String:Swift.String]?
    let methodResponses: [Swift.String:ApiGatewayClientTypes.MethodResponse]?
    let methodIntegration: ApiGatewayClientTypes.Integration?
    let authorizationScopes: [Swift.String]?
}

extension UpdateMethodOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeyRequired
        case authorizationScopes
        case authorizationType
        case authorizerId
        case httpMethod
        case methodIntegration
        case methodResponses
        case operationName
        case requestModels
        case requestParameters
        case requestValidatorId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authorizerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizerId)
        authorizerId = authorizerIdDecoded
        let apiKeyRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .apiKeyRequired)
        apiKeyRequired = apiKeyRequiredDecoded
        let requestValidatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestValidatorId)
        requestValidatorId = requestValidatorIdDecoded
        let operationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationName)
        operationName = operationNameDecoded
        let requestParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .requestParameters)
        var requestParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let requestParametersContainer = requestParametersContainer {
            requestParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in requestParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    requestParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        requestParameters = requestParametersDecoded0
        let requestModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestModels)
        var requestModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let requestModelsContainer = requestModelsContainer {
            requestModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestModelsContainer {
                if let string0 = string0 {
                    requestModelsDecoded0?[key0] = string0
                }
            }
        }
        requestModels = requestModelsDecoded0
        let methodResponsesContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.MethodResponse?].self, forKey: .methodResponses)
        var methodResponsesDecoded0: [Swift.String:ApiGatewayClientTypes.MethodResponse]? = nil
        if let methodResponsesContainer = methodResponsesContainer {
            methodResponsesDecoded0 = [Swift.String:ApiGatewayClientTypes.MethodResponse]()
            for (key0, methodresponse0) in methodResponsesContainer {
                if let methodresponse0 = methodresponse0 {
                    methodResponsesDecoded0?[key0] = methodresponse0
                }
            }
        }
        methodResponses = methodResponsesDecoded0
        let methodIntegrationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.Integration.self, forKey: .methodIntegration)
        methodIntegration = methodIntegrationDecoded
        let authorizationScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizationScopes)
        var authorizationScopesDecoded0:[Swift.String]? = nil
        if let authorizationScopesContainer = authorizationScopesContainer {
            authorizationScopesDecoded0 = [Swift.String]()
            for string0 in authorizationScopesContainer {
                if let string0 = string0 {
                    authorizationScopesDecoded0?.append(string0)
                }
            }
        }
        authorizationScopes = authorizationScopesDecoded0
    }
}

extension UpdateMethodResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateMethodResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        guard let httpMethod = httpMethod else {
            return nil
        }
        guard let statusCode = statusCode else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())/methods/\(httpMethod.urlPercentEncoding())/responses/\(statusCode.urlPercentEncoding())"
    }
}

/// A request to update an existing [MethodResponse] resource.
public struct UpdateMethodResponseInput: Swift.Equatable {
    /// [Required] The HTTP verb of the [Method] resource.
    /// This member is required.
    public var httpMethod: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The [Resource] identifier for the [MethodResponse] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The status code for the [MethodResponse] resource.
    /// This member is required.
    public var statusCode: Swift.String?

    public init (
        httpMethod: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.httpMethod = httpMethod
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
        self.statusCode = statusCode
    }
}

struct UpdateMethodResponseInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateMethodResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateMethodResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMethodResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMethodResponseOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMethodResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateMethodResponseOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.responseModels = output.responseModels
            self.responseParameters = output.responseParameters
            self.statusCode = output.statusCode
        } else {
            self.responseModels = nil
            self.responseParameters = nil
            self.statusCode = nil
        }
    }
}

/// Represents a method response of a given HTTP status code returned to the client. The method response is passed from the back end through the associated integration response that can be transformed using a mapping template.
/// Example: A MethodResponse instance of an API
///
///
/// Request
///
/// The example request retrieves a MethodResponse of the 200 status code. GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200 HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20160603T222952Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20160603/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
/// Response
///
/// The successful response returns 200 OK status and a payload as follows: { "_links": { "curies": { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true }, "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" }[Method], [IntegrationResponse], [Integration][Creating an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct UpdateMethodResponseOutputResponse: Swift.Equatable {
    /// Specifies the [Model] resources used for the response's content-type. Response models are represented as a key/value map, with a content-type as the key and a [Model] name as the value.
    public var responseModels: [Swift.String:Swift.String]?
    /// A key-value map specifying required or optional response parameters that API Gateway can send back to the caller. A key defines a method response header and the value specifies whether the associated method response header is required or not. The expression of the key must match the pattern method.response.header.{name}, where name is a valid and unique header name. API Gateway passes certain integration response data to the method response headers specified here according to the mapping you prescribe in the API's [IntegrationResponse]. The integration response data that can be mapped include an integration response header expressed in integration.response.header.{name}, a static value enclosed within a pair of single quotes (e.g., 'application/json'), or a JSON expression from the back-end response payload in the form of integration.response.body.{JSON-expression}, where JSON-expression is a valid JSON expression without the $ prefix.)
    public var responseParameters: [Swift.String:Swift.Bool]?
    /// The method response's status code.
    public var statusCode: Swift.String?

    public init (
        responseModels: [Swift.String:Swift.String]? = nil,
        responseParameters: [Swift.String:Swift.Bool]? = nil,
        statusCode: Swift.String? = nil
    )
    {
        self.responseModels = responseModels
        self.responseParameters = responseParameters
        self.statusCode = statusCode
    }
}

struct UpdateMethodResponseOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.String?
    let responseParameters: [Swift.String:Swift.Bool]?
    let responseModels: [Swift.String:Swift.String]?
}

extension UpdateMethodResponseOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case responseModels
        case responseParameters
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let responseParametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Bool?].self, forKey: .responseParameters)
        var responseParametersDecoded0: [Swift.String:Swift.Bool]? = nil
        if let responseParametersContainer = responseParametersContainer {
            responseParametersDecoded0 = [Swift.String:Swift.Bool]()
            for (key0, nullableboolean0) in responseParametersContainer {
                if let nullableboolean0 = nullableboolean0 {
                    responseParametersDecoded0?[key0] = nullableboolean0
                }
            }
        }
        responseParameters = responseParametersDecoded0
        let responseModelsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .responseModels)
        var responseModelsDecoded0: [Swift.String:Swift.String]? = nil
        if let responseModelsContainer = responseModelsContainer {
            responseModelsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in responseModelsContainer {
                if let string0 = string0 {
                    responseModelsDecoded0?[key0] = string0
                }
            }
        }
        responseModels = responseModelsDecoded0
    }
}

extension UpdateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let modelName = modelName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/models/\(modelName.urlPercentEncoding())"
    }
}

/// Request to update an existing model in an existing [RestApi] resource.
public struct UpdateModelInput: Swift.Equatable {
    /// [Required] The name of the model to update.
    /// This member is required.
    public var modelName: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        modelName: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.modelName = modelName
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateModelInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateModelOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contentType = output.contentType
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.schema = output.schema
        } else {
            self.contentType = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.schema = nil
        }
    }
}

/// Represents the data structure of a method's request or response payload. A request model defines the data structure of the client-supplied request payload. A response model defines the data structure of the response payload returned by the back end. Although not required, models are useful for mapping payloads between the front end and back end. A model is used for generating an API's SDK, validating the input request body, and creating a skeletal mapping template. [Method], [MethodResponse], [Models and Mappings](https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html)
public struct UpdateModelOutputResponse: Swift.Equatable {
    /// The content-type for the model.
    public var contentType: Swift.String?
    /// The description of the model.
    public var description: Swift.String?
    /// The identifier for the model resource.
    public var id: Swift.String?
    /// The name of the model. Must be an alphanumeric string.
    public var name: Swift.String?
    /// The schema for the model. For application/json models, this should be [JSON schema draft 4](https://tools.ietf.org/html/draft-zyp-json-schema-04) model. Do not include "\*/" characters in the description of any properties because such "\*/" characters may be interpreted as the closing marker for comments in some languages, such as Java or JavaScript, causing the installation of your API's SDK generated by API Gateway to fail.
    public var schema: Swift.String?

    public init (
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        schema: Swift.String? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.id = id
        self.name = name
        self.schema = schema
    }
}

struct UpdateModelOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let schema: Swift.String?
    let contentType: Swift.String?
}

extension UpdateModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case description
        case id
        case name
        case schema
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension UpdateRequestValidatorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateRequestValidatorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let requestValidatorId = requestValidatorId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/requestvalidators/\(requestValidatorId.urlPercentEncoding())"
    }
}

/// Updates a [RequestValidator] of a given [RestApi].
public struct UpdateRequestValidatorInput: Swift.Equatable {
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The identifier of [RequestValidator] to be updated.
    /// This member is required.
    public var requestValidatorId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        requestValidatorId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.requestValidatorId = requestValidatorId
        self.restApiId = restApiId
    }
}

struct UpdateRequestValidatorInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateRequestValidatorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateRequestValidatorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRequestValidatorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRequestValidatorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRequestValidatorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRequestValidatorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.name = output.name
            self.validateRequestBody = output.validateRequestBody
            self.validateRequestParameters = output.validateRequestParameters
        } else {
            self.id = nil
            self.name = nil
            self.validateRequestBody = false
            self.validateRequestParameters = false
        }
    }
}

/// A set of validation rules for incoming [Method] requests. In OpenAPI, a [RequestValidator] of an API is defined by the [x-amazon-apigateway-request-validators.requestValidator](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validators.requestValidator.html) object. It the referenced using the [x-amazon-apigateway-request-validator](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-swagger-extensions.html#api-gateway-swagger-extensions-request-validator) property. [Enable Basic Request Validation in API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-method-request-validation.html)
public struct UpdateRequestValidatorOutputResponse: Swift.Equatable {
    /// The identifier of this [RequestValidator].
    public var id: Swift.String?
    /// The name of this [RequestValidator]
    public var name: Swift.String?
    /// A Boolean flag to indicate whether to validate a request body according to the configured [Model] schema.
    public var validateRequestBody: Swift.Bool
    /// A Boolean flag to indicate whether to validate request parameters (true) or not (false).
    public var validateRequestParameters: Swift.Bool

    public init (
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        validateRequestBody: Swift.Bool = false,
        validateRequestParameters: Swift.Bool = false
    )
    {
        self.id = id
        self.name = name
        self.validateRequestBody = validateRequestBody
        self.validateRequestParameters = validateRequestParameters
    }
}

struct UpdateRequestValidatorOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let validateRequestBody: Swift.Bool
    let validateRequestParameters: Swift.Bool
}

extension UpdateRequestValidatorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case validateRequestBody
        case validateRequestParameters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validateRequestBodyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestBody)
        validateRequestBody = validateRequestBodyDecoded
        let validateRequestParametersDecoded = try containerValues.decode(Swift.Bool.self, forKey: .validateRequestParameters)
        validateRequestParameters = validateRequestParametersDecoded
    }
}

extension UpdateResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let resourceId = resourceId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/resources/\(resourceId.urlPercentEncoding())"
    }
}

/// Request to change information about a [Resource] resource.
public struct UpdateResourceInput: Swift.Equatable {
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The identifier of the [Resource] resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        resourceId: Swift.String? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.resourceId = resourceId
        self.restApiId = restApiId
    }
}

struct UpdateResourceInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.parentId = output.parentId
            self.path = output.path
            self.pathPart = output.pathPart
            self.resourceMethods = output.resourceMethods
        } else {
            self.id = nil
            self.parentId = nil
            self.path = nil
            self.pathPart = nil
            self.resourceMethods = nil
        }
    }
}

/// Represents an API resource. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct UpdateResourceOutputResponse: Swift.Equatable {
    /// The resource's identifier.
    public var id: Swift.String?
    /// The parent resource's identifier.
    public var parentId: Swift.String?
    /// The full path for this resource.
    public var path: Swift.String?
    /// The last path segment for this resource.
    public var pathPart: Swift.String?
    /// Gets an API resource's method of a given HTTP verb. The resource methods are a map of methods indexed by methods' HTTP verbs enabled on the resource. This method map is included in the 200 OK response of the GET /restapis/{restapi_id}/resources/{resource_id} or GET /restapis/{restapi_id}/resources/{resource_id}?embed=methods request.
    /// Example: Get the GET method of an API resource
    ///
    ///
    /// Request
    ///
    ///
    ///     GET /restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET HTTP/1.1 Content-Type: application/json Host: apigateway.us-east-1.amazonaws.com X-Amz-Date: 20170223T031827Z Authorization: AWS4-HMAC-SHA256 Credential={access_key_ID}/20170223/us-east-1/apigateway/aws4_request, SignedHeaders=content-type;host;x-amz-date, Signature={sig4_hash}
    ///
    ///
    /// Response
    ///
    /// { "_links": { "curies": [ { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-{rel}.html", "name": "integration", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-integration-response-{rel}.html", "name": "integrationresponse", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-{rel}.html", "name": "method", "templated": true }, { "href": "https://docs.aws.amazon.com/apigateway/latest/developerguide/restapi-method-response-{rel}.html", "name": "methodresponse", "templated": true } ], "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET", "name": "GET", "title": "GET" }, "integration:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "method:integration": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "method:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "method:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET" }, "methodresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/{status_code}", "templated": true } }, "apiKeyRequired": false, "authorizationType": "NONE", "httpMethod": "GET", "_embedded": { "method:integration": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integration:responses": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integration:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration" }, "integrationresponse:put": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/{status_code}", "templated": true } }, "cacheKeyParameters": [], "cacheNamespace": "3kzxbg5sa2", "credentials": "arn:aws:iam::123456789012:role/apigAwsProxyRole", "httpMethod": "POST", "passthroughBehavior": "WHEN_NO_MATCH", "requestParameters": { "integration.request.header.Content-Type": "'application/x-amz-json-1.1'" }, "requestTemplates": { "application/json": "{\n}" }, "type": "AWS", "uri": "arn:aws:apigateway:us-east-1:kinesis:action/ListStreams", "_embedded": { "integration:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200", "name": "200", "title": "200" }, "integrationresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" }, "integrationresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/integration/responses/200" } }, "responseParameters": { "method.response.header.Content-Type": "'application/xml'" }, "responseTemplates": { "application/json": "$util.urlDecode(\"%3CkinesisStreams%3E#foreach($stream in $input.path('$.StreamNames'))%3Cstream%3E%3Cname%3E$stream%3C/name%3E%3C/stream%3E#end%3C/kinesisStreams%3E\")\n" }, "statusCode": "200" } } }, "method:responses": { "_links": { "self": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200", "name": "200", "title": "200" }, "methodresponse:delete": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" }, "methodresponse:update": { "href": "/restapis/fugvjdxtri/resources/3kzxbg5sa2/methods/GET/responses/200" } }, "responseModels": { "application/json": "Empty" }, "responseParameters": { "method.response.header.Content-Type": false }, "statusCode": "200" } } } If the OPTIONS is enabled on the resource, you can follow the example here to get that method. Just replace the GET of the last path segment in the request URL with OPTIONS.
    public var resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]?

    public init (
        id: Swift.String? = nil,
        parentId: Swift.String? = nil,
        path: Swift.String? = nil,
        pathPart: Swift.String? = nil,
        resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]? = nil
    )
    {
        self.id = id
        self.parentId = parentId
        self.path = path
        self.pathPart = pathPart
        self.resourceMethods = resourceMethods
    }
}

struct UpdateResourceOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let parentId: Swift.String?
    let pathPart: Swift.String?
    let path: Swift.String?
    let resourceMethods: [Swift.String:ApiGatewayClientTypes.Method]?
}

extension UpdateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case parentId
        case path
        case pathPart
        case resourceMethods
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentId)
        parentId = parentIdDecoded
        let pathPartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathPart)
        pathPart = pathPartDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let resourceMethodsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.Method?].self, forKey: .resourceMethods)
        var resourceMethodsDecoded0: [Swift.String:ApiGatewayClientTypes.Method]? = nil
        if let resourceMethodsContainer = resourceMethodsContainer {
            resourceMethodsDecoded0 = [Swift.String:ApiGatewayClientTypes.Method]()
            for (key0, method0) in resourceMethodsContainer {
                if let method0 = method0 {
                    resourceMethodsDecoded0?[key0] = method0
                }
            }
        }
        resourceMethods = resourceMethodsDecoded0
    }
}

extension UpdateRestApiInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateRestApiInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())"
    }
}

/// Request to update an existing [RestApi] resource in your collection.
public struct UpdateRestApiInput: Swift.Equatable {
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?

    public init (
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.restApiId = restApiId
    }
}

struct UpdateRestApiInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateRestApiInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateRestApiOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRestApiOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRestApiOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRestApiOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateRestApiOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiKeySource = output.apiKeySource
            self.binaryMediaTypes = output.binaryMediaTypes
            self.createdDate = output.createdDate
            self.description = output.description
            self.disableExecuteApiEndpoint = output.disableExecuteApiEndpoint
            self.endpointConfiguration = output.endpointConfiguration
            self.id = output.id
            self.minimumCompressionSize = output.minimumCompressionSize
            self.name = output.name
            self.policy = output.policy
            self.tags = output.tags
            self.version = output.version
            self.warnings = output.warnings
        } else {
            self.apiKeySource = nil
            self.binaryMediaTypes = nil
            self.createdDate = nil
            self.description = nil
            self.disableExecuteApiEndpoint = false
            self.endpointConfiguration = nil
            self.id = nil
            self.minimumCompressionSize = nil
            self.name = nil
            self.policy = nil
            self.tags = nil
            self.version = nil
            self.warnings = nil
        }
    }
}

/// Represents a REST API. [Create an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-create-api.html)
public struct UpdateRestApiOutputResponse: Swift.Equatable {
    /// The source of the API key for metering requests according to a usage plan. Valid values are:
    ///
    /// * HEADER to read the API key from the X-API-Key header of a request.
    ///
    /// * AUTHORIZER to read the API key from the UsageIdentifierKey from a custom authorizer.
    public var apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    /// The list of binary media types supported by the [RestApi]. By default, the [RestApi] supports only UTF-8-encoded text payloads.
    public var binaryMediaTypes: [Swift.String]?
    /// The timestamp when the API was created.
    public var createdDate: ClientRuntime.Date?
    /// The API's description.
    public var description: Swift.String?
    /// Specifies whether clients can invoke your API by using the default execute-api endpoint. By default, clients can invoke your API with the default https://{api_id}.execute-api.{region}.amazonaws.com endpoint. To require that clients use a custom domain name to invoke your API, disable the default endpoint.
    public var disableExecuteApiEndpoint: Swift.Bool
    /// The endpoint configuration of this [RestApi] showing the endpoint types of the API.
    public var endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    /// The API's identifier. This identifier is unique across all of your APIs in API Gateway.
    public var id: Swift.String?
    /// A nullable integer that is used to enable compression (with non-negative between 0 and 10485760 (10M) bytes, inclusive) or disable compression (with a null value) on an API. When compression is enabled, compression or decompression is not applied on the payload if the payload size is smaller than this value. Setting it to zero allows compression for any payload size.
    public var minimumCompressionSize: Swift.Int?
    /// The API's name.
    public var name: Swift.String?
    /// A stringified JSON policy document that applies to this RestApi regardless of the caller and [Method] configuration.
    public var policy: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// A version identifier for the API.
    public var version: Swift.String?
    /// The warning messages reported when failonwarnings is turned on during API import.
    public var warnings: [Swift.String]?

    public init (
        apiKeySource: ApiGatewayClientTypes.ApiKeySourceType? = nil,
        binaryMediaTypes: [Swift.String]? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        disableExecuteApiEndpoint: Swift.Bool = false,
        endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration? = nil,
        id: Swift.String? = nil,
        minimumCompressionSize: Swift.Int? = nil,
        name: Swift.String? = nil,
        policy: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        version: Swift.String? = nil,
        warnings: [Swift.String]? = nil
    )
    {
        self.apiKeySource = apiKeySource
        self.binaryMediaTypes = binaryMediaTypes
        self.createdDate = createdDate
        self.description = description
        self.disableExecuteApiEndpoint = disableExecuteApiEndpoint
        self.endpointConfiguration = endpointConfiguration
        self.id = id
        self.minimumCompressionSize = minimumCompressionSize
        self.name = name
        self.policy = policy
        self.tags = tags
        self.version = version
        self.warnings = warnings
    }
}

struct UpdateRestApiOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
    let version: Swift.String?
    let warnings: [Swift.String]?
    let binaryMediaTypes: [Swift.String]?
    let minimumCompressionSize: Swift.Int?
    let apiKeySource: ApiGatewayClientTypes.ApiKeySourceType?
    let endpointConfiguration: ApiGatewayClientTypes.EndpointConfiguration?
    let policy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let disableExecuteApiEndpoint: Swift.Bool
}

extension UpdateRestApiOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKeySource
        case binaryMediaTypes
        case createdDate
        case description
        case disableExecuteApiEndpoint
        case endpointConfiguration
        case id
        case minimumCompressionSize
        case name
        case policy
        case tags
        case version
        case warnings
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let warningsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .warnings)
        var warningsDecoded0:[Swift.String]? = nil
        if let warningsContainer = warningsContainer {
            warningsDecoded0 = [Swift.String]()
            for string0 in warningsContainer {
                if let string0 = string0 {
                    warningsDecoded0?.append(string0)
                }
            }
        }
        warnings = warningsDecoded0
        let binaryMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .binaryMediaTypes)
        var binaryMediaTypesDecoded0:[Swift.String]? = nil
        if let binaryMediaTypesContainer = binaryMediaTypesContainer {
            binaryMediaTypesDecoded0 = [Swift.String]()
            for string0 in binaryMediaTypesContainer {
                if let string0 = string0 {
                    binaryMediaTypesDecoded0?.append(string0)
                }
            }
        }
        binaryMediaTypes = binaryMediaTypesDecoded0
        let minimumCompressionSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimumCompressionSize)
        minimumCompressionSize = minimumCompressionSizeDecoded
        let apiKeySourceDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ApiKeySourceType.self, forKey: .apiKeySource)
        apiKeySource = apiKeySourceDecoded
        let endpointConfigurationDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.EndpointConfiguration.self, forKey: .endpointConfiguration)
        endpointConfiguration = endpointConfigurationDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let disableExecuteApiEndpointDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableExecuteApiEndpoint)
        disableExecuteApiEndpoint = disableExecuteApiEndpointDecoded
    }
}

extension UpdateStageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateStageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let restApiId = restApiId else {
            return nil
        }
        guard let stageName = stageName else {
            return nil
        }
        return "/restapis/\(restApiId.urlPercentEncoding())/stages/\(stageName.urlPercentEncoding())"
    }
}

/// Requests API Gateway to change information about a [Stage] resource.
public struct UpdateStageInput: Swift.Equatable {
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The string identifier of the associated [RestApi].
    /// This member is required.
    public var restApiId: Swift.String?
    /// [Required] The name of the [Stage] resource to change information about.
    /// This member is required.
    public var stageName: Swift.String?

    public init (
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        restApiId: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.restApiId = restApiId
        self.stageName = stageName
    }
}

struct UpdateStageInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateStageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateStageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessLogSettings = output.accessLogSettings
            self.cacheClusterEnabled = output.cacheClusterEnabled
            self.cacheClusterSize = output.cacheClusterSize
            self.cacheClusterStatus = output.cacheClusterStatus
            self.canarySettings = output.canarySettings
            self.clientCertificateId = output.clientCertificateId
            self.createdDate = output.createdDate
            self.deploymentId = output.deploymentId
            self.description = output.description
            self.documentationVersion = output.documentationVersion
            self.lastUpdatedDate = output.lastUpdatedDate
            self.methodSettings = output.methodSettings
            self.stageName = output.stageName
            self.tags = output.tags
            self.tracingEnabled = output.tracingEnabled
            self.variables = output.variables
            self.webAclArn = output.webAclArn
        } else {
            self.accessLogSettings = nil
            self.cacheClusterEnabled = false
            self.cacheClusterSize = nil
            self.cacheClusterStatus = nil
            self.canarySettings = nil
            self.clientCertificateId = nil
            self.createdDate = nil
            self.deploymentId = nil
            self.description = nil
            self.documentationVersion = nil
            self.lastUpdatedDate = nil
            self.methodSettings = nil
            self.stageName = nil
            self.tags = nil
            self.tracingEnabled = false
            self.variables = nil
            self.webAclArn = nil
        }
    }
}

/// Represents a unique identifier for a version of a deployed [RestApi] that is callable by users. [Deploy an API](https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html)
public struct UpdateStageOutputResponse: Swift.Equatable {
    /// Settings for logging access in this stage.
    public var accessLogSettings: ApiGatewayClientTypes.AccessLogSettings?
    /// Specifies whether a cache cluster is enabled for the stage.
    public var cacheClusterEnabled: Swift.Bool
    /// The size of the cache cluster for the stage, if enabled.
    public var cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    /// The status of the cache cluster for the stage, if enabled.
    public var cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus?
    /// Settings for the canary deployment in this stage.
    public var canarySettings: ApiGatewayClientTypes.CanarySettings?
    /// The identifier of a client certificate for an API stage.
    public var clientCertificateId: Swift.String?
    /// The timestamp when the stage was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier of the [Deployment] that the stage points to.
    public var deploymentId: Swift.String?
    /// The stage's description.
    public var description: Swift.String?
    /// The version of the associated API documentation.
    public var documentationVersion: Swift.String?
    /// The timestamp when the stage last updated.
    public var lastUpdatedDate: ClientRuntime.Date?
    /// A map that defines the method settings for a [Stage] resource. Keys (designated as /{method_setting_key below) are method paths defined as {resource_path}/{http_method} for an individual method override, or /\*/\* for overriding all methods in the stage.
    public var methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]?
    /// The name of the stage is the first path segment in the Uniform Resource Identifier (URI) of a call to API Gateway. Stage names can only contain alphanumeric characters, hyphens, and underscores. Maximum length is 128 characters.
    public var stageName: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// Specifies whether active tracing with X-ray is enabled for the [Stage].
    public var tracingEnabled: Swift.Bool
    /// A map that defines the stage variables for a [Stage] resource. Variable names can have alphanumeric and underscore characters, and the values must match [A-Za-z0-9-._~:/?#&=,]+.
    public var variables: [Swift.String:Swift.String]?
    /// The ARN of the WebAcl associated with the [Stage].
    public var webAclArn: Swift.String?

    public init (
        accessLogSettings: ApiGatewayClientTypes.AccessLogSettings? = nil,
        cacheClusterEnabled: Swift.Bool = false,
        cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize? = nil,
        cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus? = nil,
        canarySettings: ApiGatewayClientTypes.CanarySettings? = nil,
        clientCertificateId: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        deploymentId: Swift.String? = nil,
        description: Swift.String? = nil,
        documentationVersion: Swift.String? = nil,
        lastUpdatedDate: ClientRuntime.Date? = nil,
        methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]? = nil,
        stageName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tracingEnabled: Swift.Bool = false,
        variables: [Swift.String:Swift.String]? = nil,
        webAclArn: Swift.String? = nil
    )
    {
        self.accessLogSettings = accessLogSettings
        self.cacheClusterEnabled = cacheClusterEnabled
        self.cacheClusterSize = cacheClusterSize
        self.cacheClusterStatus = cacheClusterStatus
        self.canarySettings = canarySettings
        self.clientCertificateId = clientCertificateId
        self.createdDate = createdDate
        self.deploymentId = deploymentId
        self.description = description
        self.documentationVersion = documentationVersion
        self.lastUpdatedDate = lastUpdatedDate
        self.methodSettings = methodSettings
        self.stageName = stageName
        self.tags = tags
        self.tracingEnabled = tracingEnabled
        self.variables = variables
        self.webAclArn = webAclArn
    }
}

struct UpdateStageOutputResponseBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let clientCertificateId: Swift.String?
    let stageName: Swift.String?
    let description: Swift.String?
    let cacheClusterEnabled: Swift.Bool
    let cacheClusterSize: ApiGatewayClientTypes.CacheClusterSize?
    let cacheClusterStatus: ApiGatewayClientTypes.CacheClusterStatus?
    let methodSettings: [Swift.String:ApiGatewayClientTypes.MethodSetting]?
    let variables: [Swift.String:Swift.String]?
    let documentationVersion: Swift.String?
    let accessLogSettings: ApiGatewayClientTypes.AccessLogSettings?
    let canarySettings: ApiGatewayClientTypes.CanarySettings?
    let tracingEnabled: Swift.Bool
    let webAclArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let createdDate: ClientRuntime.Date?
    let lastUpdatedDate: ClientRuntime.Date?
}

extension UpdateStageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessLogSettings
        case cacheClusterEnabled
        case cacheClusterSize
        case cacheClusterStatus
        case canarySettings
        case clientCertificateId
        case createdDate
        case deploymentId
        case description
        case documentationVersion
        case lastUpdatedDate
        case methodSettings
        case stageName
        case tags
        case tracingEnabled
        case variables
        case webAclArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let clientCertificateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCertificateId)
        clientCertificateId = clientCertificateIdDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let cacheClusterEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .cacheClusterEnabled)
        cacheClusterEnabled = cacheClusterEnabledDecoded
        let cacheClusterSizeDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterSize.self, forKey: .cacheClusterSize)
        cacheClusterSize = cacheClusterSizeDecoded
        let cacheClusterStatusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CacheClusterStatus.self, forKey: .cacheClusterStatus)
        cacheClusterStatus = cacheClusterStatusDecoded
        let methodSettingsContainer = try containerValues.decodeIfPresent([Swift.String: ApiGatewayClientTypes.MethodSetting?].self, forKey: .methodSettings)
        var methodSettingsDecoded0: [Swift.String:ApiGatewayClientTypes.MethodSetting]? = nil
        if let methodSettingsContainer = methodSettingsContainer {
            methodSettingsDecoded0 = [Swift.String:ApiGatewayClientTypes.MethodSetting]()
            for (key0, methodsetting0) in methodSettingsContainer {
                if let methodsetting0 = methodsetting0 {
                    methodSettingsDecoded0?[key0] = methodsetting0
                }
            }
        }
        methodSettings = methodSettingsDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variablesContainer {
                if let string0 = string0 {
                    variablesDecoded0?[key0] = string0
                }
            }
        }
        variables = variablesDecoded0
        let documentationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentationVersion)
        documentationVersion = documentationVersionDecoded
        let accessLogSettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.AccessLogSettings.self, forKey: .accessLogSettings)
        accessLogSettings = accessLogSettingsDecoded
        let canarySettingsDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.CanarySettings.self, forKey: .canarySettings)
        canarySettings = canarySettingsDecoded
        let tracingEnabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .tracingEnabled)
        tracingEnabled = tracingEnabledDecoded
        let webAclArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webAclArn)
        webAclArn = webAclArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let createdDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
    }
}

extension UpdateUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        guard let keyId = keyId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())/keys/\(keyId.urlPercentEncoding())/usage"
    }
}

/// The PATCH request to grant a temporary extension to the remaining quota of a usage plan associated with a specified API key.
public struct UpdateUsageInput: Swift.Equatable {
    /// [Required] The identifier of the API key associated with the usage plan in which a temporary extension is granted to the remaining quota.
    /// This member is required.
    public var keyId: Swift.String?
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The Id of the usage plan associated with the usage data.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        keyId: Swift.String? = nil,
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.keyId = keyId
        self.patchOperations = patchOperations
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsageInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUsageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endDate = output.endDate
            self.items = output.items
            self.startDate = output.startDate
            self.usagePlanId = output.usagePlanId
        } else {
            self.endDate = nil
            self.items = nil
            self.startDate = nil
            self.usagePlanId = nil
        }
        self.position = nil
    }
}

/// Represents the usage data of a usage plan. [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html), [Manage Usage in a Usage Plan](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-console.html#api-gateway-usage-plan-manage-usage)
public struct UpdateUsageOutputResponse: Swift.Equatable {
    /// The ending date of the usage data.
    public var endDate: Swift.String?
    /// The usage data, as daily logs of used and remaining quotas, over the specified time interval indexed over the API keys in a usage plan. For example, {..., "values" : { "{api_key}" : [ [0, 100], [10, 90], [100, 10]]}, where {api_key} stands for an API key value and the daily log entry is of the format [used quota, remaining quota].
    public var items: [Swift.String:[[Swift.Int]]]?
    /// The current pagination position in the paged result set.
    public var position: Swift.String?
    /// The starting date of the usage data.
    public var startDate: Swift.String?
    /// The plan Id associated with this usage data.
    public var usagePlanId: Swift.String?

    public init (
        endDate: Swift.String? = nil,
        items: [Swift.String:[[Swift.Int]]]? = nil,
        position: Swift.String? = nil,
        startDate: Swift.String? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.endDate = endDate
        self.items = items
        self.position = position
        self.startDate = startDate
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsageOutputResponseBody: Swift.Equatable {
    let usagePlanId: Swift.String?
    let startDate: Swift.String?
    let endDate: Swift.String?
    let items: [Swift.String:[[Swift.Int]]]?
}

extension UpdateUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate
        case items = "values"
        case startDate
        case usagePlanId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usagePlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usagePlanId)
        usagePlanId = usagePlanIdDecoded
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
        let itemsContainer = try containerValues.decodeIfPresent([Swift.String: [[Swift.Int?]?]?].self, forKey: .items)
        var itemsDecoded0: [Swift.String:[[Swift.Int]]]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [Swift.String:[[Swift.Int]]]()
            for (key0, listofusage0) in itemsContainer {
                var listofusage0Decoded0: [[Swift.Int]]? = nil
                if let listofusage0 = listofusage0 {
                    listofusage0Decoded0 = [[Swift.Int]]()
                    for list1 in listofusage0 {
                        var list1Decoded1: [Swift.Int]? = nil
                        if let list1 = list1 {
                            list1Decoded1 = [Swift.Int]()
                            for long2 in list1 {
                                if let long2 = long2 {
                                    list1Decoded1?.append(long2)
                                }
                            }
                        }
                        if let list1Decoded1 = list1Decoded1 {
                            listofusage0Decoded0?.append(list1Decoded1)
                        }
                    }
                }
                itemsDecoded0?[key0] = listofusage0Decoded0
            }
        }
        items = itemsDecoded0
    }
}

extension UpdateUsagePlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateUsagePlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let usagePlanId = usagePlanId else {
            return nil
        }
        return "/usageplans/\(usagePlanId.urlPercentEncoding())"
    }
}

/// The PATCH request to update a usage plan of a given plan Id.
public struct UpdateUsagePlanInput: Swift.Equatable {
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The Id of the to-be-updated usage plan.
    /// This member is required.
    public var usagePlanId: Swift.String?

    public init (
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        usagePlanId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.usagePlanId = usagePlanId
    }
}

struct UpdateUsagePlanInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateUsagePlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateUsagePlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUsagePlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUsagePlanOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUsagePlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateUsagePlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiStages = output.apiStages
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.productCode = output.productCode
            self.quota = output.quota
            self.tags = output.tags
            self.throttle = output.throttle
        } else {
            self.apiStages = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.productCode = nil
            self.quota = nil
            self.tags = nil
            self.throttle = nil
        }
    }
}

/// Represents a usage plan than can specify who can assess associated API stages with specified request limits and quotas. In a usage plan, you associate an API by specifying the API's Id and a stage name of the specified API. You add plan customers by adding API keys to the plan. [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
public struct UpdateUsagePlanOutputResponse: Swift.Equatable {
    /// The associated API stages of a usage plan.
    public var apiStages: [ApiGatewayClientTypes.ApiStage]?
    /// The description of a usage plan.
    public var description: Swift.String?
    /// The identifier of a [UsagePlan] resource.
    public var id: Swift.String?
    /// The name of a usage plan.
    public var name: Swift.String?
    /// The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.
    public var productCode: Swift.String?
    /// The maximum number of permitted requests per a given unit time interval.
    public var quota: ApiGatewayClientTypes.QuotaSettings?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The request throttle limits of a usage plan.
    public var throttle: ApiGatewayClientTypes.ThrottleSettings?

    public init (
        apiStages: [ApiGatewayClientTypes.ApiStage]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        productCode: Swift.String? = nil,
        quota: ApiGatewayClientTypes.QuotaSettings? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        throttle: ApiGatewayClientTypes.ThrottleSettings? = nil
    )
    {
        self.apiStages = apiStages
        self.description = description
        self.id = id
        self.name = name
        self.productCode = productCode
        self.quota = quota
        self.tags = tags
        self.throttle = throttle
    }
}

struct UpdateUsagePlanOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let apiStages: [ApiGatewayClientTypes.ApiStage]?
    let throttle: ApiGatewayClientTypes.ThrottleSettings?
    let quota: ApiGatewayClientTypes.QuotaSettings?
    let productCode: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateUsagePlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateVpcLinkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patchOperations = patchOperations {
            var patchOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patchOperations)
            for listofpatchoperation0 in patchOperations {
                try patchOperationsContainer.encode(listofpatchoperation0)
            }
        }
    }
}

extension UpdateVpcLinkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let vpcLinkId = vpcLinkId else {
            return nil
        }
        return "/vpclinks/\(vpcLinkId.urlPercentEncoding())"
    }
}

/// Updates an existing [VpcLink] of a specified identifier.
public struct UpdateVpcLinkInput: Swift.Equatable {
    /// A list of update operations to be applied to the specified resource and in the order specified in this list.
    public var patchOperations: [ApiGatewayClientTypes.PatchOperation]?
    /// [Required] The identifier of the [VpcLink]. It is used in an [Integration] to reference this [VpcLink].
    /// This member is required.
    public var vpcLinkId: Swift.String?

    public init (
        patchOperations: [ApiGatewayClientTypes.PatchOperation]? = nil,
        vpcLinkId: Swift.String? = nil
    )
    {
        self.patchOperations = patchOperations
        self.vpcLinkId = vpcLinkId
    }
}

struct UpdateVpcLinkInputBody: Swift.Equatable {
    let patchOperations: [ApiGatewayClientTypes.PatchOperation]?
}

extension UpdateVpcLinkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case patchOperations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patchOperationsContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.PatchOperation?].self, forKey: .patchOperations)
        var patchOperationsDecoded0:[ApiGatewayClientTypes.PatchOperation]? = nil
        if let patchOperationsContainer = patchOperationsContainer {
            patchOperationsDecoded0 = [ApiGatewayClientTypes.PatchOperation]()
            for structure0 in patchOperationsContainer {
                if let structure0 = structure0 {
                    patchOperationsDecoded0?.append(structure0)
                }
            }
        }
        patchOperations = patchOperationsDecoded0
    }
}

extension UpdateVpcLinkOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVpcLinkOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVpcLinkOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVpcLinkOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateVpcLinkOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.tags = output.tags
            self.targetArns = output.targetArns
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
            self.status = nil
            self.statusMessage = nil
            self.tags = nil
            self.targetArns = nil
        }
    }
}

/// An API Gateway VPC link for a [RestApi] to access resources in an Amazon Virtual Private Cloud (VPC). To enable access to a resource in an Amazon Virtual Private Cloud through Amazon API Gateway, you, as an API developer, create a [VpcLink] resource targeted for one or more network load balancers of the VPC and then integrate an API method with a private integration that uses the [VpcLink]. The private integration has an integration type of HTTP or HTTP_PROXY and has a connection type of VPC_LINK. The integration uses the connectionId property to identify the [VpcLink] used.
public struct UpdateVpcLinkOutputResponse: Swift.Equatable {
    /// The description of the VPC link.
    public var description: Swift.String?
    /// The identifier of the [VpcLink]. It is used in an [Integration] to reference this [VpcLink].
    public var id: Swift.String?
    /// The name used to label and identify the VPC link.
    public var name: Swift.String?
    /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
    public var status: ApiGatewayClientTypes.VpcLinkStatus?
    /// A description about the VPC link status.
    public var statusMessage: Swift.String?
    /// The collection of tags. Each tag element is associated with a given resource.
    public var tags: [Swift.String:Swift.String]?
    /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.
    public var targetArns: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: ApiGatewayClientTypes.VpcLinkStatus? = nil,
        statusMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetArns: [Swift.String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.tags = tags
        self.targetArns = targetArns
    }
}

struct UpdateVpcLinkOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let targetArns: [Swift.String]?
    let status: ApiGatewayClientTypes.VpcLinkStatus?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateVpcLinkOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayClientTypes.UsagePlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiStages
        case description
        case id
        case name
        case productCode
        case quota
        case tags
        case throttle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiStages = apiStages {
            var apiStagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .apiStages)
            for listofapistage0 in apiStages {
                try apiStagesContainer.encode(listofapistage0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productCode = productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let quota = quota {
            try encodeContainer.encode(quota, forKey: .quota)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let throttle = throttle {
            try encodeContainer.encode(throttle, forKey: .throttle)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let apiStagesContainer = try containerValues.decodeIfPresent([ApiGatewayClientTypes.ApiStage?].self, forKey: .apiStages)
        var apiStagesDecoded0:[ApiGatewayClientTypes.ApiStage]? = nil
        if let apiStagesContainer = apiStagesContainer {
            apiStagesDecoded0 = [ApiGatewayClientTypes.ApiStage]()
            for structure0 in apiStagesContainer {
                if let structure0 = structure0 {
                    apiStagesDecoded0?.append(structure0)
                }
            }
        }
        apiStages = apiStagesDecoded0
        let throttleDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.ThrottleSettings.self, forKey: .throttle)
        throttle = throttleDecoded
        let quotaDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.QuotaSettings.self, forKey: .quota)
        quota = quotaDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// Represents a usage plan than can specify who can assess associated API stages with specified request limits and quotas. In a usage plan, you associate an API by specifying the API's Id and a stage name of the specified API. You add plan customers by adding API keys to the plan. [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
    public struct UsagePlan: Swift.Equatable {
        /// The associated API stages of a usage plan.
        public var apiStages: [ApiGatewayClientTypes.ApiStage]?
        /// The description of a usage plan.
        public var description: Swift.String?
        /// The identifier of a [UsagePlan] resource.
        public var id: Swift.String?
        /// The name of a usage plan.
        public var name: Swift.String?
        /// The AWS Markeplace product identifier to associate with the usage plan as a SaaS product on AWS Marketplace.
        public var productCode: Swift.String?
        /// The maximum number of permitted requests per a given unit time interval.
        public var quota: ApiGatewayClientTypes.QuotaSettings?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// The request throttle limits of a usage plan.
        public var throttle: ApiGatewayClientTypes.ThrottleSettings?

        public init (
            apiStages: [ApiGatewayClientTypes.ApiStage]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            productCode: Swift.String? = nil,
            quota: ApiGatewayClientTypes.QuotaSettings? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            throttle: ApiGatewayClientTypes.ThrottleSettings? = nil
        )
        {
            self.apiStages = apiStages
            self.description = description
            self.id = id
            self.name = name
            self.productCode = productCode
            self.quota = quota
            self.tags = tags
            self.throttle = throttle
        }
    }

}

extension ApiGatewayClientTypes.UsagePlanKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ApiGatewayClientTypes {
    /// Represents a usage plan key to identify a plan customer. To associate an API stage with a selected API key in a usage plan, you must create a UsagePlanKey resource to represent the selected [ApiKey]. " [Create and Use Usage Plans](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-usage-plans.html)
    public struct UsagePlanKey: Swift.Equatable {
        /// The Id of a usage plan key.
        public var id: Swift.String?
        /// The name of a usage plan key.
        public var name: Swift.String?
        /// The type of a usage plan key. Currently, the valid key type is API_KEY.
        public var type: Swift.String?
        /// The value of a usage plan key.
        public var value: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
            self.type = type
            self.value = value
        }
    }

}

extension ApiGatewayClientTypes.VpcLink: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case status
        case statusMessage
        case tags
        case targetArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, mapofstringtostring0) in tags {
                try tagsContainer.encode(mapofstringtostring0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetArns = targetArns {
            var targetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetArns)
            for listofstring0 in targetArns {
                try targetArnsContainer.encode(listofstring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetArns)
        var targetArnsDecoded0:[Swift.String]? = nil
        if let targetArnsContainer = targetArnsContainer {
            targetArnsDecoded0 = [Swift.String]()
            for string0 in targetArnsContainer {
                if let string0 = string0 {
                    targetArnsDecoded0?.append(string0)
                }
            }
        }
        targetArns = targetArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ApiGatewayClientTypes.VpcLinkStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApiGatewayClientTypes {
    /// An API Gateway VPC link for a [RestApi] to access resources in an Amazon Virtual Private Cloud (VPC). To enable access to a resource in an Amazon Virtual Private Cloud through Amazon API Gateway, you, as an API developer, create a [VpcLink] resource targeted for one or more network load balancers of the VPC and then integrate an API method with a private integration that uses the [VpcLink]. The private integration has an integration type of HTTP or HTTP_PROXY and has a connection type of VPC_LINK. The integration uses the connectionId property to identify the [VpcLink] used.
    public struct VpcLink: Swift.Equatable {
        /// The description of the VPC link.
        public var description: Swift.String?
        /// The identifier of the [VpcLink]. It is used in an [Integration] to reference this [VpcLink].
        public var id: Swift.String?
        /// The name used to label and identify the VPC link.
        public var name: Swift.String?
        /// The status of the VPC link. The valid values are AVAILABLE, PENDING, DELETING, or FAILED. Deploying an API will wait if the status is PENDING and will fail if the status is DELETING.
        public var status: ApiGatewayClientTypes.VpcLinkStatus?
        /// A description about the VPC link status.
        public var statusMessage: Swift.String?
        /// The collection of tags. Each tag element is associated with a given resource.
        public var tags: [Swift.String:Swift.String]?
        /// The ARN of the network load balancer of the VPC targeted by the VPC link. The network load balancer must be owned by the same AWS account of the API owner.
        public var targetArns: [Swift.String]?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: ApiGatewayClientTypes.VpcLinkStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetArns: [Swift.String]? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.targetArns = targetArns
        }
    }

}

extension ApiGatewayClientTypes {
    public enum VpcLinkStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleting
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcLinkStatus] {
            return [
                .available,
                .deleting,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcLinkStatus(rawValue: rawValue) ?? VpcLinkStatus.sdkUnknown(rawValue)
        }
    }
}
