// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[GetApiKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetApiKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetApiKeysOutputResponse`
extension ApiGatewayClient {
    public func getApiKeysPaginated(input: GetApiKeysInput) -> ClientRuntime.PaginatorSequence<GetApiKeysInput, GetApiKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetApiKeysInput, GetApiKeysOutputResponse>(input: input, inputKey: \GetApiKeysInput.position, outputKey: \GetApiKeysOutputResponse.position, paginationFunction: self.getApiKeys(input:))
    }
}

extension GetApiKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetApiKeysInput {
        return GetApiKeysInput(
            customerId: self.customerId,
            includeValues: self.includeValues,
            limit: self.limit,
            nameQuery: self.nameQuery,
            position: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getApiKeysPaginated`
/// to access the nested member `[ApiGatewayClientTypes.ApiKey]`
/// - Returns: `[ApiGatewayClientTypes.ApiKey]`
extension PaginatorSequence where Input == GetApiKeysInput, Output == GetApiKeysOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.ApiKey] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetBasePathMappingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetBasePathMappingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetBasePathMappingsOutputResponse`
extension ApiGatewayClient {
    public func getBasePathMappingsPaginated(input: GetBasePathMappingsInput) -> ClientRuntime.PaginatorSequence<GetBasePathMappingsInput, GetBasePathMappingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetBasePathMappingsInput, GetBasePathMappingsOutputResponse>(input: input, inputKey: \GetBasePathMappingsInput.position, outputKey: \GetBasePathMappingsOutputResponse.position, paginationFunction: self.getBasePathMappings(input:))
    }
}

extension GetBasePathMappingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBasePathMappingsInput {
        return GetBasePathMappingsInput(
            domainName: self.domainName,
            limit: self.limit,
            position: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getBasePathMappingsPaginated`
/// to access the nested member `[ApiGatewayClientTypes.BasePathMapping]`
/// - Returns: `[ApiGatewayClientTypes.BasePathMapping]`
extension PaginatorSequence where Input == GetBasePathMappingsInput, Output == GetBasePathMappingsOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.BasePathMapping] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetClientCertificatesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetClientCertificatesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetClientCertificatesOutputResponse`
extension ApiGatewayClient {
    public func getClientCertificatesPaginated(input: GetClientCertificatesInput) -> ClientRuntime.PaginatorSequence<GetClientCertificatesInput, GetClientCertificatesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetClientCertificatesInput, GetClientCertificatesOutputResponse>(input: input, inputKey: \GetClientCertificatesInput.position, outputKey: \GetClientCertificatesOutputResponse.position, paginationFunction: self.getClientCertificates(input:))
    }
}

extension GetClientCertificatesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetClientCertificatesInput {
        return GetClientCertificatesInput(
            limit: self.limit,
            position: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getClientCertificatesPaginated`
/// to access the nested member `[ApiGatewayClientTypes.ClientCertificate]`
/// - Returns: `[ApiGatewayClientTypes.ClientCertificate]`
extension PaginatorSequence where Input == GetClientCertificatesInput, Output == GetClientCertificatesOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.ClientCertificate] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetDeploymentsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetDeploymentsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetDeploymentsOutputResponse`
extension ApiGatewayClient {
    public func getDeploymentsPaginated(input: GetDeploymentsInput) -> ClientRuntime.PaginatorSequence<GetDeploymentsInput, GetDeploymentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetDeploymentsInput, GetDeploymentsOutputResponse>(input: input, inputKey: \GetDeploymentsInput.position, outputKey: \GetDeploymentsOutputResponse.position, paginationFunction: self.getDeployments(input:))
    }
}

extension GetDeploymentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDeploymentsInput {
        return GetDeploymentsInput(
            limit: self.limit,
            position: token,
            restApiId: self.restApiId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getDeploymentsPaginated`
/// to access the nested member `[ApiGatewayClientTypes.Deployment]`
/// - Returns: `[ApiGatewayClientTypes.Deployment]`
extension PaginatorSequence where Input == GetDeploymentsInput, Output == GetDeploymentsOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.Deployment] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetDomainNamesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetDomainNamesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetDomainNamesOutputResponse`
extension ApiGatewayClient {
    public func getDomainNamesPaginated(input: GetDomainNamesInput) -> ClientRuntime.PaginatorSequence<GetDomainNamesInput, GetDomainNamesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetDomainNamesInput, GetDomainNamesOutputResponse>(input: input, inputKey: \GetDomainNamesInput.position, outputKey: \GetDomainNamesOutputResponse.position, paginationFunction: self.getDomainNames(input:))
    }
}

extension GetDomainNamesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDomainNamesInput {
        return GetDomainNamesInput(
            limit: self.limit,
            position: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getDomainNamesPaginated`
/// to access the nested member `[ApiGatewayClientTypes.DomainName]`
/// - Returns: `[ApiGatewayClientTypes.DomainName]`
extension PaginatorSequence where Input == GetDomainNamesInput, Output == GetDomainNamesOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.DomainName] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetModelsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetModelsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetModelsOutputResponse`
extension ApiGatewayClient {
    public func getModelsPaginated(input: GetModelsInput) -> ClientRuntime.PaginatorSequence<GetModelsInput, GetModelsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetModelsInput, GetModelsOutputResponse>(input: input, inputKey: \GetModelsInput.position, outputKey: \GetModelsOutputResponse.position, paginationFunction: self.getModels(input:))
    }
}

extension GetModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetModelsInput {
        return GetModelsInput(
            limit: self.limit,
            position: token,
            restApiId: self.restApiId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getModelsPaginated`
/// to access the nested member `[ApiGatewayClientTypes.Model]`
/// - Returns: `[ApiGatewayClientTypes.Model]`
extension PaginatorSequence where Input == GetModelsInput, Output == GetModelsOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.Model] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetResourcesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetResourcesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetResourcesOutputResponse`
extension ApiGatewayClient {
    public func getResourcesPaginated(input: GetResourcesInput) -> ClientRuntime.PaginatorSequence<GetResourcesInput, GetResourcesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetResourcesInput, GetResourcesOutputResponse>(input: input, inputKey: \GetResourcesInput.position, outputKey: \GetResourcesOutputResponse.position, paginationFunction: self.getResources(input:))
    }
}

extension GetResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetResourcesInput {
        return GetResourcesInput(
            embed: self.embed,
            limit: self.limit,
            position: token,
            restApiId: self.restApiId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getResourcesPaginated`
/// to access the nested member `[ApiGatewayClientTypes.Resource]`
/// - Returns: `[ApiGatewayClientTypes.Resource]`
extension PaginatorSequence where Input == GetResourcesInput, Output == GetResourcesOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.Resource] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetRestApisOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetRestApisInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetRestApisOutputResponse`
extension ApiGatewayClient {
    public func getRestApisPaginated(input: GetRestApisInput) -> ClientRuntime.PaginatorSequence<GetRestApisInput, GetRestApisOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetRestApisInput, GetRestApisOutputResponse>(input: input, inputKey: \GetRestApisInput.position, outputKey: \GetRestApisOutputResponse.position, paginationFunction: self.getRestApis(input:))
    }
}

extension GetRestApisInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetRestApisInput {
        return GetRestApisInput(
            limit: self.limit,
            position: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getRestApisPaginated`
/// to access the nested member `[ApiGatewayClientTypes.RestApi]`
/// - Returns: `[ApiGatewayClientTypes.RestApi]`
extension PaginatorSequence where Input == GetRestApisInput, Output == GetRestApisOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.RestApi] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetUsageOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetUsageInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetUsageOutputResponse`
extension ApiGatewayClient {
    public func getUsagePaginated(input: GetUsageInput) -> ClientRuntime.PaginatorSequence<GetUsageInput, GetUsageOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetUsageInput, GetUsageOutputResponse>(input: input, inputKey: \GetUsageInput.position, outputKey: \GetUsageOutputResponse.position, paginationFunction: self.getUsage(input:))
    }
}

extension GetUsageInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUsageInput {
        return GetUsageInput(
            endDate: self.endDate,
            keyId: self.keyId,
            limit: self.limit,
            position: token,
            startDate: self.startDate,
            usagePlanId: self.usagePlanId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getUsagePaginated`
/// to access the nested member `[(String, [[Swift.Int]])]`
/// - Returns: `[(String, [[Swift.Int]])]`
extension PaginatorSequence where Input == GetUsageInput, Output == GetUsageOutputResponse {
    public func items() async throws -> [(String, [[Swift.Int]])] {
        return try await self.asyncCompactMap { item in item.items?.map { ($0, $1) } }
    }
}

/// Paginate over `[GetUsagePlanKeysOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetUsagePlanKeysInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetUsagePlanKeysOutputResponse`
extension ApiGatewayClient {
    public func getUsagePlanKeysPaginated(input: GetUsagePlanKeysInput) -> ClientRuntime.PaginatorSequence<GetUsagePlanKeysInput, GetUsagePlanKeysOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetUsagePlanKeysInput, GetUsagePlanKeysOutputResponse>(input: input, inputKey: \GetUsagePlanKeysInput.position, outputKey: \GetUsagePlanKeysOutputResponse.position, paginationFunction: self.getUsagePlanKeys(input:))
    }
}

extension GetUsagePlanKeysInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUsagePlanKeysInput {
        return GetUsagePlanKeysInput(
            limit: self.limit,
            nameQuery: self.nameQuery,
            position: token,
            usagePlanId: self.usagePlanId
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getUsagePlanKeysPaginated`
/// to access the nested member `[ApiGatewayClientTypes.UsagePlanKey]`
/// - Returns: `[ApiGatewayClientTypes.UsagePlanKey]`
extension PaginatorSequence where Input == GetUsagePlanKeysInput, Output == GetUsagePlanKeysOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.UsagePlanKey] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetUsagePlansOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetUsagePlansInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetUsagePlansOutputResponse`
extension ApiGatewayClient {
    public func getUsagePlansPaginated(input: GetUsagePlansInput) -> ClientRuntime.PaginatorSequence<GetUsagePlansInput, GetUsagePlansOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetUsagePlansInput, GetUsagePlansOutputResponse>(input: input, inputKey: \GetUsagePlansInput.position, outputKey: \GetUsagePlansOutputResponse.position, paginationFunction: self.getUsagePlans(input:))
    }
}

extension GetUsagePlansInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetUsagePlansInput {
        return GetUsagePlansInput(
            keyId: self.keyId,
            limit: self.limit,
            position: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getUsagePlansPaginated`
/// to access the nested member `[ApiGatewayClientTypes.UsagePlan]`
/// - Returns: `[ApiGatewayClientTypes.UsagePlan]`
extension PaginatorSequence where Input == GetUsagePlansInput, Output == GetUsagePlansOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.UsagePlan] {
        return try await self.asyncCompactMap { item in item.items }
    }
}

/// Paginate over `[GetVpcLinksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[GetVpcLinksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `GetVpcLinksOutputResponse`
extension ApiGatewayClient {
    public func getVpcLinksPaginated(input: GetVpcLinksInput) -> ClientRuntime.PaginatorSequence<GetVpcLinksInput, GetVpcLinksOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetVpcLinksInput, GetVpcLinksOutputResponse>(input: input, inputKey: \GetVpcLinksInput.position, outputKey: \GetVpcLinksOutputResponse.position, paginationFunction: self.getVpcLinks(input:))
    }
}

extension GetVpcLinksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetVpcLinksInput {
        return GetVpcLinksInput(
            limit: self.limit,
            position: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `getVpcLinksPaginated`
/// to access the nested member `[ApiGatewayClientTypes.VpcLink]`
/// - Returns: `[ApiGatewayClientTypes.VpcLink]`
extension PaginatorSequence where Input == GetVpcLinksInput, Output == GetVpcLinksOutputResponse {
    public func items() async throws -> [ApiGatewayClientTypes.VpcLink] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
