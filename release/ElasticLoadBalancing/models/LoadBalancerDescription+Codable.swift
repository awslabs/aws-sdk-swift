// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension LoadBalancerDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case backendServerDescriptions = "BackendServerDescriptions"
        case canonicalHostedZoneName = "CanonicalHostedZoneName"
        case canonicalHostedZoneNameID = "CanonicalHostedZoneNameID"
        case createdTime = "CreatedTime"
        case dNSName = "DNSName"
        case healthCheck = "HealthCheck"
        case instances = "Instances"
        case listenerDescriptions = "ListenerDescriptions"
        case loadBalancerName = "LoadBalancerName"
        case policies = "Policies"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case sourceSecurityGroup = "SourceSecurityGroup"
        case subnets = "Subnets"
        case vPCId = "VPCId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let backendServerDescriptions = backendServerDescriptions {
            var backendServerDescriptionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("BackendServerDescriptions"))
            for (index0, backendserverdescription0) in backendServerDescriptions.enumerated() {
                try backendServerDescriptionsContainer.encode(backendserverdescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let canonicalHostedZoneName = canonicalHostedZoneName {
            try container.encode(canonicalHostedZoneName, forKey: Key("CanonicalHostedZoneName"))
        }
        if let canonicalHostedZoneNameID = canonicalHostedZoneNameID {
            try container.encode(canonicalHostedZoneNameID, forKey: Key("CanonicalHostedZoneNameID"))
        }
        if let createdTime = createdTime {
            try container.encode(TimestampWrapper(createdTime, format: .dateTime), forKey: Key("createdTime"))
        }
        if let dNSName = dNSName {
            try container.encode(dNSName, forKey: Key("DNSName"))
        }
        if let healthCheck = healthCheck {
            try container.encode(healthCheck, forKey: Key("HealthCheck"))
        }
        if let instances = instances {
            var instancesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Instances"))
            for (index0, instance0) in instances.enumerated() {
                try instancesContainer.encode(instance0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerDescriptions = listenerDescriptions {
            var listenerDescriptionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ListenerDescriptions"))
            for (index0, listenerdescription0) in listenerDescriptions.enumerated() {
                try listenerDescriptionsContainer.encode(listenerdescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let policies = policies {
            try container.encode(policies, forKey: Key("Policies"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let sourceSecurityGroup = sourceSecurityGroup {
            try container.encode(sourceSecurityGroup, forKey: Key("SourceSecurityGroup"))
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let vPCId = vPCId {
            try container.encode(vPCId, forKey: Key("VPCId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let dNSNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSName)
        dNSName = dNSNameDecoded
        let canonicalHostedZoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canonicalHostedZoneName)
        canonicalHostedZoneName = canonicalHostedZoneNameDecoded
        let canonicalHostedZoneNameIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canonicalHostedZoneNameID)
        canonicalHostedZoneNameID = canonicalHostedZoneNameIDDecoded
        if containerValues.contains(.listenerDescriptions) {
            struct KeyVal0{struct member{}}
            let listenerDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listenerDescriptions)
            if let listenerDescriptionsWrappedContainer = listenerDescriptionsWrappedContainer {
                let listenerDescriptionsContainer = try listenerDescriptionsWrappedContainer.decodeIfPresent([ListenerDescription].self, forKey: .member)
                var listenerDescriptionsBuffer:[ListenerDescription]? = nil
                if let listenerDescriptionsContainer = listenerDescriptionsContainer {
                    listenerDescriptionsBuffer = [ListenerDescription]()
                    for structureContainer0 in listenerDescriptionsContainer {
                        listenerDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                listenerDescriptions = listenerDescriptionsBuffer
            } else {
                listenerDescriptions = []
            }
        } else {
            listenerDescriptions = nil
        }
        let policiesDecoded = try containerValues.decodeIfPresent(Policies.self, forKey: .policies)
        policies = policiesDecoded
        if containerValues.contains(.backendServerDescriptions) {
            struct KeyVal0{struct member{}}
            let backendServerDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .backendServerDescriptions)
            if let backendServerDescriptionsWrappedContainer = backendServerDescriptionsWrappedContainer {
                let backendServerDescriptionsContainer = try backendServerDescriptionsWrappedContainer.decodeIfPresent([BackendServerDescription].self, forKey: .member)
                var backendServerDescriptionsBuffer:[BackendServerDescription]? = nil
                if let backendServerDescriptionsContainer = backendServerDescriptionsContainer {
                    backendServerDescriptionsBuffer = [BackendServerDescription]()
                    for structureContainer0 in backendServerDescriptionsContainer {
                        backendServerDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                backendServerDescriptions = backendServerDescriptionsBuffer
            } else {
                backendServerDescriptions = []
            }
        } else {
            backendServerDescriptions = nil
        }
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var availabilityZonesBuffer:[String]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [String]()
                    for stringContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(stringContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.subnets) {
            struct KeyVal0{struct member{}}
            let subnetsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .subnets)
            if let subnetsWrappedContainer = subnetsWrappedContainer {
                let subnetsContainer = try subnetsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var subnetsBuffer:[String]? = nil
                if let subnetsContainer = subnetsContainer {
                    subnetsBuffer = [String]()
                    for stringContainer0 in subnetsContainer {
                        subnetsBuffer?.append(stringContainer0)
                    }
                }
                subnets = subnetsBuffer
            } else {
                subnets = []
            }
        } else {
            subnets = nil
        }
        let vPCIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vPCId)
        vPCId = vPCIdDecoded
        if containerValues.contains(.instances) {
            struct KeyVal0{struct member{}}
            let instancesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .instances)
            if let instancesWrappedContainer = instancesWrappedContainer {
                let instancesContainer = try instancesWrappedContainer.decodeIfPresent([Instance].self, forKey: .member)
                var instancesBuffer:[Instance]? = nil
                if let instancesContainer = instancesContainer {
                    instancesBuffer = [Instance]()
                    for structureContainer0 in instancesContainer {
                        instancesBuffer?.append(structureContainer0)
                    }
                }
                instances = instancesBuffer
            } else {
                instances = []
            }
        } else {
            instances = nil
        }
        let healthCheckDecoded = try containerValues.decodeIfPresent(HealthCheck.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let sourceSecurityGroupDecoded = try containerValues.decodeIfPresent(SourceSecurityGroup.self, forKey: .sourceSecurityGroup)
        sourceSecurityGroup = sourceSecurityGroupDecoded
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var securityGroupsBuffer:[String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        var createdTimeBuffer:Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let schemeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheme)
        scheme = schemeDecoded
    }
}
